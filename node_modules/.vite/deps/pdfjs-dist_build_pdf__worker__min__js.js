import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-OL46QLBJ.js";

// node_modules/pdfjs-dist/build/pdf.worker.min.js
var require_pdf_worker_min = __commonJS({
  "node_modules/pdfjs-dist/build/pdf.worker.min.js"(exports, module) {
    !function webpackUniversalModuleDefinition(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e.pdfjsWorker = t() : "function" == typeof define && define.amd ? define("pdfjs-dist/build/pdf.worker", [], () => e.pdfjsWorker = t()) : "object" == typeof exports ? exports["pdfjs-dist/build/pdf.worker"] = e.pdfjsWorker = t() : e["pdfjs-dist/build/pdf.worker"] = e.pdfjsWorker = t();
    }(globalThis, () => (() => {
      "use strict";
      var e = [, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.WorkerTask = t2.WorkerMessageHandler = void 0;
        var r = a2(2), n = a2(3), i = a2(4), s = a2(6), o = a2(10), c = a2(68), l = a2(73), h = a2(104), u = a2(105), d = a2(72);
        class WorkerTask {
          constructor(e3) {
            this.name = e3;
            this.terminated = false;
            this._capability = new r.PromiseCapability();
          }
          get finished() {
            return this._capability.promise;
          }
          finish() {
            this._capability.resolve();
          }
          terminate() {
            this.terminated = true;
          }
          ensureNotTerminated() {
            if (this.terminated) throw new Error("Worker task was terminated");
          }
        }
        t2.WorkerTask = WorkerTask;
        class WorkerMessageHandler {
          static setup(e3, t3) {
            let a3 = false;
            e3.on("test", function(t4) {
              if (!a3) {
                a3 = true;
                e3.send("test", t4 instanceof Uint8Array);
              }
            });
            e3.on("configure", function(e4) {
              (0, r.setVerbosityLevel)(e4.verbosity);
            });
            e3.on("GetDocRequest", function(e4) {
              return WorkerMessageHandler.createDocumentHandler(e4, t3);
            });
          }
          static createDocumentHandler(e3, t3) {
            let a3, f = false, g = null;
            const p = /* @__PURE__ */ new Set(), m = (0, r.getVerbosityLevel)(), { docId: b, apiVersion: y } = e3, w = "3.11.174";
            if (y !== w) throw new Error(`The API version "${y}" does not match the Worker version "${w}".`);
            const S = [];
            for (const e4 in []) S.push(e4);
            if (S.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + S.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
            const x = b + "_worker";
            let C = new h.MessageHandler(x, b, t3);
            function ensureNotTerminated() {
              if (f) throw new Error("Worker was terminated");
            }
            function startWorkerTask(e4) {
              p.add(e4);
            }
            function finishWorkerTask(e4) {
              e4.finish();
              p.delete(e4);
            }
            async function loadDocument(e4) {
              await a3.ensureDoc("checkHeader");
              await a3.ensureDoc("parseStartXRef");
              await a3.ensureDoc("parse", [e4]);
              await a3.ensureDoc("checkFirstPage", [e4]);
              await a3.ensureDoc("checkLastPage", [e4]);
              const t4 = await a3.ensureDoc("isPureXfa");
              if (t4) {
                const e5 = new WorkerTask("loadXfaFonts");
                startWorkerTask(e5);
                await Promise.all([a3.loadXfaFonts(C, e5).catch((e6) => {
                }).then(() => finishWorkerTask(e5)), a3.loadXfaImages()]);
              }
              const [r2, n2] = await Promise.all([a3.ensureDoc("numPages"), a3.ensureDoc("fingerprints")]);
              return { numPages: r2, fingerprints: n2, htmlForXfa: t4 ? await a3.ensureDoc("htmlForXfa") : null };
            }
            function getPdfManager({ data: e4, password: t4, disableAutoFetch: a4, rangeChunkSize: i2, length: o2, docBaseUrl: c2, enableXfa: l2, evaluatorOptions: h2 }) {
              const d2 = { source: null, disableAutoFetch: a4, docBaseUrl: c2, docId: b, enableXfa: l2, evaluatorOptions: h2, handler: C, length: o2, password: t4, rangeChunkSize: i2 }, f2 = new r.PromiseCapability();
              let p2;
              if (e4) {
                try {
                  d2.source = e4;
                  p2 = new s.LocalPdfManager(d2);
                  f2.resolve(p2);
                } catch (e5) {
                  f2.reject(e5);
                }
                return f2.promise;
              }
              let m2, y2 = [];
              try {
                m2 = new u.PDFWorkerStream(C);
              } catch (e5) {
                f2.reject(e5);
                return f2.promise;
              }
              const w2 = m2.getFullReader();
              w2.headersReady.then(function() {
                if (w2.isRangeSupported) {
                  d2.source = m2;
                  d2.length = w2.contentLength;
                  d2.disableAutoFetch || (d2.disableAutoFetch = w2.isStreamingSupported);
                  p2 = new s.NetworkPdfManager(d2);
                  for (const e5 of y2) p2.sendProgressiveData(e5);
                  y2 = [];
                  f2.resolve(p2);
                  g = null;
                }
              }).catch(function(e5) {
                f2.reject(e5);
                g = null;
              });
              let S2 = 0;
              new Promise(function(e5, t5) {
                const readChunk = function({ value: e6, done: a5 }) {
                  try {
                    ensureNotTerminated();
                    if (a5) {
                      p2 || function() {
                        const e7 = (0, n.arrayBuffersToBytes)(y2);
                        o2 && e7.length !== o2 && (0, r.warn)("reported HTTP length is different from actual");
                        try {
                          d2.source = e7;
                          p2 = new s.LocalPdfManager(d2);
                          f2.resolve(p2);
                        } catch (e8) {
                          f2.reject(e8);
                        }
                        y2 = [];
                      }();
                      g = null;
                      return;
                    }
                    S2 += e6.byteLength;
                    w2.isStreamingSupported || C.send("DocProgress", { loaded: S2, total: Math.max(S2, w2.contentLength || 0) });
                    p2 ? p2.sendProgressiveData(e6) : y2.push(e6);
                    w2.read().then(readChunk, t5);
                  } catch (e7) {
                    t5(e7);
                  }
                };
                w2.read().then(readChunk, t5);
              }).catch(function(e5) {
                f2.reject(e5);
                g = null;
              });
              g = function(e5) {
                m2.cancelAllRequests(e5);
              };
              return f2.promise;
            }
            C.on("GetPage", function(e4) {
              return a3.getPage(e4.pageIndex).then(function(e5) {
                return Promise.all([a3.ensure(e5, "rotate"), a3.ensure(e5, "ref"), a3.ensure(e5, "userUnit"), a3.ensure(e5, "view")]).then(function([e6, t4, a4, r2]) {
                  return { rotate: e6, ref: t4, userUnit: a4, view: r2 };
                });
              });
            });
            C.on("GetPageIndex", function(e4) {
              const t4 = i.Ref.get(e4.num, e4.gen);
              return a3.ensureCatalog("getPageIndex", [t4]);
            });
            C.on("GetDestinations", function(e4) {
              return a3.ensureCatalog("destinations");
            });
            C.on("GetDestination", function(e4) {
              return a3.ensureCatalog("getDestination", [e4.id]);
            });
            C.on("GetPageLabels", function(e4) {
              return a3.ensureCatalog("pageLabels");
            });
            C.on("GetPageLayout", function(e4) {
              return a3.ensureCatalog("pageLayout");
            });
            C.on("GetPageMode", function(e4) {
              return a3.ensureCatalog("pageMode");
            });
            C.on("GetViewerPreferences", function(e4) {
              return a3.ensureCatalog("viewerPreferences");
            });
            C.on("GetOpenAction", function(e4) {
              return a3.ensureCatalog("openAction");
            });
            C.on("GetAttachments", function(e4) {
              return a3.ensureCatalog("attachments");
            });
            C.on("GetDocJSActions", function(e4) {
              return a3.ensureCatalog("jsActions");
            });
            C.on("GetPageJSActions", function({ pageIndex: e4 }) {
              return a3.getPage(e4).then(function(e5) {
                return a3.ensure(e5, "jsActions");
              });
            });
            C.on("GetOutline", function(e4) {
              return a3.ensureCatalog("documentOutline");
            });
            C.on("GetOptionalContentConfig", function(e4) {
              return a3.ensureCatalog("optionalContentConfig");
            });
            C.on("GetPermissions", function(e4) {
              return a3.ensureCatalog("permissions");
            });
            C.on("GetMetadata", function(e4) {
              return Promise.all([a3.ensureDoc("documentInfo"), a3.ensureCatalog("metadata")]);
            });
            C.on("GetMarkInfo", function(e4) {
              return a3.ensureCatalog("markInfo");
            });
            C.on("GetData", function(e4) {
              return a3.requestLoadedStream().then(function(e5) {
                return e5.bytes;
              });
            });
            C.on("GetAnnotations", function({ pageIndex: e4, intent: t4 }) {
              return a3.getPage(e4).then(function(a4) {
                const r2 = new WorkerTask(`GetAnnotations: page ${e4}`);
                startWorkerTask(r2);
                return a4.getAnnotationsData(C, r2, t4).then((e5) => {
                  finishWorkerTask(r2);
                  return e5;
                }, (e5) => {
                  finishWorkerTask(r2);
                  throw e5;
                });
              });
            });
            C.on("GetFieldObjects", function(e4) {
              return a3.ensureDoc("fieldObjects");
            });
            C.on("HasJSActions", function(e4) {
              return a3.ensureDoc("hasJSActions");
            });
            C.on("GetCalculationOrderIds", function(e4) {
              return a3.ensureDoc("calculationOrderIds");
            });
            C.on("SaveDocument", async function({ isPureXfa: e4, numPages: t4, annotationStorage: s2, filename: c2 }) {
              const h2 = [a3.requestLoadedStream(), a3.ensureCatalog("acroForm"), a3.ensureCatalog("acroFormRef"), a3.ensureDoc("startXRef"), a3.ensureDoc("xref"), a3.ensureDoc("linearization"), a3.ensureCatalog("structTreeRoot")], u2 = [], f2 = e4 ? null : (0, n.getNewAnnotationsMap)(s2), [g2, p2, m2, b2, y2, w2, S2] = await Promise.all(h2), x2 = y2.trailer.getRaw("Root") || null;
              let k;
              if (f2) {
                S2 ? await S2.canUpdateStructTree({ pdfManager: a3, newAnnotationsByPage: f2 }) && (k = S2) : await d.StructTreeRoot.canCreateStructureTree({ catalogRef: x2, pdfManager: a3, newAnnotationsByPage: f2 }) && (k = null);
                const e5 = o.AnnotationFactory.generateImages(s2.values(), y2, a3.evaluatorOptions.isOffscreenCanvasSupported), t5 = void 0 === k ? u2 : [];
                for (const [r2, n2] of f2) t5.push(a3.getPage(r2).then((t6) => {
                  const a4 = new WorkerTask(`Save (editor): page ${r2}`);
                  return t6.saveNewAnnotations(C, a4, n2, e5).finally(function() {
                    finishWorkerTask(a4);
                  });
                }));
                null === k ? u2.push(Promise.all(t5).then(async (e6) => {
                  await d.StructTreeRoot.createStructureTree({ newAnnotationsByPage: f2, xref: y2, catalogRef: x2, pdfManager: a3, newRefs: e6 });
                  return e6;
                })) : k && u2.push(Promise.all(t5).then(async (e6) => {
                  await k.updateStructureTree({ newAnnotationsByPage: f2, pdfManager: a3, newRefs: e6 });
                  return e6;
                }));
              }
              if (e4) u2.push(a3.serializeXfaData(s2));
              else for (let e5 = 0; e5 < t4; e5++) u2.push(a3.getPage(e5).then(function(t5) {
                const a4 = new WorkerTask(`Save: page ${e5}`);
                return t5.save(C, a4, s2).finally(function() {
                  finishWorkerTask(a4);
                });
              }));
              const v = await Promise.all(u2);
              let F = [], O = null;
              if (e4) {
                O = v[0];
                if (!O) return g2.bytes;
              } else {
                F = v.flat(2);
                if (0 === F.length) return g2.bytes;
              }
              const T = m2 && p2 instanceof i.Dict && F.some((e5) => e5.needAppearances), M = p2 instanceof i.Dict && p2.get("XFA") || null;
              let D = null, E = false;
              if (Array.isArray(M)) {
                for (let e5 = 0, t5 = M.length; e5 < t5; e5 += 2) if ("datasets" === M[e5]) {
                  D = M[e5 + 1];
                  E = true;
                }
                null === D && (D = y2.getNewTemporaryRef());
              } else M && (0, r.warn)("Unsupported XFA type.");
              let N = /* @__PURE__ */ Object.create(null);
              if (y2.trailer) {
                const e5 = /* @__PURE__ */ Object.create(null), t5 = y2.trailer.get("Info") || null;
                t5 instanceof i.Dict && t5.forEach((t6, a4) => {
                  "string" == typeof a4 && (e5[t6] = (0, r.stringToPDFString)(a4));
                });
                N = { rootRef: x2, encryptRef: y2.trailer.getRaw("Encrypt") || null, newRef: y2.getNewTemporaryRef(), infoRef: y2.trailer.getRaw("Info") || null, info: e5, fileIds: y2.trailer.get("ID") || null, startXRef: w2 ? b2 : y2.lastXRefStreamPos ?? b2, filename: c2 };
              }
              return (0, l.incrementalUpdate)({ originalData: g2.bytes, xrefInfo: N, newRefs: F, xref: y2, hasXfa: !!M, xfaDatasetsRef: D, hasXfaDatasetsEntry: E, needAppearances: T, acroFormRef: m2, acroForm: p2, xfaData: O }).finally(() => {
                y2.resetNewTemporaryRef();
              });
            });
            C.on("GetOperatorList", function(e4, t4) {
              const n2 = e4.pageIndex;
              a3.getPage(n2).then(function(a4) {
                const i2 = new WorkerTask(`GetOperatorList: page ${n2}`);
                startWorkerTask(i2);
                const s2 = m >= r.VerbosityLevel.INFOS ? Date.now() : 0;
                a4.getOperatorList({ handler: C, sink: t4, task: i2, intent: e4.intent, cacheKey: e4.cacheKey, annotationStorage: e4.annotationStorage }).then(function(e5) {
                  finishWorkerTask(i2);
                  s2 && (0, r.info)(`page=${n2 + 1} - getOperatorList: time=${Date.now() - s2}ms, len=${e5.length}`);
                  t4.close();
                }, function(e5) {
                  finishWorkerTask(i2);
                  i2.terminated || t4.error(e5);
                });
              });
            });
            C.on("GetTextContent", function(e4, t4) {
              const { pageIndex: n2, includeMarkedContent: i2, disableNormalization: s2 } = e4;
              a3.getPage(n2).then(function(e5) {
                const a4 = new WorkerTask("GetTextContent: page " + n2);
                startWorkerTask(a4);
                const o2 = m >= r.VerbosityLevel.INFOS ? Date.now() : 0;
                e5.extractTextContent({ handler: C, task: a4, sink: t4, includeMarkedContent: i2, disableNormalization: s2 }).then(function() {
                  finishWorkerTask(a4);
                  o2 && (0, r.info)(`page=${n2 + 1} - getTextContent: time=` + (Date.now() - o2) + "ms");
                  t4.close();
                }, function(e6) {
                  finishWorkerTask(a4);
                  a4.terminated || t4.error(e6);
                });
              });
            });
            C.on("GetStructTree", function(e4) {
              return a3.getPage(e4.pageIndex).then(function(e5) {
                return a3.ensure(e5, "getStructTree");
              });
            });
            C.on("FontFallback", function(e4) {
              return a3.fontFallback(e4.id, C);
            });
            C.on("Cleanup", function(e4) {
              return a3.cleanup(true);
            });
            C.on("Terminate", function(e4) {
              f = true;
              const t4 = [];
              if (a3) {
                a3.terminate(new r.AbortException("Worker was terminated."));
                const e5 = a3.cleanup();
                t4.push(e5);
                a3 = null;
              } else (0, c.clearGlobalCaches)();
              g && g(new r.AbortException("Worker was terminated."));
              for (const e5 of p) {
                t4.push(e5.finished);
                e5.terminate();
              }
              return Promise.all(t4).then(function() {
                C.destroy();
                C = null;
              });
            });
            C.on("Ready", function(t4) {
              !function setupDoc(e4) {
                function onSuccess(e5) {
                  ensureNotTerminated();
                  C.send("GetDoc", { pdfInfo: e5 });
                }
                function onFailure(e5) {
                  ensureNotTerminated();
                  if (e5 instanceof r.PasswordException) {
                    const t5 = new WorkerTask(`PasswordException: response ${e5.code}`);
                    startWorkerTask(t5);
                    C.sendWithPromise("PasswordRequest", e5).then(function({ password: e6 }) {
                      finishWorkerTask(t5);
                      a3.updatePassword(e6);
                      pdfManagerReady();
                    }).catch(function() {
                      finishWorkerTask(t5);
                      C.send("DocException", e5);
                    });
                  } else e5 instanceof r.InvalidPDFException || e5 instanceof r.MissingPDFException || e5 instanceof r.UnexpectedResponseException || e5 instanceof r.UnknownErrorException ? C.send("DocException", e5) : C.send("DocException", new r.UnknownErrorException(e5.message, e5.toString()));
                }
                function pdfManagerReady() {
                  ensureNotTerminated();
                  loadDocument(false).then(onSuccess, function(e5) {
                    ensureNotTerminated();
                    e5 instanceof n.XRefParseException ? a3.requestLoadedStream().then(function() {
                      ensureNotTerminated();
                      loadDocument(true).then(onSuccess, onFailure);
                    }) : onFailure(e5);
                  });
                }
                ensureNotTerminated();
                getPdfManager(e4).then(function(e5) {
                  if (f) {
                    e5.terminate(new r.AbortException("Worker was terminated."));
                    throw new Error("Worker was terminated");
                  }
                  a3 = e5;
                  a3.requestLoadedStream(true).then((e6) => {
                    C.send("DataLoaded", { length: e6.bytes.byteLength });
                  });
                }).then(pdfManagerReady, onFailure);
              }(e3);
              e3 = null;
            });
            return x;
          }
          static initializeFromPort(e3) {
            const t3 = new h.MessageHandler("worker", "main", e3);
            WorkerMessageHandler.setup(t3, e3);
            t3.send("ready", null);
          }
        }
        t2.WorkerMessageHandler = WorkerMessageHandler;
        "undefined" == typeof window && !r.isNodeJS && "undefined" != typeof self && function isMessagePort(e3) {
          return "function" == typeof e3.postMessage && "onmessage" in e3;
        }(self) && WorkerMessageHandler.initializeFromPort(self);
      }, (e2, t2) => {
        var _e, _a;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.VerbosityLevel = t2.Util = t2.UnknownErrorException = t2.UnexpectedResponseException = t2.TextRenderingMode = t2.RenderingIntentFlag = t2.PromiseCapability = t2.PermissionFlag = t2.PasswordResponses = t2.PasswordException = t2.PageActionEventType = t2.OPS = t2.MissingPDFException = t2.MAX_IMAGE_SIZE_TO_CACHE = t2.LINE_FACTOR = t2.LINE_DESCENT_FACTOR = t2.InvalidPDFException = t2.ImageKind = t2.IDENTITY_MATRIX = t2.FormatError = t2.FeatureTest = t2.FONT_IDENTITY_MATRIX = t2.DocumentActionEventType = t2.CMapCompressionType = t2.BaseException = t2.BASELINE_FACTOR = t2.AnnotationType = t2.AnnotationReplyType = t2.AnnotationPrefix = t2.AnnotationMode = t2.AnnotationFlag = t2.AnnotationFieldFlag = t2.AnnotationEditorType = t2.AnnotationEditorPrefix = t2.AnnotationEditorParamsType = t2.AnnotationBorderStyleType = t2.AnnotationActionEventType = t2.AbortException = void 0;
        t2.assert = function assert(e3, t3) {
          e3 || unreachable(t3);
        };
        t2.bytesToString = bytesToString;
        t2.createValidAbsoluteUrl = function createValidAbsoluteUrl(e3, t3 = null, a3 = null) {
          if (!e3) return null;
          try {
            if (a3 && "string" == typeof e3) {
              if (a3.addDefaultProtocol && e3.startsWith("www.")) {
                const t4 = e3.match(/\./g);
                (t4 == null ? void 0 : t4.length) >= 2 && (e3 = `http://${e3}`);
              }
              if (a3.tryConvertEncoding) try {
                e3 = stringToUTF8String(e3);
              } catch {
              }
            }
            const r2 = t3 ? new URL(e3, t3) : new URL(e3);
            if (function _isValidProtocol(e4) {
              switch (e4 == null ? void 0 : e4.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }(r2)) return r2;
          } catch {
          }
          return null;
        };
        t2.getModificationDate = function getModificationDate(e3 = /* @__PURE__ */ new Date()) {
          return [e3.getUTCFullYear().toString(), (e3.getUTCMonth() + 1).toString().padStart(2, "0"), e3.getUTCDate().toString().padStart(2, "0"), e3.getUTCHours().toString().padStart(2, "0"), e3.getUTCMinutes().toString().padStart(2, "0"), e3.getUTCSeconds().toString().padStart(2, "0")].join("");
        };
        t2.getUuid = function getUuid() {
          if ("undefined" != typeof crypto && "function" == typeof (crypto == null ? void 0 : crypto.randomUUID)) return crypto.randomUUID();
          const e3 = new Uint8Array(32);
          if ("undefined" != typeof crypto && "function" == typeof (crypto == null ? void 0 : crypto.getRandomValues)) crypto.getRandomValues(e3);
          else for (let t3 = 0; t3 < 32; t3++) e3[t3] = Math.floor(255 * Math.random());
          return bytesToString(e3);
        };
        t2.getVerbosityLevel = function getVerbosityLevel() {
          return n;
        };
        t2.info = function info(e3) {
          n >= r.INFOS && console.log(`Info: ${e3}`);
        };
        t2.isArrayBuffer = function isArrayBuffer(e3) {
          return "object" == typeof e3 && void 0 !== (e3 == null ? void 0 : e3.byteLength);
        };
        t2.isArrayEqual = function isArrayEqual(e3, t3) {
          if (e3.length !== t3.length) return false;
          for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) if (e3[a3] !== t3[a3]) return false;
          return true;
        };
        t2.isNodeJS = void 0;
        t2.normalizeUnicode = function normalizeUnicode(e3) {
          if (!c) {
            c = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
            l = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
          }
          return e3.replaceAll(c, (e4, t3, a3) => t3 ? t3.normalize("NFKC") : l.get(a3));
        };
        t2.objectFromMap = function objectFromMap(e3) {
          const t3 = /* @__PURE__ */ Object.create(null);
          for (const [a3, r2] of e3) t3[a3] = r2;
          return t3;
        };
        t2.objectSize = function objectSize(e3) {
          return Object.keys(e3).length;
        };
        t2.setVerbosityLevel = function setVerbosityLevel(e3) {
          Number.isInteger(e3) && (n = e3);
        };
        t2.shadow = shadow;
        t2.string32 = function string32(e3) {
          return String.fromCharCode(e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3);
        };
        t2.stringToBytes = stringToBytes;
        t2.stringToPDFString = function stringToPDFString(e3) {
          if (e3[0] >= "ï") {
            let t4;
            "þ" === e3[0] && "ÿ" === e3[1] ? t4 = "utf-16be" : "ÿ" === e3[0] && "þ" === e3[1] ? t4 = "utf-16le" : "ï" === e3[0] && "»" === e3[1] && "¿" === e3[2] && (t4 = "utf-8");
            if (t4) try {
              const a3 = new TextDecoder(t4, { fatal: true }), r2 = stringToBytes(e3);
              return a3.decode(r2);
            } catch (e4) {
              warn(`stringToPDFString: "${e4}".`);
            }
          }
          const t3 = [];
          for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) {
            const r3 = o[e3.charCodeAt(a3)];
            t3.push(r3 ? String.fromCharCode(r3) : e3.charAt(a3));
          }
          return t3.join("");
        };
        t2.stringToUTF8String = stringToUTF8String;
        t2.unreachable = unreachable;
        t2.utf8StringToString = function utf8StringToString(e3) {
          return unescape(encodeURIComponent(e3));
        };
        t2.warn = warn;
        const a2 = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
        t2.isNodeJS = a2;
        t2.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
        t2.FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
        t2.MAX_IMAGE_SIZE_TO_CACHE = 1e7;
        t2.LINE_FACTOR = 1.35;
        t2.LINE_DESCENT_FACTOR = 0.35;
        t2.BASELINE_FACTOR = 0.25925925925925924;
        t2.RenderingIntentFlag = { ANY: 1, DISPLAY: 2, PRINT: 4, SAVE: 8, ANNOTATIONS_FORMS: 16, ANNOTATIONS_STORAGE: 32, ANNOTATIONS_DISABLE: 64, OPLIST: 256 };
        t2.AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 };
        t2.AnnotationEditorPrefix = "pdfjs_internal_editor_";
        t2.AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, STAMP: 13, INK: 15 };
        t2.AnnotationEditorParamsType = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23 };
        t2.PermissionFlag = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
        t2.TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 };
        t2.ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 };
        t2.AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 };
        t2.AnnotationReplyType = { GROUP: "Group", REPLY: "R" };
        t2.AnnotationFlag = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 };
        t2.AnnotationFieldFlag = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 };
        t2.AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 };
        t2.AnnotationActionEventType = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
        t2.DocumentActionEventType = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
        t2.PageActionEventType = { O: "PageOpen", C: "PageClose" };
        const r = { ERRORS: 0, WARNINGS: 1, INFOS: 5 };
        t2.VerbosityLevel = r;
        t2.CMapCompressionType = { NONE: 0, BINARY: 1 };
        t2.OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 };
        t2.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
        let n = r.WARNINGS;
        function warn(e3) {
          n >= r.WARNINGS && console.log(`Warning: ${e3}`);
        }
        function unreachable(e3) {
          throw new Error(e3);
        }
        function shadow(e3, t3, a3, r2 = false) {
          Object.defineProperty(e3, t3, { value: a3, enumerable: !r2, configurable: true, writable: false });
          return a3;
        }
        const i = function BaseExceptionClosure() {
          function BaseException(e3, t3) {
            this.constructor === BaseException && unreachable("Cannot initialize BaseException.");
            this.message = e3;
            this.name = t3;
          }
          BaseException.prototype = new Error();
          BaseException.constructor = BaseException;
          return BaseException;
        }();
        t2.BaseException = i;
        t2.PasswordException = class PasswordException extends i {
          constructor(e3, t3) {
            super(e3, "PasswordException");
            this.code = t3;
          }
        };
        t2.UnknownErrorException = class UnknownErrorException extends i {
          constructor(e3, t3) {
            super(e3, "UnknownErrorException");
            this.details = t3;
          }
        };
        t2.InvalidPDFException = class InvalidPDFException extends i {
          constructor(e3) {
            super(e3, "InvalidPDFException");
          }
        };
        t2.MissingPDFException = class MissingPDFException extends i {
          constructor(e3) {
            super(e3, "MissingPDFException");
          }
        };
        t2.UnexpectedResponseException = class UnexpectedResponseException extends i {
          constructor(e3, t3) {
            super(e3, "UnexpectedResponseException");
            this.status = t3;
          }
        };
        t2.FormatError = class FormatError extends i {
          constructor(e3) {
            super(e3, "FormatError");
          }
        };
        t2.AbortException = class AbortException extends i {
          constructor(e3) {
            super(e3, "AbortException");
          }
        };
        function bytesToString(e3) {
          "object" == typeof e3 && void 0 !== (e3 == null ? void 0 : e3.length) || unreachable("Invalid argument for bytesToString");
          const t3 = e3.length, a3 = 8192;
          if (t3 < a3) return String.fromCharCode.apply(null, e3);
          const r2 = [];
          for (let n2 = 0; n2 < t3; n2 += a3) {
            const i2 = Math.min(n2 + a3, t3), s2 = e3.subarray(n2, i2);
            r2.push(String.fromCharCode.apply(null, s2));
          }
          return r2.join("");
        }
        function stringToBytes(e3) {
          "string" != typeof e3 && unreachable("Invalid argument for stringToBytes");
          const t3 = e3.length, a3 = new Uint8Array(t3);
          for (let r2 = 0; r2 < t3; ++r2) a3[r2] = 255 & e3.charCodeAt(r2);
          return a3;
        }
        t2.FeatureTest = class FeatureTest {
          static get isLittleEndian() {
            return shadow(this, "isLittleEndian", function isLittleEndian() {
              const e3 = new Uint8Array(4);
              e3[0] = 1;
              return 1 === new Uint32Array(e3.buffer, 0, 1)[0];
            }());
          }
          static get isEvalSupported() {
            return shadow(this, "isEvalSupported", function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch {
                return false;
              }
            }());
          }
          static get isOffscreenCanvasSupported() {
            return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
          }
          static get platform() {
            return "undefined" == typeof navigator ? shadow(this, "platform", { isWin: false, isMac: false }) : shadow(this, "platform", { isWin: navigator.platform.includes("Win"), isMac: navigator.platform.includes("Mac") });
          }
          static get isCSSRoundSupported() {
            var _a2, _b;
            return shadow(this, "isCSSRoundSupported", (_b = (_a2 = globalThis.CSS) == null ? void 0 : _a2.supports) == null ? void 0 : _b.call(_a2, "width: round(1.5px, 1px)"));
          }
        };
        const s = [...Array(256).keys()].map((e3) => e3.toString(16).padStart(2, "0"));
        t2.Util = class Util {
          static makeHexColor(e3, t3, a3) {
            return `#${s[e3]}${s[t3]}${s[a3]}`;
          }
          static scaleMinMax(e3, t3) {
            let a3;
            if (e3[0]) {
              if (e3[0] < 0) {
                a3 = t3[0];
                t3[0] = t3[1];
                t3[1] = a3;
              }
              t3[0] *= e3[0];
              t3[1] *= e3[0];
              if (e3[3] < 0) {
                a3 = t3[2];
                t3[2] = t3[3];
                t3[3] = a3;
              }
              t3[2] *= e3[3];
              t3[3] *= e3[3];
            } else {
              a3 = t3[0];
              t3[0] = t3[2];
              t3[2] = a3;
              a3 = t3[1];
              t3[1] = t3[3];
              t3[3] = a3;
              if (e3[1] < 0) {
                a3 = t3[2];
                t3[2] = t3[3];
                t3[3] = a3;
              }
              t3[2] *= e3[1];
              t3[3] *= e3[1];
              if (e3[2] < 0) {
                a3 = t3[0];
                t3[0] = t3[1];
                t3[1] = a3;
              }
              t3[0] *= e3[2];
              t3[1] *= e3[2];
            }
            t3[0] += e3[4];
            t3[1] += e3[4];
            t3[2] += e3[5];
            t3[3] += e3[5];
          }
          static transform(e3, t3) {
            return [e3[0] * t3[0] + e3[2] * t3[1], e3[1] * t3[0] + e3[3] * t3[1], e3[0] * t3[2] + e3[2] * t3[3], e3[1] * t3[2] + e3[3] * t3[3], e3[0] * t3[4] + e3[2] * t3[5] + e3[4], e3[1] * t3[4] + e3[3] * t3[5] + e3[5]];
          }
          static applyTransform(e3, t3) {
            return [e3[0] * t3[0] + e3[1] * t3[2] + t3[4], e3[0] * t3[1] + e3[1] * t3[3] + t3[5]];
          }
          static applyInverseTransform(e3, t3) {
            const a3 = t3[0] * t3[3] - t3[1] * t3[2];
            return [(e3[0] * t3[3] - e3[1] * t3[2] + t3[2] * t3[5] - t3[4] * t3[3]) / a3, (-e3[0] * t3[1] + e3[1] * t3[0] + t3[4] * t3[1] - t3[5] * t3[0]) / a3];
          }
          static getAxialAlignedBoundingBox(e3, t3) {
            const a3 = this.applyTransform(e3, t3), r2 = this.applyTransform(e3.slice(2, 4), t3), n2 = this.applyTransform([e3[0], e3[3]], t3), i2 = this.applyTransform([e3[2], e3[1]], t3);
            return [Math.min(a3[0], r2[0], n2[0], i2[0]), Math.min(a3[1], r2[1], n2[1], i2[1]), Math.max(a3[0], r2[0], n2[0], i2[0]), Math.max(a3[1], r2[1], n2[1], i2[1])];
          }
          static inverseTransform(e3) {
            const t3 = e3[0] * e3[3] - e3[1] * e3[2];
            return [e3[3] / t3, -e3[1] / t3, -e3[2] / t3, e3[0] / t3, (e3[2] * e3[5] - e3[4] * e3[3]) / t3, (e3[4] * e3[1] - e3[5] * e3[0]) / t3];
          }
          static singularValueDecompose2dScale(e3) {
            const t3 = [e3[0], e3[2], e3[1], e3[3]], a3 = e3[0] * t3[0] + e3[1] * t3[2], r2 = e3[0] * t3[1] + e3[1] * t3[3], n2 = e3[2] * t3[0] + e3[3] * t3[2], i2 = e3[2] * t3[1] + e3[3] * t3[3], s2 = (a3 + i2) / 2, o2 = Math.sqrt((a3 + i2) ** 2 - 4 * (a3 * i2 - n2 * r2)) / 2, c2 = s2 + o2 || 1, l2 = s2 - o2 || 1;
            return [Math.sqrt(c2), Math.sqrt(l2)];
          }
          static normalizeRect(e3) {
            const t3 = e3.slice(0);
            if (e3[0] > e3[2]) {
              t3[0] = e3[2];
              t3[2] = e3[0];
            }
            if (e3[1] > e3[3]) {
              t3[1] = e3[3];
              t3[3] = e3[1];
            }
            return t3;
          }
          static intersect(e3, t3) {
            const a3 = Math.max(Math.min(e3[0], e3[2]), Math.min(t3[0], t3[2])), r2 = Math.min(Math.max(e3[0], e3[2]), Math.max(t3[0], t3[2]));
            if (a3 > r2) return null;
            const n2 = Math.max(Math.min(e3[1], e3[3]), Math.min(t3[1], t3[3])), i2 = Math.min(Math.max(e3[1], e3[3]), Math.max(t3[1], t3[3]));
            return n2 > i2 ? null : [a3, n2, r2, i2];
          }
          static bezierBoundingBox(e3, t3, a3, r2, n2, i2, s2, o2) {
            const c2 = [], l2 = [[], []];
            let h, u, d, f, g, p, m, b;
            for (let l3 = 0; l3 < 2; ++l3) {
              if (0 === l3) {
                u = 6 * e3 - 12 * a3 + 6 * n2;
                h = -3 * e3 + 9 * a3 - 9 * n2 + 3 * s2;
                d = 3 * a3 - 3 * e3;
              } else {
                u = 6 * t3 - 12 * r2 + 6 * i2;
                h = -3 * t3 + 9 * r2 - 9 * i2 + 3 * o2;
                d = 3 * r2 - 3 * t3;
              }
              if (Math.abs(h) < 1e-12) {
                if (Math.abs(u) < 1e-12) continue;
                f = -d / u;
                0 < f && f < 1 && c2.push(f);
              } else {
                m = u * u - 4 * d * h;
                b = Math.sqrt(m);
                if (!(m < 0)) {
                  g = (-u + b) / (2 * h);
                  0 < g && g < 1 && c2.push(g);
                  p = (-u - b) / (2 * h);
                  0 < p && p < 1 && c2.push(p);
                }
              }
            }
            let y, w = c2.length;
            const S = w;
            for (; w--; ) {
              f = c2[w];
              y = 1 - f;
              l2[0][w] = y * y * y * e3 + 3 * y * y * f * a3 + 3 * y * f * f * n2 + f * f * f * s2;
              l2[1][w] = y * y * y * t3 + 3 * y * y * f * r2 + 3 * y * f * f * i2 + f * f * f * o2;
            }
            l2[0][S] = e3;
            l2[1][S] = t3;
            l2[0][S + 1] = s2;
            l2[1][S + 1] = o2;
            l2[0].length = l2[1].length = S + 2;
            return [Math.min(...l2[0]), Math.min(...l2[1]), Math.max(...l2[0]), Math.max(...l2[1])];
          }
        };
        const o = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
        function stringToUTF8String(e3) {
          return decodeURIComponent(escape(e3));
        }
        t2.PromiseCapability = (_a = class {
          constructor() {
            __privateAdd(this, _e, false);
            this.promise = new Promise((e3, t3) => {
              this.resolve = (t4) => {
                __privateSet(this, _e, true);
                e3(t4);
              };
              this.reject = (e4) => {
                __privateSet(this, _e, true);
                t3(e4);
              };
            });
          }
          get settled() {
            return __privateGet(this, _e);
          }
        }, _e = new WeakMap(), _a);
        let c = null, l = null;
        t2.AnnotationPrefix = "pdfjs_internal_id_";
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XRefParseException = t2.XRefEntryException = t2.ParserEOFException = t2.PDF_VERSION_REGEXP = t2.MissingDataException = void 0;
        t2.arrayBuffersToBytes = function arrayBuffersToBytes(e3) {
          const t3 = e3.length;
          if (0 === t3) return new Uint8Array(0);
          if (1 === t3) return new Uint8Array(e3[0]);
          let a3 = 0;
          for (let r3 = 0; r3 < t3; r3++) a3 += e3[r3].byteLength;
          const r2 = new Uint8Array(a3);
          let n2 = 0;
          for (let a4 = 0; a4 < t3; a4++) {
            const t4 = new Uint8Array(e3[a4]);
            r2.set(t4, n2);
            n2 += t4.byteLength;
          }
          return r2;
        };
        t2.collectActions = function collectActions(e3, t3, a3) {
          const i2 = /* @__PURE__ */ Object.create(null), s2 = getInheritableProperty({ dict: t3, key: "AA", stopWhenFound: false });
          if (s2) for (let t4 = s2.length - 1; t4 >= 0; t4--) {
            const r2 = s2[t4];
            if (r2 instanceof n.Dict) for (const t5 of r2.getKeys()) {
              const s3 = a3[t5];
              if (!s3) continue;
              const o2 = [];
              _collectJS(r2.getRaw(t5), e3, o2, new n.RefSet());
              o2.length > 0 && (i2[s3] = o2);
            }
          }
          if (t3.has("A")) {
            const a4 = [];
            _collectJS(t3.get("A"), e3, a4, new n.RefSet());
            a4.length > 0 && (i2.Action = a4);
          }
          return (0, r.objectSize)(i2) > 0 ? i2 : null;
        };
        t2.encodeToXmlString = function encodeToXmlString(e3) {
          const t3 = [];
          let a3 = 0;
          for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) {
            const n3 = e3.codePointAt(r2);
            if (32 <= n3 && n3 <= 126) {
              const i2 = o[n3];
              if (i2) {
                a3 < r2 && t3.push(e3.substring(a3, r2));
                t3.push(i2);
                a3 = r2 + 1;
              }
            } else {
              a3 < r2 && t3.push(e3.substring(a3, r2));
              t3.push(`&#x${n3.toString(16).toUpperCase()};`);
              n3 > 55295 && (n3 < 57344 || n3 > 65533) && r2++;
              a3 = r2 + 1;
            }
          }
          if (0 === t3.length) return e3;
          a3 < e3.length && t3.push(e3.substring(a3, e3.length));
          return t3.join("");
        };
        t2.escapePDFName = function escapePDFName(e3) {
          const t3 = [];
          let a3 = 0;
          for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) {
            const n3 = e3.charCodeAt(r2);
            if (n3 < 33 || n3 > 126 || 35 === n3 || 40 === n3 || 41 === n3 || 60 === n3 || 62 === n3 || 91 === n3 || 93 === n3 || 123 === n3 || 125 === n3 || 47 === n3 || 37 === n3) {
              a3 < r2 && t3.push(e3.substring(a3, r2));
              t3.push(`#${n3.toString(16)}`);
              a3 = r2 + 1;
            }
          }
          if (0 === t3.length) return e3;
          a3 < e3.length && t3.push(e3.substring(a3, e3.length));
          return t3.join("");
        };
        t2.escapeString = function escapeString(e3) {
          return e3.replaceAll(/([()\\\n\r])/g, (e4) => "\n" === e4 ? "\\n" : "\r" === e4 ? "\\r" : `\\${e4}`);
        };
        t2.getInheritableProperty = getInheritableProperty;
        t2.getLookupTableFactory = function getLookupTableFactory(e3) {
          let t3;
          return function() {
            if (e3) {
              t3 = /* @__PURE__ */ Object.create(null);
              e3(t3);
              e3 = null;
            }
            return t3;
          };
        };
        t2.getNewAnnotationsMap = function getNewAnnotationsMap(e3) {
          if (!e3) return null;
          const t3 = /* @__PURE__ */ new Map();
          for (const [a3, n2] of e3) {
            if (!a3.startsWith(r.AnnotationEditorPrefix)) continue;
            let e4 = t3.get(n2.pageIndex);
            if (!e4) {
              e4 = [];
              t3.set(n2.pageIndex, e4);
            }
            e4.push(n2);
          }
          return t3.size > 0 ? t3 : null;
        };
        t2.getRotationMatrix = function getRotationMatrix(e3, t3, a3) {
          switch (e3) {
            case 90:
              return [0, 1, -1, 0, t3, 0];
            case 180:
              return [-1, 0, 0, -1, t3, a3];
            case 270:
              return [0, -1, 1, 0, 0, a3];
            default:
              throw new Error("Invalid rotation");
          }
        };
        t2.isAscii = function isAscii(e3) {
          return /^[\x00-\x7F]*$/.test(e3);
        };
        t2.isWhiteSpace = function isWhiteSpace(e3) {
          return 32 === e3 || 9 === e3 || 13 === e3 || 10 === e3;
        };
        t2.log2 = function log2(e3) {
          if (e3 <= 0) return 0;
          return Math.ceil(Math.log2(e3));
        };
        t2.numberToString = function numberToString(e3) {
          if (Number.isInteger(e3)) return e3.toString();
          const t3 = Math.round(100 * e3);
          if (t3 % 100 == 0) return (t3 / 100).toString();
          if (t3 % 10 == 0) return e3.toFixed(1);
          return e3.toFixed(2);
        };
        t2.parseXFAPath = function parseXFAPath(e3) {
          const t3 = /(.+)\[(\d+)\]$/;
          return e3.split(".").map((e4) => {
            const a3 = e4.match(t3);
            return a3 ? { name: a3[1], pos: parseInt(a3[2], 10) } : { name: e4, pos: 0 };
          });
        };
        t2.readInt8 = function readInt8(e3, t3) {
          return e3[t3] << 24 >> 24;
        };
        t2.readUint16 = function readUint16(e3, t3) {
          return e3[t3] << 8 | e3[t3 + 1];
        };
        t2.readUint32 = function readUint32(e3, t3) {
          return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
        };
        t2.recoverJsURL = function recoverJsURL(e3) {
          const t3 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e3);
          if (t3 == null ? void 0 : t3[2]) {
            const e4 = t3[2];
            let a3 = false;
            "true" === t3[3] && "app.launchURL" === t3[1] && (a3 = true);
            return { url: e4, newWindow: a3 };
          }
          return null;
        };
        t2.stringToUTF16HexString = function stringToUTF16HexString(e3) {
          const t3 = [];
          for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) {
            const r3 = e3.charCodeAt(a3);
            t3.push((r3 >> 8 & 255).toString(16).padStart(2, "0"), (255 & r3).toString(16).padStart(2, "0"));
          }
          return t3.join("");
        };
        t2.stringToUTF16String = function stringToUTF16String(e3, t3 = false) {
          const a3 = [];
          t3 && a3.push("þÿ");
          for (let t4 = 0, r2 = e3.length; t4 < r2; t4++) {
            const r3 = e3.charCodeAt(t4);
            a3.push(String.fromCharCode(r3 >> 8 & 255), String.fromCharCode(255 & r3));
          }
          return a3.join("");
        };
        t2.toRomanNumerals = function toRomanNumerals(e3, t3 = false) {
          (0, r.assert)(Number.isInteger(e3) && e3 > 0, "The number should be a positive integer.");
          const a3 = [];
          let n2;
          for (; e3 >= 1e3; ) {
            e3 -= 1e3;
            a3.push("M");
          }
          n2 = e3 / 100 | 0;
          e3 %= 100;
          a3.push(s[n2]);
          n2 = e3 / 10 | 0;
          e3 %= 10;
          a3.push(s[10 + n2]);
          a3.push(s[20 + e3]);
          const i2 = a3.join("");
          return t3 ? i2.toLowerCase() : i2;
        };
        t2.validateCSSFont = function validateCSSFont(e3) {
          const t3 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: a3, fontWeight: r2, italicAngle: n2 } = e3;
          if (!validateFontName(a3, true)) return false;
          const i2 = r2 ? r2.toString() : "";
          e3.fontWeight = t3.has(i2) ? i2 : "400";
          const s2 = parseFloat(n2);
          e3.italicAngle = isNaN(s2) || s2 < -90 || s2 > 90 ? "14" : n2.toString();
          return true;
        };
        t2.validateFontName = validateFontName;
        var r = a2(2), n = a2(4), i = a2(5);
        t2.PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
        class MissingDataException extends r.BaseException {
          constructor(e3, t3) {
            super(`Missing data [${e3}, ${t3})`, "MissingDataException");
            this.begin = e3;
            this.end = t3;
          }
        }
        t2.MissingDataException = MissingDataException;
        class ParserEOFException extends r.BaseException {
          constructor(e3) {
            super(e3, "ParserEOFException");
          }
        }
        t2.ParserEOFException = ParserEOFException;
        class XRefEntryException extends r.BaseException {
          constructor(e3) {
            super(e3, "XRefEntryException");
          }
        }
        t2.XRefEntryException = XRefEntryException;
        class XRefParseException extends r.BaseException {
          constructor(e3) {
            super(e3, "XRefParseException");
          }
        }
        t2.XRefParseException = XRefParseException;
        function getInheritableProperty({ dict: e3, key: t3, getArray: a3 = false, stopWhenFound: r2 = true }) {
          let i2;
          const s2 = new n.RefSet();
          for (; e3 instanceof n.Dict && (!e3.objId || !s2.has(e3.objId)); ) {
            e3.objId && s2.put(e3.objId);
            const n2 = a3 ? e3.getArray(t3) : e3.get(t3);
            if (void 0 !== n2) {
              if (r2) return n2;
              (i2 || (i2 = [])).push(n2);
            }
            e3 = e3.get("Parent");
          }
          return i2;
        }
        const s = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
        function _collectJS(e3, t3, a3, s2) {
          if (!e3) return;
          let o2 = null;
          if (e3 instanceof n.Ref) {
            if (s2.has(e3)) return;
            o2 = e3;
            s2.put(o2);
            e3 = t3.fetch(e3);
          }
          if (Array.isArray(e3)) for (const r2 of e3) _collectJS(r2, t3, a3, s2);
          else if (e3 instanceof n.Dict) {
            if ((0, n.isName)(e3.get("S"), "JavaScript")) {
              const t4 = e3.get("JS");
              let n2;
              t4 instanceof i.BaseStream ? n2 = t4.getString() : "string" == typeof t4 && (n2 = t4);
              n2 && (n2 = (0, r.stringToPDFString)(n2).replaceAll("\0", ""));
              n2 && a3.push(n2);
            }
            _collectJS(e3.getRaw("Next"), t3, a3, s2);
          }
          o2 && s2.remove(o2);
        }
        const o = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
        function validateFontName(e3, t3 = false) {
          const a3 = /^("|').*("|')$/.exec(e3);
          if (a3 && a3[1] === a3[2]) {
            if (new RegExp(`[^\\\\]${a3[1]}`).test(e3.slice(1, -1))) {
              t3 && (0, r.warn)(`FontFamily contains unescaped ${a3[1]}: ${e3}.`);
              return false;
            }
          } else for (const a4 of e3.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(a4) || !/^[\w-\\]+$/.test(a4)) {
            t3 && (0, r.warn)(`FontFamily contains invalid <custom-ident>: ${e3}.`);
            return false;
          }
          return true;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.RefSetCache = t2.RefSet = t2.Ref = t2.Name = t2.EOF = t2.Dict = t2.Cmd = t2.CIRCULAR_REF = void 0;
        t2.clearPrimitiveCaches = function clearPrimitiveCaches() {
          s = /* @__PURE__ */ Object.create(null);
          o = /* @__PURE__ */ Object.create(null);
          c = /* @__PURE__ */ Object.create(null);
        };
        t2.isCmd = function isCmd(e3, t3) {
          return e3 instanceof Cmd && (void 0 === t3 || e3.cmd === t3);
        };
        t2.isDict = function isDict(e3, t3) {
          return e3 instanceof Dict && (void 0 === t3 || isName(e3.get("Type"), t3));
        };
        t2.isName = isName;
        t2.isRefsEqual = function isRefsEqual(e3, t3) {
          return e3.num === t3.num && e3.gen === t3.gen;
        };
        var r = a2(2);
        const n = Symbol("CIRCULAR_REF");
        t2.CIRCULAR_REF = n;
        const i = Symbol("EOF");
        t2.EOF = i;
        let s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null);
        class Name {
          constructor(e3) {
            this.name = e3;
          }
          static get(e3) {
            return o[e3] || (o[e3] = new Name(e3));
          }
        }
        t2.Name = Name;
        class Cmd {
          constructor(e3) {
            this.cmd = e3;
          }
          static get(e3) {
            return s[e3] || (s[e3] = new Cmd(e3));
          }
        }
        t2.Cmd = Cmd;
        const l = function nonSerializableClosure() {
          return l;
        };
        class Dict {
          constructor(e3 = null) {
            this._map = /* @__PURE__ */ Object.create(null);
            this.xref = e3;
            this.objId = null;
            this.suppressEncryption = false;
            this.__nonSerializable__ = l;
          }
          assignXref(e3) {
            this.xref = e3;
          }
          get size() {
            return Object.keys(this._map).length;
          }
          get(e3, t3, a3) {
            let r2 = this._map[e3];
            if (void 0 === r2 && void 0 !== t3) {
              r2 = this._map[t3];
              void 0 === r2 && void 0 !== a3 && (r2 = this._map[a3]);
            }
            return r2 instanceof Ref && this.xref ? this.xref.fetch(r2, this.suppressEncryption) : r2;
          }
          async getAsync(e3, t3, a3) {
            let r2 = this._map[e3];
            if (void 0 === r2 && void 0 !== t3) {
              r2 = this._map[t3];
              void 0 === r2 && void 0 !== a3 && (r2 = this._map[a3]);
            }
            return r2 instanceof Ref && this.xref ? this.xref.fetchAsync(r2, this.suppressEncryption) : r2;
          }
          getArray(e3, t3, a3) {
            let r2 = this._map[e3];
            if (void 0 === r2 && void 0 !== t3) {
              r2 = this._map[t3];
              void 0 === r2 && void 0 !== a3 && (r2 = this._map[a3]);
            }
            r2 instanceof Ref && this.xref && (r2 = this.xref.fetch(r2, this.suppressEncryption));
            if (Array.isArray(r2)) {
              r2 = r2.slice();
              for (let e4 = 0, t4 = r2.length; e4 < t4; e4++) r2[e4] instanceof Ref && this.xref && (r2[e4] = this.xref.fetch(r2[e4], this.suppressEncryption));
            }
            return r2;
          }
          getRaw(e3) {
            return this._map[e3];
          }
          getKeys() {
            return Object.keys(this._map);
          }
          getRawValues() {
            return Object.values(this._map);
          }
          set(e3, t3) {
            this._map[e3] = t3;
          }
          has(e3) {
            return void 0 !== this._map[e3];
          }
          forEach(e3) {
            for (const t3 in this._map) e3(t3, this.get(t3));
          }
          static get empty() {
            const e3 = new Dict(null);
            e3.set = (e4, t3) => {
              (0, r.unreachable)("Should not call `set` on the empty dictionary.");
            };
            return (0, r.shadow)(this, "empty", e3);
          }
          static merge({ xref: e3, dictArray: t3, mergeSubDicts: a3 = false }) {
            const r2 = new Dict(e3), n2 = /* @__PURE__ */ new Map();
            for (const e4 of t3) if (e4 instanceof Dict) for (const [t4, r3] of Object.entries(e4._map)) {
              let e5 = n2.get(t4);
              if (void 0 === e5) {
                e5 = [];
                n2.set(t4, e5);
              } else if (!(a3 && r3 instanceof Dict)) continue;
              e5.push(r3);
            }
            for (const [t4, a4] of n2) {
              if (1 === a4.length || !(a4[0] instanceof Dict)) {
                r2._map[t4] = a4[0];
                continue;
              }
              const n3 = new Dict(e3);
              for (const e4 of a4) for (const [t5, a5] of Object.entries(e4._map)) void 0 === n3._map[t5] && (n3._map[t5] = a5);
              n3.size > 0 && (r2._map[t4] = n3);
            }
            n2.clear();
            return r2.size > 0 ? r2 : Dict.empty;
          }
          clone() {
            const e3 = new Dict(this.xref);
            for (const t3 of this.getKeys()) e3.set(t3, this.getRaw(t3));
            return e3;
          }
        }
        t2.Dict = Dict;
        class Ref {
          constructor(e3, t3) {
            this.num = e3;
            this.gen = t3;
          }
          toString() {
            return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
          }
          static fromString(e3) {
            const t3 = c[e3];
            if (t3) return t3;
            const a3 = /^(\d+)R(\d*)$/.exec(e3);
            return a3 && "0" !== a3[1] ? c[e3] = new Ref(parseInt(a3[1]), a3[2] ? parseInt(a3[2]) : 0) : null;
          }
          static get(e3, t3) {
            const a3 = 0 === t3 ? `${e3}R` : `${e3}R${t3}`;
            return c[a3] || (c[a3] = new Ref(e3, t3));
          }
        }
        t2.Ref = Ref;
        class RefSet {
          constructor(e3 = null) {
            this._set = new Set(e3 == null ? void 0 : e3._set);
          }
          has(e3) {
            return this._set.has(e3.toString());
          }
          put(e3) {
            this._set.add(e3.toString());
          }
          remove(e3) {
            this._set.delete(e3.toString());
          }
          [Symbol.iterator]() {
            return this._set.values();
          }
          clear() {
            this._set.clear();
          }
        }
        t2.RefSet = RefSet;
        class RefSetCache {
          constructor() {
            this._map = /* @__PURE__ */ new Map();
          }
          get size() {
            return this._map.size;
          }
          get(e3) {
            return this._map.get(e3.toString());
          }
          has(e3) {
            return this._map.has(e3.toString());
          }
          put(e3, t3) {
            this._map.set(e3.toString(), t3);
          }
          putAlias(e3, t3) {
            this._map.set(e3.toString(), this.get(t3));
          }
          [Symbol.iterator]() {
            return this._map.values();
          }
          clear() {
            this._map.clear();
          }
        }
        t2.RefSetCache = RefSetCache;
        function isName(e3, t3) {
          return e3 instanceof Name && (void 0 === t3 || e3.name === t3);
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.BaseStream = void 0;
        var r = a2(2);
        class BaseStream {
          constructor() {
            this.constructor === BaseStream && (0, r.unreachable)("Cannot initialize BaseStream.");
          }
          get length() {
            (0, r.unreachable)("Abstract getter `length` accessed");
          }
          get isEmpty() {
            (0, r.unreachable)("Abstract getter `isEmpty` accessed");
          }
          get isDataLoaded() {
            return (0, r.shadow)(this, "isDataLoaded", true);
          }
          getByte() {
            (0, r.unreachable)("Abstract method `getByte` called");
          }
          getBytes(e3) {
            (0, r.unreachable)("Abstract method `getBytes` called");
          }
          peekByte() {
            const e3 = this.getByte();
            -1 !== e3 && this.pos--;
            return e3;
          }
          peekBytes(e3) {
            const t3 = this.getBytes(e3);
            this.pos -= t3.length;
            return t3;
          }
          getUint16() {
            const e3 = this.getByte(), t3 = this.getByte();
            return -1 === e3 || -1 === t3 ? -1 : (e3 << 8) + t3;
          }
          getInt32() {
            return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
          }
          getByteRange(e3, t3) {
            (0, r.unreachable)("Abstract method `getByteRange` called");
          }
          getString(e3) {
            return (0, r.bytesToString)(this.getBytes(e3));
          }
          skip(e3) {
            this.pos += e3 || 1;
          }
          reset() {
            (0, r.unreachable)("Abstract method `reset` called");
          }
          moveStart() {
            (0, r.unreachable)("Abstract method `moveStart` called");
          }
          makeSubStream(e3, t3, a3 = null) {
            (0, r.unreachable)("Abstract method `makeSubStream` called");
          }
          getBaseStreams() {
            return null;
          }
        }
        t2.BaseStream = BaseStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NetworkPdfManager = t2.LocalPdfManager = void 0;
        var r = a2(2), n = a2(7), i = a2(3), s = a2(9), o = a2(8);
        class BasePdfManager {
          constructor(e3) {
            var _a;
            this.constructor === BasePdfManager && (0, r.unreachable)("Cannot initialize BasePdfManager.");
            this._docBaseUrl = function parseDocBaseUrl(e4) {
              if (e4) {
                const t3 = (0, r.createValidAbsoluteUrl)(e4);
                if (t3) return t3.href;
                (0, r.warn)(`Invalid absolute docBaseUrl: "${e4}".`);
              }
              return null;
            }(e3.docBaseUrl);
            this._docId = e3.docId;
            this._password = e3.password;
            this.enableXfa = e3.enableXfa;
            (_a = e3.evaluatorOptions).isOffscreenCanvasSupported && (_a.isOffscreenCanvasSupported = r.FeatureTest.isOffscreenCanvasSupported);
            this.evaluatorOptions = e3.evaluatorOptions;
          }
          get docId() {
            return this._docId;
          }
          get password() {
            return this._password;
          }
          get docBaseUrl() {
            return this._docBaseUrl;
          }
          get catalog() {
            return this.pdfDocument.catalog;
          }
          ensureDoc(e3, t3) {
            return this.ensure(this.pdfDocument, e3, t3);
          }
          ensureXRef(e3, t3) {
            return this.ensure(this.pdfDocument.xref, e3, t3);
          }
          ensureCatalog(e3, t3) {
            return this.ensure(this.pdfDocument.catalog, e3, t3);
          }
          getPage(e3) {
            return this.pdfDocument.getPage(e3);
          }
          fontFallback(e3, t3) {
            return this.pdfDocument.fontFallback(e3, t3);
          }
          loadXfaFonts(e3, t3) {
            return this.pdfDocument.loadXfaFonts(e3, t3);
          }
          loadXfaImages() {
            return this.pdfDocument.loadXfaImages();
          }
          serializeXfaData(e3) {
            return this.pdfDocument.serializeXfaData(e3);
          }
          cleanup(e3 = false) {
            return this.pdfDocument.cleanup(e3);
          }
          async ensure(e3, t3, a3) {
            (0, r.unreachable)("Abstract method `ensure` called");
          }
          requestRange(e3, t3) {
            (0, r.unreachable)("Abstract method `requestRange` called");
          }
          requestLoadedStream(e3 = false) {
            (0, r.unreachable)("Abstract method `requestLoadedStream` called");
          }
          sendProgressiveData(e3) {
            (0, r.unreachable)("Abstract method `sendProgressiveData` called");
          }
          updatePassword(e3) {
            this._password = e3;
          }
          terminate(e3) {
            (0, r.unreachable)("Abstract method `terminate` called");
          }
        }
        t2.LocalPdfManager = class LocalPdfManager extends BasePdfManager {
          constructor(e3) {
            super(e3);
            const t3 = new o.Stream(e3.source);
            this.pdfDocument = new s.PDFDocument(this, t3);
            this._loadedStreamPromise = Promise.resolve(t3);
          }
          async ensure(e3, t3, a3) {
            const r2 = e3[t3];
            return "function" == typeof r2 ? r2.apply(e3, a3) : r2;
          }
          requestRange(e3, t3) {
            return Promise.resolve();
          }
          requestLoadedStream(e3 = false) {
            return this._loadedStreamPromise;
          }
          terminate(e3) {
          }
        };
        t2.NetworkPdfManager = class NetworkPdfManager extends BasePdfManager {
          constructor(e3) {
            super(e3);
            this.streamManager = new n.ChunkedStreamManager(e3.source, { msgHandler: e3.handler, length: e3.length, disableAutoFetch: e3.disableAutoFetch, rangeChunkSize: e3.rangeChunkSize });
            this.pdfDocument = new s.PDFDocument(this, this.streamManager.getStream());
          }
          async ensure(e3, t3, a3) {
            try {
              const r2 = e3[t3];
              return "function" == typeof r2 ? r2.apply(e3, a3) : r2;
            } catch (r2) {
              if (!(r2 instanceof i.MissingDataException)) throw r2;
              await this.requestRange(r2.begin, r2.end);
              return this.ensure(e3, t3, a3);
            }
          }
          requestRange(e3, t3) {
            return this.streamManager.requestRange(e3, t3);
          }
          requestLoadedStream(e3 = false) {
            return this.streamManager.requestAllChunks(e3);
          }
          sendProgressiveData(e3) {
            this.streamManager.onReceiveData({ chunk: e3 });
          }
          terminate(e3) {
            this.streamManager.abort(e3);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ChunkedStreamManager = t2.ChunkedStream = void 0;
        var r = a2(3), n = a2(2), i = a2(8);
        class ChunkedStream extends i.Stream {
          constructor(e3, t3, a3) {
            super(new Uint8Array(e3), 0, e3, null);
            this.chunkSize = t3;
            this._loadedChunks = /* @__PURE__ */ new Set();
            this.numChunks = Math.ceil(e3 / t3);
            this.manager = a3;
            this.progressiveDataLength = 0;
            this.lastSuccessfulEnsureByteChunk = -1;
          }
          getMissingChunks() {
            const e3 = [];
            for (let t3 = 0, a3 = this.numChunks; t3 < a3; ++t3) this._loadedChunks.has(t3) || e3.push(t3);
            return e3;
          }
          get numChunksLoaded() {
            return this._loadedChunks.size;
          }
          get isDataLoaded() {
            return this.numChunksLoaded === this.numChunks;
          }
          onReceiveData(e3, t3) {
            const a3 = this.chunkSize;
            if (e3 % a3 != 0) throw new Error(`Bad begin offset: ${e3}`);
            const r2 = e3 + t3.byteLength;
            if (r2 % a3 != 0 && r2 !== this.bytes.length) throw new Error(`Bad end offset: ${r2}`);
            this.bytes.set(new Uint8Array(t3), e3);
            const n2 = Math.floor(e3 / a3), i2 = Math.floor((r2 - 1) / a3) + 1;
            for (let e4 = n2; e4 < i2; ++e4) this._loadedChunks.add(e4);
          }
          onReceiveProgressiveData(e3) {
            let t3 = this.progressiveDataLength;
            const a3 = Math.floor(t3 / this.chunkSize);
            this.bytes.set(new Uint8Array(e3), t3);
            t3 += e3.byteLength;
            this.progressiveDataLength = t3;
            const r2 = t3 >= this.end ? this.numChunks : Math.floor(t3 / this.chunkSize);
            for (let e4 = a3; e4 < r2; ++e4) this._loadedChunks.add(e4);
          }
          ensureByte(e3) {
            if (e3 < this.progressiveDataLength) return;
            const t3 = Math.floor(e3 / this.chunkSize);
            if (!(t3 > this.numChunks) && t3 !== this.lastSuccessfulEnsureByteChunk) {
              if (!this._loadedChunks.has(t3)) throw new r.MissingDataException(e3, e3 + 1);
              this.lastSuccessfulEnsureByteChunk = t3;
            }
          }
          ensureRange(e3, t3) {
            if (e3 >= t3) return;
            if (t3 <= this.progressiveDataLength) return;
            const a3 = Math.floor(e3 / this.chunkSize);
            if (a3 > this.numChunks) return;
            const n2 = Math.min(Math.floor((t3 - 1) / this.chunkSize) + 1, this.numChunks);
            for (let i2 = a3; i2 < n2; ++i2) if (!this._loadedChunks.has(i2)) throw new r.MissingDataException(e3, t3);
          }
          nextEmptyChunk(e3) {
            const t3 = this.numChunks;
            for (let a3 = 0; a3 < t3; ++a3) {
              const r2 = (e3 + a3) % t3;
              if (!this._loadedChunks.has(r2)) return r2;
            }
            return null;
          }
          hasChunk(e3) {
            return this._loadedChunks.has(e3);
          }
          getByte() {
            const e3 = this.pos;
            if (e3 >= this.end) return -1;
            e3 >= this.progressiveDataLength && this.ensureByte(e3);
            return this.bytes[this.pos++];
          }
          getBytes(e3) {
            const t3 = this.bytes, a3 = this.pos, r2 = this.end;
            if (!e3) {
              r2 > this.progressiveDataLength && this.ensureRange(a3, r2);
              return t3.subarray(a3, r2);
            }
            let n2 = a3 + e3;
            n2 > r2 && (n2 = r2);
            n2 > this.progressiveDataLength && this.ensureRange(a3, n2);
            this.pos = n2;
            return t3.subarray(a3, n2);
          }
          getByteRange(e3, t3) {
            e3 < 0 && (e3 = 0);
            t3 > this.end && (t3 = this.end);
            t3 > this.progressiveDataLength && this.ensureRange(e3, t3);
            return this.bytes.subarray(e3, t3);
          }
          makeSubStream(e3, t3, a3 = null) {
            t3 ? e3 + t3 > this.progressiveDataLength && this.ensureRange(e3, e3 + t3) : e3 >= this.progressiveDataLength && this.ensureByte(e3);
            function ChunkedStreamSubstream() {
            }
            ChunkedStreamSubstream.prototype = Object.create(this);
            ChunkedStreamSubstream.prototype.getMissingChunks = function() {
              const e4 = this.chunkSize, t4 = Math.floor(this.start / e4), a4 = Math.floor((this.end - 1) / e4) + 1, r3 = [];
              for (let e5 = t4; e5 < a4; ++e5) this._loadedChunks.has(e5) || r3.push(e5);
              return r3;
            };
            Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
              return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
            }, configurable: true });
            const r2 = new ChunkedStreamSubstream();
            r2.pos = r2.start = e3;
            r2.end = e3 + t3 || this.end;
            r2.dict = a3;
            return r2;
          }
          getBaseStreams() {
            return [this];
          }
        }
        t2.ChunkedStream = ChunkedStream;
        t2.ChunkedStreamManager = class ChunkedStreamManager {
          constructor(e3, t3) {
            this.length = t3.length;
            this.chunkSize = t3.rangeChunkSize;
            this.stream = new ChunkedStream(this.length, this.chunkSize, this);
            this.pdfNetworkStream = e3;
            this.disableAutoFetch = t3.disableAutoFetch;
            this.msgHandler = t3.msgHandler;
            this.currRequestId = 0;
            this._chunksNeededByRequest = /* @__PURE__ */ new Map();
            this._requestsByChunk = /* @__PURE__ */ new Map();
            this._promisesByRequest = /* @__PURE__ */ new Map();
            this.progressiveDataLength = 0;
            this.aborted = false;
            this._loadedStreamCapability = new n.PromiseCapability();
          }
          sendRequest(e3, t3) {
            const a3 = this.pdfNetworkStream.getRangeReader(e3, t3);
            a3.isStreamingSupported || (a3.onProgress = this.onProgress.bind(this));
            let n2 = [], i2 = 0;
            return new Promise((e4, t4) => {
              const readChunk = ({ value: s, done: o }) => {
                try {
                  if (o) {
                    const t5 = (0, r.arrayBuffersToBytes)(n2);
                    n2 = null;
                    e4(t5);
                    return;
                  }
                  i2 += s.byteLength;
                  a3.isStreamingSupported && this.onProgress({ loaded: i2 });
                  n2.push(s);
                  a3.read().then(readChunk, t4);
                } catch (e5) {
                  t4(e5);
                }
              };
              a3.read().then(readChunk, t4);
            }).then((t4) => {
              this.aborted || this.onReceiveData({ chunk: t4, begin: e3 });
            });
          }
          requestAllChunks(e3 = false) {
            if (!e3) {
              const e4 = this.stream.getMissingChunks();
              this._requestChunks(e4);
            }
            return this._loadedStreamCapability.promise;
          }
          _requestChunks(e3) {
            const t3 = this.currRequestId++, a3 = /* @__PURE__ */ new Set();
            this._chunksNeededByRequest.set(t3, a3);
            for (const t4 of e3) this.stream.hasChunk(t4) || a3.add(t4);
            if (0 === a3.size) return Promise.resolve();
            const r2 = new n.PromiseCapability();
            this._promisesByRequest.set(t3, r2);
            const i2 = [];
            for (const e4 of a3) {
              let a4 = this._requestsByChunk.get(e4);
              if (!a4) {
                a4 = [];
                this._requestsByChunk.set(e4, a4);
                i2.push(e4);
              }
              a4.push(t3);
            }
            if (i2.length > 0) {
              const e4 = this.groupChunks(i2);
              for (const t4 of e4) {
                const e5 = t4.beginChunk * this.chunkSize, a4 = Math.min(t4.endChunk * this.chunkSize, this.length);
                this.sendRequest(e5, a4).catch(r2.reject);
              }
            }
            return r2.promise.catch((e4) => {
              if (!this.aborted) throw e4;
            });
          }
          getStream() {
            return this.stream;
          }
          requestRange(e3, t3) {
            t3 = Math.min(t3, this.length);
            const a3 = this.getBeginChunk(e3), r2 = this.getEndChunk(t3), n2 = [];
            for (let e4 = a3; e4 < r2; ++e4) n2.push(e4);
            return this._requestChunks(n2);
          }
          requestRanges(e3 = []) {
            const t3 = [];
            for (const a3 of e3) {
              const e4 = this.getBeginChunk(a3.begin), r2 = this.getEndChunk(a3.end);
              for (let a4 = e4; a4 < r2; ++a4) t3.includes(a4) || t3.push(a4);
            }
            t3.sort(function(e4, t4) {
              return e4 - t4;
            });
            return this._requestChunks(t3);
          }
          groupChunks(e3) {
            const t3 = [];
            let a3 = -1, r2 = -1;
            for (let n2 = 0, i2 = e3.length; n2 < i2; ++n2) {
              const i3 = e3[n2];
              a3 < 0 && (a3 = i3);
              if (r2 >= 0 && r2 + 1 !== i3) {
                t3.push({ beginChunk: a3, endChunk: r2 + 1 });
                a3 = i3;
              }
              n2 + 1 === e3.length && t3.push({ beginChunk: a3, endChunk: i3 + 1 });
              r2 = i3;
            }
            return t3;
          }
          onProgress(e3) {
            this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e3.loaded, total: this.length });
          }
          onReceiveData(e3) {
            const t3 = e3.chunk, a3 = void 0 === e3.begin, r2 = a3 ? this.progressiveDataLength : e3.begin, n2 = r2 + t3.byteLength, i2 = Math.floor(r2 / this.chunkSize), s = n2 < this.length ? Math.floor(n2 / this.chunkSize) : Math.ceil(n2 / this.chunkSize);
            if (a3) {
              this.stream.onReceiveProgressiveData(t3);
              this.progressiveDataLength = n2;
            } else this.stream.onReceiveData(r2, t3);
            this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
            const o = [];
            for (let e4 = i2; e4 < s; ++e4) {
              const t4 = this._requestsByChunk.get(e4);
              if (t4) {
                this._requestsByChunk.delete(e4);
                for (const a4 of t4) {
                  const t5 = this._chunksNeededByRequest.get(a4);
                  t5.has(e4) && t5.delete(e4);
                  t5.size > 0 || o.push(a4);
                }
              }
            }
            if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
              let e4;
              if (1 === this.stream.numChunksLoaded) {
                const t4 = this.stream.numChunks - 1;
                this.stream.hasChunk(t4) || (e4 = t4);
              } else e4 = this.stream.nextEmptyChunk(s);
              Number.isInteger(e4) && this._requestChunks([e4]);
            }
            for (const e4 of o) {
              const t4 = this._promisesByRequest.get(e4);
              this._promisesByRequest.delete(e4);
              t4.resolve();
            }
            this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
          }
          onError(e3) {
            this._loadedStreamCapability.reject(e3);
          }
          getBeginChunk(e3) {
            return Math.floor(e3 / this.chunkSize);
          }
          getEndChunk(e3) {
            return Math.floor((e3 - 1) / this.chunkSize) + 1;
          }
          abort(e3) {
            var _a;
            this.aborted = true;
            (_a = this.pdfNetworkStream) == null ? void 0 : _a.cancelAllRequests(e3);
            for (const t3 of this._promisesByRequest.values()) t3.reject(e3);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.StringStream = t2.Stream = t2.NullStream = void 0;
        var r = a2(5), n = a2(2);
        class Stream extends r.BaseStream {
          constructor(e3, t3, a3, r2) {
            super();
            this.bytes = e3 instanceof Uint8Array ? e3 : new Uint8Array(e3);
            this.start = t3 || 0;
            this.pos = this.start;
            this.end = t3 + a3 || this.bytes.length;
            this.dict = r2;
          }
          get length() {
            return this.end - this.start;
          }
          get isEmpty() {
            return 0 === this.length;
          }
          getByte() {
            return this.pos >= this.end ? -1 : this.bytes[this.pos++];
          }
          getBytes(e3) {
            const t3 = this.bytes, a3 = this.pos, r2 = this.end;
            if (!e3) return t3.subarray(a3, r2);
            let n2 = a3 + e3;
            n2 > r2 && (n2 = r2);
            this.pos = n2;
            return t3.subarray(a3, n2);
          }
          getByteRange(e3, t3) {
            e3 < 0 && (e3 = 0);
            t3 > this.end && (t3 = this.end);
            return this.bytes.subarray(e3, t3);
          }
          reset() {
            this.pos = this.start;
          }
          moveStart() {
            this.start = this.pos;
          }
          makeSubStream(e3, t3, a3 = null) {
            return new Stream(this.bytes.buffer, e3, t3, a3);
          }
        }
        t2.Stream = Stream;
        t2.StringStream = class StringStream extends Stream {
          constructor(e3) {
            super((0, n.stringToBytes)(e3));
          }
        };
        t2.NullStream = class NullStream extends Stream {
          constructor() {
            super(new Uint8Array(0));
          }
        };
      }, (e2, t2, a2) => {
        var _Page_instances, t_fn, _PDFDocument_instances, a_fn, _a;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Page = t2.PDFDocument = void 0;
        var r = a2(2), n = a2(10), i = a2(3), s = a2(4), o = a2(51), c = a2(5), l = a2(74), h = a2(66), u = a2(68), d = a2(102), f = a2(16), g = a2(8), p = a2(76), m = a2(64), b = a2(13), y = a2(18), w = a2(72), S = a2(73), x = a2(77), C = a2(103);
        const k = [0, 0, 612, 792];
        class Page {
          constructor({ pdfManager: e3, xref: t3, pageIndex: a3, pageDict: r2, ref: n2, globalIdFactory: i2, fontCache: s2, builtInCMapCache: o2, standardFontDataCache: c2, globalImageCache: l2, systemFontCache: h2, nonBlendModesSet: u2, xfaFactory: d2 }) {
            __privateAdd(this, _Page_instances);
            this.pdfManager = e3;
            this.pageIndex = a3;
            this.pageDict = r2;
            this.xref = t3;
            this.ref = n2;
            this.fontCache = s2;
            this.builtInCMapCache = o2;
            this.standardFontDataCache = c2;
            this.globalImageCache = l2;
            this.systemFontCache = h2;
            this.nonBlendModesSet = u2;
            this.evaluatorOptions = e3.evaluatorOptions;
            this.resourcesPromise = null;
            this.xfaFactory = d2;
            const f2 = { obj: 0 };
            this._localIdFactory = class extends i2 {
              static createObjId() {
                return `p${a3}_${++f2.obj}`;
              }
              static getPageObjId() {
                return `p${n2.toString()}`;
              }
            };
          }
          _getInheritableProperty(e3, t3 = false) {
            const a3 = (0, i.getInheritableProperty)({ dict: this.pageDict, key: e3, getArray: t3, stopWhenFound: false });
            return Array.isArray(a3) ? 1 !== a3.length && a3[0] instanceof s.Dict ? s.Dict.merge({ xref: this.xref, dictArray: a3 }) : a3[0] : a3;
          }
          get content() {
            return this.pageDict.getArray("Contents");
          }
          get resources() {
            const e3 = this._getInheritableProperty("Resources");
            return (0, r.shadow)(this, "resources", e3 instanceof s.Dict ? e3 : s.Dict.empty);
          }
          _getBoundingBox(e3) {
            if (this.xfaData) return this.xfaData.bbox;
            let t3 = this._getInheritableProperty(e3, true);
            if (Array.isArray(t3) && 4 === t3.length) {
              t3 = r.Util.normalizeRect(t3);
              if (t3[2] - t3[0] > 0 && t3[3] - t3[1] > 0) return t3;
              (0, r.warn)(`Empty, or invalid, /${e3} entry.`);
            }
            return null;
          }
          get mediaBox() {
            return (0, r.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || k);
          }
          get cropBox() {
            return (0, r.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
          }
          get userUnit() {
            let e3 = this.pageDict.get("UserUnit");
            ("number" != typeof e3 || e3 <= 0) && (e3 = 1);
            return (0, r.shadow)(this, "userUnit", e3);
          }
          get view() {
            const { cropBox: e3, mediaBox: t3 } = this;
            if (e3 !== t3 && !(0, r.isArrayEqual)(e3, t3)) {
              const a3 = r.Util.intersect(e3, t3);
              if (a3 && a3[2] - a3[0] > 0 && a3[3] - a3[1] > 0) return (0, r.shadow)(this, "view", a3);
              (0, r.warn)("Empty /CropBox and /MediaBox intersection.");
            }
            return (0, r.shadow)(this, "view", t3);
          }
          get rotate() {
            let e3 = this._getInheritableProperty("Rotate") || 0;
            e3 % 90 != 0 ? e3 = 0 : e3 >= 360 ? e3 %= 360 : e3 < 0 && (e3 = (e3 % 360 + 360) % 360);
            return (0, r.shadow)(this, "rotate", e3);
          }
          _onSubStreamError(e3, t3) {
            if (!this.evaluatorOptions.ignoreErrors) throw e3;
            (0, r.warn)(`getContentStream - ignoring sub-stream (${t3}): "${e3}".`);
          }
          getContentStream() {
            return this.pdfManager.ensure(this, "content").then((e3) => e3 instanceof c.BaseStream ? e3 : Array.isArray(e3) ? new y.StreamsSequenceStream(e3, this._onSubStreamError.bind(this)) : new g.NullStream());
          }
          get xfaData() {
            return (0, r.shadow)(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
          }
          async saveNewAnnotations(e3, t3, a3, r2) {
            if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
            const i2 = new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), o2 = new s.RefSet(), c2 = new s.RefSet();
            __privateMethod(this, _Page_instances, t_fn).call(this, a3, o2, c2);
            const l2 = this.pageDict, h2 = this.annotations.filter((e4) => !(e4 instanceof s.Ref && o2.has(e4))), u2 = await n.AnnotationFactory.saveNewAnnotations(i2, t3, a3, r2);
            for (const { ref: e4 } of u2.annotations) e4 instanceof s.Ref && !c2.has(e4) && h2.push(e4);
            const d2 = l2.get("Annots");
            l2.set("Annots", h2);
            const f2 = [];
            await (0, S.writeObject)(this.ref, l2, f2, this.xref);
            d2 && l2.set("Annots", d2);
            const g2 = u2.dependencies;
            g2.push({ ref: this.ref, data: f2.join("") }, ...u2.annotations);
            return g2;
          }
          save(e3, t3, a3) {
            const n2 = new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
            return this._parsedAnnotations.then(function(e4) {
              const i2 = [];
              for (const s2 of e4) s2.mustBePrinted(a3) && i2.push(s2.save(n2, t3, a3).catch(function(e5) {
                (0, r.warn)(`save - ignoring annotation data during "${t3.name}" task: "${e5}".`);
                return null;
              }));
              return Promise.all(i2).then(function(e5) {
                return e5.filter((e6) => !!e6);
              });
            });
          }
          loadResources(e3) {
            this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources"));
            return this.resourcesPromise.then(() => new p.ObjectLoader(this.resources, e3, this.xref).load());
          }
          getOperatorList({ handler: e3, sink: t3, task: a3, intent: o2, cacheKey: c2, annotationStorage: l2 = null }) {
            const h2 = this.getContentStream(), u2 = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), d2 = new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), f2 = this.xfaFactory ? null : (0, i.getNewAnnotationsMap)(l2);
            let g2 = null, p2 = Promise.resolve(null);
            if (f2) {
              const e4 = f2.get(this.pageIndex);
              if (e4) {
                const t4 = this.pdfManager.ensureDoc("annotationGlobals");
                let i2;
                const o3 = /* @__PURE__ */ new Set();
                for (const { bitmapId: t5, bitmap: a4 } of e4) !t5 || a4 || o3.has(t5) || o3.add(t5);
                const { isOffscreenCanvasSupported: c3 } = this.evaluatorOptions;
                if (o3.size > 0) {
                  const t5 = e4.slice();
                  for (const [e5, a4] of l2) e5.startsWith(r.AnnotationEditorPrefix) && a4.bitmap && o3.has(a4.bitmapId) && t5.push(a4);
                  i2 = n.AnnotationFactory.generateImages(t5, this.xref, c3);
                } else i2 = n.AnnotationFactory.generateImages(e4, this.xref, c3);
                g2 = new s.RefSet();
                __privateMethod(this, _Page_instances, t_fn).call(this, e4, g2, null);
                p2 = t4.then((t5) => t5 ? n.AnnotationFactory.printNewAnnotations(t5, d2, a3, e4, i2) : null);
              }
            }
            const y2 = Promise.all([h2, u2]).then(([r2]) => {
              const n2 = new m.OperatorList(o2, t3);
              e3.send("StartRenderPage", { transparency: d2.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: c2 });
              return d2.getOperatorList({ stream: r2, task: a3, resources: this.resources, operatorList: n2 }).then(function() {
                return n2;
              });
            });
            return Promise.all([y2, this._parsedAnnotations, p2]).then(function([e4, t4, n2]) {
              if (n2) {
                t4 = t4.filter((e5) => !(e5.ref && g2.has(e5.ref)));
                for (let e5 = 0, a4 = n2.length; e5 < a4; e5++) {
                  const r2 = n2[e5];
                  if (r2.refToReplace) {
                    const i3 = t4.findIndex((e6) => e6.ref && (0, s.isRefsEqual)(e6.ref, r2.refToReplace));
                    if (i3 >= 0) {
                      t4.splice(i3, 1, r2);
                      n2.splice(e5--, 1);
                      a4--;
                    }
                  }
                }
                t4 = t4.concat(n2);
              }
              if (0 === t4.length || o2 & r.RenderingIntentFlag.ANNOTATIONS_DISABLE) {
                e4.flush(true);
                return { length: e4.totalLength };
              }
              const i2 = !!(o2 & r.RenderingIntentFlag.ANNOTATIONS_FORMS), c3 = !!(o2 & r.RenderingIntentFlag.ANY), h3 = !!(o2 & r.RenderingIntentFlag.DISPLAY), u3 = !!(o2 & r.RenderingIntentFlag.PRINT), f3 = [];
              for (const e5 of t4) (c3 || h3 && e5.mustBeViewed(l2, i2) || u3 && e5.mustBePrinted(l2)) && f3.push(e5.getOperatorList(d2, a3, o2, i2, l2).catch(function(e6) {
                (0, r.warn)(`getOperatorList - ignoring annotation data during "${a3.name}" task: "${e6}".`);
                return { opList: null, separateForm: false, separateCanvas: false };
              }));
              return Promise.all(f3).then(function(t5) {
                let a4 = false, r2 = false;
                for (const { opList: n3, separateForm: i3, separateCanvas: s2 } of t5) {
                  e4.addOpList(n3);
                  a4 || (a4 = i3);
                  r2 || (r2 = s2);
                }
                e4.flush(true, { form: a4, canvas: r2 });
                return { length: e4.totalLength };
              });
            });
          }
          extractTextContent({ handler: e3, task: t3, includeMarkedContent: a3, disableNormalization: r2, sink: n2 }) {
            const i2 = this.getContentStream(), s2 = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
            return Promise.all([i2, s2]).then(([i3]) => new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: i3, task: t3, resources: this.resources, includeMarkedContent: a3, disableNormalization: r2, sink: n2, viewBox: this.view }));
          }
          async getStructTree() {
            const e3 = await this.pdfManager.ensureCatalog("structTreeRoot");
            if (!e3) return null;
            await this._parsedAnnotations;
            return (await this.pdfManager.ensure(this, "_parseStructTree", [e3])).serializable;
          }
          _parseStructTree(e3) {
            const t3 = new w.StructTreePage(e3, this.pageDict);
            t3.parse(this.ref);
            return t3;
          }
          async getAnnotationsData(e3, t3, a3) {
            const n2 = await this._parsedAnnotations;
            if (0 === n2.length) return n2;
            const i2 = [], s2 = [];
            let o2;
            const c2 = !!(a3 & r.RenderingIntentFlag.ANY), l2 = !!(a3 & r.RenderingIntentFlag.DISPLAY), h2 = !!(a3 & r.RenderingIntentFlag.PRINT);
            for (const a4 of n2) {
              const n3 = c2 || l2 && a4.viewable;
              (n3 || h2 && a4.printable) && i2.push(a4.data);
              if (a4.hasTextContent && n3) {
                o2 || (o2 = new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }));
                s2.push(a4.extractTextContent(o2, t3, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(e4) {
                  (0, r.warn)(`getAnnotationsData - ignoring textContent during "${t3.name}" task: "${e4}".`);
                }));
              }
            }
            await Promise.all(s2);
            return i2;
          }
          get annotations() {
            const e3 = this._getInheritableProperty("Annots");
            return (0, r.shadow)(this, "annotations", Array.isArray(e3) ? e3 : []);
          }
          get _parsedAnnotations() {
            const e3 = this.pdfManager.ensure(this, "annotations").then(async (e4) => {
              if (0 === e4.length) return e4;
              const t3 = await this.pdfManager.ensureDoc("annotationGlobals");
              if (!t3) return [];
              const a3 = [];
              for (const i3 of e4) a3.push(n.AnnotationFactory.create(this.xref, i3, t3, this._localIdFactory, false, this.ref).catch(function(e5) {
                (0, r.warn)(`_parsedAnnotations: "${e5}".`);
                return null;
              }));
              const i2 = [];
              let s2;
              for (const e5 of await Promise.all(a3)) e5 && (e5 instanceof n.PopupAnnotation ? (s2 || (s2 = [])).push(e5) : i2.push(e5));
              s2 && i2.push(...s2);
              return i2;
            });
            return (0, r.shadow)(this, "_parsedAnnotations", e3);
          }
          get jsActions() {
            const e3 = (0, i.collectActions)(this.xref, this.pageDict, r.PageActionEventType);
            return (0, r.shadow)(this, "jsActions", e3);
          }
        }
        _Page_instances = new WeakSet();
        t_fn = function(e3, t3, a3) {
          for (const n2 of e3) if (n2.id) {
            const e4 = s.Ref.fromString(n2.id);
            if (!e4) {
              (0, r.warn)(`A non-linked annotation cannot be modified: ${n2.id}`);
              continue;
            }
            if (n2.deleted) {
              t3.put(e4);
              continue;
            }
            a3 == null ? void 0 : a3.put(e4);
            n2.ref = e4;
            delete n2.id;
          }
        };
        t2.Page = Page;
        const v = new Uint8Array([37, 80, 68, 70, 45]), F = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), O = new Uint8Array([101, 110, 100, 111, 98, 106]);
        function find(e3, t3, a3 = 1024, r2 = false) {
          const n2 = t3.length, i2 = e3.peekBytes(a3), s2 = i2.length - n2;
          if (s2 <= 0) return false;
          if (r2) {
            const a4 = n2 - 1;
            let r3 = i2.length - 1;
            for (; r3 >= a4; ) {
              let s3 = 0;
              for (; s3 < n2 && i2[r3 - s3] === t3[a4 - s3]; ) s3++;
              if (s3 >= n2) {
                e3.pos += r3 - a4;
                return true;
              }
              r3--;
            }
          } else {
            let a4 = 0;
            for (; a4 <= s2; ) {
              let r3 = 0;
              for (; r3 < n2 && i2[a4 + r3] === t3[r3]; ) r3++;
              if (r3 >= n2) {
                e3.pos += a4;
                return true;
              }
              a4++;
            }
          }
          return false;
        }
        t2.PDFDocument = (_a = class {
          constructor(e3, t3) {
            __privateAdd(this, _PDFDocument_instances);
            if (t3.length <= 0) throw new r.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
            this.pdfManager = e3;
            this.stream = t3;
            this.xref = new C.XRef(t3, e3);
            this._pagePromises = /* @__PURE__ */ new Map();
            this._version = null;
            const a3 = { font: 0 };
            this._globalIdFactory = class {
              static getDocId() {
                return `g_${e3.docId}`;
              }
              static createFontId() {
                return "f" + ++a3.font;
              }
              static createObjId() {
                (0, r.unreachable)("Abstract method `createObjId` called.");
              }
              static getPageObjId() {
                (0, r.unreachable)("Abstract method `getPageObjId` called.");
              }
            };
          }
          parse(e3) {
            this.xref.parse(e3);
            this.catalog = new h.Catalog(this.pdfManager, this.xref);
          }
          get linearization() {
            let e3 = null;
            try {
              e3 = f.Linearization.create(this.stream);
            } catch (e4) {
              if (e4 instanceof i.MissingDataException) throw e4;
              (0, r.info)(e4);
            }
            return (0, r.shadow)(this, "linearization", e3);
          }
          get startXRef() {
            const e3 = this.stream;
            let t3 = 0;
            if (this.linearization) {
              e3.reset();
              find(e3, O) && (t3 = e3.pos + 6 - e3.start);
            } else {
              const a3 = 1024, r2 = F.length;
              let n2 = false, s2 = e3.end;
              for (; !n2 && s2 > 0; ) {
                s2 -= a3 - r2;
                s2 < 0 && (s2 = 0);
                e3.pos = s2;
                n2 = find(e3, F, a3, true);
              }
              if (n2) {
                e3.skip(9);
                let a4;
                do {
                  a4 = e3.getByte();
                } while ((0, i.isWhiteSpace)(a4));
                let r3 = "";
                for (; a4 >= 32 && a4 <= 57; ) {
                  r3 += String.fromCharCode(a4);
                  a4 = e3.getByte();
                }
                t3 = parseInt(r3, 10);
                isNaN(t3) && (t3 = 0);
              }
            }
            return (0, r.shadow)(this, "startXRef", t3);
          }
          checkHeader() {
            const e3 = this.stream;
            e3.reset();
            if (!find(e3, v)) return;
            e3.moveStart();
            e3.skip(v.length);
            let t3, a3 = "";
            for (; (t3 = e3.getByte()) > 32 && a3.length < 7; ) a3 += String.fromCharCode(t3);
            i.PDF_VERSION_REGEXP.test(a3) ? this._version = a3 : (0, r.warn)(`Invalid PDF header version: ${a3}`);
          }
          parseStartXRef() {
            this.xref.setStartXRef(this.startXRef);
          }
          get numPages() {
            let e3 = 0;
            e3 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
            return (0, r.shadow)(this, "numPages", e3);
          }
          _hasOnlyDocumentSignatures(e3, t3 = 0) {
            return !!Array.isArray(e3) && e3.every((e4) => {
              if (!((e4 = this.xref.fetchIfRef(e4)) instanceof s.Dict)) return false;
              if (e4.has("Kids")) {
                if (++t3 > 10) {
                  (0, r.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached");
                  return false;
                }
                return this._hasOnlyDocumentSignatures(e4.get("Kids"), t3);
              }
              const a3 = (0, s.isName)(e4.get("FT"), "Sig"), n2 = e4.get("Rect"), i2 = Array.isArray(n2) && n2.every((e5) => 0 === e5);
              return a3 && i2;
            });
          }
          get _xfaStreams() {
            const e3 = this.catalog.acroForm;
            if (!e3) return null;
            const t3 = e3.get("XFA"), a3 = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
            if (t3 instanceof c.BaseStream && !t3.isEmpty) {
              a3["xdp:xdp"] = t3;
              return a3;
            }
            if (!Array.isArray(t3) || 0 === t3.length) return null;
            for (let e4 = 0, r2 = t3.length; e4 < r2; e4 += 2) {
              let n2;
              n2 = 0 === e4 ? "xdp:xdp" : e4 === r2 - 2 ? "/xdp:xdp" : t3[e4];
              if (!a3.hasOwnProperty(n2)) continue;
              const i2 = this.xref.fetchIfRef(t3[e4 + 1]);
              i2 instanceof c.BaseStream && !i2.isEmpty && (a3[n2] = i2);
            }
            return a3;
          }
          get xfaDatasets() {
            const e3 = this._xfaStreams;
            if (!e3) return (0, r.shadow)(this, "xfaDatasets", null);
            for (const t3 of ["datasets", "xdp:xdp"]) {
              const a3 = e3[t3];
              if (a3) try {
                const e4 = { [t3]: (0, r.stringToUTF8String)(a3.getString()) };
                return (0, r.shadow)(this, "xfaDatasets", new d.DatasetReader(e4));
              } catch {
                (0, r.warn)("XFA - Invalid utf-8 string.");
                break;
              }
            }
            return (0, r.shadow)(this, "xfaDatasets", null);
          }
          get xfaData() {
            const e3 = this._xfaStreams;
            if (!e3) return null;
            const t3 = /* @__PURE__ */ Object.create(null);
            for (const [a3, n2] of Object.entries(e3)) if (n2) try {
              t3[a3] = (0, r.stringToUTF8String)(n2.getString());
            } catch {
              (0, r.warn)("XFA - Invalid utf-8 string.");
              return null;
            }
            return t3;
          }
          get xfaFactory() {
            let e3;
            this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e3 = this.xfaData);
            return (0, r.shadow)(this, "xfaFactory", e3 ? new x.XFAFactory(e3) : null);
          }
          get isPureXfa() {
            return !!this.xfaFactory && this.xfaFactory.isValid();
          }
          get htmlForXfa() {
            return this.xfaFactory ? this.xfaFactory.getPages() : null;
          }
          async loadXfaImages() {
            const e3 = await this.pdfManager.ensureCatalog("xfaImages");
            if (!e3) return;
            const t3 = e3.getKeys(), a3 = new p.ObjectLoader(e3, t3, this.xref);
            await a3.load();
            const r2 = /* @__PURE__ */ new Map();
            for (const a4 of t3) {
              const t4 = e3.get(a4);
              t4 instanceof c.BaseStream && r2.set(a4, t4.getBytes());
            }
            this.xfaFactory.setImages(r2);
          }
          async loadXfaFonts(e3, t3) {
            const a3 = await this.pdfManager.ensureCatalog("acroForm");
            if (!a3) return;
            const n2 = await a3.getAsync("DR");
            if (!(n2 instanceof s.Dict)) return;
            const c2 = new p.ObjectLoader(n2, ["Font"], this.xref);
            await c2.load();
            const l2 = n2.get("Font");
            if (!(l2 instanceof s.Dict)) return;
            const h2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
            h2.useSystemFonts = false;
            const u2 = new b.PartialEvaluator({ xref: this.xref, handler: e3, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: h2 }), d2 = new m.OperatorList(), f2 = [], g2 = { get font() {
              return f2.at(-1);
            }, set font(e4) {
              f2.push(e4);
            }, clone() {
              return this;
            } }, y2 = /* @__PURE__ */ new Map();
            l2.forEach((e4, t4) => {
              y2.set(e4, t4);
            });
            const w2 = [];
            for (const [e4, a4] of y2) {
              const o2 = a4.get("FontDescriptor");
              if (!(o2 instanceof s.Dict)) continue;
              let c3 = o2.get("FontFamily");
              c3 = c3.replaceAll(/[ ]+(\d)/g, "$1");
              const l3 = { fontFamily: c3, fontWeight: o2.get("FontWeight"), italicAngle: -o2.get("ItalicAngle") };
              (0, i.validateCSSFont)(l3) && w2.push(u2.handleSetFont(n2, [s.Name.get(e4), 1], null, d2, t3, g2, null, l3).catch(function(e5) {
                (0, r.warn)(`loadXfaFonts: "${e5}".`);
                return null;
              }));
            }
            await Promise.all(w2);
            const S2 = this.xfaFactory.setFonts(f2);
            if (!S2) return;
            h2.ignoreErrors = true;
            w2.length = 0;
            f2.length = 0;
            const x2 = /* @__PURE__ */ new Set();
            for (const e4 of S2) (0, o.getXfaFontName)(`${e4}-Regular`) || x2.add(e4);
            x2.size && S2.push("PdfJS-Fallback");
            for (const e4 of S2) if (!x2.has(e4)) for (const a4 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
              const i2 = `${e4}-${a4.name}`, c3 = (0, o.getXfaFontDict)(i2);
              w2.push(u2.handleSetFont(n2, [s.Name.get(i2), 1], null, d2, t3, g2, c3, { fontFamily: e4, fontWeight: a4.fontWeight, italicAngle: a4.italicAngle }).catch(function(e5) {
                (0, r.warn)(`loadXfaFonts: "${e5}".`);
                return null;
              }));
            }
            await Promise.all(w2);
            this.xfaFactory.appendFonts(f2, x2);
          }
          async serializeXfaData(e3) {
            return this.xfaFactory ? this.xfaFactory.serializeData(e3) : null;
          }
          get version() {
            return this.catalog.version || this._version;
          }
          get formInfo() {
            const e3 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, t3 = this.catalog.acroForm;
            if (!t3) return (0, r.shadow)(this, "formInfo", e3);
            try {
              const a3 = t3.get("Fields"), r2 = Array.isArray(a3) && a3.length > 0;
              e3.hasFields = r2;
              const n2 = t3.get("XFA");
              e3.hasXfa = Array.isArray(n2) && n2.length > 0 || n2 instanceof c.BaseStream && !n2.isEmpty;
              const i2 = !!(1 & t3.get("SigFlags")), s2 = i2 && this._hasOnlyDocumentSignatures(a3);
              e3.hasAcroForm = r2 && !s2;
              e3.hasSignatures = i2;
            } catch (e4) {
              if (e4 instanceof i.MissingDataException) throw e4;
              (0, r.warn)(`Cannot fetch form information: "${e4}".`);
            }
            return (0, r.shadow)(this, "formInfo", e3);
          }
          get documentInfo() {
            const e3 = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
            let t3;
            try {
              t3 = this.xref.trailer.get("Info");
            } catch (e4) {
              if (e4 instanceof i.MissingDataException) throw e4;
              (0, r.info)("The document information dictionary is invalid.");
            }
            if (!(t3 instanceof s.Dict)) return (0, r.shadow)(this, "documentInfo", e3);
            for (const a3 of t3.getKeys()) {
              const n2 = t3.get(a3);
              switch (a3) {
                case "Title":
                case "Author":
                case "Subject":
                case "Keywords":
                case "Creator":
                case "Producer":
                case "CreationDate":
                case "ModDate":
                  if ("string" == typeof n2) {
                    e3[a3] = (0, r.stringToPDFString)(n2);
                    continue;
                  }
                  break;
                case "Trapped":
                  if (n2 instanceof s.Name) {
                    e3[a3] = n2;
                    continue;
                  }
                  break;
                default:
                  let t4;
                  switch (typeof n2) {
                    case "string":
                      t4 = (0, r.stringToPDFString)(n2);
                      break;
                    case "number":
                    case "boolean":
                      t4 = n2;
                      break;
                    default:
                      n2 instanceof s.Name && (t4 = n2);
                  }
                  if (void 0 === t4) {
                    (0, r.warn)(`Bad value, for custom key "${a3}", in Info: ${n2}.`);
                    continue;
                  }
                  e3.Custom || (e3.Custom = /* @__PURE__ */ Object.create(null));
                  e3.Custom[a3] = t4;
                  continue;
              }
              (0, r.warn)(`Bad value, for key "${a3}", in Info: ${n2}.`);
            }
            return (0, r.shadow)(this, "documentInfo", e3);
          }
          get fingerprints() {
            function validate(e4) {
              return "string" == typeof e4 && e4.length > 0 && "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" !== e4;
            }
            function hexString(e4) {
              const t4 = [];
              for (const a4 of e4) {
                const e5 = a4.toString(16);
                t4.push(e5.padStart(2, "0"));
              }
              return t4.join("");
            }
            const e3 = this.xref.trailer.get("ID");
            let t3, a3;
            if (Array.isArray(e3) && validate(e3[0])) {
              t3 = (0, r.stringToBytes)(e3[0]);
              e3[1] !== e3[0] && validate(e3[1]) && (a3 = (0, r.stringToBytes)(e3[1]));
            } else t3 = (0, l.calculateMD5)(this.stream.getByteRange(0, 1024), 0, 1024);
            return (0, r.shadow)(this, "fingerprints", [hexString(t3), a3 ? hexString(a3) : null]);
          }
          async _getLinearizationPage(e3) {
            const { catalog: t3, linearization: a3, xref: n2 } = this, i2 = s.Ref.get(a3.objectNumberFirst, 0);
            try {
              const e4 = await n2.fetchAsync(i2);
              if (e4 instanceof s.Dict) {
                let a4 = e4.getRaw("Type");
                a4 instanceof s.Ref && (a4 = await n2.fetchAsync(a4));
                if ((0, s.isName)(a4, "Page") || !e4.has("Type") && !e4.has("Kids")) {
                  t3.pageKidsCountCache.has(i2) || t3.pageKidsCountCache.put(i2, 1);
                  t3.pageIndexCache.has(i2) || t3.pageIndexCache.put(i2, 0);
                  return [e4, i2];
                }
              }
              throw new r.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
            } catch (a4) {
              (0, r.warn)(`_getLinearizationPage: "${a4.message}".`);
              return t3.getPageDict(e3);
            }
          }
          getPage(e3) {
            const t3 = this._pagePromises.get(e3);
            if (t3) return t3;
            const { catalog: a3, linearization: r2, xfaFactory: n2 } = this;
            let i2;
            i2 = n2 ? Promise.resolve([s.Dict.empty, null]) : (r2 == null ? void 0 : r2.pageFirst) === e3 ? this._getLinearizationPage(e3) : a3.getPageDict(e3);
            i2 = i2.then(([t4, r3]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e3, pageDict: t4, ref: r3, globalIdFactory: this._globalIdFactory, fontCache: a3.fontCache, builtInCMapCache: a3.builtInCMapCache, standardFontDataCache: a3.standardFontDataCache, globalImageCache: a3.globalImageCache, systemFontCache: a3.systemFontCache, nonBlendModesSet: a3.nonBlendModesSet, xfaFactory: n2 }));
            this._pagePromises.set(e3, i2);
            return i2;
          }
          async checkFirstPage(e3 = false) {
            if (!e3) try {
              await this.getPage(0);
            } catch (e4) {
              if (e4 instanceof i.XRefEntryException) {
                this._pagePromises.delete(0);
                await this.cleanup();
                throw new i.XRefParseException();
              }
            }
          }
          async checkLastPage(e3 = false) {
            const { catalog: t3, pdfManager: a3 } = this;
            t3.setActualNumPages();
            let n2;
            try {
              await Promise.all([a3.ensureDoc("xfaFactory"), a3.ensureDoc("linearization"), a3.ensureCatalog("numPages")]);
              if (this.xfaFactory) return;
              n2 = this.linearization ? this.linearization.numPages : t3.numPages;
              if (!Number.isInteger(n2)) throw new r.FormatError("Page count is not an integer.");
              if (n2 <= 1) return;
              await this.getPage(n2 - 1);
            } catch (s2) {
              this._pagePromises.delete(n2 - 1);
              await this.cleanup();
              if (s2 instanceof i.XRefEntryException && !e3) throw new i.XRefParseException();
              (0, r.warn)(`checkLastPage - invalid /Pages tree /Count: ${n2}.`);
              let o2;
              try {
                o2 = await t3.getAllPageDicts(e3);
              } catch (a4) {
                if (a4 instanceof i.XRefEntryException && !e3) throw new i.XRefParseException();
                t3.setActualNumPages(1);
                return;
              }
              for (const [e4, [r2, n3]] of o2) {
                let i2;
                if (r2 instanceof Error) {
                  i2 = Promise.reject(r2);
                  i2.catch(() => {
                  });
                } else i2 = Promise.resolve(new Page({ pdfManager: a3, xref: this.xref, pageIndex: e4, pageDict: r2, ref: n3, globalIdFactory: this._globalIdFactory, fontCache: t3.fontCache, builtInCMapCache: t3.builtInCMapCache, standardFontDataCache: t3.standardFontDataCache, globalImageCache: t3.globalImageCache, systemFontCache: t3.systemFontCache, nonBlendModesSet: t3.nonBlendModesSet, xfaFactory: null }));
                this._pagePromises.set(e4, i2);
              }
              t3.setActualNumPages(o2.size);
            }
          }
          fontFallback(e3, t3) {
            return this.catalog.fontFallback(e3, t3);
          }
          async cleanup(e3 = false) {
            return this.catalog ? this.catalog.cleanup(e3) : (0, u.clearGlobalCaches)();
          }
          get fieldObjects() {
            if (!this.formInfo.hasFields) return (0, r.shadow)(this, "fieldObjects", Promise.resolve(null));
            const e3 = this.pdfManager.ensureDoc("annotationGlobals").then(async (e4) => {
              if (!e4) return null;
              const t3 = /* @__PURE__ */ Object.create(null), a3 = /* @__PURE__ */ new Map();
              for (const t4 of this.catalog.acroForm.get("Fields")) __privateMethod(this, _PDFDocument_instances, a_fn).call(this, "", t4, a3, e4);
              const r2 = [];
              for (const [e5, n2] of a3) r2.push(Promise.all(n2).then((a4) => {
                (a4 = a4.filter((e6) => !!e6)).length > 0 && (t3[e5] = a4);
              }));
              await Promise.all(r2);
              return t3;
            });
            return (0, r.shadow)(this, "fieldObjects", e3);
          }
          get hasJSActions() {
            const e3 = this.pdfManager.ensureDoc("_parseHasJSActions");
            return (0, r.shadow)(this, "hasJSActions", e3);
          }
          async _parseHasJSActions() {
            const [e3, t3] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
            return !!e3 || !!t3 && Object.values(t3).some((e4) => e4.some((e5) => null !== e5.actions));
          }
          get calculationOrderIds() {
            const e3 = this.catalog.acroForm;
            if (!(e3 == null ? void 0 : e3.has("CO"))) return (0, r.shadow)(this, "calculationOrderIds", null);
            const t3 = e3.get("CO");
            if (!Array.isArray(t3) || 0 === t3.length) return (0, r.shadow)(this, "calculationOrderIds", null);
            const a3 = [];
            for (const e4 of t3) e4 instanceof s.Ref && a3.push(e4.toString());
            return 0 === a3.length ? (0, r.shadow)(this, "calculationOrderIds", null) : (0, r.shadow)(this, "calculationOrderIds", a3);
          }
          get annotationGlobals() {
            return (0, r.shadow)(this, "annotationGlobals", n.AnnotationFactory.createGlobals(this.pdfManager));
          }
        }, _PDFDocument_instances = new WeakSet(), a_fn = function(e3, t3, a3, i2) {
          const s2 = this.xref.fetchIfRef(t3);
          if (s2.has("T")) {
            const t4 = (0, r.stringToPDFString)(s2.get("T"));
            e3 = "" === e3 ? t4 : `${e3}.${t4}`;
          }
          a3.has(e3) || a3.set(e3, []);
          a3.get(e3).push(n.AnnotationFactory.create(this.xref, t3, i2, this._localIdFactory, true, null).then((e4) => e4 == null ? void 0 : e4.getFieldObject()).catch(function(e4) {
            (0, r.warn)(`#collectFieldObjects: "${e4}".`);
            return null;
          }));
          if (s2.has("Kids")) for (const t4 of s2.get("Kids")) __privateMethod(this, _PDFDocument_instances, a_fn).call(this, e3, t4, a3, i2);
        }, _a);
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PopupAnnotation = t2.MarkupAnnotation = t2.AnnotationFactory = t2.AnnotationBorderStyle = t2.Annotation = void 0;
        t2.getQuadPoints = getQuadPoints;
        var r = a2(2), n = a2(3), i = a2(11), s = a2(4), o = a2(8), c = a2(5), l = a2(60), h = a2(66), u = a2(12), d = a2(69), f = a2(26), g = a2(76), p = a2(64), m = a2(73), b = a2(77);
        t2.AnnotationFactory = class AnnotationFactory {
          static createGlobals(e3) {
            return Promise.all([e3.ensureCatalog("acroForm"), e3.ensureDoc("xfaDatasets"), e3.ensureCatalog("structTreeRoot"), e3.ensureCatalog("baseUrl"), e3.ensureCatalog("attachments")]).then(([t3, a3, r2, n2, i2]) => ({ pdfManager: e3, acroForm: t3 instanceof s.Dict ? t3 : s.Dict.empty, xfaDatasets: a3, structTreeRoot: r2, baseUrl: n2, attachments: i2 }), (e4) => {
              (0, r.warn)(`createGlobals: "${e4}".`);
              return null;
            });
          }
          static async create(e3, t3, a3, r2, n2, i2) {
            const s2 = n2 ? await this._getPageIndex(e3, t3, a3.pdfManager) : null;
            return a3.pdfManager.ensure(this, "_create", [e3, t3, a3, r2, n2, s2, i2]);
          }
          static _create(e3, t3, a3, i2, o2 = false, c2 = null, l2 = null) {
            const h2 = e3.fetchIfRef(t3);
            if (!(h2 instanceof s.Dict)) return;
            const { acroForm: u2, pdfManager: d2 } = a3, f2 = t3 instanceof s.Ref ? t3.toString() : `annot_${i2.createObjId()}`;
            let g2 = h2.get("Subtype");
            g2 = g2 instanceof s.Name ? g2.name : null;
            const p2 = { xref: e3, ref: t3, dict: h2, subtype: g2, id: f2, annotationGlobals: a3, collectFields: o2, needAppearances: !o2 && true === u2.get("NeedAppearances"), pageIndex: c2, evaluatorOptions: d2.evaluatorOptions, pageRef: l2 };
            switch (g2) {
              case "Link":
                return new LinkAnnotation(p2);
              case "Text":
                return new TextAnnotation(p2);
              case "Widget":
                let e4 = (0, n.getInheritableProperty)({ dict: h2, key: "FT" });
                e4 = e4 instanceof s.Name ? e4.name : null;
                switch (e4) {
                  case "Tx":
                    return new TextWidgetAnnotation(p2);
                  case "Btn":
                    return new ButtonWidgetAnnotation(p2);
                  case "Ch":
                    return new ChoiceWidgetAnnotation(p2);
                  case "Sig":
                    return new SignatureWidgetAnnotation(p2);
                }
                (0, r.warn)(`Unimplemented widget field type "${e4}", falling back to base field type.`);
                return new WidgetAnnotation(p2);
              case "Popup":
                return new PopupAnnotation(p2);
              case "FreeText":
                return new FreeTextAnnotation(p2);
              case "Line":
                return new LineAnnotation(p2);
              case "Square":
                return new SquareAnnotation(p2);
              case "Circle":
                return new CircleAnnotation(p2);
              case "PolyLine":
                return new PolylineAnnotation(p2);
              case "Polygon":
                return new PolygonAnnotation(p2);
              case "Caret":
                return new CaretAnnotation(p2);
              case "Ink":
                return new InkAnnotation(p2);
              case "Highlight":
                return new HighlightAnnotation(p2);
              case "Underline":
                return new UnderlineAnnotation(p2);
              case "Squiggly":
                return new SquigglyAnnotation(p2);
              case "StrikeOut":
                return new StrikeOutAnnotation(p2);
              case "Stamp":
                return new StampAnnotation(p2);
              case "FileAttachment":
                return new FileAttachmentAnnotation(p2);
              default:
                o2 || (g2 ? (0, r.warn)(`Unimplemented annotation type "${g2}", falling back to base annotation.`) : (0, r.warn)("Annotation is missing the required /Subtype."));
                return new Annotation(p2);
            }
          }
          static async _getPageIndex(e3, t3, a3) {
            try {
              const n2 = await e3.fetchIfRefAsync(t3);
              if (!(n2 instanceof s.Dict)) return -1;
              const i2 = n2.getRaw("P");
              if (i2 instanceof s.Ref) try {
                return await a3.ensureCatalog("getPageIndex", [i2]);
              } catch (e4) {
                (0, r.info)(`_getPageIndex -- not a valid page reference: "${e4}".`);
              }
              if (n2.has("Kids")) return -1;
              const o2 = await a3.ensureDoc("numPages");
              for (let e4 = 0; e4 < o2; e4++) {
                const r2 = await a3.getPage(e4), n3 = await a3.ensure(r2, "annotations");
                for (const a4 of n3) if (a4 instanceof s.Ref && (0, s.isRefsEqual)(a4, t3)) return e4;
              }
            } catch (e4) {
              (0, r.warn)(`_getPageIndex: "${e4}".`);
            }
            return -1;
          }
          static generateImages(e3, t3, a3) {
            if (!a3) {
              (0, r.warn)("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
              return null;
            }
            let n2;
            for (const { bitmapId: a4, bitmap: r2 } of e3) if (r2) {
              n2 || (n2 = /* @__PURE__ */ new Map());
              n2.set(a4, StampAnnotation.createImage(r2, t3));
            }
            return n2;
          }
          static async saveNewAnnotations(e3, t3, a3, n2) {
            const i2 = e3.xref;
            let o2;
            const c2 = [], l2 = [], { isOffscreenCanvasSupported: h2 } = e3.options;
            for (const u2 of a3) if (!u2.deleted) switch (u2.annotationType) {
              case r.AnnotationEditorType.FREETEXT:
                if (!o2) {
                  const e4 = new s.Dict(i2);
                  e4.set("BaseFont", s.Name.get("Helvetica"));
                  e4.set("Type", s.Name.get("Font"));
                  e4.set("Subtype", s.Name.get("Type1"));
                  e4.set("Encoding", s.Name.get("WinAnsiEncoding"));
                  const t4 = [];
                  o2 = i2.getNewTemporaryRef();
                  await (0, m.writeObject)(o2, e4, t4, i2);
                  c2.push({ ref: o2, data: t4.join("") });
                }
                l2.push(FreeTextAnnotation.createNewAnnotation(i2, u2, c2, { evaluator: e3, task: t3, baseFontRef: o2 }));
                break;
              case r.AnnotationEditorType.INK:
                l2.push(InkAnnotation.createNewAnnotation(i2, u2, c2));
                break;
              case r.AnnotationEditorType.STAMP:
                if (!h2) break;
                const a4 = await n2.get(u2.bitmapId);
                if (a4.imageStream) {
                  const { imageStream: e4, smaskStream: t4 } = a4, r2 = [];
                  if (t4) {
                    const a5 = i2.getNewTemporaryRef();
                    await (0, m.writeObject)(a5, t4, r2, i2);
                    c2.push({ ref: a5, data: r2.join("") });
                    e4.dict.set("SMask", a5);
                    r2.length = 0;
                  }
                  const n3 = a4.imageRef = i2.getNewTemporaryRef();
                  await (0, m.writeObject)(n3, e4, r2, i2);
                  c2.push({ ref: n3, data: r2.join("") });
                  a4.imageStream = a4.smaskStream = null;
                }
                l2.push(StampAnnotation.createNewAnnotation(i2, u2, c2, { image: a4 }));
            }
            return { annotations: await Promise.all(l2), dependencies: c2 };
          }
          static async printNewAnnotations(e3, t3, a3, n2, i2) {
            if (!n2) return null;
            const { options: s2, xref: o2 } = t3, c2 = [];
            for (const l2 of n2) if (!l2.deleted) switch (l2.annotationType) {
              case r.AnnotationEditorType.FREETEXT:
                c2.push(FreeTextAnnotation.createNewPrintAnnotation(e3, o2, l2, { evaluator: t3, task: a3, evaluatorOptions: s2 }));
                break;
              case r.AnnotationEditorType.INK:
                c2.push(InkAnnotation.createNewPrintAnnotation(e3, o2, l2, { evaluatorOptions: s2 }));
                break;
              case r.AnnotationEditorType.STAMP:
                if (!s2.isOffscreenCanvasSupported) break;
                const n3 = await i2.get(l2.bitmapId);
                if (n3.imageStream) {
                  const { imageStream: e4, smaskStream: t4 } = n3;
                  t4 && e4.dict.set("SMask", t4);
                  n3.imageRef = new f.JpegStream(e4, e4.length);
                  n3.imageStream = n3.smaskStream = null;
                }
                c2.push(StampAnnotation.createNewPrintAnnotation(e3, o2, l2, { image: n3, evaluatorOptions: s2 }));
            }
            return Promise.all(c2);
          }
        };
        function getRgbColor(e3, t3 = new Uint8ClampedArray(3)) {
          if (!Array.isArray(e3)) return t3;
          const a3 = t3 || new Uint8ClampedArray(3);
          switch (e3.length) {
            case 0:
              return null;
            case 1:
              u.ColorSpace.singletons.gray.getRgbItem(e3, 0, a3, 0);
              return a3;
            case 3:
              u.ColorSpace.singletons.rgb.getRgbItem(e3, 0, a3, 0);
              return a3;
            case 4:
              u.ColorSpace.singletons.cmyk.getRgbItem(e3, 0, a3, 0);
              return a3;
            default:
              return t3;
          }
        }
        function getPdfColorArray(e3) {
          return Array.from(e3, (e4) => e4 / 255);
        }
        function getQuadPoints(e3, t3) {
          const a3 = e3.getArray("QuadPoints");
          if (!Array.isArray(a3) || 0 === a3.length || a3.length % 8 > 0) return null;
          const r2 = [];
          for (let e4 = 0, n2 = a3.length / 8; e4 < n2; e4++) {
            let n3 = 1 / 0, i2 = -1 / 0, s2 = 1 / 0, o2 = -1 / 0;
            for (let t4 = 8 * e4, r3 = 8 * e4 + 8; t4 < r3; t4 += 2) {
              const e5 = a3[t4], r4 = a3[t4 + 1];
              n3 = Math.min(e5, n3);
              i2 = Math.max(e5, i2);
              s2 = Math.min(r4, s2);
              o2 = Math.max(r4, o2);
            }
            if (null !== t3 && (n3 < t3[0] || i2 > t3[2] || s2 < t3[1] || o2 > t3[3])) return null;
            r2.push([{ x: n3, y: o2 }, { x: i2, y: o2 }, { x: n3, y: s2 }, { x: i2, y: s2 }]);
          }
          return r2;
        }
        function getTransformMatrix(e3, t3, a3) {
          const [n2, i2, s2, o2] = r.Util.getAxialAlignedBoundingBox(t3, a3);
          if (n2 === s2 || i2 === o2) return [1, 0, 0, 1, e3[0], e3[1]];
          const c2 = (e3[2] - e3[0]) / (s2 - n2), l2 = (e3[3] - e3[1]) / (o2 - i2);
          return [c2, 0, 0, l2, e3[0] - n2 * c2, e3[1] - i2 * l2];
        }
        class Annotation {
          constructor(e3) {
            const { dict: t3, xref: a3, annotationGlobals: i2 } = e3;
            this.setTitle(t3.get("T"));
            this.setContents(t3.get("Contents"));
            this.setModificationDate(t3.get("M"));
            this.setFlags(t3.get("F"));
            this.setRectangle(t3.getArray("Rect"));
            this.setColor(t3.getArray("C"));
            this.setBorderStyle(t3);
            this.setAppearance(t3);
            this.setOptionalContent(t3);
            const o2 = t3.get("MK");
            this.setBorderAndBackgroundColors(o2);
            this.setRotation(o2, t3);
            this.ref = e3.ref instanceof s.Ref ? e3.ref : null;
            this._streams = [];
            this.appearance && this._streams.push(this.appearance);
            const c2 = !!(this.flags & r.AnnotationFlag.LOCKED), l2 = !!(this.flags & r.AnnotationFlag.LOCKEDCONTENTS);
            if (i2.structTreeRoot) {
              let a4 = t3.get("StructParent");
              a4 = Number.isInteger(a4) && a4 >= 0 ? a4 : -1;
              i2.structTreeRoot.addAnnotationIdToPage(e3.pageRef, a4);
            }
            this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e3.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e3.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & r.AnnotationFlag.NOROTATE), noHTML: c2 && l2 };
            if (e3.collectFields) {
              const i3 = t3.get("Kids");
              if (Array.isArray(i3)) {
                const e4 = [];
                for (const t4 of i3) t4 instanceof s.Ref && e4.push(t4.toString());
                0 !== e4.length && (this.data.kidIds = e4);
              }
              this.data.actions = (0, n.collectActions)(a3, t3, r.AnnotationActionEventType);
              this.data.fieldName = this._constructFieldName(t3);
              this.data.pageIndex = e3.pageIndex;
            }
            this._isOffscreenCanvasSupported = e3.evaluatorOptions.isOffscreenCanvasSupported;
            this._fallbackFontDict = null;
            this._needAppearances = false;
          }
          _hasFlag(e3, t3) {
            return !!(e3 & t3);
          }
          _isViewable(e3) {
            return !this._hasFlag(e3, r.AnnotationFlag.INVISIBLE) && !this._hasFlag(e3, r.AnnotationFlag.NOVIEW);
          }
          _isPrintable(e3) {
            return this._hasFlag(e3, r.AnnotationFlag.PRINT) && !this._hasFlag(e3, r.AnnotationFlag.HIDDEN) && !this._hasFlag(e3, r.AnnotationFlag.INVISIBLE);
          }
          mustBeViewed(e3, t3) {
            var _a;
            const a3 = (_a = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a.noView;
            return void 0 !== a3 ? !a3 : this.viewable && !this._hasFlag(this.flags, r.AnnotationFlag.HIDDEN);
          }
          mustBePrinted(e3) {
            var _a;
            const t3 = (_a = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a.noPrint;
            return void 0 !== t3 ? !t3 : this.printable;
          }
          get viewable() {
            return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
          }
          get printable() {
            return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
          }
          _parseStringHelper(e3) {
            const t3 = "string" == typeof e3 ? (0, r.stringToPDFString)(e3) : "";
            return { str: t3, dir: t3 && "rtl" === (0, l.bidi)(t3).dir ? "rtl" : "ltr" };
          }
          setDefaultAppearance(e3) {
            const { dict: t3, annotationGlobals: a3 } = e3, r2 = (0, n.getInheritableProperty)({ dict: t3, key: "DA" }) || a3.acroForm.get("DA");
            this._defaultAppearance = "string" == typeof r2 ? r2 : "";
            this.data.defaultAppearanceData = (0, i.parseDefaultAppearance)(this._defaultAppearance);
          }
          setTitle(e3) {
            this._title = this._parseStringHelper(e3);
          }
          setContents(e3) {
            this._contents = this._parseStringHelper(e3);
          }
          setModificationDate(e3) {
            this.modificationDate = "string" == typeof e3 ? e3 : null;
          }
          setFlags(e3) {
            this.flags = Number.isInteger(e3) && e3 > 0 ? e3 : 0;
          }
          hasFlag(e3) {
            return this._hasFlag(this.flags, e3);
          }
          setRectangle(e3) {
            this.rectangle = Array.isArray(e3) && 4 === e3.length ? r.Util.normalizeRect(e3) : [0, 0, 0, 0];
          }
          setColor(e3) {
            this.color = getRgbColor(e3);
          }
          setLineEndings(e3) {
            this.lineEndings = ["None", "None"];
            if (Array.isArray(e3) && 2 === e3.length) for (let t3 = 0; t3 < 2; t3++) {
              const a3 = e3[t3];
              if (a3 instanceof s.Name) switch (a3.name) {
                case "None":
                  continue;
                case "Square":
                case "Circle":
                case "Diamond":
                case "OpenArrow":
                case "ClosedArrow":
                case "Butt":
                case "ROpenArrow":
                case "RClosedArrow":
                case "Slash":
                  this.lineEndings[t3] = a3.name;
                  continue;
              }
              (0, r.warn)(`Ignoring invalid lineEnding: ${a3}`);
            }
          }
          setRotation(e3, t3) {
            this.rotation = 0;
            let a3 = e3 instanceof s.Dict ? e3.get("R") || 0 : t3.get("Rotate") || 0;
            if (Number.isInteger(a3) && 0 !== a3) {
              a3 %= 360;
              a3 < 0 && (a3 += 360);
              a3 % 90 == 0 && (this.rotation = a3);
            }
          }
          setBorderAndBackgroundColors(e3) {
            if (e3 instanceof s.Dict) {
              this.borderColor = getRgbColor(e3.getArray("BC"), null);
              this.backgroundColor = getRgbColor(e3.getArray("BG"), null);
            } else this.borderColor = this.backgroundColor = null;
          }
          setBorderStyle(e3) {
            this.borderStyle = new AnnotationBorderStyle();
            if (e3 instanceof s.Dict) if (e3.has("BS")) {
              const t3 = e3.get("BS"), a3 = t3.get("Type");
              if (!a3 || (0, s.isName)(a3, "Border")) {
                this.borderStyle.setWidth(t3.get("W"), this.rectangle);
                this.borderStyle.setStyle(t3.get("S"));
                this.borderStyle.setDashArray(t3.getArray("D"));
              }
            } else if (e3.has("Border")) {
              const t3 = e3.getArray("Border");
              if (Array.isArray(t3) && t3.length >= 3) {
                this.borderStyle.setHorizontalCornerRadius(t3[0]);
                this.borderStyle.setVerticalCornerRadius(t3[1]);
                this.borderStyle.setWidth(t3[2], this.rectangle);
                4 === t3.length && this.borderStyle.setDashArray(t3[3], true);
              }
            } else this.borderStyle.setWidth(0);
          }
          setAppearance(e3) {
            this.appearance = null;
            const t3 = e3.get("AP");
            if (!(t3 instanceof s.Dict)) return;
            const a3 = t3.get("N");
            if (a3 instanceof c.BaseStream) {
              this.appearance = a3;
              return;
            }
            if (!(a3 instanceof s.Dict)) return;
            const r2 = e3.get("AS");
            if (!(r2 instanceof s.Name && a3.has(r2.name))) return;
            const n2 = a3.get(r2.name);
            n2 instanceof c.BaseStream && (this.appearance = n2);
          }
          setOptionalContent(e3) {
            this.oc = null;
            const t3 = e3.get("OC");
            t3 instanceof s.Name ? (0, r.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : t3 instanceof s.Dict && (this.oc = t3);
          }
          loadResources(e3, t3) {
            return t3.dict.getAsync("Resources").then((t4) => {
              if (!t4) return;
              return new g.ObjectLoader(t4, e3, t4.xref).load().then(function() {
                return t4;
              });
            });
          }
          async getOperatorList(e3, t3, a3, n2, i2) {
            const c2 = this.data;
            let l2 = this.appearance;
            const h2 = !!(this.data.hasOwnCanvas && a3 & r.RenderingIntentFlag.DISPLAY);
            if (!l2) {
              if (!h2) return { opList: new p.OperatorList(), separateForm: false, separateCanvas: false };
              l2 = new o.StringStream("");
              l2.dict = new s.Dict();
            }
            const u2 = l2.dict, d2 = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], l2), f2 = u2.getArray("BBox") || [0, 0, 1, 1], g2 = u2.getArray("Matrix") || [1, 0, 0, 1, 0, 0], m2 = getTransformMatrix(c2.rect, f2, g2), b2 = new p.OperatorList();
            let y;
            this.oc && (y = await e3.parseMarkedContentProps(this.oc, null));
            void 0 !== y && b2.addOp(r.OPS.beginMarkedContentProps, ["OC", y]);
            b2.addOp(r.OPS.beginAnnotation, [c2.id, c2.rect, m2, g2, h2]);
            await e3.getOperatorList({ stream: l2, task: t3, resources: d2, operatorList: b2, fallbackFontDict: this._fallbackFontDict });
            b2.addOp(r.OPS.endAnnotation, []);
            void 0 !== y && b2.addOp(r.OPS.endMarkedContent, []);
            this.reset();
            return { opList: b2, separateForm: false, separateCanvas: h2 };
          }
          async save(e3, t3, a3) {
            return null;
          }
          get hasTextContent() {
            return false;
          }
          async extractTextContent(e3, t3, a3) {
            if (!this.appearance) return;
            const n2 = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), i2 = [], s2 = [];
            let o2 = null;
            const c2 = { desiredSize: Math.Infinity, ready: true, enqueue(e4, t4) {
              for (const t5 of e4.items) if (void 0 !== t5.str) {
                o2 || (o2 = t5.transform.slice(-2));
                s2.push(t5.str);
                if (t5.hasEOL) {
                  i2.push(s2.join(""));
                  s2.length = 0;
                }
              }
            } };
            await e3.getTextContent({ stream: this.appearance, task: t3, resources: n2, includeMarkedContent: true, sink: c2, viewBox: a3 });
            this.reset();
            s2.length && i2.push(s2.join(""));
            if (i2.length > 1 || i2[0]) {
              const e4 = this.appearance.dict, t4 = e4.getArray("BBox") || [0, 0, 1, 1], a4 = e4.getArray("Matrix") || [1, 0, 0, 1, 0, 0], n3 = this.data.rect, s3 = getTransformMatrix(n3, t4, a4);
              s3[4] -= n3[0];
              s3[5] -= n3[1];
              o2 = r.Util.applyTransform(o2, s3);
              o2 = r.Util.applyTransform(o2, a4);
              this.data.textPosition = o2;
              this.data.textContent = i2;
            }
          }
          getFieldObject() {
            return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
          }
          reset() {
            for (const e3 of this._streams) e3.reset();
          }
          _constructFieldName(e3) {
            if (!e3.has("T") && !e3.has("Parent")) {
              (0, r.warn)("Unknown field name, falling back to empty field name.");
              return "";
            }
            if (!e3.has("Parent")) return (0, r.stringToPDFString)(e3.get("T"));
            const t3 = [];
            e3.has("T") && t3.unshift((0, r.stringToPDFString)(e3.get("T")));
            let a3 = e3;
            const n2 = new s.RefSet();
            e3.objId && n2.put(e3.objId);
            for (; a3.has("Parent"); ) {
              a3 = a3.get("Parent");
              if (!(a3 instanceof s.Dict) || a3.objId && n2.has(a3.objId)) break;
              a3.objId && n2.put(a3.objId);
              a3.has("T") && t3.unshift((0, r.stringToPDFString)(a3.get("T")));
            }
            return t3.join(".");
          }
        }
        t2.Annotation = Annotation;
        class AnnotationBorderStyle {
          constructor() {
            this.width = 1;
            this.style = r.AnnotationBorderStyleType.SOLID;
            this.dashArray = [3];
            this.horizontalCornerRadius = 0;
            this.verticalCornerRadius = 0;
          }
          setWidth(e3, t3 = [0, 0, 0, 0]) {
            if (e3 instanceof s.Name) this.width = 0;
            else if ("number" == typeof e3) {
              if (e3 > 0) {
                const a3 = (t3[2] - t3[0]) / 2, n2 = (t3[3] - t3[1]) / 2;
                if (a3 > 0 && n2 > 0 && (e3 > a3 || e3 > n2)) {
                  (0, r.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${e3}`);
                  e3 = 1;
                }
              }
              this.width = e3;
            }
          }
          setStyle(e3) {
            if (e3 instanceof s.Name) switch (e3.name) {
              case "S":
                this.style = r.AnnotationBorderStyleType.SOLID;
                break;
              case "D":
                this.style = r.AnnotationBorderStyleType.DASHED;
                break;
              case "B":
                this.style = r.AnnotationBorderStyleType.BEVELED;
                break;
              case "I":
                this.style = r.AnnotationBorderStyleType.INSET;
                break;
              case "U":
                this.style = r.AnnotationBorderStyleType.UNDERLINE;
            }
          }
          setDashArray(e3, t3 = false) {
            if (Array.isArray(e3) && e3.length > 0) {
              let a3 = true, r2 = true;
              for (const t4 of e3) {
                if (!(+t4 >= 0)) {
                  a3 = false;
                  break;
                }
                t4 > 0 && (r2 = false);
              }
              if (a3 && !r2) {
                this.dashArray = e3;
                t3 && this.setStyle(s.Name.get("D"));
              } else this.width = 0;
            } else e3 && (this.width = 0);
          }
          setHorizontalCornerRadius(e3) {
            Number.isInteger(e3) && (this.horizontalCornerRadius = e3);
          }
          setVerticalCornerRadius(e3) {
            Number.isInteger(e3) && (this.verticalCornerRadius = e3);
          }
        }
        t2.AnnotationBorderStyle = AnnotationBorderStyle;
        class MarkupAnnotation extends Annotation {
          constructor(e3) {
            super(e3);
            const { dict: t3 } = e3;
            if (t3.has("IRT")) {
              const e4 = t3.getRaw("IRT");
              this.data.inReplyTo = e4 instanceof s.Ref ? e4.toString() : null;
              const a4 = t3.get("RT");
              this.data.replyType = a4 instanceof s.Name ? a4.name : r.AnnotationReplyType.REPLY;
            }
            let a3 = null;
            if (this.data.replyType === r.AnnotationReplyType.GROUP) {
              const e4 = t3.get("IRT");
              this.setTitle(e4.get("T"));
              this.data.titleObj = this._title;
              this.setContents(e4.get("Contents"));
              this.data.contentsObj = this._contents;
              if (e4.has("CreationDate")) {
                this.setCreationDate(e4.get("CreationDate"));
                this.data.creationDate = this.creationDate;
              } else this.data.creationDate = null;
              if (e4.has("M")) {
                this.setModificationDate(e4.get("M"));
                this.data.modificationDate = this.modificationDate;
              } else this.data.modificationDate = null;
              a3 = e4.getRaw("Popup");
              if (e4.has("C")) {
                this.setColor(e4.getArray("C"));
                this.data.color = this.color;
              } else this.data.color = null;
            } else {
              this.data.titleObj = this._title;
              this.setCreationDate(t3.get("CreationDate"));
              this.data.creationDate = this.creationDate;
              a3 = t3.getRaw("Popup");
              t3.has("C") || (this.data.color = null);
            }
            this.data.popupRef = a3 instanceof s.Ref ? a3.toString() : null;
            t3.has("RC") && (this.data.richText = b.XFAFactory.getRichTextAsHtml(t3.get("RC")));
          }
          setCreationDate(e3) {
            this.creationDate = "string" == typeof e3 ? e3 : null;
          }
          _setDefaultAppearance({ xref: e3, extra: t3, strokeColor: a3, fillColor: r2, blendMode: n2, strokeAlpha: i2, fillAlpha: c2, pointsCallback: l2 }) {
            let h2 = Number.MAX_VALUE, u2 = Number.MAX_VALUE, d2 = Number.MIN_VALUE, f2 = Number.MIN_VALUE;
            const g2 = ["q"];
            t3 && g2.push(t3);
            a3 && g2.push(`${a3[0]} ${a3[1]} ${a3[2]} RG`);
            r2 && g2.push(`${r2[0]} ${r2[1]} ${r2[2]} rg`);
            let p2 = this.data.quadPoints;
            p2 || (p2 = [[{ x: this.rectangle[0], y: this.rectangle[3] }, { x: this.rectangle[2], y: this.rectangle[3] }, { x: this.rectangle[0], y: this.rectangle[1] }, { x: this.rectangle[2], y: this.rectangle[1] }]]);
            for (const e4 of p2) {
              const [t4, a4, r3, n3] = l2(g2, e4);
              h2 = Math.min(h2, t4);
              d2 = Math.max(d2, a4);
              u2 = Math.min(u2, r3);
              f2 = Math.max(f2, n3);
            }
            g2.push("Q");
            const m2 = new s.Dict(e3), b2 = new s.Dict(e3);
            b2.set("Subtype", s.Name.get("Form"));
            const y = new o.StringStream(g2.join(" "));
            y.dict = b2;
            m2.set("Fm0", y);
            const w = new s.Dict(e3);
            n2 && w.set("BM", s.Name.get(n2));
            "number" == typeof i2 && w.set("CA", i2);
            "number" == typeof c2 && w.set("ca", c2);
            const S = new s.Dict(e3);
            S.set("GS0", w);
            const x = new s.Dict(e3);
            x.set("ExtGState", S);
            x.set("XObject", m2);
            const C = new s.Dict(e3);
            C.set("Resources", x);
            const k = this.data.rect = [h2, u2, d2, f2];
            C.set("BBox", k);
            this.appearance = new o.StringStream("/GS0 gs /Fm0 Do");
            this.appearance.dict = C;
            this._streams.push(this.appearance, y);
          }
          static async createNewAnnotation(e3, t3, a3, r2) {
            const n2 = t3.ref || (t3.ref = e3.getNewTemporaryRef()), i2 = await this.createNewAppearanceStream(t3, e3, r2), s2 = [];
            let o2;
            if (i2) {
              const r3 = e3.getNewTemporaryRef();
              o2 = this.createNewDict(t3, e3, { apRef: r3 });
              await (0, m.writeObject)(r3, i2, s2, e3);
              a3.push({ ref: r3, data: s2.join("") });
            } else o2 = this.createNewDict(t3, e3, {});
            Number.isInteger(t3.parentTreeId) && o2.set("StructParent", t3.parentTreeId);
            s2.length = 0;
            await (0, m.writeObject)(n2, o2, s2, e3);
            return { ref: n2, data: s2.join("") };
          }
          static async createNewPrintAnnotation(e3, t3, a3, r2) {
            const n2 = await this.createNewAppearanceStream(a3, t3, r2), i2 = this.createNewDict(a3, t3, { ap: n2 }), s2 = new this.prototype.constructor({ dict: i2, xref: t3, annotationGlobals: e3, evaluatorOptions: r2.evaluatorOptions });
            a3.ref && (s2.ref = s2.refToReplace = a3.ref);
            return s2;
          }
        }
        t2.MarkupAnnotation = MarkupAnnotation;
        class WidgetAnnotation extends Annotation {
          constructor(e3) {
            var _a;
            super(e3);
            const { dict: t3, xref: a3, annotationGlobals: i2 } = e3, o2 = this.data;
            this._needAppearances = e3.needAppearances;
            o2.annotationType = r.AnnotationType.WIDGET;
            void 0 === o2.fieldName && (o2.fieldName = this._constructFieldName(t3));
            void 0 === o2.actions && (o2.actions = (0, n.collectActions)(a3, t3, r.AnnotationActionEventType));
            let c2 = (0, n.getInheritableProperty)({ dict: t3, key: "V", getArray: true });
            o2.fieldValue = this._decodeFormValue(c2);
            const l2 = (0, n.getInheritableProperty)({ dict: t3, key: "DV", getArray: true });
            o2.defaultFieldValue = this._decodeFormValue(l2);
            if (void 0 === c2 && i2.xfaDatasets) {
              const e4 = this._title.str;
              if (e4) {
                this._hasValueFromXFA = true;
                o2.fieldValue = c2 = i2.xfaDatasets.getValue(e4);
              }
            }
            void 0 === c2 && null !== o2.defaultFieldValue && (o2.fieldValue = o2.defaultFieldValue);
            o2.alternativeText = (0, r.stringToPDFString)(t3.get("TU") || "");
            this.setDefaultAppearance(e3);
            o2.hasAppearance || (o2.hasAppearance = this._needAppearances && void 0 !== o2.fieldValue && null !== o2.fieldValue);
            const h2 = (0, n.getInheritableProperty)({ dict: t3, key: "FT" });
            o2.fieldType = h2 instanceof s.Name ? h2.name : null;
            const u2 = (0, n.getInheritableProperty)({ dict: t3, key: "DR" }), d2 = i2.acroForm.get("DR"), f2 = (_a = this.appearance) == null ? void 0 : _a.dict.get("Resources");
            this._fieldResources = { localResources: u2, acroFormResources: d2, appearanceResources: f2, mergedResources: s.Dict.merge({ xref: a3, dictArray: [u2, f2, d2], mergeSubDicts: true }) };
            o2.fieldFlags = (0, n.getInheritableProperty)({ dict: t3, key: "Ff" });
            (!Number.isInteger(o2.fieldFlags) || o2.fieldFlags < 0) && (o2.fieldFlags = 0);
            o2.readOnly = this.hasFieldFlag(r.AnnotationFieldFlag.READONLY);
            o2.required = this.hasFieldFlag(r.AnnotationFieldFlag.REQUIRED);
            o2.hidden = this._hasFlag(o2.annotationFlags, r.AnnotationFlag.HIDDEN) || this._hasFlag(o2.annotationFlags, r.AnnotationFlag.NOVIEW);
          }
          _decodeFormValue(e3) {
            return Array.isArray(e3) ? e3.filter((e4) => "string" == typeof e4).map((e4) => (0, r.stringToPDFString)(e4)) : e3 instanceof s.Name ? (0, r.stringToPDFString)(e3.name) : "string" == typeof e3 ? (0, r.stringToPDFString)(e3) : null;
          }
          hasFieldFlag(e3) {
            return !!(this.data.fieldFlags & e3);
          }
          _isViewable(e3) {
            return !this._hasFlag(e3, r.AnnotationFlag.INVISIBLE);
          }
          mustBeViewed(e3, t3) {
            return t3 ? this.viewable : super.mustBeViewed(e3, t3) && !this._hasFlag(this.flags, r.AnnotationFlag.NOVIEW);
          }
          getRotationMatrix(e3) {
            var _a;
            let t3 = (_a = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a.rotation;
            void 0 === t3 && (t3 = this.rotation);
            if (0 === t3) return r.IDENTITY_MATRIX;
            const a3 = this.data.rect[2] - this.data.rect[0], i2 = this.data.rect[3] - this.data.rect[1];
            return (0, n.getRotationMatrix)(t3, a3, i2);
          }
          getBorderAndBackgroundAppearances(e3) {
            var _a;
            let t3 = (_a = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a.rotation;
            void 0 === t3 && (t3 = this.rotation);
            if (!this.backgroundColor && !this.borderColor) return "";
            const a3 = this.data.rect[2] - this.data.rect[0], r2 = this.data.rect[3] - this.data.rect[1], n2 = 0 === t3 || 180 === t3 ? `0 0 ${a3} ${r2} re` : `0 0 ${r2} ${a3} re`;
            let s2 = "";
            this.backgroundColor && (s2 = `${(0, i.getPdfColor)(this.backgroundColor, true)} ${n2} f `);
            if (this.borderColor) {
              s2 += `${this.borderStyle.width || 1} w ${(0, i.getPdfColor)(this.borderColor, false)} ${n2} S `;
            }
            return s2;
          }
          async getOperatorList(e3, t3, a3, n2, i2) {
            if (n2 && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new p.OperatorList(), separateForm: true, separateCanvas: false };
            if (!this._hasText) return super.getOperatorList(e3, t3, a3, n2, i2);
            const s2 = await this._getAppearance(e3, t3, a3, i2);
            if (this.appearance && null === s2) return super.getOperatorList(e3, t3, a3, n2, i2);
            const c2 = new p.OperatorList();
            if (!this._defaultAppearance || null === s2) return { opList: c2, separateForm: false, separateCanvas: false };
            const l2 = !!(this.data.hasOwnCanvas && a3 & r.RenderingIntentFlag.DISPLAY), h2 = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], u2 = getTransformMatrix(this.data.rect, h2, [1, 0, 0, 1, 0, 0]);
            let d2;
            this.oc && (d2 = await e3.parseMarkedContentProps(this.oc, null));
            void 0 !== d2 && c2.addOp(r.OPS.beginMarkedContentProps, ["OC", d2]);
            c2.addOp(r.OPS.beginAnnotation, [this.data.id, this.data.rect, u2, this.getRotationMatrix(i2), l2]);
            const f2 = new o.StringStream(s2);
            await e3.getOperatorList({ stream: f2, task: t3, resources: this._fieldResources.mergedResources, operatorList: c2 });
            c2.addOp(r.OPS.endAnnotation, []);
            void 0 !== d2 && c2.addOp(r.OPS.endMarkedContent, []);
            return { opList: c2, separateForm: false, separateCanvas: l2 };
          }
          _getMKDict(e3) {
            const t3 = new s.Dict(null);
            e3 && t3.set("R", e3);
            this.borderColor && t3.set("BC", getPdfColorArray(this.borderColor));
            this.backgroundColor && t3.set("BG", getPdfColorArray(this.backgroundColor));
            return t3.size > 0 ? t3 : null;
          }
          amendSavedDict(e3, t3) {
          }
          async save(e3, t3, a3) {
            const i2 = a3 == null ? void 0 : a3.get(this.data.id);
            let c2 = i2 == null ? void 0 : i2.value, l2 = i2 == null ? void 0 : i2.rotation;
            if (c2 === this.data.fieldValue || void 0 === c2) {
              if (!this._hasValueFromXFA && void 0 === l2) return null;
              c2 || (c2 = this.data.fieldValue);
            }
            if (void 0 === l2 && !this._hasValueFromXFA && Array.isArray(c2) && Array.isArray(this.data.fieldValue) && c2.length === this.data.fieldValue.length && c2.every((e4, t4) => e4 === this.data.fieldValue[t4])) return null;
            void 0 === l2 && (l2 = this.rotation);
            let h2 = null;
            if (!this._needAppearances) {
              h2 = await this._getAppearance(e3, t3, r.RenderingIntentFlag.SAVE, a3);
              if (null === h2) return null;
            }
            let u2 = false;
            if (h2 == null ? void 0 : h2.needAppearances) {
              u2 = true;
              h2 = null;
            }
            const { xref: d2 } = e3, f2 = d2.fetchIfRef(this.ref);
            if (!(f2 instanceof s.Dict)) return null;
            const g2 = new s.Dict(d2);
            for (const e4 of f2.getKeys()) "AP" !== e4 && g2.set(e4, f2.getRaw(e4));
            const p2 = { path: this.data.fieldName, value: c2 }, encoder = (e4) => (0, n.isAscii)(e4) ? e4 : (0, n.stringToUTF16String)(e4, true);
            g2.set("V", Array.isArray(c2) ? c2.map(encoder) : encoder(c2));
            this.amendSavedDict(a3, g2);
            const b2 = this._getMKDict(l2);
            b2 && g2.set("MK", b2);
            const y = [], w = [{ ref: this.ref, data: "", xfa: p2, needAppearances: u2 }];
            if (null !== h2) {
              const e4 = d2.getNewTemporaryRef(), t4 = new s.Dict(d2);
              g2.set("AP", t4);
              t4.set("N", e4);
              const n2 = this._getSaveFieldResources(d2), i3 = new o.StringStream(h2), c3 = i3.dict = new s.Dict(d2);
              c3.set("Subtype", s.Name.get("Form"));
              c3.set("Resources", n2);
              c3.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
              const l3 = this.getRotationMatrix(a3);
              l3 !== r.IDENTITY_MATRIX && c3.set("Matrix", l3);
              await (0, m.writeObject)(e4, i3, y, d2);
              w.push({ ref: e4, data: y.join(""), xfa: null, needAppearances: false });
              y.length = 0;
            }
            g2.set("M", `D:${(0, r.getModificationDate)()}`);
            await (0, m.writeObject)(this.ref, g2, y, d2);
            w[0].data = y.join("");
            return w;
          }
          async _getAppearance(e3, t3, a3, s2) {
            if (this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD)) return null;
            const o2 = s2 == null ? void 0 : s2.get(this.data.id);
            let c2, l2;
            if (o2) {
              c2 = o2.formattedValue || o2.value;
              l2 = o2.rotation;
            }
            if (void 0 === l2 && void 0 === c2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
            const h2 = this.getBorderAndBackgroundAppearances(s2);
            if (void 0 === c2) {
              c2 = this.data.fieldValue;
              if (!c2) return `/Tx BMC q ${h2}Q EMC`;
            }
            Array.isArray(c2) && 1 === c2.length && (c2 = c2[0]);
            (0, r.assert)("string" == typeof c2, "Expected `value` to be a string.");
            c2 = c2.trim();
            if (this.data.combo) {
              const e4 = this.data.options.find(({ exportValue: e5 }) => c2 === e5);
              c2 = (e4 == null ? void 0 : e4.displayValue) || c2;
            }
            if ("" === c2) return `/Tx BMC q ${h2}Q EMC`;
            void 0 === l2 && (l2 = this.rotation);
            let u2, d2 = -1;
            if (this.data.multiLine) {
              u2 = c2.split(/\r\n?|\n/).map((e4) => e4.normalize("NFC"));
              d2 = u2.length;
            } else u2 = [c2.replace(/\r\n?|\n/, "").normalize("NFC")];
            let f2 = this.data.rect[3] - this.data.rect[1], g2 = this.data.rect[2] - this.data.rect[0];
            90 !== l2 && 270 !== l2 || ([g2, f2] = [f2, g2]);
            this._defaultAppearance || (this.data.defaultAppearanceData = (0, i.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
            let p2, m2, b2, y = await WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
            const w = [];
            let S = false;
            for (const e4 of u2) {
              const t4 = y.encodeString(e4);
              t4.length > 1 && (S = true);
              w.push(t4.join(""));
            }
            if (S && a3 & r.RenderingIntentFlag.SAVE) return { needAppearances: true };
            if (S && this._isOffscreenCanvasSupported) {
              const a4 = this.data.comb ? "monospace" : "sans-serif", r2 = new i.FakeUnicodeFont(e3.xref, a4), s3 = r2.createFontResources(u2.join("")), o3 = s3.getRaw("Font");
              if (this._fieldResources.mergedResources.has("Font")) {
                const e4 = this._fieldResources.mergedResources.get("Font");
                for (const t4 of o3.getKeys()) e4.set(t4, o3.getRaw(t4));
              } else this._fieldResources.mergedResources.set("Font", o3);
              const l3 = r2.fontName.name;
              y = await WidgetAnnotation._getFontData(e3, t3, { fontName: l3, fontSize: 0 }, s3);
              for (let e4 = 0, t4 = w.length; e4 < t4; e4++) w[e4] = (0, n.stringToUTF16String)(u2[e4]);
              const h3 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
              this.data.defaultAppearanceData.fontSize = 0;
              this.data.defaultAppearanceData.fontName = l3;
              [p2, m2, b2] = this._computeFontSize(f2 - 2, g2 - 4, c2, y, d2);
              this.data.defaultAppearanceData = h3;
            } else {
              this._isOffscreenCanvasSupported || (0, r.warn)("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
              [p2, m2, b2] = this._computeFontSize(f2 - 2, g2 - 4, c2, y, d2);
            }
            let x = y.descent;
            x = isNaN(x) ? r.BASELINE_FACTOR * b2 : Math.max(r.BASELINE_FACTOR * b2, Math.abs(x) * m2);
            const C = Math.min(Math.floor((f2 - m2) / 2), 1), k = this.data.textAlignment;
            if (this.data.multiLine) return this._getMultilineAppearance(p2, w, y, m2, g2, f2, k, 2, C, x, b2, s2);
            if (this.data.comb) return this._getCombAppearance(p2, y, w[0], m2, g2, f2, 2, C, x, b2, s2);
            const v = C + x;
            if (0 === k || k > 2) return `/Tx BMC q ${h2}BT ` + p2 + ` 1 0 0 1 ${(0, n.numberToString)(2)} ${(0, n.numberToString)(v)} Tm (${(0, n.escapeString)(w[0])}) Tj ET Q EMC`;
            return `/Tx BMC q ${h2}BT ` + p2 + ` 1 0 0 1 0 0 Tm ${this._renderText(w[0], y, m2, g2, k, { shift: 0 }, 2, v)} ET Q EMC`;
          }
          static async _getFontData(e3, t3, a3, r2) {
            const n2 = new p.OperatorList(), i2 = { font: null, clone() {
              return this;
            } }, { fontName: o2, fontSize: c2 } = a3;
            await e3.handleSetFont(r2, [o2 && s.Name.get(o2), c2], null, n2, t3, i2, null);
            return i2.font;
          }
          _getTextWidth(e3, t3) {
            return t3.charsToGlyphs(e3).reduce((e4, t4) => e4 + t4.width, 0) / 1e3;
          }
          _computeFontSize(e3, t3, a3, n2, s2) {
            let { fontSize: o2 } = this.data.defaultAppearanceData, c2 = (o2 || 12) * r.LINE_FACTOR, l2 = Math.round(e3 / c2);
            if (!o2) {
              const roundWithTwoDigits = (e4) => Math.floor(100 * e4) / 100;
              if (-1 === s2) {
                const i2 = this._getTextWidth(a3, n2);
                o2 = roundWithTwoDigits(Math.min(e3 / r.LINE_FACTOR, i2 > t3 ? t3 / i2 : 1 / 0));
                l2 = 1;
              } else {
                const i2 = a3.split(/\r\n?|\n/), h3 = [];
                for (const e4 of i2) {
                  const t4 = n2.encodeString(e4).join(""), a4 = n2.charsToGlyphs(t4), r2 = n2.getCharPositions(t4);
                  h3.push({ line: t4, glyphs: a4, positions: r2 });
                }
                const isTooBig = (a4) => {
                  let r2 = 0;
                  for (const i3 of h3) {
                    r2 += this._splitLine(null, n2, a4, t3, i3).length * a4;
                    if (r2 > e3) return true;
                  }
                  return false;
                };
                l2 = Math.max(l2, s2);
                for (; ; ) {
                  c2 = e3 / l2;
                  o2 = roundWithTwoDigits(c2 / r.LINE_FACTOR);
                  if (!isTooBig(o2)) break;
                  l2++;
                }
              }
              const { fontName: h2, fontColor: u2 } = this.data.defaultAppearanceData;
              this._defaultAppearance = (0, i.createDefaultAppearance)({ fontSize: o2, fontName: h2, fontColor: u2 });
            }
            return [this._defaultAppearance, o2, e3 / l2];
          }
          _renderText(e3, t3, a3, r2, i2, s2, o2, c2) {
            let l2;
            if (1 === i2) {
              l2 = (r2 - this._getTextWidth(e3, t3) * a3) / 2;
            } else if (2 === i2) {
              l2 = r2 - this._getTextWidth(e3, t3) * a3 - o2;
            } else l2 = o2;
            const h2 = (0, n.numberToString)(l2 - s2.shift);
            s2.shift = l2;
            return `${h2} ${c2 = (0, n.numberToString)(c2)} Td (${(0, n.escapeString)(e3)}) Tj`;
          }
          _getSaveFieldResources(e3) {
            var _a;
            const { localResources: t3, appearanceResources: a3, acroFormResources: r2 } = this._fieldResources, n2 = (_a = this.data.defaultAppearanceData) == null ? void 0 : _a.fontName;
            if (!n2) return t3 || s.Dict.empty;
            for (const e4 of [t3, a3]) if (e4 instanceof s.Dict) {
              const t4 = e4.get("Font");
              if (t4 instanceof s.Dict && t4.has(n2)) return e4;
            }
            if (r2 instanceof s.Dict) {
              const a4 = r2.get("Font");
              if (a4 instanceof s.Dict && a4.has(n2)) {
                const r3 = new s.Dict(e3);
                r3.set(n2, a4.getRaw(n2));
                const i2 = new s.Dict(e3);
                i2.set("Font", r3);
                return s.Dict.merge({ xref: e3, dictArray: [i2, t3], mergeSubDicts: true });
              }
            }
            return t3 || s.Dict.empty;
          }
          getFieldObject() {
            return null;
          }
        }
        class TextWidgetAnnotation extends WidgetAnnotation {
          constructor(e3) {
            super(e3);
            this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
            this._hasText = true;
            const t3 = e3.dict;
            "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
            let a3 = (0, n.getInheritableProperty)({ dict: t3, key: "Q" });
            (!Number.isInteger(a3) || a3 < 0 || a3 > 2) && (a3 = null);
            this.data.textAlignment = a3;
            let i2 = (0, n.getInheritableProperty)({ dict: t3, key: "MaxLen" });
            (!Number.isInteger(i2) || i2 < 0) && (i2 = 0);
            this.data.maxLen = i2;
            this.data.multiLine = this.hasFieldFlag(r.AnnotationFieldFlag.MULTILINE);
            this.data.comb = this.hasFieldFlag(r.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(r.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(r.AnnotationFieldFlag.FILESELECT) && 0 !== this.data.maxLen;
            this.data.doNotScroll = this.hasFieldFlag(r.AnnotationFieldFlag.DONOTSCROLL);
          }
          get hasTextContent() {
            return !!this.appearance && !this._needAppearances;
          }
          _getCombAppearance(e3, t3, a3, r2, i2, s2, o2, c2, l2, h2, u2) {
            const d2 = i2 / this.data.maxLen, f2 = this.getBorderAndBackgroundAppearances(u2), g2 = [], p2 = t3.getCharPositions(a3);
            for (const [e4, t4] of p2) g2.push(`(${(0, n.escapeString)(a3.substring(e4, t4))}) Tj`);
            const m2 = g2.join(` ${(0, n.numberToString)(d2)} 0 Td `);
            return `/Tx BMC q ${f2}BT ` + e3 + ` 1 0 0 1 ${(0, n.numberToString)(o2)} ${(0, n.numberToString)(c2 + l2)} Tm ${m2} ET Q EMC`;
          }
          _getMultilineAppearance(e3, t3, a3, r2, i2, s2, o2, c2, l2, h2, u2, d2) {
            const f2 = [], g2 = i2 - 2 * c2, p2 = { shift: 0 };
            for (let e4 = 0, n2 = t3.length; e4 < n2; e4++) {
              const n3 = t3[e4], s3 = this._splitLine(n3, a3, r2, g2);
              for (let t4 = 0, n4 = s3.length; t4 < n4; t4++) {
                const n5 = s3[t4], d3 = 0 === e4 && 0 === t4 ? -l2 - (u2 - h2) : -u2;
                f2.push(this._renderText(n5, a3, r2, i2, o2, p2, c2, d3));
              }
            }
            const m2 = this.getBorderAndBackgroundAppearances(d2), b2 = f2.join("\n");
            return `/Tx BMC q ${m2}BT ` + e3 + ` 1 0 0 1 0 ${(0, n.numberToString)(s2)} Tm ${b2} ET Q EMC`;
          }
          _splitLine(e3, t3, a3, r2, n2 = {}) {
            e3 = n2.line || e3;
            const i2 = n2.glyphs || t3.charsToGlyphs(e3);
            if (i2.length <= 1) return [e3];
            const s2 = n2.positions || t3.getCharPositions(e3), o2 = a3 / 1e3, c2 = [];
            let l2 = -1, h2 = -1, u2 = -1, d2 = 0, f2 = 0;
            for (let t4 = 0, a4 = i2.length; t4 < a4; t4++) {
              const [a5, n3] = s2[t4], g2 = i2[t4], p2 = g2.width * o2;
              if (" " === g2.unicode) if (f2 + p2 > r2) {
                c2.push(e3.substring(d2, a5));
                d2 = a5;
                f2 = p2;
                l2 = -1;
                u2 = -1;
              } else {
                f2 += p2;
                l2 = a5;
                h2 = n3;
                u2 = t4;
              }
              else if (f2 + p2 > r2) if (-1 !== l2) {
                c2.push(e3.substring(d2, h2));
                d2 = h2;
                t4 = u2 + 1;
                l2 = -1;
                f2 = 0;
              } else {
                c2.push(e3.substring(d2, a5));
                d2 = a5;
                f2 = p2;
              }
              else f2 += p2;
            }
            d2 < e3.length && c2.push(e3.substring(d2, e3.length));
            return c2;
          }
          getFieldObject() {
            return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(r.AnnotationFieldFlag.PASSWORD), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
          }
        }
        class ButtonWidgetAnnotation extends WidgetAnnotation {
          constructor(e3) {
            super(e3);
            this.checkedAppearance = null;
            this.uncheckedAppearance = null;
            this.data.checkBox = !this.hasFieldFlag(r.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
            this.data.radioButton = this.hasFieldFlag(r.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
            this.data.pushButton = this.hasFieldFlag(r.AnnotationFieldFlag.PUSHBUTTON);
            this.data.isTooltipOnly = false;
            if (this.data.checkBox) this._processCheckBox(e3);
            else if (this.data.radioButton) this._processRadioButton(e3);
            else if (this.data.pushButton) {
              this.data.hasOwnCanvas = true;
              this._processPushButton(e3);
            } else (0, r.warn)("Invalid field flags for button widget annotation");
          }
          async getOperatorList(e3, t3, a3, n2, i2) {
            if (this.data.pushButton) return super.getOperatorList(e3, t3, a3, false, i2);
            let s2 = null, o2 = null;
            if (i2) {
              const e4 = i2.get(this.data.id);
              s2 = e4 ? e4.value : null;
              o2 = e4 ? e4.rotation : null;
            }
            if (null === s2 && this.appearance) return super.getOperatorList(e3, t3, a3, n2, i2);
            null == s2 && (s2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
            const c2 = s2 ? this.checkedAppearance : this.uncheckedAppearance;
            if (c2) {
              const s3 = this.appearance, l2 = c2.dict.getArray("Matrix") || r.IDENTITY_MATRIX;
              o2 && c2.dict.set("Matrix", this.getRotationMatrix(i2));
              this.appearance = c2;
              const h2 = super.getOperatorList(e3, t3, a3, n2, i2);
              this.appearance = s3;
              c2.dict.set("Matrix", l2);
              return h2;
            }
            return { opList: new p.OperatorList(), separateForm: false, separateCanvas: false };
          }
          async save(e3, t3, a3) {
            return this.data.checkBox ? this._saveCheckbox(e3, t3, a3) : this.data.radioButton ? this._saveRadioButton(e3, t3, a3) : null;
          }
          async _saveCheckbox(e3, t3, a3) {
            if (!a3) return null;
            const n2 = a3.get(this.data.id);
            let i2 = n2 == null ? void 0 : n2.rotation, o2 = n2 == null ? void 0 : n2.value;
            if (void 0 === i2) {
              if (void 0 === o2) return null;
              if (this.data.fieldValue === this.data.exportValue === o2) return null;
            }
            const c2 = e3.xref.fetchIfRef(this.ref);
            if (!(c2 instanceof s.Dict)) return null;
            void 0 === i2 && (i2 = this.rotation);
            void 0 === o2 && (o2 = this.data.fieldValue === this.data.exportValue);
            const l2 = { path: this.data.fieldName, value: o2 ? this.data.exportValue : "" }, h2 = s.Name.get(o2 ? this.data.exportValue : "Off");
            c2.set("V", h2);
            c2.set("AS", h2);
            c2.set("M", `D:${(0, r.getModificationDate)()}`);
            const u2 = this._getMKDict(i2);
            u2 && c2.set("MK", u2);
            const d2 = [];
            await (0, m.writeObject)(this.ref, c2, d2, e3.xref);
            return [{ ref: this.ref, data: d2.join(""), xfa: l2 }];
          }
          async _saveRadioButton(e3, t3, a3) {
            if (!a3) return null;
            const n2 = a3.get(this.data.id);
            let i2 = n2 == null ? void 0 : n2.rotation, o2 = n2 == null ? void 0 : n2.value;
            if (void 0 === i2) {
              if (void 0 === o2) return null;
              if (this.data.fieldValue === this.data.buttonValue === o2) return null;
            }
            const c2 = e3.xref.fetchIfRef(this.ref);
            if (!(c2 instanceof s.Dict)) return null;
            void 0 === o2 && (o2 = this.data.fieldValue === this.data.buttonValue);
            void 0 === i2 && (i2 = this.rotation);
            const l2 = { path: this.data.fieldName, value: o2 ? this.data.buttonValue : "" }, h2 = s.Name.get(o2 ? this.data.buttonValue : "Off"), u2 = [];
            let d2 = null;
            if (o2) if (this.parent instanceof s.Ref) {
              const t4 = e3.xref.fetch(this.parent);
              t4.set("V", h2);
              await (0, m.writeObject)(this.parent, t4, u2, e3.xref);
              d2 = u2.join("");
              u2.length = 0;
            } else this.parent instanceof s.Dict && this.parent.set("V", h2);
            c2.set("AS", h2);
            c2.set("M", `D:${(0, r.getModificationDate)()}`);
            const f2 = this._getMKDict(i2);
            f2 && c2.set("MK", f2);
            await (0, m.writeObject)(this.ref, c2, u2, e3.xref);
            const g2 = [{ ref: this.ref, data: u2.join(""), xfa: l2 }];
            d2 && g2.push({ ref: this.parent, data: d2, xfa: null });
            return g2;
          }
          _getDefaultCheckedAppearance(e3, t3) {
            const a3 = this.data.rect[2] - this.data.rect[0], i2 = this.data.rect[3] - this.data.rect[1], c2 = [0, 0, a3, i2], l2 = 0.8 * Math.min(a3, i2);
            let h2, u2;
            if ("check" === t3) {
              h2 = { width: 0.755 * l2, height: 0.705 * l2 };
              u2 = "3";
            } else if ("disc" === t3) {
              h2 = { width: 0.791 * l2, height: 0.705 * l2 };
              u2 = "l";
            } else (0, r.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${t3}`);
            const d2 = `q BT /PdfJsZaDb ${l2} Tf 0 g ${(0, n.numberToString)((a3 - h2.width) / 2)} ${(0, n.numberToString)((i2 - h2.height) / 2)} Td (${u2}) Tj ET Q`, f2 = new s.Dict(e3.xref);
            f2.set("FormType", 1);
            f2.set("Subtype", s.Name.get("Form"));
            f2.set("Type", s.Name.get("XObject"));
            f2.set("BBox", c2);
            f2.set("Matrix", [1, 0, 0, 1, 0, 0]);
            f2.set("Length", d2.length);
            const g2 = new s.Dict(e3.xref), p2 = new s.Dict(e3.xref);
            p2.set("PdfJsZaDb", this.fallbackFontDict);
            g2.set("Font", p2);
            f2.set("Resources", g2);
            this.checkedAppearance = new o.StringStream(d2);
            this.checkedAppearance.dict = f2;
            this._streams.push(this.checkedAppearance);
          }
          _processCheckBox(e3) {
            const t3 = e3.dict.get("AP");
            if (!(t3 instanceof s.Dict)) return;
            const a3 = t3.get("N");
            if (!(a3 instanceof s.Dict)) return;
            const r2 = this._decodeFormValue(e3.dict.get("AS"));
            "string" == typeof r2 && (this.data.fieldValue = r2);
            const n2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", i2 = a3.getKeys();
            if (0 === i2.length) i2.push("Off", n2);
            else if (1 === i2.length) "Off" === i2[0] ? i2.push(n2) : i2.unshift("Off");
            else if (i2.includes(n2)) {
              i2.length = 0;
              i2.push("Off", n2);
            } else {
              const e4 = i2.find((e5) => "Off" !== e5);
              i2.length = 0;
              i2.push("Off", e4);
            }
            i2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
            this.data.exportValue = i2[1];
            const o2 = a3.get(this.data.exportValue);
            this.checkedAppearance = o2 instanceof c.BaseStream ? o2 : null;
            const l2 = a3.get("Off");
            this.uncheckedAppearance = l2 instanceof c.BaseStream ? l2 : null;
            this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "check");
            this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
            this._fallbackFontDict = this.fallbackFontDict;
            null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
          }
          _processRadioButton(e3) {
            this.data.fieldValue = this.data.buttonValue = null;
            const t3 = e3.dict.get("Parent");
            if (t3 instanceof s.Dict) {
              this.parent = e3.dict.getRaw("Parent");
              const a4 = t3.get("V");
              a4 instanceof s.Name && (this.data.fieldValue = this._decodeFormValue(a4));
            }
            const a3 = e3.dict.get("AP");
            if (!(a3 instanceof s.Dict)) return;
            const r2 = a3.get("N");
            if (!(r2 instanceof s.Dict)) return;
            for (const e4 of r2.getKeys()) if ("Off" !== e4) {
              this.data.buttonValue = this._decodeFormValue(e4);
              break;
            }
            const n2 = r2.get(this.data.buttonValue);
            this.checkedAppearance = n2 instanceof c.BaseStream ? n2 : null;
            const i2 = r2.get("Off");
            this.uncheckedAppearance = i2 instanceof c.BaseStream ? i2 : null;
            this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e3, "disc");
            this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
            this._fallbackFontDict = this.fallbackFontDict;
            null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
          }
          _processPushButton(e3) {
            const { dict: t3, annotationGlobals: a3 } = e3;
            if (t3.has("A") || t3.has("AA") || this.data.alternativeText) {
              this.data.isTooltipOnly = !t3.has("A") && !t3.has("AA");
              h.Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: a3.baseUrl, docAttachments: a3.attachments });
            } else (0, r.warn)("Push buttons without action dictionaries are not supported");
          }
          getFieldObject() {
            let e3, t3 = "button";
            if (this.data.checkBox) {
              t3 = "checkbox";
              e3 = this.data.exportValue;
            } else if (this.data.radioButton) {
              t3 = "radiobutton";
              e3 = this.data.buttonValue;
            }
            return { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e3, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t3 };
          }
          get fallbackFontDict() {
            const e3 = new s.Dict();
            e3.set("BaseFont", s.Name.get("ZapfDingbats"));
            e3.set("Type", s.Name.get("FallbackType"));
            e3.set("Subtype", s.Name.get("FallbackType"));
            e3.set("Encoding", s.Name.get("ZapfDingbatsEncoding"));
            return (0, r.shadow)(this, "fallbackFontDict", e3);
          }
        }
        class ChoiceWidgetAnnotation extends WidgetAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.indices = t3.getArray("I");
            this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
            this.data.options = [];
            const i2 = (0, n.getInheritableProperty)({ dict: t3, key: "Opt" });
            if (Array.isArray(i2)) for (let e4 = 0, t4 = i2.length; e4 < t4; e4++) {
              const t5 = a3.fetchIfRef(i2[e4]), r2 = Array.isArray(t5);
              this.data.options[e4] = { exportValue: this._decodeFormValue(r2 ? a3.fetchIfRef(t5[0]) : t5), displayValue: this._decodeFormValue(r2 ? a3.fetchIfRef(t5[1]) : t5) };
            }
            if (this.hasIndices) {
              this.data.fieldValue = [];
              const e4 = this.data.options.length;
              for (const t4 of this.indices) Number.isInteger(t4) && t4 >= 0 && t4 < e4 && this.data.fieldValue.push(this.data.options[t4].exportValue);
            } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
            this.data.combo = this.hasFieldFlag(r.AnnotationFieldFlag.COMBO);
            this.data.multiSelect = this.hasFieldFlag(r.AnnotationFieldFlag.MULTISELECT);
            this._hasText = true;
          }
          getFieldObject() {
            const e3 = this.data.combo ? "combobox" : "listbox", t3 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
            return { id: this.data.id, value: t3, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e3 };
          }
          amendSavedDict(e3, t3) {
            var _a;
            if (!this.hasIndices) return;
            let a3 = (_a = e3 == null ? void 0 : e3.get(this.data.id)) == null ? void 0 : _a.value;
            Array.isArray(a3) || (a3 = [a3]);
            const r2 = [], { options: n2 } = this.data;
            for (let e4 = 0, t4 = 0, i2 = n2.length; e4 < i2; e4++) if (n2[e4].exportValue === a3[t4]) {
              r2.push(e4);
              t4 += 1;
            }
            t3.set("I", r2);
          }
          async _getAppearance(e3, t3, a3, n2) {
            if (this.data.combo) return super._getAppearance(e3, t3, a3, n2);
            let s2, o2;
            const c2 = n2 == null ? void 0 : n2.get(this.data.id);
            if (c2) {
              o2 = c2.rotation;
              s2 = c2.value;
            }
            if (void 0 === o2 && void 0 === s2 && !this._needAppearances) return null;
            void 0 === s2 ? s2 = this.data.fieldValue : Array.isArray(s2) || (s2 = [s2]);
            let l2 = this.data.rect[3] - this.data.rect[1], h2 = this.data.rect[2] - this.data.rect[0];
            90 !== o2 && 270 !== o2 || ([h2, l2] = [l2, h2]);
            const u2 = this.data.options.length, d2 = [];
            for (let e4 = 0; e4 < u2; e4++) {
              const { exportValue: t4 } = this.data.options[e4];
              s2.includes(t4) && d2.push(e4);
            }
            this._defaultAppearance || (this.data.defaultAppearanceData = (0, i.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
            const f2 = await WidgetAnnotation._getFontData(e3, t3, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
            let g2, { fontSize: p2 } = this.data.defaultAppearanceData;
            if (p2) g2 = this._defaultAppearance;
            else {
              const e4 = (l2 - 1) / u2;
              let t4, a4 = -1;
              for (const { displayValue: e5 } of this.data.options) {
                const r2 = this._getTextWidth(e5, f2);
                if (r2 > a4) {
                  a4 = r2;
                  t4 = e5;
                }
              }
              [g2, p2] = this._computeFontSize(e4, h2 - 4, t4, f2, -1);
            }
            const m2 = p2 * r.LINE_FACTOR, b2 = (m2 - p2) / 2, y = Math.floor(l2 / m2);
            let w = 0;
            if (d2.length > 0) {
              const e4 = Math.min(...d2), t4 = Math.max(...d2);
              w = Math.max(0, t4 - y + 1);
              w > e4 && (w = e4);
            }
            const S = Math.min(w + y + 1, u2), x = ["/Tx BMC q", `1 1 ${h2} ${l2} re W n`];
            if (d2.length) {
              x.push("0.600006 0.756866 0.854904 rg");
              for (const e4 of d2) w <= e4 && e4 < S && x.push(`1 ${l2 - (e4 - w + 1) * m2} ${h2} ${m2} re f`);
            }
            x.push("BT", g2, `1 0 0 1 0 ${l2} Tm`);
            const C = { shift: 0 };
            for (let e4 = w; e4 < S; e4++) {
              const { displayValue: t4 } = this.data.options[e4], a4 = e4 === w ? b2 : 0;
              x.push(this._renderText(t4, f2, p2, h2, 0, C, 2, -m2 + a4));
            }
            x.push("ET Q EMC");
            return x.join("\n");
          }
        }
        class SignatureWidgetAnnotation extends WidgetAnnotation {
          constructor(e3) {
            super(e3);
            this.data.fieldValue = null;
            this.data.hasOwnCanvas = this.data.noRotate;
          }
          getFieldObject() {
            return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
          }
        }
        class TextAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            this.data.noRotate = true;
            this.data.hasOwnCanvas = this.data.noRotate;
            const { dict: t3 } = e3;
            this.data.annotationType = r.AnnotationType.TEXT;
            if (this.data.hasAppearance) this.data.name = "NoIcon";
            else {
              this.data.rect[1] = this.data.rect[3] - 22;
              this.data.rect[2] = this.data.rect[0] + 22;
              this.data.name = t3.has("Name") ? t3.get("Name").name : "Note";
            }
            if (t3.has("State")) {
              this.data.state = t3.get("State") || null;
              this.data.stateModel = t3.get("StateModel") || null;
            } else {
              this.data.state = null;
              this.data.stateModel = null;
            }
          }
        }
        class LinkAnnotation extends Annotation {
          constructor(e3) {
            var _a;
            super(e3);
            const { dict: t3, annotationGlobals: a3 } = e3;
            this.data.annotationType = r.AnnotationType.LINK;
            const n2 = getQuadPoints(t3, this.rectangle);
            n2 && (this.data.quadPoints = n2);
            (_a = this.data).borderColor || (_a.borderColor = this.data.color);
            h.Catalog.parseDestDictionary({ destDict: t3, resultObj: this.data, docBaseUrl: a3.baseUrl, docAttachments: a3.attachments });
          }
        }
        class PopupAnnotation extends Annotation {
          constructor(e3) {
            super(e3);
            const { dict: t3 } = e3;
            this.data.annotationType = r.AnnotationType.POPUP;
            this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
            let a3 = t3.get("Parent");
            if (!a3) {
              (0, r.warn)("Popup annotation has a missing or invalid parent annotation.");
              return;
            }
            const n2 = a3.getArray("Rect");
            this.data.parentRect = Array.isArray(n2) && 4 === n2.length ? r.Util.normalizeRect(n2) : null;
            const i2 = a3.get("RT");
            (0, s.isName)(i2, r.AnnotationReplyType.GROUP) && (a3 = a3.get("IRT"));
            if (a3.has("M")) {
              this.setModificationDate(a3.get("M"));
              this.data.modificationDate = this.modificationDate;
            } else this.data.modificationDate = null;
            if (a3.has("C")) {
              this.setColor(a3.getArray("C"));
              this.data.color = this.color;
            } else this.data.color = null;
            if (!this.viewable) {
              const e4 = a3.get("F");
              this._isViewable(e4) && this.setFlags(e4);
            }
            this.setTitle(a3.get("T"));
            this.data.titleObj = this._title;
            this.setContents(a3.get("Contents"));
            this.data.contentsObj = this._contents;
            a3.has("RC") && (this.data.richText = b.XFAFactory.getRichTextAsHtml(a3.get("RC")));
            this.data.open = !!t3.get("Open");
          }
        }
        t2.PopupAnnotation = PopupAnnotation;
        class FreeTextAnnotation extends MarkupAnnotation {
          constructor(e3) {
            var _a;
            super(e3);
            this.data.hasOwnCanvas = true;
            const { evaluatorOptions: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.FREETEXT;
            this.setDefaultAppearance(e3);
            if (this.appearance) {
              const { fontColor: e4, fontSize: r2 } = (0, i.parseAppearanceStream)(this.appearance, t3, a3);
              this.data.defaultAppearanceData.fontColor = e4;
              this.data.defaultAppearanceData.fontSize = r2 || 10;
            } else if (this._isOffscreenCanvasSupported) {
              const t4 = e3.dict.get("CA"), r2 = new i.FakeUnicodeFont(a3, "sans-serif");
              (_a = this.data.defaultAppearanceData).fontSize || (_a.fontSize = 10);
              const { fontColor: n2, fontSize: s2 } = this.data.defaultAppearanceData;
              this.appearance = r2.createAppearance(this._contents.str, this.rectangle, this.rotation, s2, n2, t4);
              this._streams.push(this.appearance, i.FakeUnicodeFont.toUnicodeStream);
            } else (0, r.warn)("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
          }
          get hasTextContent() {
            return !!this.appearance;
          }
          static createNewDict(e3, t3, { apRef: a3, ap: o2 }) {
            const { color: c2, fontSize: l2, rect: h2, rotation: u2, user: d2, value: f2 } = e3, g2 = new s.Dict(t3);
            g2.set("Type", s.Name.get("Annot"));
            g2.set("Subtype", s.Name.get("FreeText"));
            g2.set("CreationDate", `D:${(0, r.getModificationDate)()}`);
            g2.set("Rect", h2);
            const p2 = `/Helv ${l2} Tf ${(0, i.getPdfColor)(c2, true)}`;
            g2.set("DA", p2);
            g2.set("Contents", (0, n.isAscii)(f2) ? f2 : (0, n.stringToUTF16String)(f2, true));
            g2.set("F", 4);
            g2.set("Border", [0, 0, 0]);
            g2.set("Rotate", u2);
            d2 && g2.set("T", (0, n.isAscii)(d2) ? d2 : (0, n.stringToUTF16String)(d2, true));
            if (a3 || o2) {
              const e4 = new s.Dict(t3);
              g2.set("AP", e4);
              a3 ? e4.set("N", a3) : e4.set("N", o2);
            }
            return g2;
          }
          static async createNewAppearanceStream(e3, t3, a3) {
            const { baseFontRef: c2, evaluator: l2, task: h2 } = a3, { color: u2, fontSize: d2, rect: f2, rotation: g2, value: p2 } = e3, m2 = new s.Dict(t3), b2 = new s.Dict(t3);
            if (c2) b2.set("Helv", c2);
            else {
              const e4 = new s.Dict(t3);
              e4.set("BaseFont", s.Name.get("Helvetica"));
              e4.set("Type", s.Name.get("Font"));
              e4.set("Subtype", s.Name.get("Type1"));
              e4.set("Encoding", s.Name.get("WinAnsiEncoding"));
              b2.set("Helv", e4);
            }
            m2.set("Font", b2);
            const y = await WidgetAnnotation._getFontData(l2, h2, { fontName: "Helv", fontSize: d2 }, m2), [w, S, x, C] = f2;
            let k = x - w, v = C - S;
            g2 % 180 != 0 && ([k, v] = [v, k]);
            const F = p2.split("\n"), O = d2 / 1e3;
            let T = -1 / 0;
            const M = [];
            for (let e4 of F) {
              const t4 = y.encodeString(e4);
              if (t4.length > 1) return null;
              e4 = t4.join("");
              M.push(e4);
              let a4 = 0;
              const r2 = y.charsToGlyphs(e4);
              for (const e5 of r2) a4 += e5.width * O;
              T = Math.max(T, a4);
            }
            let D = 1;
            T > k && (D = k / T);
            let E = 1;
            const N = r.LINE_FACTOR * d2, R = (r.LINE_FACTOR - r.LINE_DESCENT_FACTOR) * d2, L = N * F.length;
            L > v && (E = v / L);
            const $ = d2 * Math.min(D, E);
            let _, j, U;
            switch (g2) {
              case 0:
                U = [1, 0, 0, 1];
                j = [f2[0], f2[1], k, v];
                _ = [f2[0], f2[3] - R];
                break;
              case 90:
                U = [0, 1, -1, 0];
                j = [f2[1], -f2[2], k, v];
                _ = [f2[1], -f2[0] - R];
                break;
              case 180:
                U = [-1, 0, 0, -1];
                j = [-f2[2], -f2[3], k, v];
                _ = [-f2[2], -f2[1] - R];
                break;
              case 270:
                U = [0, -1, 1, 0];
                j = [-f2[3], f2[0], k, v];
                _ = [-f2[3], f2[2] - R];
            }
            const X = ["q", `${U.join(" ")} 0 0 cm`, `${j.join(" ")} re W n`, "BT", `${(0, i.getPdfColor)(u2, true)}`, `0 Tc /Helv ${(0, n.numberToString)($)} Tf`];
            X.push(`${_.join(" ")} Td (${(0, n.escapeString)(M[0])}) Tj`);
            const H = (0, n.numberToString)(N);
            for (let e4 = 1, t4 = M.length; e4 < t4; e4++) {
              const t5 = M[e4];
              X.push(`0 -${H} Td (${(0, n.escapeString)(t5)}) Tj`);
            }
            X.push("ET", "Q");
            const q = X.join("\n"), z = new s.Dict(t3);
            z.set("FormType", 1);
            z.set("Subtype", s.Name.get("Form"));
            z.set("Type", s.Name.get("XObject"));
            z.set("BBox", f2);
            z.set("Resources", m2);
            z.set("Matrix", [1, 0, 0, 1, -f2[0], -f2[1]]);
            const W = new o.StringStream(q);
            W.dict = z;
            return W;
          }
        }
        class LineAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.LINE;
            this.data.hasOwnCanvas = this.data.noRotate;
            const n2 = t3.getArray("L");
            this.data.lineCoordinates = r.Util.normalizeRect(n2);
            this.setLineEndings(t3.getArray("LE"));
            this.data.lineEndings = this.lineEndings;
            if (!this.appearance) {
              const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], i2 = t3.get("CA"), s2 = getRgbColor(t3.getArray("IC"), null), o2 = s2 ? getPdfColorArray(s2) : null, c2 = o2 ? i2 : null, l2 = this.borderStyle.width || 1, h2 = 2 * l2, u2 = [this.data.lineCoordinates[0] - h2, this.data.lineCoordinates[1] - h2, this.data.lineCoordinates[2] + h2, this.data.lineCoordinates[3] + h2];
              r.Util.intersect(this.rectangle, u2) || (this.rectangle = u2);
              this._setDefaultAppearance({ xref: a3, extra: `${l2} w`, strokeColor: e4, fillColor: o2, strokeAlpha: i2, fillAlpha: c2, pointsCallback: (e5, t4) => {
                e5.push(`${n2[0]} ${n2[1]} m`, `${n2[2]} ${n2[3]} l`, "S");
                return [t4[0].x - l2, t4[1].x + l2, t4[3].y - l2, t4[1].y + l2];
              } });
            }
          }
        }
        class SquareAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.SQUARE;
            this.data.hasOwnCanvas = this.data.noRotate;
            if (!this.appearance) {
              const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], r2 = t3.get("CA"), n2 = getRgbColor(t3.getArray("IC"), null), i2 = n2 ? getPdfColorArray(n2) : null, s2 = i2 ? r2 : null;
              if (0 === this.borderStyle.width && !i2) return;
              this._setDefaultAppearance({ xref: a3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: i2, strokeAlpha: r2, fillAlpha: s2, pointsCallback: (e5, t4) => {
                const a4 = t4[2].x + this.borderStyle.width / 2, r3 = t4[2].y + this.borderStyle.width / 2, n3 = t4[3].x - t4[2].x - this.borderStyle.width, s3 = t4[1].y - t4[3].y - this.borderStyle.width;
                e5.push(`${a4} ${r3} ${n3} ${s3} re`);
                i2 ? e5.push("B") : e5.push("S");
                return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
              } });
            }
          }
        }
        class CircleAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.CIRCLE;
            if (!this.appearance) {
              const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], r2 = t3.get("CA"), n2 = getRgbColor(t3.getArray("IC"), null), i2 = n2 ? getPdfColorArray(n2) : null, s2 = i2 ? r2 : null;
              if (0 === this.borderStyle.width && !i2) return;
              const o2 = 4 / 3 * Math.tan(Math.PI / 8);
              this._setDefaultAppearance({ xref: a3, extra: `${this.borderStyle.width} w`, strokeColor: e4, fillColor: i2, strokeAlpha: r2, fillAlpha: s2, pointsCallback: (e5, t4) => {
                const a4 = t4[0].x + this.borderStyle.width / 2, r3 = t4[0].y - this.borderStyle.width / 2, n3 = t4[3].x - this.borderStyle.width / 2, s3 = t4[3].y + this.borderStyle.width / 2, c2 = a4 + (n3 - a4) / 2, l2 = r3 + (s3 - r3) / 2, h2 = (n3 - a4) / 2 * o2, u2 = (s3 - r3) / 2 * o2;
                e5.push(`${c2} ${s3} m`, `${c2 + h2} ${s3} ${n3} ${l2 + u2} ${n3} ${l2} c`, `${n3} ${l2 - u2} ${c2 + h2} ${r3} ${c2} ${r3} c`, `${c2 - h2} ${r3} ${a4} ${l2 - u2} ${a4} ${l2} c`, `${a4} ${l2 + u2} ${c2 - h2} ${s3} ${c2} ${s3} c`, "h");
                i2 ? e5.push("B") : e5.push("S");
                return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
              } });
            }
          }
        }
        class PolylineAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.POLYLINE;
            this.data.hasOwnCanvas = this.data.noRotate;
            this.data.vertices = [];
            if (!(this instanceof PolygonAnnotation)) {
              this.setLineEndings(t3.getArray("LE"));
              this.data.lineEndings = this.lineEndings;
            }
            const n2 = t3.getArray("Vertices");
            if (Array.isArray(n2)) {
              for (let e4 = 0, t4 = n2.length; e4 < t4; e4 += 2) this.data.vertices.push({ x: n2[e4], y: n2[e4 + 1] });
              if (!this.appearance) {
                const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], n3 = t3.get("CA"), i2 = this.borderStyle.width || 1, s2 = 2 * i2, o2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const e5 of this.data.vertices) {
                  o2[0] = Math.min(o2[0], e5.x - s2);
                  o2[1] = Math.min(o2[1], e5.y - s2);
                  o2[2] = Math.max(o2[2], e5.x + s2);
                  o2[3] = Math.max(o2[3], e5.y + s2);
                }
                r.Util.intersect(this.rectangle, o2) || (this.rectangle = o2);
                this._setDefaultAppearance({ xref: a3, extra: `${i2} w`, strokeColor: e4, strokeAlpha: n3, pointsCallback: (e5, t4) => {
                  const a4 = this.data.vertices;
                  for (let t5 = 0, r2 = a4.length; t5 < r2; t5++) e5.push(`${a4[t5].x} ${a4[t5].y} ${0 === t5 ? "m" : "l"}`);
                  e5.push("S");
                  return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
                } });
              }
            }
          }
        }
        class PolygonAnnotation extends PolylineAnnotation {
          constructor(e3) {
            super(e3);
            this.data.annotationType = r.AnnotationType.POLYGON;
          }
        }
        class CaretAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            this.data.annotationType = r.AnnotationType.CARET;
          }
        }
        class InkAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            this.data.hasOwnCanvas = this.data.noRotate;
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.INK;
            this.data.inkLists = [];
            const n2 = t3.getArray("InkList");
            if (Array.isArray(n2)) {
              for (let e4 = 0, t4 = n2.length; e4 < t4; ++e4) {
                this.data.inkLists.push([]);
                for (let t5 = 0, r2 = n2[e4].length; t5 < r2; t5 += 2) this.data.inkLists[e4].push({ x: a3.fetchIfRef(n2[e4][t5]), y: a3.fetchIfRef(n2[e4][t5 + 1]) });
              }
              if (!this.appearance) {
                const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], n3 = t3.get("CA"), i2 = this.borderStyle.width || 1, s2 = 2 * i2, o2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (const e5 of this.data.inkLists) for (const t4 of e5) {
                  o2[0] = Math.min(o2[0], t4.x - s2);
                  o2[1] = Math.min(o2[1], t4.y - s2);
                  o2[2] = Math.max(o2[2], t4.x + s2);
                  o2[3] = Math.max(o2[3], t4.y + s2);
                }
                r.Util.intersect(this.rectangle, o2) || (this.rectangle = o2);
                this._setDefaultAppearance({ xref: a3, extra: `${i2} w`, strokeColor: e4, strokeAlpha: n3, pointsCallback: (e5, t4) => {
                  for (const t5 of this.data.inkLists) {
                    for (let a4 = 0, r2 = t5.length; a4 < r2; a4++) e5.push(`${t5[a4].x} ${t5[a4].y} ${0 === a4 ? "m" : "l"}`);
                    e5.push("S");
                  }
                  return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
                } });
              }
            }
          }
          static createNewDict(e3, t3, { apRef: a3, ap: n2 }) {
            const { color: i2, opacity: o2, paths: c2, rect: l2, rotation: h2, thickness: u2 } = e3, d2 = new s.Dict(t3);
            d2.set("Type", s.Name.get("Annot"));
            d2.set("Subtype", s.Name.get("Ink"));
            d2.set("CreationDate", `D:${(0, r.getModificationDate)()}`);
            d2.set("Rect", l2);
            d2.set("InkList", c2.map((e4) => e4.points));
            d2.set("F", 4);
            d2.set("Rotate", h2);
            const f2 = new s.Dict(t3);
            d2.set("BS", f2);
            f2.set("W", u2);
            d2.set("C", Array.from(i2, (e4) => e4 / 255));
            d2.set("CA", o2);
            const g2 = new s.Dict(t3);
            d2.set("AP", g2);
            a3 ? g2.set("N", a3) : g2.set("N", n2);
            return d2;
          }
          static async createNewAppearanceStream(e3, t3, a3) {
            const { color: r2, rect: c2, paths: l2, thickness: h2, opacity: u2 } = e3, d2 = [`${h2} w 1 J 1 j`, `${(0, i.getPdfColor)(r2, false)}`];
            1 !== u2 && d2.push("/R0 gs");
            const f2 = [];
            for (const { bezier: e4 } of l2) {
              f2.length = 0;
              f2.push(`${(0, n.numberToString)(e4[0])} ${(0, n.numberToString)(e4[1])} m`);
              for (let t4 = 2, a4 = e4.length; t4 < a4; t4 += 6) {
                const a5 = e4.slice(t4, t4 + 6).map(n.numberToString).join(" ");
                f2.push(`${a5} c`);
              }
              f2.push("S");
              d2.push(f2.join("\n"));
            }
            const g2 = d2.join("\n"), p2 = new s.Dict(t3);
            p2.set("FormType", 1);
            p2.set("Subtype", s.Name.get("Form"));
            p2.set("Type", s.Name.get("XObject"));
            p2.set("BBox", c2);
            p2.set("Length", g2.length);
            if (1 !== u2) {
              const e4 = new s.Dict(t3), a4 = new s.Dict(t3), r3 = new s.Dict(t3);
              r3.set("CA", u2);
              r3.set("Type", s.Name.get("ExtGState"));
              a4.set("R0", r3);
              e4.set("ExtGState", a4);
              p2.set("Resources", e4);
            }
            const m2 = new o.StringStream(g2);
            m2.dict = p2;
            return m2;
          }
        }
        class HighlightAnnotation extends MarkupAnnotation {
          constructor(e3) {
            var _a;
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.HIGHLIGHT;
            if (this.data.quadPoints = getQuadPoints(t3, null)) {
              const e4 = (_a = this.appearance) == null ? void 0 : _a.dict.get("Resources");
              if (!this.appearance || !(e4 == null ? void 0 : e4.has("ExtGState"))) {
                this.appearance && (0, r.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                const e5 = this.color ? getPdfColorArray(this.color) : [1, 1, 0], n2 = t3.get("CA");
                this._setDefaultAppearance({ xref: a3, fillColor: e5, blendMode: "Multiply", fillAlpha: n2, pointsCallback: (e6, t4) => {
                  e6.push(`${t4[0].x} ${t4[0].y} m`, `${t4[1].x} ${t4[1].y} l`, `${t4[3].x} ${t4[3].y} l`, `${t4[2].x} ${t4[2].y} l`, "f");
                  return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
                } });
              }
            } else this.data.popupRef = null;
          }
        }
        class UnderlineAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.UNDERLINE;
            if (this.data.quadPoints = getQuadPoints(t3, null)) {
              if (!this.appearance) {
                const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], r2 = t3.get("CA");
                this._setDefaultAppearance({ xref: a3, extra: "[] 0 d 0.571 w", strokeColor: e4, strokeAlpha: r2, pointsCallback: (e5, t4) => {
                  e5.push(`${t4[2].x} ${t4[2].y + 1.3} m`, `${t4[3].x} ${t4[3].y + 1.3} l`, "S");
                  return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
                } });
              }
            } else this.data.popupRef = null;
          }
        }
        class SquigglyAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.SQUIGGLY;
            if (this.data.quadPoints = getQuadPoints(t3, null)) {
              if (!this.appearance) {
                const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], r2 = t3.get("CA");
                this._setDefaultAppearance({ xref: a3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: r2, pointsCallback: (e5, t4) => {
                  const a4 = (t4[0].y - t4[2].y) / 6;
                  let r3 = a4, n2 = t4[2].x;
                  const i2 = t4[2].y, s2 = t4[3].x;
                  e5.push(`${n2} ${i2 + r3} m`);
                  do {
                    n2 += 2;
                    r3 = 0 === r3 ? a4 : 0;
                    e5.push(`${n2} ${i2 + r3} l`);
                  } while (n2 < s2);
                  e5.push("S");
                  return [t4[2].x, s2, i2 - 2 * a4, i2 + 2 * a4];
                } });
              }
            } else this.data.popupRef = null;
          }
        }
        class StrikeOutAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3;
            this.data.annotationType = r.AnnotationType.STRIKEOUT;
            if (this.data.quadPoints = getQuadPoints(t3, null)) {
              if (!this.appearance) {
                const e4 = this.color ? getPdfColorArray(this.color) : [0, 0, 0], r2 = t3.get("CA");
                this._setDefaultAppearance({ xref: a3, extra: "[] 0 d 1 w", strokeColor: e4, strokeAlpha: r2, pointsCallback: (e5, t4) => {
                  e5.push((t4[0].x + t4[2].x) / 2 + " " + (t4[0].y + t4[2].y) / 2 + " m", (t4[1].x + t4[3].x) / 2 + " " + (t4[1].y + t4[3].y) / 2 + " l", "S");
                  return [t4[0].x, t4[1].x, t4[3].y, t4[1].y];
                } });
              }
            } else this.data.popupRef = null;
          }
        }
        class StampAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            this.data.annotationType = r.AnnotationType.STAMP;
            this.data.hasOwnCanvas = this.data.noRotate;
          }
          static async createImage(e3, t3) {
            const { width: a3, height: n2 } = e3, i2 = new OffscreenCanvas(a3, n2), c2 = i2.getContext("2d", { alpha: true });
            c2.drawImage(e3, 0, 0);
            const l2 = c2.getImageData(0, 0, a3, n2).data, h2 = new Uint32Array(l2.buffer), u2 = h2.some(r.FeatureTest.isLittleEndian ? (e4) => e4 >>> 24 != 255 : (e4) => 255 != (255 & e4));
            if (u2) {
              c2.fillStyle = "white";
              c2.fillRect(0, 0, a3, n2);
              c2.drawImage(e3, 0, 0);
            }
            const d2 = i2.convertToBlob({ type: "image/jpeg", quality: 1 }).then((e4) => e4.arrayBuffer()), f2 = s.Name.get("XObject"), g2 = s.Name.get("Image"), p2 = new s.Dict(t3);
            p2.set("Type", f2);
            p2.set("Subtype", g2);
            p2.set("BitsPerComponent", 8);
            p2.set("ColorSpace", s.Name.get("DeviceRGB"));
            p2.set("Filter", s.Name.get("DCTDecode"));
            p2.set("BBox", [0, 0, a3, n2]);
            p2.set("Width", a3);
            p2.set("Height", n2);
            let m2 = null;
            if (u2) {
              const e4 = new Uint8Array(h2.length);
              if (r.FeatureTest.isLittleEndian) for (let t4 = 0, a4 = h2.length; t4 < a4; t4++) e4[t4] = h2[t4] >>> 24;
              else for (let t4 = 0, a4 = h2.length; t4 < a4; t4++) e4[t4] = 255 & h2[t4];
              const i3 = new s.Dict(t3);
              i3.set("Type", f2);
              i3.set("Subtype", g2);
              i3.set("BitsPerComponent", 8);
              i3.set("ColorSpace", s.Name.get("DeviceGray"));
              i3.set("Width", a3);
              i3.set("Height", n2);
              m2 = new o.Stream(e4, 0, 0, i3);
            }
            return { imageStream: new o.Stream(await d2, 0, 0, p2), smaskStream: m2, width: a3, height: n2 };
          }
          static createNewDict(e3, t3, { apRef: a3, ap: i2 }) {
            const { rect: o2, rotation: c2, user: l2 } = e3, h2 = new s.Dict(t3);
            h2.set("Type", s.Name.get("Annot"));
            h2.set("Subtype", s.Name.get("Stamp"));
            h2.set("CreationDate", `D:${(0, r.getModificationDate)()}`);
            h2.set("Rect", o2);
            h2.set("F", 4);
            h2.set("Border", [0, 0, 0]);
            h2.set("Rotate", c2);
            l2 && h2.set("T", (0, n.isAscii)(l2) ? l2 : (0, n.stringToUTF16String)(l2, true));
            if (a3 || i2) {
              const e4 = new s.Dict(t3);
              h2.set("AP", e4);
              a3 ? e4.set("N", a3) : e4.set("N", i2);
            }
            return h2;
          }
          static async createNewAppearanceStream(e3, t3, a3) {
            const { rotation: r2 } = e3, { imageRef: i2, width: c2, height: l2 } = a3.image, h2 = new s.Dict(t3), u2 = new s.Dict(t3);
            h2.set("XObject", u2);
            u2.set("Im0", i2);
            const d2 = `q ${c2} 0 0 ${l2} 0 0 cm /Im0 Do Q`, f2 = new s.Dict(t3);
            f2.set("FormType", 1);
            f2.set("Subtype", s.Name.get("Form"));
            f2.set("Type", s.Name.get("XObject"));
            f2.set("BBox", [0, 0, c2, l2]);
            f2.set("Resources", h2);
            if (r2) {
              const e4 = (0, n.getRotationMatrix)(r2, c2, l2);
              f2.set("Matrix", e4);
            }
            const g2 = new o.StringStream(d2);
            g2.dict = f2;
            return g2;
          }
        }
        class FileAttachmentAnnotation extends MarkupAnnotation {
          constructor(e3) {
            super(e3);
            const { dict: t3, xref: a3 } = e3, n2 = new d.FileSpec(t3.get("FS"), a3);
            this.data.annotationType = r.AnnotationType.FILEATTACHMENT;
            this.data.hasOwnCanvas = this.data.noRotate;
            this.data.file = n2.serializable;
            const i2 = t3.get("Name");
            this.data.name = i2 instanceof s.Name ? (0, r.stringToPDFString)(i2.name) : "PushPin";
            const o2 = t3.get("ca");
            this.data.fillAlpha = "number" == typeof o2 && o2 >= 0 && o2 <= 1 ? o2 : null;
          }
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.FakeUnicodeFont = void 0;
        t2.createDefaultAppearance = function createDefaultAppearance({ fontSize: e3, fontName: t3, fontColor: a3 }) {
          return `/${(0, n.escapePDFName)(t3)} ${e3} Tf ${getPdfColor(a3, true)}`;
        };
        t2.getPdfColor = getPdfColor;
        t2.parseAppearanceStream = function parseAppearanceStream(e3, t3, a3) {
          return new AppearanceStreamEvaluator(e3, t3, a3).parse();
        };
        t2.parseDefaultAppearance = function parseDefaultAppearance(e3) {
          return new DefaultAppearanceEvaluator(e3).parse();
        };
        var r = a2(4), n = a2(3), i = a2(2), s = a2(12), o = a2(13), c = a2(59), l = a2(57), h = a2(8);
        class DefaultAppearanceEvaluator extends o.EvaluatorPreprocessor {
          constructor(e3) {
            super(new h.StringStream(e3));
          }
          parse() {
            const e3 = { fn: 0, args: [] }, t3 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
            try {
              for (; ; ) {
                e3.args.length = 0;
                if (!this.read(e3)) break;
                if (0 !== this.savedStatesDepth) continue;
                const { fn: a3, args: n2 } = e3;
                switch (0 | a3) {
                  case i.OPS.setFont:
                    const [e4, a4] = n2;
                    e4 instanceof r.Name && (t3.fontName = e4.name);
                    "number" == typeof a4 && a4 > 0 && (t3.fontSize = a4);
                    break;
                  case i.OPS.setFillRGBColor:
                    s.ColorSpace.singletons.rgb.getRgbItem(n2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.setFillGray:
                    s.ColorSpace.singletons.gray.getRgbItem(n2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.setFillCMYKColor:
                    s.ColorSpace.singletons.cmyk.getRgbItem(n2, 0, t3.fontColor, 0);
                }
              }
            } catch (e4) {
              (0, i.warn)(`parseDefaultAppearance - ignoring errors: "${e4}".`);
            }
            return t3;
          }
        }
        class AppearanceStreamEvaluator extends o.EvaluatorPreprocessor {
          constructor(e3, t3, a3) {
            var _a;
            super(e3);
            this.stream = e3;
            this.evaluatorOptions = t3;
            this.xref = a3;
            this.resources = (_a = e3.dict) == null ? void 0 : _a.get("Resources");
          }
          parse() {
            const e3 = { fn: 0, args: [] };
            let t3 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: s.ColorSpace.singletons.gray }, a3 = false;
            const n2 = [];
            try {
              for (; ; ) {
                e3.args.length = 0;
                if (a3 || !this.read(e3)) break;
                const { fn: o2, args: c2 } = e3;
                switch (0 | o2) {
                  case i.OPS.save:
                    n2.push({ scaleFactor: t3.scaleFactor, fontSize: t3.fontSize, fontName: t3.fontName, fontColor: t3.fontColor.slice(), fillColorSpace: t3.fillColorSpace });
                    break;
                  case i.OPS.restore:
                    t3 = n2.pop() || t3;
                    break;
                  case i.OPS.setTextMatrix:
                    t3.scaleFactor *= Math.hypot(c2[0], c2[1]);
                    break;
                  case i.OPS.setFont:
                    const [e4, o3] = c2;
                    e4 instanceof r.Name && (t3.fontName = e4.name);
                    "number" == typeof o3 && o3 > 0 && (t3.fontSize = o3 * t3.scaleFactor);
                    break;
                  case i.OPS.setFillColorSpace:
                    t3.fillColorSpace = s.ColorSpace.parse({ cs: c2[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
                    break;
                  case i.OPS.setFillColor:
                    t3.fillColorSpace.getRgbItem(c2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.setFillRGBColor:
                    s.ColorSpace.singletons.rgb.getRgbItem(c2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.setFillGray:
                    s.ColorSpace.singletons.gray.getRgbItem(c2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.setFillCMYKColor:
                    s.ColorSpace.singletons.cmyk.getRgbItem(c2, 0, t3.fontColor, 0);
                    break;
                  case i.OPS.showText:
                  case i.OPS.showSpacedText:
                  case i.OPS.nextLineShowText:
                  case i.OPS.nextLineSetSpacingShowText:
                    a3 = true;
                }
              }
            } catch (e4) {
              (0, i.warn)(`parseAppearanceStream - ignoring errors: "${e4}".`);
            }
            this.stream.reset();
            delete t3.scaleFactor;
            delete t3.fillColorSpace;
            return t3;
          }
          get _localColorSpaceCache() {
            return (0, i.shadow)(this, "_localColorSpaceCache", new c.LocalColorSpaceCache());
          }
          get _pdfFunctionFactory() {
            const e3 = new l.PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported });
            return (0, i.shadow)(this, "_pdfFunctionFactory", e3);
          }
        }
        function getPdfColor(e3, t3) {
          if (e3[0] === e3[1] && e3[1] === e3[2]) {
            const a3 = e3[0] / 255;
            return `${(0, n.numberToString)(a3)} ${t3 ? "g" : "G"}`;
          }
          return Array.from(e3, (e4) => (0, n.numberToString)(e4 / 255)).join(" ") + " " + (t3 ? "rg" : "RG");
        }
        class FakeUnicodeFont {
          constructor(e3, t3) {
            this.xref = e3;
            this.widths = null;
            this.firstChar = 1 / 0;
            this.lastChar = -1 / 0;
            this.fontFamily = t3;
            const a3 = new OffscreenCanvas(1, 1);
            this.ctxMeasure = a3.getContext("2d");
            FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1);
            this.fontName = r.Name.get(`InvalidPDFjsFont_${t3}_${FakeUnicodeFont._fontNameId++}`);
          }
          get toUnicodeRef() {
            if (!FakeUnicodeFont._toUnicodeRef) {
              const e3 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (Adobe)\n/Ordering (UCS) /Supplement 0 >> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000> <FFFF>\nendcodespacerange\n1 beginbfrange\n<0000> <FFFF> <0000>\nendbfrange\nendcmap CMapName currentdict /CMap defineresource pop end end", t3 = FakeUnicodeFont.toUnicodeStream = new h.StringStream(e3), a3 = new r.Dict(this.xref);
              t3.dict = a3;
              a3.set("Length", e3.length);
              FakeUnicodeFont._toUnicodeRef = this.xref.getNewPersistentRef(t3);
            }
            return FakeUnicodeFont._toUnicodeRef;
          }
          get fontDescriptorRef() {
            if (!FakeUnicodeFont._fontDescriptorRef) {
              const e3 = new r.Dict(this.xref);
              e3.set("Type", r.Name.get("FontDescriptor"));
              e3.set("FontName", this.fontName);
              e3.set("FontFamily", "MyriadPro Regular");
              e3.set("FontBBox", [0, 0, 0, 0]);
              e3.set("FontStretch", r.Name.get("Normal"));
              e3.set("FontWeight", 400);
              e3.set("ItalicAngle", 0);
              FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e3);
            }
            return FakeUnicodeFont._fontDescriptorRef;
          }
          get descendantFontRef() {
            const e3 = new r.Dict(this.xref);
            e3.set("BaseFont", this.fontName);
            e3.set("Type", r.Name.get("Font"));
            e3.set("Subtype", r.Name.get("CIDFontType0"));
            e3.set("CIDToGIDMap", r.Name.get("Identity"));
            e3.set("FirstChar", this.firstChar);
            e3.set("LastChar", this.lastChar);
            e3.set("FontDescriptor", this.fontDescriptorRef);
            e3.set("DW", 1e3);
            const t3 = [], a3 = [...this.widths.entries()].sort();
            let n2 = null, i2 = null;
            for (const [e4, r2] of a3) if (n2) if (e4 === n2 + i2.length) i2.push(r2);
            else {
              t3.push(n2, i2);
              n2 = e4;
              i2 = [r2];
            }
            else {
              n2 = e4;
              i2 = [r2];
            }
            n2 && t3.push(n2, i2);
            e3.set("W", t3);
            const s2 = new r.Dict(this.xref);
            s2.set("Ordering", "Identity");
            s2.set("Registry", "Adobe");
            s2.set("Supplement", 0);
            e3.set("CIDSystemInfo", s2);
            return this.xref.getNewPersistentRef(e3);
          }
          get baseFontRef() {
            const e3 = new r.Dict(this.xref);
            e3.set("BaseFont", this.fontName);
            e3.set("Type", r.Name.get("Font"));
            e3.set("Subtype", r.Name.get("Type0"));
            e3.set("Encoding", r.Name.get("Identity-H"));
            e3.set("DescendantFonts", [this.descendantFontRef]);
            e3.set("ToUnicode", this.toUnicodeRef);
            return this.xref.getNewPersistentRef(e3);
          }
          get resources() {
            const e3 = new r.Dict(this.xref), t3 = new r.Dict(this.xref);
            t3.set(this.fontName.name, this.baseFontRef);
            e3.set("Font", t3);
            return e3;
          }
          _createContext() {
            this.widths = /* @__PURE__ */ new Map();
            this.ctxMeasure.font = `1000px ${this.fontFamily}`;
            return this.ctxMeasure;
          }
          createFontResources(e3) {
            const t3 = this._createContext();
            for (const a3 of e3.split(/\r\n?|\n/)) for (const e4 of a3.split("")) {
              const a4 = e4.charCodeAt(0);
              if (this.widths.has(a4)) continue;
              const r2 = t3.measureText(e4), n2 = Math.ceil(r2.width);
              this.widths.set(a4, n2);
              this.firstChar = Math.min(a4, this.firstChar);
              this.lastChar = Math.max(a4, this.lastChar);
            }
            return this.resources;
          }
          createAppearance(e3, t3, a3, s2, o2, c2) {
            const l2 = this._createContext(), u = [];
            let d = -1 / 0;
            for (const t4 of e3.split(/\r\n?|\n/)) {
              u.push(t4);
              const e4 = l2.measureText(t4).width;
              d = Math.max(d, e4);
              for (const e5 of t4.split("")) {
                const t5 = e5.charCodeAt(0);
                let a4 = this.widths.get(t5);
                if (void 0 === a4) {
                  const r2 = l2.measureText(e5);
                  a4 = Math.ceil(r2.width);
                  this.widths.set(t5, a4);
                  this.firstChar = Math.min(t5, this.firstChar);
                  this.lastChar = Math.max(t5, this.lastChar);
                }
              }
            }
            d *= s2 / 1e3;
            const [f, g, p, m] = t3;
            let b = p - f, y = m - g;
            a3 % 180 != 0 && ([b, y] = [y, b]);
            let w = 1;
            d > b && (w = b / d);
            let S = 1;
            const x = i.LINE_FACTOR * s2, C = i.LINE_DESCENT_FACTOR * s2, k = x * u.length;
            k > y && (S = y / k);
            const v = s2 * Math.min(w, S), F = ["q", `0 0 ${(0, n.numberToString)(b)} ${(0, n.numberToString)(y)} re W n`, "BT", `1 0 0 1 0 ${(0, n.numberToString)(y + C)} Tm 0 Tc ${getPdfColor(o2, true)}`, `/${this.fontName.name} ${(0, n.numberToString)(v)} Tf`], { resources: O } = this;
            if (1 !== (c2 = "number" == typeof c2 && c2 >= 0 && c2 <= 1 ? c2 : 1)) {
              F.push("/R0 gs");
              const e4 = new r.Dict(this.xref), t4 = new r.Dict(this.xref);
              t4.set("ca", c2);
              t4.set("CA", c2);
              t4.set("Type", r.Name.get("ExtGState"));
              e4.set("R0", t4);
              O.set("ExtGState", e4);
            }
            const T = (0, n.numberToString)(x);
            for (const e4 of u) F.push(`0 -${T} Td <${(0, n.stringToUTF16HexString)(e4)}> Tj`);
            F.push("ET", "Q");
            const M = F.join("\n"), D = new r.Dict(this.xref);
            D.set("Subtype", r.Name.get("Form"));
            D.set("Type", r.Name.get("XObject"));
            D.set("BBox", [0, 0, b, y]);
            D.set("Length", M.length);
            D.set("Resources", O);
            if (a3) {
              const e4 = (0, n.getRotationMatrix)(a3, b, y);
              D.set("Matrix", e4);
            }
            const E = new h.StringStream(M);
            E.dict = D;
            return E;
          }
        }
        t2.FakeUnicodeFont = FakeUnicodeFont;
      }, (e2, t2, a2) => {
        var _DeviceCmykCS_instances, r_fn, _CalGrayCS_instances, r_fn2, _n, _i, _s, _o, _c, _l, _h, _u, _CalRGBCS_instances, d_fn, f_fn, g_fn, p_fn, m_fn, b_fn, y_fn, w_fn, S_fn, r_fn3, _LabCS_instances, x_fn, A_fn, r_fn4;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ColorSpace = void 0;
        var r = a2(2), n = a2(4), i = a2(5), s = a2(3);
        class ColorSpace {
          constructor(e3, t3) {
            this.constructor === ColorSpace && (0, r.unreachable)("Cannot initialize ColorSpace.");
            this.name = e3;
            this.numComps = t3;
          }
          getRgb(e3, t3) {
            const a3 = new Uint8ClampedArray(3);
            this.getRgbItem(e3, t3, a3, 0);
            return a3;
          }
          getRgbItem(e3, t3, a3, n2) {
            (0, r.unreachable)("Should not call ColorSpace.getRgbItem");
          }
          getRgbBuffer(e3, t3, a3, n2, i2, s2, o) {
            (0, r.unreachable)("Should not call ColorSpace.getRgbBuffer");
          }
          getOutputLength(e3, t3) {
            (0, r.unreachable)("Should not call ColorSpace.getOutputLength");
          }
          isPassthrough(e3) {
            return false;
          }
          isDefaultDecode(e3, t3) {
            return ColorSpace.isDefaultDecode(e3, this.numComps);
          }
          fillRgb(e3, t3, a3, r2, n2, i2, s2, o, c) {
            const l = t3 * a3;
            let h = null;
            const u = 1 << s2, d = a3 !== n2 || t3 !== r2;
            if (this.isPassthrough(s2)) h = o;
            else if (1 === this.numComps && l > u && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
              const t4 = s2 <= 8 ? new Uint8Array(u) : new Uint16Array(u);
              for (let e4 = 0; e4 < u; e4++) t4[e4] = e4;
              const a4 = new Uint8ClampedArray(3 * u);
              this.getRgbBuffer(t4, 0, u, a4, 0, s2, 0);
              if (d) {
                h = new Uint8Array(3 * l);
                let e4 = 0;
                for (let t5 = 0; t5 < l; ++t5) {
                  const r3 = 3 * o[t5];
                  h[e4++] = a4[r3];
                  h[e4++] = a4[r3 + 1];
                  h[e4++] = a4[r3 + 2];
                }
              } else {
                let t5 = 0;
                for (let r3 = 0; r3 < l; ++r3) {
                  const n3 = 3 * o[r3];
                  e3[t5++] = a4[n3];
                  e3[t5++] = a4[n3 + 1];
                  e3[t5++] = a4[n3 + 2];
                  t5 += c;
                }
              }
            } else if (d) {
              h = new Uint8ClampedArray(3 * l);
              this.getRgbBuffer(o, 0, l, h, 0, s2, 0);
            } else this.getRgbBuffer(o, 0, r2 * i2, e3, 0, s2, c);
            if (h) if (d) !function resizeRgbImage(e4, t4, a4, r3, n3, i3, s3) {
              s3 = 1 !== s3 ? 0 : s3;
              const o2 = a4 / n3, c2 = r3 / i3;
              let l2, h2 = 0;
              const u2 = new Uint16Array(n3), d2 = 3 * a4;
              for (let e5 = 0; e5 < n3; e5++) u2[e5] = 3 * Math.floor(e5 * o2);
              for (let a5 = 0; a5 < i3; a5++) {
                const r4 = Math.floor(a5 * c2) * d2;
                for (let a6 = 0; a6 < n3; a6++) {
                  l2 = r4 + u2[a6];
                  t4[h2++] = e4[l2++];
                  t4[h2++] = e4[l2++];
                  t4[h2++] = e4[l2++];
                  h2 += s3;
                }
              }
            }(h, e3, t3, a3, r2, n2, c);
            else {
              let t4 = 0, a4 = 0;
              for (let n3 = 0, s3 = r2 * i2; n3 < s3; n3++) {
                e3[t4++] = h[a4++];
                e3[t4++] = h[a4++];
                e3[t4++] = h[a4++];
                t4 += c;
              }
            }
          }
          get usesZeroToOneRange() {
            return (0, r.shadow)(this, "usesZeroToOneRange", true);
          }
          static _cache(e3, t3, a3, r2) {
            if (!a3) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
            if (!r2) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
            let i2, s2;
            if (e3 instanceof n.Ref) {
              s2 = e3;
              e3 = t3.fetch(e3);
            }
            e3 instanceof n.Name && (i2 = e3.name);
            (i2 || s2) && a3.set(i2, s2, r2);
          }
          static getCached(e3, t3, a3) {
            if (!a3) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
            if (e3 instanceof n.Ref) {
              const r2 = a3.getByRef(e3);
              if (r2) return r2;
              try {
                e3 = t3.fetch(e3);
              } catch (e4) {
                if (e4 instanceof s.MissingDataException) throw e4;
              }
            }
            if (e3 instanceof n.Name) {
              const t4 = a3.getByName(e3.name);
              if (t4) return t4;
            }
            return null;
          }
          static async parseAsync({ cs: e3, xref: t3, resources: a3 = null, pdfFunctionFactory: r2, localColorSpaceCache: n2 }) {
            const i2 = this._parse(e3, t3, a3, r2);
            this._cache(e3, t3, n2, i2);
            return i2;
          }
          static parse({ cs: e3, xref: t3, resources: a3 = null, pdfFunctionFactory: r2, localColorSpaceCache: n2 }) {
            const i2 = this.getCached(e3, t3, n2);
            if (i2) return i2;
            const s2 = this._parse(e3, t3, a3, r2);
            this._cache(e3, t3, n2, s2);
            return s2;
          }
          static _parse(e3, t3, a3 = null, i2) {
            if ((e3 = t3.fetchIfRef(e3)) instanceof n.Name) switch (e3.name) {
              case "G":
              case "DeviceGray":
                return this.singletons.gray;
              case "RGB":
              case "DeviceRGB":
                return this.singletons.rgb;
              case "CMYK":
              case "DeviceCMYK":
                return this.singletons.cmyk;
              case "Pattern":
                return new PatternCS(null);
              default:
                if (a3 instanceof n.Dict) {
                  const r2 = a3.get("ColorSpace");
                  if (r2 instanceof n.Dict) {
                    const s2 = r2.get(e3.name);
                    if (s2) {
                      if (s2 instanceof n.Name) return this._parse(s2, t3, a3, i2);
                      e3 = s2;
                      break;
                    }
                  }
                }
                throw new r.FormatError(`Unrecognized ColorSpace: ${e3.name}`);
            }
            if (Array.isArray(e3)) {
              const n2 = t3.fetchIfRef(e3[0]).name;
              let s2, o, c, l, h, u;
              switch (n2) {
                case "G":
                case "DeviceGray":
                  return this.singletons.gray;
                case "RGB":
                case "DeviceRGB":
                  return this.singletons.rgb;
                case "CMYK":
                case "DeviceCMYK":
                  return this.singletons.cmyk;
                case "CalGray":
                  s2 = t3.fetchIfRef(e3[1]);
                  l = s2.getArray("WhitePoint");
                  h = s2.getArray("BlackPoint");
                  u = s2.get("Gamma");
                  return new CalGrayCS(l, h, u);
                case "CalRGB":
                  s2 = t3.fetchIfRef(e3[1]);
                  l = s2.getArray("WhitePoint");
                  h = s2.getArray("BlackPoint");
                  u = s2.getArray("Gamma");
                  const d = s2.getArray("Matrix");
                  return new CalRGBCS(l, h, u, d);
                case "ICCBased":
                  const f = t3.fetchIfRef(e3[1]).dict;
                  o = f.get("N");
                  const g = f.get("Alternate");
                  if (g) {
                    const e4 = this._parse(g, t3, a3, i2);
                    if (e4.numComps === o) return e4;
                    (0, r.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                  }
                  if (1 === o) return this.singletons.gray;
                  if (3 === o) return this.singletons.rgb;
                  if (4 === o) return this.singletons.cmyk;
                  break;
                case "Pattern":
                  c = e3[1] || null;
                  c && (c = this._parse(c, t3, a3, i2));
                  return new PatternCS(c);
                case "I":
                case "Indexed":
                  c = this._parse(e3[1], t3, a3, i2);
                  const p = t3.fetchIfRef(e3[2]) + 1, m = t3.fetchIfRef(e3[3]);
                  return new IndexedCS(c, p, m);
                case "Separation":
                case "DeviceN":
                  const b = t3.fetchIfRef(e3[1]);
                  o = Array.isArray(b) ? b.length : 1;
                  c = this._parse(e3[2], t3, a3, i2);
                  const y = i2.create(e3[3]);
                  return new AlternateCS(o, c, y);
                case "Lab":
                  s2 = t3.fetchIfRef(e3[1]);
                  l = s2.getArray("WhitePoint");
                  h = s2.getArray("BlackPoint");
                  const w = s2.getArray("Range");
                  return new LabCS(l, h, w);
                default:
                  throw new r.FormatError(`Unimplemented ColorSpace object: ${n2}`);
              }
            }
            throw new r.FormatError(`Unrecognized ColorSpace object: ${e3}`);
          }
          static isDefaultDecode(e3, t3) {
            if (!Array.isArray(e3)) return true;
            if (2 * t3 !== e3.length) {
              (0, r.warn)("The decode map is not the correct length");
              return true;
            }
            for (let t4 = 0, a3 = e3.length; t4 < a3; t4 += 2) if (0 !== e3[t4] || 1 !== e3[t4 + 1]) return false;
            return true;
          }
          static get singletons() {
            return (0, r.shadow)(this, "singletons", { get gray() {
              return (0, r.shadow)(this, "gray", new DeviceGrayCS());
            }, get rgb() {
              return (0, r.shadow)(this, "rgb", new DeviceRgbCS());
            }, get cmyk() {
              return (0, r.shadow)(this, "cmyk", new DeviceCmykCS());
            } });
          }
        }
        t2.ColorSpace = ColorSpace;
        class AlternateCS extends ColorSpace {
          constructor(e3, t3, a3) {
            super("Alternate", e3);
            this.base = t3;
            this.tintFn = a3;
            this.tmpBuf = new Float32Array(t3.numComps);
          }
          getRgbItem(e3, t3, a3, r2) {
            const n2 = this.tmpBuf;
            this.tintFn(e3, t3, n2, 0);
            this.base.getRgbItem(n2, 0, a3, r2);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = this.tintFn, c = this.base, l = 1 / ((1 << i2) - 1), h = c.numComps, u = c.usesZeroToOneRange, d = (c.isPassthrough(8) || !u) && 0 === s2;
            let f = d ? n2 : 0;
            const g = d ? r2 : new Uint8ClampedArray(h * a3), p = this.numComps, m = new Float32Array(p), b = new Float32Array(h);
            let y, w;
            for (y = 0; y < a3; y++) {
              for (w = 0; w < p; w++) m[w] = e3[t3++] * l;
              o(m, 0, b, 0);
              if (u) for (w = 0; w < h; w++) g[f++] = 255 * b[w];
              else {
                c.getRgbItem(b, 0, g, f);
                f += h;
              }
            }
            d || c.getRgbBuffer(g, 0, a3, r2, n2, 8, s2);
          }
          getOutputLength(e3, t3) {
            return this.base.getOutputLength(e3 * this.base.numComps / this.numComps, t3);
          }
        }
        class PatternCS extends ColorSpace {
          constructor(e3) {
            super("Pattern", null);
            this.base = e3;
          }
          isDefaultDecode(e3, t3) {
            (0, r.unreachable)("Should not call PatternCS.isDefaultDecode");
          }
        }
        class IndexedCS extends ColorSpace {
          constructor(e3, t3, a3) {
            super("Indexed", 1);
            this.base = e3;
            this.highVal = t3;
            const n2 = e3.numComps * t3;
            this.lookup = new Uint8Array(n2);
            if (a3 instanceof i.BaseStream) {
              const e4 = a3.getBytes(n2);
              this.lookup.set(e4);
            } else {
              if ("string" != typeof a3) throw new r.FormatError(`IndexedCS - unrecognized lookup table: ${a3}`);
              for (let e4 = 0; e4 < n2; ++e4) this.lookup[e4] = 255 & a3.charCodeAt(e4);
            }
          }
          getRgbItem(e3, t3, a3, r2) {
            const n2 = this.base.numComps, i2 = e3[t3] * n2;
            this.base.getRgbBuffer(this.lookup, i2, 1, a3, r2, 8, 0);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = this.base, c = o.numComps, l = o.getOutputLength(c, s2), h = this.lookup;
            for (let i3 = 0; i3 < a3; ++i3) {
              const a4 = e3[t3++] * c;
              o.getRgbBuffer(h, a4, 1, r2, n2, 8, s2);
              n2 += l;
            }
          }
          getOutputLength(e3, t3) {
            return this.base.getOutputLength(e3 * this.base.numComps, t3);
          }
          isDefaultDecode(e3, t3) {
            if (!Array.isArray(e3)) return true;
            if (2 !== e3.length) {
              (0, r.warn)("Decode map length is not correct");
              return true;
            }
            if (!Number.isInteger(t3) || t3 < 1) {
              (0, r.warn)("Bits per component is not correct");
              return true;
            }
            return 0 === e3[0] && e3[1] === (1 << t3) - 1;
          }
        }
        class DeviceGrayCS extends ColorSpace {
          constructor() {
            super("DeviceGray", 1);
          }
          getRgbItem(e3, t3, a3, r2) {
            const n2 = 255 * e3[t3];
            a3[r2] = a3[r2 + 1] = a3[r2 + 2] = n2;
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = 255 / ((1 << i2) - 1);
            let c = t3, l = n2;
            for (let t4 = 0; t4 < a3; ++t4) {
              const t5 = o * e3[c++];
              r2[l++] = t5;
              r2[l++] = t5;
              r2[l++] = t5;
              l += s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 * (3 + t3);
          }
        }
        class DeviceRgbCS extends ColorSpace {
          constructor() {
            super("DeviceRGB", 3);
          }
          getRgbItem(e3, t3, a3, r2) {
            a3[r2] = 255 * e3[t3];
            a3[r2 + 1] = 255 * e3[t3 + 1];
            a3[r2 + 2] = 255 * e3[t3 + 2];
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            if (8 === i2 && 0 === s2) {
              r2.set(e3.subarray(t3, t3 + 3 * a3), n2);
              return;
            }
            const o = 255 / ((1 << i2) - 1);
            let c = t3, l = n2;
            for (let t4 = 0; t4 < a3; ++t4) {
              r2[l++] = o * e3[c++];
              r2[l++] = o * e3[c++];
              r2[l++] = o * e3[c++];
              l += s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 * (3 + t3) / 3 | 0;
          }
          isPassthrough(e3) {
            return 8 === e3;
          }
        }
        class DeviceCmykCS extends ColorSpace {
          constructor() {
            super("DeviceCMYK", 4);
            __privateAdd(this, _DeviceCmykCS_instances);
          }
          getRgbItem(e3, t3, a3, r2) {
            __privateMethod(this, _DeviceCmykCS_instances, r_fn).call(this, e3, t3, 1, a3, r2);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = 1 / ((1 << i2) - 1);
            for (let i3 = 0; i3 < a3; i3++) {
              __privateMethod(this, _DeviceCmykCS_instances, r_fn).call(this, e3, t3, o, r2, n2);
              t3 += 4;
              n2 += 3 + s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 / 4 * (3 + t3) | 0;
          }
        }
        _DeviceCmykCS_instances = new WeakSet();
        r_fn = function(e3, t3, a3, r2, n2) {
          const i2 = e3[t3] * a3, s2 = e3[t3 + 1] * a3, o = e3[t3 + 2] * a3, c = e3[t3 + 3] * a3;
          r2[n2] = 255 + i2 * (-4.387332384609988 * i2 + 54.48615194189176 * s2 + 18.82290502165302 * o + 212.25662451639585 * c - 285.2331026137004) + s2 * (1.7149763477362134 * s2 - 5.6096736904047315 * o + -17.873870861415444 * c - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * c + 17.5119270841813) + c * (-21.86122147463605 * c - 189.48180835922747);
          r2[n2 + 1] = 255 + i2 * (8.841041422036149 * i2 + 60.118027045597366 * s2 + 6.871425592049007 * o + 31.159100130055922 * c - 79.2970844816548) + s2 * (-15.310361306967817 * s2 + 17.575251261109482 * o + 131.35250912493976 * c - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * c - 24.86741582555878) + c * (-20.737325471181034 * c - 187.80453709719578);
          r2[n2 + 2] = 255 + i2 * (0.8842522430003296 * i2 + 8.078677503112928 * s2 + 30.89978309703729 * o - 0.23883238689178934 * c - 14.183576799673286) + s2 * (10.49593273432072 * s2 + 63.02378494754052 * o + 50.606957656360734 * c - 112.23884253719248) + o * (0.03296041114873217 * o + 115.60384449646641 * c - 193.58209356861505) + c * (-22.33816807309886 * c - 180.12613974708367);
        };
        class CalGrayCS extends ColorSpace {
          constructor(e3, t3, a3) {
            super("CalGray", 1);
            __privateAdd(this, _CalGrayCS_instances);
            if (!e3) throw new r.FormatError("WhitePoint missing - required for color space CalGray");
            [this.XW, this.YW, this.ZW] = e3;
            [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0];
            this.G = a3 || 1;
            if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new r.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
              (0, r.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`);
              this.XB = this.YB = this.ZB = 0;
            }
            0 === this.XB && 0 === this.YB && 0 === this.ZB || (0, r.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
            if (this.G < 1) {
              (0, r.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
              this.G = 1;
            }
          }
          getRgbItem(e3, t3, a3, r2) {
            __privateMethod(this, _CalGrayCS_instances, r_fn2).call(this, e3, t3, a3, r2, 1);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = 1 / ((1 << i2) - 1);
            for (let i3 = 0; i3 < a3; ++i3) {
              __privateMethod(this, _CalGrayCS_instances, r_fn2).call(this, e3, t3, r2, n2, o);
              t3 += 1;
              n2 += 3 + s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 * (3 + t3);
          }
        }
        _CalGrayCS_instances = new WeakSet();
        r_fn2 = function(e3, t3, a3, r2, n2) {
          const i2 = (e3[t3] * n2) ** this.G, s2 = this.YW * i2, o = Math.max(295.8 * s2 ** 0.3333333333333333 - 40.8, 0);
          a3[r2] = o;
          a3[r2 + 1] = o;
          a3[r2 + 2] = o;
        };
        const _CalRGBCS = class _CalRGBCS extends ColorSpace {
          constructor(e3, t3, a3, n2) {
            super("CalRGB", 3);
            __privateAdd(this, _CalRGBCS_instances);
            if (!e3) throw new r.FormatError("WhitePoint missing - required for color space CalRGB");
            const [i2, s2, o] = this.whitePoint = e3, [c, l, h] = this.blackPoint = t3 || new Float32Array(3);
            [this.GR, this.GG, this.GB] = a3 || new Float32Array([1, 1, 1]);
            [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = n2 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            if (i2 < 0 || o < 0 || 1 !== s2) throw new r.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
            if (c < 0 || l < 0 || h < 0) {
              (0, r.info)(`Invalid BlackPoint for ${this.name} [${c}, ${l}, ${h}], falling back to default.`);
              this.blackPoint = new Float32Array(3);
            }
            if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
              (0, r.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
              this.GR = this.GG = this.GB = 1;
            }
          }
          getRgbItem(e3, t3, a3, r2) {
            __privateMethod(this, _CalRGBCS_instances, r_fn3).call(this, e3, t3, a3, r2, 1);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = 1 / ((1 << i2) - 1);
            for (let i3 = 0; i3 < a3; ++i3) {
              __privateMethod(this, _CalRGBCS_instances, r_fn3).call(this, e3, t3, r2, n2, o);
              t3 += 3;
              n2 += 3 + s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 * (3 + t3) / 3 | 0;
          }
        };
        _n = new WeakMap();
        _i = new WeakMap();
        _s = new WeakMap();
        _o = new WeakMap();
        _c = new WeakMap();
        _l = new WeakMap();
        _h = new WeakMap();
        _u = new WeakMap();
        _CalRGBCS_instances = new WeakSet();
        d_fn = function(e3, t3, a3) {
          a3[0] = e3[0] * t3[0] + e3[1] * t3[1] + e3[2] * t3[2];
          a3[1] = e3[3] * t3[0] + e3[4] * t3[1] + e3[5] * t3[2];
          a3[2] = e3[6] * t3[0] + e3[7] * t3[1] + e3[8] * t3[2];
        };
        f_fn = function(e3, t3, a3) {
          a3[0] = 1 * t3[0] / e3[0];
          a3[1] = 1 * t3[1] / e3[1];
          a3[2] = 1 * t3[2] / e3[2];
        };
        g_fn = function(e3, t3, a3) {
          a3[0] = 0.95047 * t3[0] / e3[0];
          a3[1] = 1 * t3[1] / e3[1];
          a3[2] = 1.08883 * t3[2] / e3[2];
        };
        p_fn = function(e3) {
          return e3 <= 31308e-7 ? __privateMethod(this, _CalRGBCS_instances, m_fn).call(this, 0, 1, 12.92 * e3) : e3 >= 0.99554525 ? 1 : __privateMethod(this, _CalRGBCS_instances, m_fn).call(this, 0, 1, 1.055 * e3 ** (1 / 2.4) - 0.055);
        };
        m_fn = function(e3, t3, a3) {
          return Math.max(e3, Math.min(t3, a3));
        };
        b_fn = function(e3) {
          return e3 < 0 ? -__privateMethod(this, _CalRGBCS_instances, b_fn).call(this, -e3) : e3 > 8 ? ((e3 + 16) / 116) ** 3 : e3 * __privateGet(_CalRGBCS, _u);
        };
        y_fn = function(e3, t3, a3) {
          if (0 === e3[0] && 0 === e3[1] && 0 === e3[2]) {
            a3[0] = t3[0];
            a3[1] = t3[1];
            a3[2] = t3[2];
            return;
          }
          const r2 = __privateMethod(this, _CalRGBCS_instances, b_fn).call(this, 0), n2 = (1 - r2) / (1 - __privateMethod(this, _CalRGBCS_instances, b_fn).call(this, e3[0])), i2 = 1 - n2, s2 = (1 - r2) / (1 - __privateMethod(this, _CalRGBCS_instances, b_fn).call(this, e3[1])), o = 1 - s2, c = (1 - r2) / (1 - __privateMethod(this, _CalRGBCS_instances, b_fn).call(this, e3[2])), l = 1 - c;
          a3[0] = t3[0] * n2 + i2;
          a3[1] = t3[1] * s2 + o;
          a3[2] = t3[2] * c + l;
        };
        w_fn = function(e3, t3, a3) {
          if (1 === e3[0] && 1 === e3[2]) {
            a3[0] = t3[0];
            a3[1] = t3[1];
            a3[2] = t3[2];
            return;
          }
          const r2 = a3;
          __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _n), t3, r2);
          const n2 = __privateGet(_CalRGBCS, _c);
          __privateMethod(this, _CalRGBCS_instances, f_fn).call(this, e3, r2, n2);
          __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _i), n2, a3);
        };
        S_fn = function(e3, t3, a3) {
          const r2 = a3;
          __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _n), t3, r2);
          const n2 = __privateGet(_CalRGBCS, _c);
          __privateMethod(this, _CalRGBCS_instances, g_fn).call(this, e3, r2, n2);
          __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _i), n2, a3);
        };
        r_fn3 = function(e3, t3, a3, r2, n2) {
          const i2 = __privateMethod(this, _CalRGBCS_instances, m_fn).call(this, 0, 1, e3[t3] * n2), s2 = __privateMethod(this, _CalRGBCS_instances, m_fn).call(this, 0, 1, e3[t3 + 1] * n2), o = __privateMethod(this, _CalRGBCS_instances, m_fn).call(this, 0, 1, e3[t3 + 2] * n2), c = 1 === i2 ? 1 : i2 ** this.GR, l = 1 === s2 ? 1 : s2 ** this.GG, h = 1 === o ? 1 : o ** this.GB, u = this.MXA * c + this.MXB * l + this.MXC * h, d = this.MYA * c + this.MYB * l + this.MYC * h, f = this.MZA * c + this.MZB * l + this.MZC * h, g = __privateGet(_CalRGBCS, _l);
          g[0] = u;
          g[1] = d;
          g[2] = f;
          const p = __privateGet(_CalRGBCS, _h);
          __privateMethod(this, _CalRGBCS_instances, w_fn).call(this, this.whitePoint, g, p);
          const m = __privateGet(_CalRGBCS, _l);
          __privateMethod(this, _CalRGBCS_instances, y_fn).call(this, this.blackPoint, p, m);
          const b = __privateGet(_CalRGBCS, _h);
          __privateMethod(this, _CalRGBCS_instances, S_fn).call(this, __privateGet(_CalRGBCS, _o), m, b);
          const y = __privateGet(_CalRGBCS, _l);
          __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _s), b, y);
          a3[r2] = 255 * __privateMethod(this, _CalRGBCS_instances, p_fn).call(this, y[0]);
          a3[r2 + 1] = 255 * __privateMethod(this, _CalRGBCS_instances, p_fn).call(this, y[1]);
          a3[r2 + 2] = 255 * __privateMethod(this, _CalRGBCS_instances, p_fn).call(this, y[2]);
        };
        __privateAdd(_CalRGBCS, _n, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]));
        __privateAdd(_CalRGBCS, _i, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]));
        __privateAdd(_CalRGBCS, _s, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]));
        __privateAdd(_CalRGBCS, _o, new Float32Array([1, 1, 1]));
        __privateAdd(_CalRGBCS, _c, new Float32Array(3));
        __privateAdd(_CalRGBCS, _l, new Float32Array(3));
        __privateAdd(_CalRGBCS, _h, new Float32Array(3));
        __privateAdd(_CalRGBCS, _u, (24 / 116) ** 3 / 8);
        let CalRGBCS = _CalRGBCS;
        class LabCS extends ColorSpace {
          constructor(e3, t3, a3) {
            super("Lab", 3);
            __privateAdd(this, _LabCS_instances);
            if (!e3) throw new r.FormatError("WhitePoint missing - required for color space Lab");
            [this.XW, this.YW, this.ZW] = e3;
            [this.amin, this.amax, this.bmin, this.bmax] = a3 || [-100, 100, -100, 100];
            [this.XB, this.YB, this.ZB] = t3 || [0, 0, 0];
            if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new r.FormatError("Invalid WhitePoint components, no fallback available");
            if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
              (0, r.info)("Invalid BlackPoint, falling back to default");
              this.XB = this.YB = this.ZB = 0;
            }
            if (this.amin > this.amax || this.bmin > this.bmax) {
              (0, r.info)("Invalid Range, falling back to defaults");
              this.amin = -100;
              this.amax = 100;
              this.bmin = -100;
              this.bmax = 100;
            }
          }
          getRgbItem(e3, t3, a3, r2) {
            __privateMethod(this, _LabCS_instances, r_fn4).call(this, e3, t3, false, a3, r2);
          }
          getRgbBuffer(e3, t3, a3, r2, n2, i2, s2) {
            const o = (1 << i2) - 1;
            for (let i3 = 0; i3 < a3; i3++) {
              __privateMethod(this, _LabCS_instances, r_fn4).call(this, e3, t3, o, r2, n2);
              t3 += 3;
              n2 += 3 + s2;
            }
          }
          getOutputLength(e3, t3) {
            return e3 * (3 + t3) / 3 | 0;
          }
          isDefaultDecode(e3, t3) {
            return true;
          }
          get usesZeroToOneRange() {
            return (0, r.shadow)(this, "usesZeroToOneRange", false);
          }
        }
        _LabCS_instances = new WeakSet();
        x_fn = function(e3) {
          return e3 >= 6 / 29 ? e3 ** 3 : 108 / 841 * (e3 - 4 / 29);
        };
        A_fn = function(e3, t3, a3, r2) {
          return a3 + e3 * (r2 - a3) / t3;
        };
        r_fn4 = function(e3, t3, a3, r2, n2) {
          let i2 = e3[t3], s2 = e3[t3 + 1], o = e3[t3 + 2];
          if (false !== a3) {
            i2 = __privateMethod(this, _LabCS_instances, A_fn).call(this, i2, a3, 0, 100);
            s2 = __privateMethod(this, _LabCS_instances, A_fn).call(this, s2, a3, this.amin, this.amax);
            o = __privateMethod(this, _LabCS_instances, A_fn).call(this, o, a3, this.bmin, this.bmax);
          }
          s2 > this.amax ? s2 = this.amax : s2 < this.amin && (s2 = this.amin);
          o > this.bmax ? o = this.bmax : o < this.bmin && (o = this.bmin);
          const c = (i2 + 16) / 116, l = c + s2 / 500, h = c - o / 200, u = this.XW * __privateMethod(this, _LabCS_instances, x_fn).call(this, l), d = this.YW * __privateMethod(this, _LabCS_instances, x_fn).call(this, c), f = this.ZW * __privateMethod(this, _LabCS_instances, x_fn).call(this, h);
          let g, p, m;
          if (this.ZW < 1) {
            g = 3.1339 * u + -1.617 * d + -0.4906 * f;
            p = -0.9785 * u + 1.916 * d + 0.0333 * f;
            m = 0.072 * u + -0.229 * d + 1.4057 * f;
          } else {
            g = 3.2406 * u + -1.5372 * d + -0.4986 * f;
            p = -0.9689 * u + 1.8758 * d + 0.0415 * f;
            m = 0.0557 * u + -0.204 * d + 1.057 * f;
          }
          r2[n2] = 255 * Math.sqrt(g);
          r2[n2 + 1] = 255 * Math.sqrt(p);
          r2[n2 + 2] = 255 * Math.sqrt(m);
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PartialEvaluator = t2.EvaluatorPreprocessor = void 0;
        var r = a2(2), n = a2(14), i = a2(4), s = a2(34), o = a2(37), c = a2(41), l = a2(50), h = a2(51), u = a2(42), d = a2(57), f = a2(16), g = a2(59), p = a2(8), m = a2(5), b = a2(60), y = a2(12), w = a2(18), S = a2(38), x = a2(61), C = a2(39), k = a2(45), v = a2(40), F = a2(62), O = a2(63), T = a2(64), M = a2(65);
        const D = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, cMapUrl: null, standardFontDataUrl: null }), E = 1, N = 2, R = Promise.resolve();
        function normalizeBlendMode(e3, t3 = false) {
          if (Array.isArray(e3)) {
            for (const t4 of e3) {
              const e4 = normalizeBlendMode(t4, true);
              if (e4) return e4;
            }
            (0, r.warn)(`Unsupported blend mode Array: ${e3}`);
            return "source-over";
          }
          if (!(e3 instanceof i.Name)) return t3 ? null : "source-over";
          switch (e3.name) {
            case "Normal":
            case "Compatible":
              return "source-over";
            case "Multiply":
              return "multiply";
            case "Screen":
              return "screen";
            case "Overlay":
              return "overlay";
            case "Darken":
              return "darken";
            case "Lighten":
              return "lighten";
            case "ColorDodge":
              return "color-dodge";
            case "ColorBurn":
              return "color-burn";
            case "HardLight":
              return "hard-light";
            case "SoftLight":
              return "soft-light";
            case "Difference":
              return "difference";
            case "Exclusion":
              return "exclusion";
            case "Hue":
              return "hue";
            case "Saturation":
              return "saturation";
            case "Color":
              return "color";
            case "Luminosity":
              return "luminosity";
          }
          if (t3) return null;
          (0, r.warn)(`Unsupported blend mode: ${e3.name}`);
          return "source-over";
        }
        function incrementCachedImageMaskCount(e3) {
          var _a;
          e3.fn === r.OPS.paintImageMaskXObject && ((_a = e3.args[0]) == null ? void 0 : _a.count) > 0 && e3.args[0].count++;
        }
        const _TimeSlotManager = class _TimeSlotManager {
          constructor() {
            this.reset();
          }
          check() {
            if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) return false;
            this.checked = 0;
            return this.endTime <= Date.now();
          }
          reset() {
            this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
            this.checked = 0;
          }
        };
        __publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
        __publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
        let TimeSlotManager = _TimeSlotManager;
        class PartialEvaluator {
          constructor({ xref: e3, handler: t3, pageIndex: a3, idFactory: r2, fontCache: n2, builtInCMapCache: i2, standardFontDataCache: s2, globalImageCache: o2, systemFontCache: c2, options: l2 = null }) {
            this.xref = e3;
            this.handler = t3;
            this.pageIndex = a3;
            this.idFactory = r2;
            this.fontCache = n2;
            this.builtInCMapCache = i2;
            this.standardFontDataCache = s2;
            this.globalImageCache = o2;
            this.systemFontCache = c2;
            this.options = l2 || D;
            this.parsingType3Font = false;
            this._regionalImageCache = new g.RegionalImageCache();
            this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
            F.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
          }
          get _pdfFunctionFactory() {
            const e3 = new d.PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported });
            return (0, r.shadow)(this, "_pdfFunctionFactory", e3);
          }
          clone(e3 = null) {
            const t3 = Object.create(this);
            t3.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e3);
            return t3;
          }
          hasBlendModes(e3, t3) {
            if (!(e3 instanceof i.Dict)) return false;
            if (e3.objId && t3.has(e3.objId)) return false;
            const a3 = new i.RefSet(t3);
            e3.objId && a3.put(e3.objId);
            const n2 = [e3], s2 = this.xref;
            for (; n2.length; ) {
              const e4 = n2.shift(), t4 = e4.get("ExtGState");
              if (t4 instanceof i.Dict) for (let e5 of t4.getRawValues()) {
                if (e5 instanceof i.Ref) {
                  if (a3.has(e5)) continue;
                  try {
                    e5 = s2.fetch(e5);
                  } catch (t6) {
                    a3.put(e5);
                    (0, r.info)(`hasBlendModes - ignoring ExtGState: "${t6}".`);
                    continue;
                  }
                }
                if (!(e5 instanceof i.Dict)) continue;
                e5.objId && a3.put(e5.objId);
                const t5 = e5.get("BM");
                if (t5 instanceof i.Name) {
                  if ("Normal" !== t5.name) return true;
                } else if (void 0 !== t5 && Array.isArray(t5)) {
                  for (const e6 of t5) if (e6 instanceof i.Name && "Normal" !== e6.name) return true;
                }
              }
              const o2 = e4.get("XObject");
              if (o2 instanceof i.Dict) for (let e5 of o2.getRawValues()) {
                if (e5 instanceof i.Ref) {
                  if (a3.has(e5)) continue;
                  try {
                    e5 = s2.fetch(e5);
                  } catch (t6) {
                    a3.put(e5);
                    (0, r.info)(`hasBlendModes - ignoring XObject: "${t6}".`);
                    continue;
                  }
                }
                if (!(e5 instanceof m.BaseStream)) continue;
                e5.dict.objId && a3.put(e5.dict.objId);
                const t5 = e5.dict.get("Resources");
                if (t5 instanceof i.Dict && (!t5.objId || !a3.has(t5.objId))) {
                  n2.push(t5);
                  t5.objId && a3.put(t5.objId);
                }
              }
            }
            for (const e4 of a3) t3.put(e4);
            return false;
          }
          async fetchBuiltInCMap(e3) {
            const t3 = this.builtInCMapCache.get(e3);
            if (t3) return t3;
            let a3;
            if (null !== this.options.cMapUrl) {
              const t4 = `${this.options.cMapUrl}${e3}.bcmap`, n2 = await fetch(t4);
              if (!n2.ok) throw new Error(`fetchBuiltInCMap: failed to fetch file "${t4}" with "${n2.statusText}".`);
              a3 = { cMapData: new Uint8Array(await n2.arrayBuffer()), compressionType: r.CMapCompressionType.BINARY };
            } else a3 = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: e3 });
            a3.compressionType !== r.CMapCompressionType.NONE && this.builtInCMapCache.set(e3, a3);
            return a3;
          }
          async fetchStandardFontData(e3) {
            const t3 = this.standardFontDataCache.get(e3);
            if (t3) return new p.Stream(t3);
            if (this.options.useSystemFonts && "Symbol" !== e3 && "ZapfDingbats" !== e3) return null;
            const a3 = (0, c.getFontNameToFileMap)()[e3];
            let n2;
            if (null !== this.options.standardFontDataUrl) {
              const e4 = `${this.options.standardFontDataUrl}${a3}`, t4 = await fetch(e4);
              t4.ok ? n2 = await t4.arrayBuffer() : (0, r.warn)(`fetchStandardFontData: failed to fetch file "${e4}" with "${t4.statusText}".`);
            } else try {
              n2 = await this.handler.sendWithPromise("FetchStandardFontData", { filename: a3 });
            } catch (e4) {
              (0, r.warn)(`fetchStandardFontData: failed to fetch file "${a3}" with "${e4}".`);
            }
            if (!n2) return null;
            this.standardFontDataCache.set(e3, n2);
            return new p.Stream(n2);
          }
          async buildFormXObject(e3, t3, a3, n2, s2, o2, c2) {
            const l2 = t3.dict, h2 = l2.getArray("Matrix");
            let u2, d2, f2 = l2.getArray("BBox");
            f2 = Array.isArray(f2) && 4 === f2.length ? r.Util.normalizeRect(f2) : null;
            l2.has("OC") && (u2 = await this.parseMarkedContentProps(l2.get("OC"), e3));
            void 0 !== u2 && n2.addOp(r.OPS.beginMarkedContentProps, ["OC", u2]);
            const g2 = l2.get("Group");
            if (g2) {
              d2 = { matrix: h2, bbox: f2, smask: a3, isolated: false, knockout: false };
              const t4 = g2.get("S");
              let s3 = null;
              if ((0, i.isName)(t4, "Transparency")) {
                d2.isolated = g2.get("I") || false;
                d2.knockout = g2.get("K") || false;
                if (g2.has("CS")) {
                  const t5 = g2.getRaw("CS"), a4 = y.ColorSpace.getCached(t5, this.xref, c2);
                  s3 = a4 || await this.parseColorSpace({ cs: t5, resources: e3, localColorSpaceCache: c2 });
                }
              }
              if (a3 == null ? void 0 : a3.backdrop) {
                s3 || (s3 = y.ColorSpace.singletons.rgb);
                a3.backdrop = s3.getRgb(a3.backdrop, 0);
              }
              n2.addOp(r.OPS.beginGroup, [d2]);
            }
            const p2 = g2 ? [h2, null] : [h2, f2];
            n2.addOp(r.OPS.paintFormXObjectBegin, p2);
            return this.getOperatorList({ stream: t3, task: s2, resources: l2.get("Resources") || e3, operatorList: n2, initialState: o2 }).then(function() {
              n2.addOp(r.OPS.paintFormXObjectEnd, []);
              g2 && n2.addOp(r.OPS.endGroup, [d2]);
              void 0 !== u2 && n2.addOp(r.OPS.endMarkedContent, []);
            });
          }
          _sendImgData(e3, t3, a3 = false) {
            const r2 = t3 ? [t3.bitmap || t3.data.buffer] : null;
            return this.parsingType3Font || a3 ? this.handler.send("commonobj", [e3, "Image", t3], r2) : this.handler.send("obj", [e3, this.pageIndex, "Image", t3], r2);
          }
          async buildPaintImageXObject({ resources: e3, image: t3, isInline: a3 = false, operatorList: n2, cacheKey: i2, localImageCache: s2, localColorSpaceCache: o2 }) {
            const c2 = t3.dict, l2 = c2.objId, h2 = c2.get("W", "Width"), u2 = c2.get("H", "Height");
            if (!h2 || "number" != typeof h2 || !u2 || "number" != typeof u2) {
              (0, r.warn)("Image dimensions are missing, or not numbers.");
              return;
            }
            const d2 = this.options.maxImageSize;
            if (-1 !== d2 && h2 * u2 > d2) {
              const e4 = "Image exceeded maximum allowed size and was removed.";
              if (this.options.ignoreErrors) {
                (0, r.warn)(e4);
                return;
              }
              throw new Error(e4);
            }
            let f2;
            c2.has("OC") && (f2 = await this.parseMarkedContentProps(c2.get("OC"), e3));
            let g2, p2;
            if (c2.get("IM", "ImageMask") || false) {
              const e4 = c2.get("I", "Interpolate"), a4 = h2 + 7 >> 3, o3 = t3.getBytes(a4 * u2), d3 = c2.getArray("D", "Decode");
              if (this.parsingType3Font) {
                g2 = M.PDFImage.createRawMask({ imgArray: o3, width: h2, height: u2, imageIsFromDecodeStream: t3 instanceof w.DecodeStream, inverseDecode: (d3 == null ? void 0 : d3[0]) > 0, interpolate: e4 });
                g2.cached = !!i2;
                p2 = [g2];
                n2.addImageOps(r.OPS.paintImageMaskXObject, p2, f2);
                if (i2) {
                  const e5 = { fn: r.OPS.paintImageMaskXObject, args: p2, optionalContent: f2 };
                  s2.set(i2, l2, e5);
                  l2 && this._regionalImageCache.set(null, l2, e5);
                }
                return;
              }
              g2 = await M.PDFImage.createMask({ imgArray: o3, width: h2, height: u2, imageIsFromDecodeStream: t3 instanceof w.DecodeStream, inverseDecode: (d3 == null ? void 0 : d3[0]) > 0, interpolate: e4, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported });
              if (g2.isSingleOpaquePixel) {
                n2.addImageOps(r.OPS.paintSolidColorImageMask, [], f2);
                if (i2) {
                  const e5 = { fn: r.OPS.paintSolidColorImageMask, args: [], optionalContent: f2 };
                  s2.set(i2, l2, e5);
                  l2 && this._regionalImageCache.set(null, l2, e5);
                }
                return;
              }
              const m3 = `mask_${this.idFactory.createObjId()}`;
              n2.addDependency(m3);
              this._sendImgData(m3, g2);
              p2 = [{ data: m3, width: g2.width, height: g2.height, interpolate: g2.interpolate, count: 1 }];
              n2.addImageOps(r.OPS.paintImageMaskXObject, p2, f2);
              if (i2) {
                const e5 = { fn: r.OPS.paintImageMaskXObject, args: p2, optionalContent: f2 };
                s2.set(i2, l2, e5);
                l2 && this._regionalImageCache.set(null, l2, e5);
              }
              return;
            }
            if (a3 && !c2.has("SMask") && !c2.has("Mask") && h2 + u2 < 200) {
              const i3 = new M.PDFImage({ xref: this.xref, res: e3, image: t3, isInline: a3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: o2 });
              g2 = await i3.createImageData(true, false);
              n2.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
              n2.addImageOps(r.OPS.paintInlineImageXObject, [g2], f2);
              return;
            }
            let m2 = `img_${this.idFactory.createObjId()}`, b2 = false;
            if (this.parsingType3Font) m2 = `${this.idFactory.getDocId()}_type3_${m2}`;
            else if (l2) {
              b2 = this.globalImageCache.shouldCache(l2, this.pageIndex);
              b2 && (m2 = `${this.idFactory.getDocId()}_${m2}`);
            }
            n2.addDependency(m2);
            p2 = [m2, h2, u2];
            M.PDFImage.buildImage({ xref: this.xref, res: e3, image: t3, isInline: a3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: o2 }).then(async (e4) => {
              g2 = await e4.createImageData(false, this.options.isOffscreenCanvasSupported);
              if (i2 && l2 && b2) {
                const e5 = g2.bitmap ? g2.width * g2.height * 4 : g2.data.length;
                this.globalImageCache.addByteSize(l2, e5);
              }
              return this._sendImgData(m2, g2, b2);
            }).catch((e4) => {
              (0, r.warn)(`Unable to decode image "${m2}": "${e4}".`);
              return this._sendImgData(m2, null, b2);
            });
            n2.addImageOps(r.OPS.paintImageXObject, p2, f2);
            if (i2) {
              const e4 = { fn: r.OPS.paintImageXObject, args: p2, optionalContent: f2 };
              s2.set(i2, l2, e4);
              if (l2) {
                this._regionalImageCache.set(null, l2, e4);
                if (b2) {
                  (0, r.assert)(!a3, "Cannot cache an inline image globally.");
                  this.globalImageCache.setData(l2, { objId: m2, fn: r.OPS.paintImageXObject, args: p2, optionalContent: f2, byteSize: 0 });
                }
              }
            }
          }
          handleSMask(e3, t3, a3, r2, n2, i2) {
            const s2 = e3.get("G"), o2 = { subtype: e3.get("S").name, backdrop: e3.get("BC") }, c2 = e3.get("TR");
            if ((0, d.isPDFFunction)(c2)) {
              const e4 = this._pdfFunctionFactory.create(c2), t4 = new Uint8Array(256), a4 = new Float32Array(1);
              for (let r3 = 0; r3 < 256; r3++) {
                a4[0] = r3 / 255;
                e4(a4, 0, a4, 0);
                t4[r3] = 255 * a4[0] | 0;
              }
              o2.transferMap = t4;
            }
            return this.buildFormXObject(t3, s2, o2, a3, r2, n2.state.clone(), i2);
          }
          handleTransferFunction(e3) {
            let t3;
            if (Array.isArray(e3)) t3 = e3;
            else {
              if (!(0, d.isPDFFunction)(e3)) return null;
              t3 = [e3];
            }
            const a3 = [];
            let r2 = 0, n2 = 0;
            for (const e4 of t3) {
              const t4 = this.xref.fetchIfRef(e4);
              r2++;
              if ((0, i.isName)(t4, "Identity")) {
                a3.push(null);
                continue;
              }
              if (!(0, d.isPDFFunction)(t4)) return null;
              const s2 = this._pdfFunctionFactory.create(t4), o2 = new Uint8Array(256), c2 = new Float32Array(1);
              for (let e5 = 0; e5 < 256; e5++) {
                c2[0] = e5 / 255;
                s2(c2, 0, c2, 0);
                o2[e5] = 255 * c2[0] | 0;
              }
              a3.push(o2);
              n2++;
            }
            return 1 !== r2 && 4 !== r2 || 0 === n2 ? null : a3;
          }
          handleTilingType(e3, t3, a3, n2, s2, o2, c2, h2) {
            const u2 = new T.OperatorList(), d2 = i.Dict.merge({ xref: this.xref, dictArray: [s2.get("Resources"), a3] });
            return this.getOperatorList({ stream: n2, task: c2, resources: d2, operatorList: u2 }).then(function() {
              const a4 = u2.getIR(), r2 = (0, l.getTilingPatternIR)(a4, s2, t3);
              o2.addDependencies(u2.dependencies);
              o2.addOp(e3, r2);
              s2.objId && h2.set(null, s2.objId, { operatorListIR: a4, dict: s2 });
            }).catch((e4) => {
              if (!(e4 instanceof r.AbortException)) {
                if (!this.options.ignoreErrors) throw e4;
                (0, r.warn)(`handleTilingType - ignoring pattern: "${e4}".`);
              }
            });
          }
          handleSetFont(e3, t3, a3, r2, n2, o2, c2 = null, l2 = null) {
            const h2 = (t3 == null ? void 0 : t3[0]) instanceof i.Name ? t3[0].name : null;
            return this.loadFont(h2, a3, e3, c2, l2).then((t4) => t4.font.isType3Font ? t4.loadType3Data(this, e3, n2).then(function() {
              r2.addDependencies(t4.type3Dependencies);
              return t4;
            }).catch((e4) => new TranslatedFont({ loadedName: "g_font_error", font: new s.ErrorFont(`Type3 font load error: ${e4}`), dict: t4.font, evaluatorOptions: this.options })) : t4).then((e4) => {
              o2.font = e4.font;
              e4.send(this.handler);
              return e4.loadedName;
            });
          }
          handleText(e3, t3) {
            const a3 = t3.font, n2 = a3.charsToGlyphs(e3);
            if (a3.data) {
              (!!(t3.textRenderingMode & r.TextRenderingMode.ADD_TO_PATH_FLAG) || "Pattern" === t3.fillColorSpace.name || a3.disableFontFace || this.options.disableFontFace) && PartialEvaluator.buildFontPaths(a3, n2, this.handler, this.options);
            }
            return n2;
          }
          ensureStateFont(e3) {
            if (e3.font) return;
            const t3 = new r.FormatError("Missing setFont (Tf) operator before text rendering operator.");
            if (!this.options.ignoreErrors) throw t3;
            (0, r.warn)(`ensureStateFont: "${t3}".`);
          }
          async setGState({ resources: e3, gState: t3, operatorList: a3, cacheKey: n2, task: s2, stateManager: o2, localGStateCache: c2, localColorSpaceCache: l2 }) {
            const h2 = t3.objId;
            let u2 = true;
            const d2 = [];
            let f2 = Promise.resolve();
            for (const n3 of t3.getKeys()) {
              const c3 = t3.get(n3);
              switch (n3) {
                case "Type":
                  break;
                case "LW":
                case "LC":
                case "LJ":
                case "ML":
                case "D":
                case "RI":
                case "FL":
                case "CA":
                case "ca":
                  d2.push([n3, c3]);
                  break;
                case "Font":
                  u2 = false;
                  f2 = f2.then(() => this.handleSetFont(e3, null, c3[0], a3, s2, o2.state).then(function(e4) {
                    a3.addDependency(e4);
                    d2.push([n3, [e4, c3[1]]]);
                  }));
                  break;
                case "BM":
                  d2.push([n3, normalizeBlendMode(c3)]);
                  break;
                case "SMask":
                  if ((0, i.isName)(c3, "None")) {
                    d2.push([n3, false]);
                    break;
                  }
                  if (c3 instanceof i.Dict) {
                    u2 = false;
                    f2 = f2.then(() => this.handleSMask(c3, e3, a3, s2, o2, l2));
                    d2.push([n3, true]);
                  } else (0, r.warn)("Unsupported SMask type");
                  break;
                case "TR":
                  const t4 = this.handleTransferFunction(c3);
                  d2.push([n3, t4]);
                  break;
                case "OP":
                case "op":
                case "OPM":
                case "BG":
                case "BG2":
                case "UCR":
                case "UCR2":
                case "TR2":
                case "HT":
                case "SM":
                case "SA":
                case "AIS":
                case "TK":
                  (0, r.info)("graphic state operator " + n3);
                  break;
                default:
                  (0, r.info)("Unknown graphic state operator " + n3);
              }
            }
            return f2.then(function() {
              d2.length > 0 && a3.addOp(r.OPS.setGState, [d2]);
              u2 && c2.set(n2, h2, d2);
            });
          }
          loadFont(e3, t3, a3, n2 = null, o2 = null) {
            const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new s.ErrorFont(`Font "${e3}" is not available.`), dict: t3, evaluatorOptions: this.options });
            let c2;
            if (t3) t3 instanceof i.Ref && (c2 = t3);
            else {
              const t4 = a3.get("Font");
              t4 && (c2 = t4.getRaw(e3));
            }
            if (c2) {
              if (this.parsingType3Font && this.type3FontRefs.has(c2)) return errorFont();
              if (this.fontCache.has(c2)) return this.fontCache.get(c2);
              t3 = this.xref.fetchIfRef(c2);
            }
            if (!(t3 instanceof i.Dict)) {
              if (!this.options.ignoreErrors && !this.parsingType3Font) {
                (0, r.warn)(`Font "${e3}" is not available.`);
                return errorFont();
              }
              (0, r.warn)(`Font "${e3}" is not available -- attempting to fallback to a default font.`);
              t3 = n2 || PartialEvaluator.fallbackFontDict;
            }
            if (t3.cacheKey && this.fontCache.has(t3.cacheKey)) return this.fontCache.get(t3.cacheKey);
            const l2 = new r.PromiseCapability();
            let h2;
            try {
              h2 = this.preEvaluateFont(t3);
              h2.cssFontInfo = o2;
            } catch (e4) {
              (0, r.warn)(`loadFont - preEvaluateFont failed: "${e4}".`);
              return errorFont();
            }
            const { descriptor: u2, hash: d2 } = h2, f2 = c2 instanceof i.Ref;
            let g2;
            if (d2 && u2 instanceof i.Dict) {
              const e4 = u2.fontAliases || (u2.fontAliases = /* @__PURE__ */ Object.create(null));
              if (e4[d2]) {
                const t4 = e4[d2].aliasRef;
                if (f2 && t4 && this.fontCache.has(t4)) {
                  this.fontCache.putAlias(c2, t4);
                  return this.fontCache.get(c2);
                }
              } else e4[d2] = { fontID: this.idFactory.createFontId() };
              f2 && (e4[d2].aliasRef = c2);
              g2 = e4[d2].fontID;
            } else g2 = this.idFactory.createFontId();
            (0, r.assert)(g2 == null ? void 0 : g2.startsWith("f"), 'The "fontID" must be (correctly) defined.');
            if (f2) this.fontCache.put(c2, l2.promise);
            else {
              t3.cacheKey = `cacheKey_${g2}`;
              this.fontCache.put(t3.cacheKey, l2.promise);
            }
            t3.loadedName = `${this.idFactory.getDocId()}_${g2}`;
            this.translateFont(h2).then((e4) => {
              l2.resolve(new TranslatedFont({ loadedName: t3.loadedName, font: e4, dict: t3, evaluatorOptions: this.options }));
            }).catch((e4) => {
              (0, r.warn)(`loadFont - translateFont failed: "${e4}".`);
              l2.resolve(new TranslatedFont({ loadedName: t3.loadedName, font: new s.ErrorFont(e4 instanceof Error ? e4.message : e4), dict: t3, evaluatorOptions: this.options }));
            });
            return l2.promise;
          }
          buildPath(e3, t3, a3, n2 = false) {
            const i2 = e3.length - 1;
            a3 || (a3 = []);
            if (i2 < 0 || e3.fnArray[i2] !== r.OPS.constructPath) {
              if (n2) {
                (0, r.warn)(`Encountered path operator "${t3}" inside of a text object.`);
                e3.addOp(r.OPS.save, null);
              }
              let i3;
              switch (t3) {
                case r.OPS.rectangle:
                  const e4 = a3[0] + a3[2], t4 = a3[1] + a3[3];
                  i3 = [Math.min(a3[0], e4), Math.max(a3[0], e4), Math.min(a3[1], t4), Math.max(a3[1], t4)];
                  break;
                case r.OPS.moveTo:
                case r.OPS.lineTo:
                  i3 = [a3[0], a3[0], a3[1], a3[1]];
                  break;
                default:
                  i3 = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
              }
              e3.addOp(r.OPS.constructPath, [[t3], a3, i3]);
              n2 && e3.addOp(r.OPS.restore, null);
            } else {
              const n3 = e3.argsArray[i2];
              n3[0].push(t3);
              n3[1].push(...a3);
              const s2 = n3[2];
              switch (t3) {
                case r.OPS.rectangle:
                  const e4 = a3[0] + a3[2], t4 = a3[1] + a3[3];
                  s2[0] = Math.min(s2[0], a3[0], e4);
                  s2[1] = Math.max(s2[1], a3[0], e4);
                  s2[2] = Math.min(s2[2], a3[1], t4);
                  s2[3] = Math.max(s2[3], a3[1], t4);
                  break;
                case r.OPS.moveTo:
                case r.OPS.lineTo:
                  s2[0] = Math.min(s2[0], a3[0]);
                  s2[1] = Math.max(s2[1], a3[0]);
                  s2[2] = Math.min(s2[2], a3[1]);
                  s2[3] = Math.max(s2[3], a3[1]);
              }
            }
          }
          parseColorSpace({ cs: e3, resources: t3, localColorSpaceCache: a3 }) {
            return y.ColorSpace.parseAsync({ cs: e3, xref: this.xref, resources: t3, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: a3 }).catch((e4) => {
              if (e4 instanceof r.AbortException) return null;
              if (this.options.ignoreErrors) {
                (0, r.warn)(`parseColorSpace - ignoring ColorSpace: "${e4}".`);
                return null;
              }
              throw e4;
            });
          }
          parseShading({ shading: e3, resources: t3, localColorSpaceCache: a3, localShadingPatternCache: r2 }) {
            let n2 = r2.get(e3);
            if (!n2) {
              const i2 = l.Pattern.parseShading(e3, this.xref, t3, this._pdfFunctionFactory, a3).getIR();
              n2 = `pattern_${this.idFactory.createObjId()}`;
              this.parsingType3Font && (n2 = `${this.idFactory.getDocId()}_type3_${n2}`);
              r2.set(e3, n2);
              this.parsingType3Font ? this.handler.send("commonobj", [n2, "Pattern", i2]) : this.handler.send("obj", [n2, this.pageIndex, "Pattern", i2]);
            }
            return n2;
          }
          handleColorN(e3, t3, a3, n2, s2, o2, c2, h2, u2, d2) {
            const f2 = a3.pop();
            if (f2 instanceof i.Name) {
              const g2 = s2.getRaw(f2.name), p2 = g2 instanceof i.Ref && u2.getByRef(g2);
              if (p2) try {
                const r2 = n2.base ? n2.base.getRgb(a3, 0) : null, i2 = (0, l.getTilingPatternIR)(p2.operatorListIR, p2.dict, r2);
                e3.addOp(t3, i2);
                return;
              } catch {
              }
              const b2 = this.xref.fetchIfRef(g2);
              if (b2) {
                const i2 = b2 instanceof m.BaseStream ? b2.dict : b2, s3 = i2.get("PatternType");
                if (s3 === E) {
                  const r2 = n2.base ? n2.base.getRgb(a3, 0) : null;
                  return this.handleTilingType(t3, r2, o2, b2, i2, e3, c2, u2);
                }
                if (s3 === N) {
                  const a4 = i2.get("Shading"), r2 = i2.getArray("Matrix"), n3 = this.parseShading({ shading: a4, resources: o2, localColorSpaceCache: h2, localShadingPatternCache: d2 });
                  e3.addOp(t3, ["Shading", n3, r2]);
                  return;
                }
                throw new r.FormatError(`Unknown PatternType: ${s3}`);
              }
            }
            throw new r.FormatError(`Unknown PatternName: ${f2}`);
          }
          _parseVisibilityExpression(e3, t3, a3) {
            if (++t3 > 10) {
              (0, r.warn)("Visibility expression is too deeply nested");
              return;
            }
            const n2 = e3.length, s2 = this.xref.fetchIfRef(e3[0]);
            if (!(n2 < 2) && s2 instanceof i.Name) {
              switch (s2.name) {
                case "And":
                case "Or":
                case "Not":
                  a3.push(s2.name);
                  break;
                default:
                  (0, r.warn)(`Invalid operator ${s2.name} in visibility expression`);
                  return;
              }
              for (let r2 = 1; r2 < n2; r2++) {
                const n3 = e3[r2], s3 = this.xref.fetchIfRef(n3);
                if (Array.isArray(s3)) {
                  const e4 = [];
                  a3.push(e4);
                  this._parseVisibilityExpression(s3, t3, e4);
                } else n3 instanceof i.Ref && a3.push(n3.toString());
              }
            } else (0, r.warn)("Invalid visibility expression");
          }
          async parseMarkedContentProps(e3, t3) {
            var _a;
            let a3;
            if (e3 instanceof i.Name) {
              a3 = t3.get("Properties").get(e3.name);
            } else {
              if (!(e3 instanceof i.Dict)) throw new r.FormatError("Optional content properties malformed.");
              a3 = e3;
            }
            const n2 = (_a = a3.get("Type")) == null ? void 0 : _a.name;
            if ("OCG" === n2) return { type: n2, id: a3.objId };
            if ("OCMD" === n2) {
              const e4 = a3.get("VE");
              if (Array.isArray(e4)) {
                const t5 = [];
                this._parseVisibilityExpression(e4, 0, t5);
                if (t5.length > 0) return { type: "OCMD", expression: t5 };
              }
              const t4 = a3.get("OCGs");
              if (Array.isArray(t4) || t4 instanceof i.Dict) {
                const e5 = [];
                if (Array.isArray(t4)) for (const a4 of t4) e5.push(a4.toString());
                else e5.push(t4.objId);
                return { type: n2, ids: e5, policy: a3.get("P") instanceof i.Name ? a3.get("P").name : null, expression: null };
              }
              if (t4 instanceof i.Ref) return { type: n2, id: t4.toString() };
            }
            return null;
          }
          getOperatorList({ stream: e3, task: t3, resources: a3, operatorList: n2, initialState: s2 = null, fallbackFontDict: o2 = null }) {
            a3 || (a3 = i.Dict.empty);
            s2 || (s2 = new EvalState());
            if (!n2) throw new Error('getOperatorList: missing "operatorList" parameter');
            const c2 = this, l2 = this.xref;
            let h2 = false;
            const u2 = new g.LocalImageCache(), d2 = new g.LocalColorSpaceCache(), f2 = new g.LocalGStateCache(), p2 = new g.LocalTilingPatternCache(), b2 = /* @__PURE__ */ new Map(), w2 = a3.get("XObject") || i.Dict.empty, S2 = a3.get("Pattern") || i.Dict.empty, x2 = new StateManager(s2), C2 = new EvaluatorPreprocessor(e3, l2, x2), k2 = new TimeSlotManager();
            function closePendingRestoreOPS(e4) {
              for (let e5 = 0, t4 = C2.savedStatesDepth; e5 < t4; e5++) n2.addOp(r.OPS.restore, []);
            }
            return new Promise(function promiseBody(e4, s3) {
              const next = function(t4) {
                Promise.all([t4, n2.ready]).then(function() {
                  try {
                    promiseBody(e4, s3);
                  } catch (e5) {
                    s3(e5);
                  }
                }, s3);
              };
              t3.ensureNotTerminated();
              k2.reset();
              const g2 = {};
              let v2, F2, O2, T2, M2, D2;
              for (; !(v2 = k2.check()); ) {
                g2.args = null;
                if (!C2.read(g2)) break;
                let e5 = g2.args, s4 = g2.fn;
                switch (0 | s4) {
                  case r.OPS.paintXObject:
                    D2 = e5[0] instanceof i.Name;
                    M2 = e5[0].name;
                    if (D2) {
                      const t4 = u2.getByName(M2);
                      if (t4) {
                        n2.addImageOps(t4.fn, t4.args, t4.optionalContent);
                        incrementCachedImageMaskCount(t4);
                        e5 = null;
                        continue;
                      }
                    }
                    next(new Promise(function(e6, s5) {
                      if (!D2) throw new r.FormatError("XObject must be referred to by name.");
                      let o3 = w2.getRaw(M2);
                      if (o3 instanceof i.Ref) {
                        const t4 = u2.getByRef(o3) || c2._regionalImageCache.getByRef(o3);
                        if (t4) {
                          n2.addImageOps(t4.fn, t4.args, t4.optionalContent);
                          incrementCachedImageMaskCount(t4);
                          e6();
                          return;
                        }
                        const a4 = c2.globalImageCache.getData(o3, c2.pageIndex);
                        if (a4) {
                          n2.addDependency(a4.objId);
                          n2.addImageOps(a4.fn, a4.args, a4.optionalContent);
                          e6();
                          return;
                        }
                        o3 = l2.fetch(o3);
                      }
                      if (!(o3 instanceof m.BaseStream)) throw new r.FormatError("XObject should be a stream");
                      const h3 = o3.dict.get("Subtype");
                      if (!(h3 instanceof i.Name)) throw new r.FormatError("XObject should have a Name subtype");
                      if ("Form" !== h3.name) if ("Image" !== h3.name) {
                        if ("PS" !== h3.name) throw new r.FormatError(`Unhandled XObject subtype ${h3.name}`);
                        (0, r.info)("Ignored XObject subtype PS");
                        e6();
                      } else c2.buildPaintImageXObject({ resources: a3, image: o3, operatorList: n2, cacheKey: M2, localImageCache: u2, localColorSpaceCache: d2 }).then(e6, s5);
                      else {
                        x2.save();
                        c2.buildFormXObject(a3, o3, null, n2, t3, x2.state.clone(), d2).then(function() {
                          x2.restore();
                          e6();
                        }, s5);
                      }
                    }).catch(function(e6) {
                      if (!(e6 instanceof r.AbortException)) {
                        if (!c2.options.ignoreErrors) throw e6;
                        (0, r.warn)(`getOperatorList - ignoring XObject: "${e6}".`);
                      }
                    }));
                    return;
                  case r.OPS.setFont:
                    var E2 = e5[1];
                    next(c2.handleSetFont(a3, e5, null, n2, t3, x2.state, o2).then(function(e6) {
                      n2.addDependency(e6);
                      n2.addOp(r.OPS.setFont, [e6, E2]);
                    }));
                    return;
                  case r.OPS.beginText:
                    h2 = true;
                    break;
                  case r.OPS.endText:
                    h2 = false;
                    break;
                  case r.OPS.endInlineImage:
                    var N2 = e5[0].cacheKey;
                    if (N2) {
                      const t4 = u2.getByName(N2);
                      if (t4) {
                        n2.addImageOps(t4.fn, t4.args, t4.optionalContent);
                        incrementCachedImageMaskCount(t4);
                        e5 = null;
                        continue;
                      }
                    }
                    next(c2.buildPaintImageXObject({ resources: a3, image: e5[0], isInline: true, operatorList: n2, cacheKey: N2, localImageCache: u2, localColorSpaceCache: d2 }));
                    return;
                  case r.OPS.showText:
                    if (!x2.state.font) {
                      c2.ensureStateFont(x2.state);
                      continue;
                    }
                    e5[0] = c2.handleText(e5[0], x2.state);
                    break;
                  case r.OPS.showSpacedText:
                    if (!x2.state.font) {
                      c2.ensureStateFont(x2.state);
                      continue;
                    }
                    var L = [], $ = x2.state;
                    for (const t4 of e5[0]) "string" == typeof t4 ? L.push(...c2.handleText(t4, $)) : "number" == typeof t4 && L.push(t4);
                    e5[0] = L;
                    s4 = r.OPS.showText;
                    break;
                  case r.OPS.nextLineShowText:
                    if (!x2.state.font) {
                      c2.ensureStateFont(x2.state);
                      continue;
                    }
                    n2.addOp(r.OPS.nextLine);
                    e5[0] = c2.handleText(e5[0], x2.state);
                    s4 = r.OPS.showText;
                    break;
                  case r.OPS.nextLineSetSpacingShowText:
                    if (!x2.state.font) {
                      c2.ensureStateFont(x2.state);
                      continue;
                    }
                    n2.addOp(r.OPS.nextLine);
                    n2.addOp(r.OPS.setWordSpacing, [e5.shift()]);
                    n2.addOp(r.OPS.setCharSpacing, [e5.shift()]);
                    e5[0] = c2.handleText(e5[0], x2.state);
                    s4 = r.OPS.showText;
                    break;
                  case r.OPS.setTextRenderingMode:
                    x2.state.textRenderingMode = e5[0];
                    break;
                  case r.OPS.setFillColorSpace: {
                    const t4 = y.ColorSpace.getCached(e5[0], l2, d2);
                    if (t4) {
                      x2.state.fillColorSpace = t4;
                      continue;
                    }
                    next(c2.parseColorSpace({ cs: e5[0], resources: a3, localColorSpaceCache: d2 }).then(function(e6) {
                      e6 && (x2.state.fillColorSpace = e6);
                    }));
                    return;
                  }
                  case r.OPS.setStrokeColorSpace: {
                    const t4 = y.ColorSpace.getCached(e5[0], l2, d2);
                    if (t4) {
                      x2.state.strokeColorSpace = t4;
                      continue;
                    }
                    next(c2.parseColorSpace({ cs: e5[0], resources: a3, localColorSpaceCache: d2 }).then(function(e6) {
                      e6 && (x2.state.strokeColorSpace = e6);
                    }));
                    return;
                  }
                  case r.OPS.setFillColor:
                    T2 = x2.state.fillColorSpace;
                    e5 = T2.getRgb(e5, 0);
                    s4 = r.OPS.setFillRGBColor;
                    break;
                  case r.OPS.setStrokeColor:
                    T2 = x2.state.strokeColorSpace;
                    e5 = T2.getRgb(e5, 0);
                    s4 = r.OPS.setStrokeRGBColor;
                    break;
                  case r.OPS.setFillGray:
                    x2.state.fillColorSpace = y.ColorSpace.singletons.gray;
                    e5 = y.ColorSpace.singletons.gray.getRgb(e5, 0);
                    s4 = r.OPS.setFillRGBColor;
                    break;
                  case r.OPS.setStrokeGray:
                    x2.state.strokeColorSpace = y.ColorSpace.singletons.gray;
                    e5 = y.ColorSpace.singletons.gray.getRgb(e5, 0);
                    s4 = r.OPS.setStrokeRGBColor;
                    break;
                  case r.OPS.setFillCMYKColor:
                    x2.state.fillColorSpace = y.ColorSpace.singletons.cmyk;
                    e5 = y.ColorSpace.singletons.cmyk.getRgb(e5, 0);
                    s4 = r.OPS.setFillRGBColor;
                    break;
                  case r.OPS.setStrokeCMYKColor:
                    x2.state.strokeColorSpace = y.ColorSpace.singletons.cmyk;
                    e5 = y.ColorSpace.singletons.cmyk.getRgb(e5, 0);
                    s4 = r.OPS.setStrokeRGBColor;
                    break;
                  case r.OPS.setFillRGBColor:
                    x2.state.fillColorSpace = y.ColorSpace.singletons.rgb;
                    e5 = y.ColorSpace.singletons.rgb.getRgb(e5, 0);
                    break;
                  case r.OPS.setStrokeRGBColor:
                    x2.state.strokeColorSpace = y.ColorSpace.singletons.rgb;
                    e5 = y.ColorSpace.singletons.rgb.getRgb(e5, 0);
                    break;
                  case r.OPS.setFillColorN:
                    T2 = x2.state.fillColorSpace;
                    if ("Pattern" === T2.name) {
                      next(c2.handleColorN(n2, r.OPS.setFillColorN, e5, T2, S2, a3, t3, d2, p2, b2));
                      return;
                    }
                    e5 = T2.getRgb(e5, 0);
                    s4 = r.OPS.setFillRGBColor;
                    break;
                  case r.OPS.setStrokeColorN:
                    T2 = x2.state.strokeColorSpace;
                    if ("Pattern" === T2.name) {
                      next(c2.handleColorN(n2, r.OPS.setStrokeColorN, e5, T2, S2, a3, t3, d2, p2, b2));
                      return;
                    }
                    e5 = T2.getRgb(e5, 0);
                    s4 = r.OPS.setStrokeRGBColor;
                    break;
                  case r.OPS.shadingFill:
                    var _ = a3.get("Shading");
                    if (!_) throw new r.FormatError("No shading resource found");
                    var j = _.get(e5[0].name);
                    if (!j) throw new r.FormatError("No shading object found");
                    e5 = [c2.parseShading({ shading: j, resources: a3, localColorSpaceCache: d2, localShadingPatternCache: b2 })];
                    s4 = r.OPS.shadingFill;
                    break;
                  case r.OPS.setGState:
                    D2 = e5[0] instanceof i.Name;
                    M2 = e5[0].name;
                    if (D2) {
                      const t4 = f2.getByName(M2);
                      if (t4) {
                        t4.length > 0 && n2.addOp(r.OPS.setGState, [t4]);
                        e5 = null;
                        continue;
                      }
                    }
                    next(new Promise(function(e6, s5) {
                      if (!D2) throw new r.FormatError("GState must be referred to by name.");
                      const o3 = a3.get("ExtGState");
                      if (!(o3 instanceof i.Dict)) throw new r.FormatError("ExtGState should be a dictionary.");
                      const l3 = o3.get(M2);
                      if (!(l3 instanceof i.Dict)) throw new r.FormatError("GState should be a dictionary.");
                      c2.setGState({ resources: a3, gState: l3, operatorList: n2, cacheKey: M2, task: t3, stateManager: x2, localGStateCache: f2, localColorSpaceCache: d2 }).then(e6, s5);
                    }).catch(function(e6) {
                      if (!(e6 instanceof r.AbortException)) {
                        if (!c2.options.ignoreErrors) throw e6;
                        (0, r.warn)(`getOperatorList - ignoring ExtGState: "${e6}".`);
                      }
                    }));
                    return;
                  case r.OPS.moveTo:
                  case r.OPS.lineTo:
                  case r.OPS.curveTo:
                  case r.OPS.curveTo2:
                  case r.OPS.curveTo3:
                  case r.OPS.closePath:
                  case r.OPS.rectangle:
                    c2.buildPath(n2, s4, e5, h2);
                    continue;
                  case r.OPS.markPoint:
                  case r.OPS.markPointProps:
                  case r.OPS.beginCompat:
                  case r.OPS.endCompat:
                    continue;
                  case r.OPS.beginMarkedContentProps:
                    if (!(e5[0] instanceof i.Name)) {
                      (0, r.warn)(`Expected name for beginMarkedContentProps arg0=${e5[0]}`);
                      continue;
                    }
                    if ("OC" === e5[0].name) {
                      next(c2.parseMarkedContentProps(e5[1], a3).then((e6) => {
                        n2.addOp(r.OPS.beginMarkedContentProps, ["OC", e6]);
                      }).catch((e6) => {
                        if (!(e6 instanceof r.AbortException)) {
                          if (!c2.options.ignoreErrors) throw e6;
                          (0, r.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${e6}".`);
                        }
                      }));
                      return;
                    }
                    e5 = [e5[0].name, e5[1] instanceof i.Dict ? e5[1].get("MCID") : null];
                    break;
                  case r.OPS.beginMarkedContent:
                  case r.OPS.endMarkedContent:
                  default:
                    if (null !== e5) {
                      for (F2 = 0, O2 = e5.length; F2 < O2 && !(e5[F2] instanceof i.Dict); F2++) ;
                      if (F2 < O2) {
                        (0, r.warn)("getOperatorList - ignoring operator: " + s4);
                        continue;
                      }
                    }
                }
                n2.addOp(s4, e5);
              }
              if (v2) next(R);
              else {
                closePendingRestoreOPS();
                e4();
              }
            }).catch((e4) => {
              if (!(e4 instanceof r.AbortException)) {
                if (!this.options.ignoreErrors) throw e4;
                (0, r.warn)(`getOperatorList - ignoring errors during "${t3.name}" task: "${e4}".`);
                closePendingRestoreOPS();
              }
            });
          }
          getTextContent({ stream: e3, task: t3, resources: a3, stateManager: n2 = null, includeMarkedContent: s2 = false, sink: o2, seenStyles: c2 = /* @__PURE__ */ new Set(), viewBox: l2, markedContentData: h2 = null, disableNormalization: u2 = false }) {
            a3 || (a3 = i.Dict.empty);
            n2 || (n2 = new StateManager(new TextState()));
            s2 && (h2 || (h2 = { level: 0 }));
            const d2 = { items: [], styles: /* @__PURE__ */ Object.create(null) }, f2 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, p2 = [" ", " "];
            let y2 = 0;
            function saveLastChar(e4) {
              const t4 = (y2 + 1) % 2, a4 = " " !== p2[y2] && " " === p2[t4];
              p2[y2] = e4;
              y2 = t4;
              return a4;
            }
            function shouldAddWhitepsace() {
              return " " !== p2[y2] && " " === p2[(y2 + 1) % 2];
            }
            function resetLastChars() {
              p2[0] = p2[1] = " ";
              y2 = 0;
            }
            const w2 = this, S2 = this.xref, x2 = [];
            let C2 = null;
            const k2 = new g.LocalImageCache(), v2 = new g.LocalGStateCache(), F2 = new EvaluatorPreprocessor(e3, S2, n2);
            let O2;
            function pushWhitespace({ width: e4 = 0, height: t4 = 0, transform: a4 = f2.prevTransform, fontName: r2 = f2.fontName }) {
              d2.items.push({ str: " ", dir: "ltr", width: e4, height: t4, transform: a4, fontName: r2, hasEOL: false });
            }
            function getCurrentTextTransform() {
              const e4 = O2.font, t4 = [O2.fontSize * O2.textHScale, 0, 0, O2.fontSize, 0, O2.textRise];
              if (e4.isType3Font && (O2.fontSize <= 1 || e4.isCharBBox) && !(0, r.isArrayEqual)(O2.fontMatrix, r.FONT_IDENTITY_MATRIX)) {
                const a4 = e4.bbox[3] - e4.bbox[1];
                a4 > 0 && (t4[3] *= a4 * O2.fontMatrix[3]);
              }
              return r.Util.transform(O2.ctm, r.Util.transform(O2.textMatrix, t4));
            }
            function ensureTextContentItem() {
              if (f2.initialized) return f2;
              const { font: e4, loadedName: t4 } = O2;
              if (!c2.has(t4)) {
                c2.add(t4);
                d2.styles[t4] = { fontFamily: e4.fallbackName, ascent: e4.ascent, descent: e4.descent, vertical: e4.vertical };
              }
              f2.fontName = t4;
              const a4 = f2.transform = getCurrentTextTransform();
              if (e4.vertical) {
                f2.width = f2.totalWidth = Math.hypot(a4[0], a4[1]);
                f2.height = f2.totalHeight = 0;
                f2.vertical = true;
              } else {
                f2.width = f2.totalWidth = 0;
                f2.height = f2.totalHeight = Math.hypot(a4[2], a4[3]);
                f2.vertical = false;
              }
              const r2 = Math.hypot(O2.textLineMatrix[0], O2.textLineMatrix[1]), n3 = Math.hypot(O2.ctm[0], O2.ctm[1]);
              f2.textAdvanceScale = n3 * r2;
              const { fontSize: i2 } = O2;
              f2.trackingSpaceMin = 0.102 * i2;
              f2.notASpace = 0.03 * i2;
              f2.negativeSpaceMax = -0.2 * i2;
              f2.spaceInFlowMin = 0.102 * i2;
              f2.spaceInFlowMax = 0.6 * i2;
              f2.hasEOL = false;
              f2.initialized = true;
              return f2;
            }
            function updateAdvanceScale() {
              if (!f2.initialized) return;
              const e4 = Math.hypot(O2.textLineMatrix[0], O2.textLineMatrix[1]), t4 = Math.hypot(O2.ctm[0], O2.ctm[1]) * e4;
              if (t4 !== f2.textAdvanceScale) {
                if (f2.vertical) {
                  f2.totalHeight += f2.height * f2.textAdvanceScale;
                  f2.height = 0;
                } else {
                  f2.totalWidth += f2.width * f2.textAdvanceScale;
                  f2.width = 0;
                }
                f2.textAdvanceScale = t4;
              }
            }
            function handleSetFont(e4, n3) {
              return w2.loadFont(e4, n3, a3).then(function(e5) {
                return e5.font.isType3Font ? e5.loadType3Data(w2, a3, t3).catch(function() {
                }).then(function() {
                  return e5;
                }) : e5;
              }).then(function(e5) {
                O2.loadedName = e5.loadedName;
                O2.font = e5.font;
                O2.fontMatrix = e5.font.fontMatrix || r.FONT_IDENTITY_MATRIX;
              });
            }
            function applyInverseRotation(e4, t4, a4) {
              const r2 = Math.hypot(a4[0], a4[1]);
              return [(a4[0] * e4 + a4[1] * t4) / r2, (a4[2] * e4 + a4[3] * t4) / r2];
            }
            function compareWithLastPosition(e4) {
              var _a;
              const t4 = getCurrentTextTransform();
              let a4 = t4[4], r2 = t4[5];
              if ((_a = O2.font) == null ? void 0 : _a.vertical) {
                if (a4 < l2[0] || a4 > l2[2] || r2 + e4 < l2[1] || r2 > l2[3]) return false;
              } else if (a4 + e4 < l2[0] || a4 > l2[2] || r2 < l2[1] || r2 > l2[3]) return false;
              if (!O2.font || !f2.prevTransform) return true;
              let n3 = f2.prevTransform[4], i2 = f2.prevTransform[5];
              if (n3 === a4 && i2 === r2) return true;
              let s3 = -1;
              t4[0] && 0 === t4[1] && 0 === t4[2] ? s3 = t4[0] > 0 ? 0 : 180 : t4[1] && 0 === t4[0] && 0 === t4[3] && (s3 = t4[1] > 0 ? 90 : 270);
              switch (s3) {
                case 0:
                  break;
                case 90:
                  [a4, r2] = [r2, a4];
                  [n3, i2] = [i2, n3];
                  break;
                case 180:
                  [a4, r2, n3, i2] = [-a4, -r2, -n3, -i2];
                  break;
                case 270:
                  [a4, r2] = [-r2, -a4];
                  [n3, i2] = [-i2, -n3];
                  break;
                default:
                  [a4, r2] = applyInverseRotation(a4, r2, t4);
                  [n3, i2] = applyInverseRotation(n3, i2, f2.prevTransform);
              }
              if (O2.font.vertical) {
                const e5 = (i2 - r2) / f2.textAdvanceScale, t5 = a4 - n3, s4 = Math.sign(f2.height);
                if (e5 < s4 * f2.negativeSpaceMax) {
                  if (Math.abs(t5) > 0.5 * f2.width) {
                    appendEOL();
                    return true;
                  }
                  resetLastChars();
                  flushTextContentItem();
                  return true;
                }
                if (Math.abs(t5) > f2.width) {
                  appendEOL();
                  return true;
                }
                e5 <= s4 * f2.notASpace && resetLastChars();
                if (e5 <= s4 * f2.trackingSpaceMin) if (shouldAddWhitepsace()) {
                  resetLastChars();
                  flushTextContentItem();
                  pushWhitespace({ height: Math.abs(e5) });
                } else f2.height += e5;
                else if (!addFakeSpaces(e5, f2.prevTransform, s4)) if (0 === f2.str.length) {
                  resetLastChars();
                  pushWhitespace({ height: Math.abs(e5) });
                } else f2.height += e5;
                Math.abs(t5) > 0.25 * f2.width && flushTextContentItem();
                return true;
              }
              const o3 = (a4 - n3) / f2.textAdvanceScale, c3 = r2 - i2, h3 = Math.sign(f2.width);
              if (o3 < h3 * f2.negativeSpaceMax) {
                if (Math.abs(c3) > 0.5 * f2.height) {
                  appendEOL();
                  return true;
                }
                resetLastChars();
                flushTextContentItem();
                return true;
              }
              if (Math.abs(c3) > f2.height) {
                appendEOL();
                return true;
              }
              o3 <= h3 * f2.notASpace && resetLastChars();
              if (o3 <= h3 * f2.trackingSpaceMin) if (shouldAddWhitepsace()) {
                resetLastChars();
                flushTextContentItem();
                pushWhitespace({ width: Math.abs(o3) });
              } else f2.width += o3;
              else if (!addFakeSpaces(o3, f2.prevTransform, h3)) if (0 === f2.str.length) {
                resetLastChars();
                pushWhitespace({ width: Math.abs(o3) });
              } else f2.width += o3;
              Math.abs(c3) > 0.25 * f2.height && flushTextContentItem();
              return true;
            }
            function buildTextContentItem({ chars: e4, extraSpacing: t4 }) {
              const a4 = O2.font;
              if (!e4) {
                const e5 = O2.charSpacing + t4;
                e5 && (a4.vertical ? O2.translateTextMatrix(0, -e5) : O2.translateTextMatrix(e5 * O2.textHScale, 0));
                return;
              }
              const r2 = a4.charsToGlyphs(e4), n3 = O2.fontMatrix[0] * O2.fontSize;
              for (let e5 = 0, i2 = r2.length; e5 < i2; e5++) {
                const s3 = r2[e5], { category: o3 } = s3;
                if (o3.isInvisibleFormatMark) continue;
                let c3 = O2.charSpacing + (e5 + 1 === i2 ? t4 : 0), l3 = s3.width;
                a4.vertical && (l3 = s3.vmetric ? s3.vmetric[0] : -l3);
                let h3 = l3 * n3;
                if (o3.isWhitespace) {
                  if (a4.vertical) {
                    c3 += -h3 + O2.wordSpacing;
                    O2.translateTextMatrix(0, -c3);
                  } else {
                    c3 += h3 + O2.wordSpacing;
                    O2.translateTextMatrix(c3 * O2.textHScale, 0);
                  }
                  saveLastChar(" ");
                  continue;
                }
                if (!o3.isZeroWidthDiacritic && !compareWithLastPosition(h3)) {
                  a4.vertical ? O2.translateTextMatrix(0, h3) : O2.translateTextMatrix(h3 * O2.textHScale, 0);
                  continue;
                }
                const u3 = ensureTextContentItem();
                o3.isZeroWidthDiacritic && (h3 = 0);
                if (a4.vertical) {
                  O2.translateTextMatrix(0, h3);
                  h3 = Math.abs(h3);
                  u3.height += h3;
                } else {
                  h3 *= O2.textHScale;
                  O2.translateTextMatrix(h3, 0);
                  u3.width += h3;
                }
                h3 && (u3.prevTransform = getCurrentTextTransform());
                const d3 = s3.unicode;
                saveLastChar(d3) && u3.str.push(" ");
                u3.str.push(d3);
                c3 && (a4.vertical ? O2.translateTextMatrix(0, -c3) : O2.translateTextMatrix(c3 * O2.textHScale, 0));
              }
            }
            function appendEOL() {
              resetLastChars();
              if (f2.initialized) {
                f2.hasEOL = true;
                flushTextContentItem();
              } else d2.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: O2.loadedName, hasEOL: true });
            }
            function addFakeSpaces(e4, t4, a4) {
              if (a4 * f2.spaceInFlowMin <= e4 && e4 <= a4 * f2.spaceInFlowMax) {
                if (f2.initialized) {
                  resetLastChars();
                  f2.str.push(" ");
                }
                return false;
              }
              const r2 = f2.fontName;
              let n3 = 0;
              if (f2.vertical) {
                n3 = e4;
                e4 = 0;
              }
              flushTextContentItem();
              resetLastChars();
              pushWhitespace({ width: Math.abs(e4), height: Math.abs(n3), transform: t4 || getCurrentTextTransform(), fontName: r2 });
              return true;
            }
            function flushTextContentItem() {
              if (f2.initialized && f2.str) {
                f2.vertical ? f2.totalHeight += f2.height * f2.textAdvanceScale : f2.totalWidth += f2.width * f2.textAdvanceScale;
                d2.items.push(function runBidiTransform(e4) {
                  let t4 = e4.str.join("");
                  u2 || (t4 = (0, r.normalizeUnicode)(t4));
                  const a4 = (0, b.bidi)(t4, -1, e4.vertical);
                  return { str: a4.str, dir: a4.dir, width: Math.abs(e4.totalWidth), height: Math.abs(e4.totalHeight), transform: e4.transform, fontName: e4.fontName, hasEOL: e4.hasEOL };
                }(f2));
                f2.initialized = false;
                f2.str.length = 0;
              }
            }
            function enqueueChunk(e4 = false) {
              const t4 = d2.items.length;
              if (0 !== t4 && !(e4 && t4 < 10)) {
                o2.enqueue(d2, t4);
                d2.items = [];
                d2.styles = /* @__PURE__ */ Object.create(null);
              }
            }
            const T2 = new TimeSlotManager();
            return new Promise(function promiseBody(e4, f3) {
              const next = function(t4) {
                enqueueChunk(true);
                Promise.all([t4, o2.ready]).then(function() {
                  try {
                    promiseBody(e4, f3);
                  } catch (e5) {
                    f3(e5);
                  }
                }, f3);
              };
              t3.ensureNotTerminated();
              T2.reset();
              const g2 = {};
              let p3, b2 = [];
              for (; !(p3 = T2.check()); ) {
                b2.length = 0;
                g2.args = b2;
                if (!F2.read(g2)) break;
                const e5 = O2;
                O2 = n2.state;
                const f4 = g2.fn;
                b2 = g2.args;
                switch (0 | f4) {
                  case r.OPS.setFont:
                    var y3 = b2[0].name, M2 = b2[1];
                    if (O2.font && y3 === O2.fontName && M2 === O2.fontSize) break;
                    flushTextContentItem();
                    O2.fontName = y3;
                    O2.fontSize = M2;
                    next(handleSetFont(y3, null));
                    return;
                  case r.OPS.setTextRise:
                    O2.textRise = b2[0];
                    break;
                  case r.OPS.setHScale:
                    O2.textHScale = b2[0] / 100;
                    break;
                  case r.OPS.setLeading:
                    O2.leading = b2[0];
                    break;
                  case r.OPS.moveText:
                    O2.translateTextLineMatrix(b2[0], b2[1]);
                    O2.textMatrix = O2.textLineMatrix.slice();
                    break;
                  case r.OPS.setLeadingMoveText:
                    O2.leading = -b2[1];
                    O2.translateTextLineMatrix(b2[0], b2[1]);
                    O2.textMatrix = O2.textLineMatrix.slice();
                    break;
                  case r.OPS.nextLine:
                    O2.carriageReturn();
                    break;
                  case r.OPS.setTextMatrix:
                    O2.setTextMatrix(b2[0], b2[1], b2[2], b2[3], b2[4], b2[5]);
                    O2.setTextLineMatrix(b2[0], b2[1], b2[2], b2[3], b2[4], b2[5]);
                    updateAdvanceScale();
                    break;
                  case r.OPS.setCharSpacing:
                    O2.charSpacing = b2[0];
                    break;
                  case r.OPS.setWordSpacing:
                    O2.wordSpacing = b2[0];
                    break;
                  case r.OPS.beginText:
                    O2.textMatrix = r.IDENTITY_MATRIX.slice();
                    O2.textLineMatrix = r.IDENTITY_MATRIX.slice();
                    break;
                  case r.OPS.showSpacedText:
                    if (!n2.state.font) {
                      w2.ensureStateFont(n2.state);
                      continue;
                    }
                    const f5 = (O2.font.vertical ? 1 : -1) * O2.fontSize / 1e3, g3 = b2[0];
                    for (let e6 = 0, t4 = g3.length; e6 < t4; e6++) {
                      const t5 = g3[e6];
                      if ("string" == typeof t5) x2.push(t5);
                      else if ("number" == typeof t5 && 0 !== t5) {
                        const e7 = x2.join("");
                        x2.length = 0;
                        buildTextContentItem({ chars: e7, extraSpacing: t5 * f5 });
                      }
                    }
                    if (x2.length > 0) {
                      const e6 = x2.join("");
                      x2.length = 0;
                      buildTextContentItem({ chars: e6, extraSpacing: 0 });
                    }
                    break;
                  case r.OPS.showText:
                    if (!n2.state.font) {
                      w2.ensureStateFont(n2.state);
                      continue;
                    }
                    buildTextContentItem({ chars: b2[0], extraSpacing: 0 });
                    break;
                  case r.OPS.nextLineShowText:
                    if (!n2.state.font) {
                      w2.ensureStateFont(n2.state);
                      continue;
                    }
                    O2.carriageReturn();
                    buildTextContentItem({ chars: b2[0], extraSpacing: 0 });
                    break;
                  case r.OPS.nextLineSetSpacingShowText:
                    if (!n2.state.font) {
                      w2.ensureStateFont(n2.state);
                      continue;
                    }
                    O2.wordSpacing = b2[0];
                    O2.charSpacing = b2[1];
                    O2.carriageReturn();
                    buildTextContentItem({ chars: b2[2], extraSpacing: 0 });
                    break;
                  case r.OPS.paintXObject:
                    flushTextContentItem();
                    C2 || (C2 = a3.get("XObject") || i.Dict.empty);
                    var D2 = b2[0] instanceof i.Name, E2 = b2[0].name;
                    if (D2 && k2.getByName(E2)) break;
                    next(new Promise(function(e6, d3) {
                      if (!D2) throw new r.FormatError("XObject must be referred to by name.");
                      let f6 = C2.getRaw(E2);
                      if (f6 instanceof i.Ref) {
                        if (k2.getByRef(f6)) {
                          e6();
                          return;
                        }
                        if (w2.globalImageCache.getData(f6, w2.pageIndex)) {
                          e6();
                          return;
                        }
                        f6 = S2.fetch(f6);
                      }
                      if (!(f6 instanceof m.BaseStream)) throw new r.FormatError("XObject should be a stream");
                      const g4 = f6.dict.get("Subtype");
                      if (!(g4 instanceof i.Name)) throw new r.FormatError("XObject should have a Name subtype");
                      if ("Form" !== g4.name) {
                        k2.set(E2, f6.dict.objId, true);
                        e6();
                        return;
                      }
                      const p4 = n2.state.clone(), b3 = new StateManager(p4), y4 = f6.dict.getArray("Matrix");
                      Array.isArray(y4) && 6 === y4.length && b3.transform(y4);
                      enqueueChunk();
                      const x3 = { enqueueInvoked: false, enqueue(e7, t4) {
                        this.enqueueInvoked = true;
                        o2.enqueue(e7, t4);
                      }, get desiredSize() {
                        return o2.desiredSize;
                      }, get ready() {
                        return o2.ready;
                      } };
                      w2.getTextContent({ stream: f6, task: t3, resources: f6.dict.get("Resources") || a3, stateManager: b3, includeMarkedContent: s2, sink: x3, seenStyles: c2, viewBox: l2, markedContentData: h2, disableNormalization: u2 }).then(function() {
                        x3.enqueueInvoked || k2.set(E2, f6.dict.objId, true);
                        e6();
                      }, d3);
                    }).catch(function(e6) {
                      if (!(e6 instanceof r.AbortException)) {
                        if (!w2.options.ignoreErrors) throw e6;
                        (0, r.warn)(`getTextContent - ignoring XObject: "${e6}".`);
                      }
                    }));
                    return;
                  case r.OPS.setGState:
                    D2 = b2[0] instanceof i.Name;
                    E2 = b2[0].name;
                    if (D2 && v2.getByName(E2)) break;
                    next(new Promise(function(e6, t4) {
                      if (!D2) throw new r.FormatError("GState must be referred to by name.");
                      const n3 = a3.get("ExtGState");
                      if (!(n3 instanceof i.Dict)) throw new r.FormatError("ExtGState should be a dictionary.");
                      const s3 = n3.get(E2);
                      if (!(s3 instanceof i.Dict)) throw new r.FormatError("GState should be a dictionary.");
                      const o3 = s3.get("Font");
                      if (o3) {
                        flushTextContentItem();
                        O2.fontName = null;
                        O2.fontSize = o3[1];
                        handleSetFont(null, o3[0]).then(e6, t4);
                      } else {
                        v2.set(E2, s3.objId, true);
                        e6();
                      }
                    }).catch(function(e6) {
                      if (!(e6 instanceof r.AbortException)) {
                        if (!w2.options.ignoreErrors) throw e6;
                        (0, r.warn)(`getTextContent - ignoring ExtGState: "${e6}".`);
                      }
                    }));
                    return;
                  case r.OPS.beginMarkedContent:
                    flushTextContentItem();
                    if (s2) {
                      h2.level++;
                      d2.items.push({ type: "beginMarkedContent", tag: b2[0] instanceof i.Name ? b2[0].name : null });
                    }
                    break;
                  case r.OPS.beginMarkedContentProps:
                    flushTextContentItem();
                    if (s2) {
                      h2.level++;
                      let e6 = null;
                      b2[1] instanceof i.Dict && (e6 = b2[1].get("MCID"));
                      d2.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e6) ? `${w2.idFactory.getPageObjId()}_mc${e6}` : null, tag: b2[0] instanceof i.Name ? b2[0].name : null });
                    }
                    break;
                  case r.OPS.endMarkedContent:
                    flushTextContentItem();
                    if (s2) {
                      if (0 === h2.level) break;
                      h2.level--;
                      d2.items.push({ type: "endMarkedContent" });
                    }
                    break;
                  case r.OPS.restore:
                    !e5 || e5.font === O2.font && e5.fontSize === O2.fontSize && e5.fontName === O2.fontName || flushTextContentItem();
                }
                if (d2.items.length >= o2.desiredSize) {
                  p3 = true;
                  break;
                }
              }
              if (p3) next(R);
              else {
                flushTextContentItem();
                enqueueChunk();
                e4();
              }
            }).catch((e4) => {
              if (!(e4 instanceof r.AbortException)) {
                if (!this.options.ignoreErrors) throw e4;
                (0, r.warn)(`getTextContent - ignoring errors during "${t3.name}" task: "${e4}".`);
                flushTextContentItem();
                enqueueChunk();
              }
            });
          }
          extractDataStructures(e3, t3, a3) {
            const n2 = this.xref;
            let s2;
            const l2 = this.readToUnicode(a3.toUnicode || e3.get("ToUnicode") || t3.get("ToUnicode"));
            if (a3.composite) {
              const t4 = e3.get("CIDSystemInfo");
              t4 instanceof i.Dict && (a3.cidSystemInfo = { registry: (0, r.stringToPDFString)(t4.get("Registry")), ordering: (0, r.stringToPDFString)(t4.get("Ordering")), supplement: t4.get("Supplement") });
              try {
                const t5 = e3.get("CIDToGIDMap");
                t5 instanceof m.BaseStream && (s2 = t5.getBytes());
              } catch (e4) {
                if (!this.options.ignoreErrors) throw e4;
                (0, r.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${e4}".`);
              }
            }
            const h2 = [];
            let u2, d2 = null;
            if (e3.has("Encoding")) {
              u2 = e3.get("Encoding");
              if (u2 instanceof i.Dict) {
                d2 = u2.get("BaseEncoding");
                d2 = d2 instanceof i.Name ? d2.name : null;
                if (u2.has("Differences")) {
                  const e4 = u2.get("Differences");
                  let t4 = 0;
                  for (const a4 of e4) {
                    const e5 = n2.fetchIfRef(a4);
                    if ("number" == typeof e5) t4 = e5;
                    else {
                      if (!(e5 instanceof i.Name)) throw new r.FormatError(`Invalid entry in 'Differences' array: ${e5}`);
                      h2[t4++] = e5.name;
                    }
                  }
                }
              } else if (u2 instanceof i.Name) d2 = u2.name;
              else {
                const e4 = "Encoding is not a Name nor a Dict";
                if (!this.options.ignoreErrors) throw new r.FormatError(e4);
                (0, r.warn)(e4);
              }
              "MacRomanEncoding" !== d2 && "MacExpertEncoding" !== d2 && "WinAnsiEncoding" !== d2 && (d2 = null);
            }
            const f2 = !a3.file || a3.isInternalFont, g2 = (0, c.getSymbolsFonts)()[a3.name];
            d2 && f2 && g2 && (d2 = null);
            if (d2) a3.defaultEncoding = (0, o.getEncoding)(d2);
            else {
              const e4 = !!(a3.flags & S.FontFlags.Symbolic), t4 = !!(a3.flags & S.FontFlags.Nonsymbolic);
              u2 = o.StandardEncoding;
              "TrueType" !== a3.type || t4 || (u2 = o.WinAnsiEncoding);
              if (e4 || g2) {
                u2 = o.MacRomanEncoding;
                f2 && (/Symbol/i.test(a3.name) ? u2 = o.SymbolSetEncoding : /Dingbats/i.test(a3.name) ? u2 = o.ZapfDingbatsEncoding : /Wingdings/i.test(a3.name) && (u2 = o.WinAnsiEncoding));
              }
              a3.defaultEncoding = u2;
            }
            a3.differences = h2;
            a3.baseEncodingName = d2;
            a3.hasEncoding = !!d2 || h2.length > 0;
            a3.dict = e3;
            return l2.then((e4) => {
              a3.toUnicode = e4;
              return this.buildToUnicode(a3);
            }).then((e4) => {
              a3.toUnicode = e4;
              s2 && (a3.cidToGidMap = this.readCidToGidMap(s2, e4));
              return a3;
            });
          }
          _simpleFontToUnicode(e3, t3 = false) {
            (0, r.assert)(!e3.composite, "Must be a simple font.");
            const a3 = [], n2 = e3.defaultEncoding.slice(), i2 = e3.baseEncodingName, s2 = e3.differences;
            for (const e4 in s2) {
              const t4 = s2[e4];
              ".notdef" !== t4 && (n2[e4] = t4);
            }
            const c2 = (0, C.getGlyphsUnicode)();
            for (const r2 in n2) {
              let s3 = n2[r2];
              if ("" === s3) continue;
              let l2 = c2[s3];
              if (void 0 !== l2) {
                a3[r2] = String.fromCharCode(l2);
                continue;
              }
              let h2 = 0;
              switch (s3[0]) {
                case "G":
                  3 === s3.length && (h2 = parseInt(s3.substring(1), 16));
                  break;
                case "g":
                  5 === s3.length && (h2 = parseInt(s3.substring(1), 16));
                  break;
                case "C":
                case "c":
                  if (s3.length >= 3 && s3.length <= 4) {
                    const a4 = s3.substring(1);
                    if (t3) {
                      h2 = parseInt(a4, 16);
                      break;
                    }
                    h2 = +a4;
                    if (Number.isNaN(h2) && Number.isInteger(parseInt(a4, 16))) return this._simpleFontToUnicode(e3, true);
                  }
                  break;
                case "u":
                  l2 = (0, v.getUnicodeForGlyph)(s3, c2);
                  -1 !== l2 && (h2 = l2);
                  break;
                default:
                  switch (s3) {
                    case "f_h":
                    case "f_t":
                    case "T_h":
                      a3[r2] = s3.replaceAll("_", "");
                      continue;
                  }
              }
              if (h2 > 0 && h2 <= 1114111 && Number.isInteger(h2)) {
                if (i2 && h2 === +r2) {
                  const e4 = (0, o.getEncoding)(i2);
                  if (e4 && (s3 = e4[r2])) {
                    a3[r2] = String.fromCharCode(c2[s3]);
                    continue;
                  }
                }
                a3[r2] = String.fromCodePoint(h2);
              }
            }
            return a3;
          }
          async buildToUnicode(e3) {
            var _a;
            e3.hasIncludedToUnicodeMap = ((_a = e3.toUnicode) == null ? void 0 : _a.length) > 0;
            if (e3.hasIncludedToUnicodeMap) {
              !e3.composite && e3.hasEncoding && (e3.fallbackToUnicode = this._simpleFontToUnicode(e3));
              return e3.toUnicode;
            }
            if (!e3.composite) return new u.ToUnicodeMap(this._simpleFontToUnicode(e3));
            if (e3.composite && (e3.cMap.builtInCMap && !(e3.cMap instanceof n.IdentityCMap) || "Adobe" === e3.cidSystemInfo.registry && ("GB1" === e3.cidSystemInfo.ordering || "CNS1" === e3.cidSystemInfo.ordering || "Japan1" === e3.cidSystemInfo.ordering || "Korea1" === e3.cidSystemInfo.ordering))) {
              const { registry: t3, ordering: a3 } = e3.cidSystemInfo, s2 = i.Name.get(`${t3}-${a3}-UCS2`), o2 = await n.CMapFactory.create({ encoding: s2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), c2 = [], l2 = [];
              e3.cMap.forEach(function(e4, t4) {
                if (t4 > 65535) throw new r.FormatError("Max size of CID is 65,535");
                const a4 = o2.lookup(t4);
                if (a4) {
                  l2.length = 0;
                  for (let e5 = 0, t5 = a4.length; e5 < t5; e5 += 2) l2.push((a4.charCodeAt(e5) << 8) + a4.charCodeAt(e5 + 1));
                  c2[e4] = String.fromCharCode(...l2);
                }
              });
              return new u.ToUnicodeMap(c2);
            }
            return new u.IdentityToUnicodeMap(e3.firstChar, e3.lastChar);
          }
          readToUnicode(e3) {
            return e3 ? e3 instanceof i.Name ? n.CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }).then(function(e4) {
              return e4 instanceof n.IdentityCMap ? new u.IdentityToUnicodeMap(0, 65535) : new u.ToUnicodeMap(e4.getMap());
            }) : e3 instanceof m.BaseStream ? n.CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }).then(function(e4) {
              if (e4 instanceof n.IdentityCMap) return new u.IdentityToUnicodeMap(0, 65535);
              const t3 = new Array(e4.length);
              e4.forEach(function(e5, a3) {
                if ("number" == typeof a3) {
                  t3[e5] = String.fromCodePoint(a3);
                  return;
                }
                const r2 = [];
                for (let e6 = 0; e6 < a3.length; e6 += 2) {
                  const t4 = a3.charCodeAt(e6) << 8 | a3.charCodeAt(e6 + 1);
                  if (55296 != (63488 & t4)) {
                    r2.push(t4);
                    continue;
                  }
                  e6 += 2;
                  const n2 = a3.charCodeAt(e6) << 8 | a3.charCodeAt(e6 + 1);
                  r2.push(((1023 & t4) << 10) + (1023 & n2) + 65536);
                }
                t3[e5] = String.fromCodePoint(...r2);
              });
              return new u.ToUnicodeMap(t3);
            }, (e4) => {
              if (e4 instanceof r.AbortException) return null;
              if (this.options.ignoreErrors) {
                (0, r.warn)(`readToUnicode - ignoring ToUnicode data: "${e4}".`);
                return null;
              }
              throw e4;
            }) : Promise.resolve(null) : Promise.resolve(null);
          }
          readCidToGidMap(e3, t3) {
            const a3 = [];
            for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) {
              const n3 = e3[r2++] << 8 | e3[r2], i2 = r2 >> 1;
              (0 !== n3 || t3.has(i2)) && (a3[i2] = n3);
            }
            return a3;
          }
          extractWidths(e3, t3, a3) {
            const r2 = this.xref;
            let n2 = [], s2 = 0;
            const o2 = [];
            let c2, l2, h2, u2, d2, f2, g2, p2;
            if (a3.composite) {
              s2 = e3.has("DW") ? e3.get("DW") : 1e3;
              p2 = e3.get("W");
              if (p2) for (l2 = 0, h2 = p2.length; l2 < h2; l2++) {
                f2 = r2.fetchIfRef(p2[l2++]);
                g2 = r2.fetchIfRef(p2[l2]);
                if (Array.isArray(g2)) for (u2 = 0, d2 = g2.length; u2 < d2; u2++) n2[f2++] = r2.fetchIfRef(g2[u2]);
                else {
                  const e4 = r2.fetchIfRef(p2[++l2]);
                  for (u2 = f2; u2 <= g2; u2++) n2[u2] = e4;
                }
              }
              if (a3.vertical) {
                let t4 = e3.getArray("DW2") || [880, -1e3];
                c2 = [t4[1], 0.5 * s2, t4[0]];
                t4 = e3.get("W2");
                if (t4) for (l2 = 0, h2 = t4.length; l2 < h2; l2++) {
                  f2 = r2.fetchIfRef(t4[l2++]);
                  g2 = r2.fetchIfRef(t4[l2]);
                  if (Array.isArray(g2)) for (u2 = 0, d2 = g2.length; u2 < d2; u2++) o2[f2++] = [r2.fetchIfRef(g2[u2++]), r2.fetchIfRef(g2[u2++]), r2.fetchIfRef(g2[u2])];
                  else {
                    const e4 = [r2.fetchIfRef(t4[++l2]), r2.fetchIfRef(t4[++l2]), r2.fetchIfRef(t4[++l2])];
                    for (u2 = f2; u2 <= g2; u2++) o2[u2] = e4;
                  }
                }
              }
            } else {
              const o3 = a3.firstChar;
              p2 = e3.get("Widths");
              if (p2) {
                u2 = o3;
                for (l2 = 0, h2 = p2.length; l2 < h2; l2++) n2[u2++] = r2.fetchIfRef(p2[l2]);
                s2 = parseFloat(t3.get("MissingWidth")) || 0;
              } else {
                const t4 = e3.get("BaseFont");
                if (t4 instanceof i.Name) {
                  const e4 = this.getBaseFontMetrics(t4.name);
                  n2 = this.buildCharCodeToWidth(e4.widths, a3);
                  s2 = e4.defaultWidth;
                }
              }
            }
            let m2 = true, b2 = s2;
            for (const e4 in n2) {
              const t4 = n2[e4];
              if (t4) if (b2) {
                if (b2 !== t4) {
                  m2 = false;
                  break;
                }
              } else b2 = t4;
            }
            m2 ? a3.flags |= S.FontFlags.FixedPitch : a3.flags &= ~S.FontFlags.FixedPitch;
            a3.defaultWidth = s2;
            a3.widths = n2;
            a3.defaultVMetrics = c2;
            a3.vmetrics = o2;
          }
          isSerifFont(e3) {
            const t3 = e3.split("-")[0];
            return t3 in (0, c.getSerifFonts)() || /serif/gi.test(t3);
          }
          getBaseFontMetrics(e3) {
            let t3 = 0, a3 = /* @__PURE__ */ Object.create(null), r2 = false;
            let n2 = (0, c.getStdFontMap)()[e3] || e3;
            const i2 = (0, k.getMetrics)();
            n2 in i2 || (n2 = this.isSerifFont(e3) ? "Times-Roman" : "Helvetica");
            const s2 = i2[n2];
            if ("number" == typeof s2) {
              t3 = s2;
              r2 = true;
            } else a3 = s2();
            return { defaultWidth: t3, monospace: r2, widths: a3 };
          }
          buildCharCodeToWidth(e3, t3) {
            const a3 = /* @__PURE__ */ Object.create(null), r2 = t3.differences, n2 = t3.defaultEncoding;
            for (let t4 = 0; t4 < 256; t4++) t4 in r2 && e3[r2[t4]] ? a3[t4] = e3[r2[t4]] : t4 in n2 && e3[n2[t4]] && (a3[t4] = e3[n2[t4]]);
            return a3;
          }
          preEvaluateFont(e3) {
            const t3 = e3;
            let a3 = e3.get("Subtype");
            if (!(a3 instanceof i.Name)) throw new r.FormatError("invalid font Subtype");
            let n2, s2, o2 = false;
            if ("Type0" === a3.name) {
              const t4 = e3.get("DescendantFonts");
              if (!t4) throw new r.FormatError("Descendant fonts are not specified");
              if (!((e3 = Array.isArray(t4) ? this.xref.fetchIfRef(t4[0]) : t4) instanceof i.Dict)) throw new r.FormatError("Descendant font is not a dictionary.");
              a3 = e3.get("Subtype");
              if (!(a3 instanceof i.Name)) throw new r.FormatError("invalid font Subtype");
              o2 = true;
            }
            const c2 = e3.get("FirstChar") || 0, l2 = e3.get("LastChar") || (o2 ? 65535 : 255), h2 = e3.get("FontDescriptor");
            if (h2) {
              n2 = new O.MurmurHash3_64();
              const a4 = t3.getRaw("Encoding");
              if (a4 instanceof i.Name) n2.update(a4.name);
              else if (a4 instanceof i.Ref) n2.update(a4.toString());
              else if (a4 instanceof i.Dict) {
                for (const e4 of a4.getRawValues()) if (e4 instanceof i.Name) n2.update(e4.name);
                else if (e4 instanceof i.Ref) n2.update(e4.toString());
                else if (Array.isArray(e4)) {
                  const t4 = e4.length, a5 = new Array(t4);
                  for (let r3 = 0; r3 < t4; r3++) {
                    const t5 = e4[r3];
                    t5 instanceof i.Name ? a5[r3] = t5.name : ("number" == typeof t5 || t5 instanceof i.Ref) && (a5[r3] = t5.toString());
                  }
                  n2.update(a5.join());
                }
              }
              n2.update(`${c2}-${l2}`);
              s2 = e3.get("ToUnicode") || t3.get("ToUnicode");
              if (s2 instanceof m.BaseStream) {
                const e4 = s2.str || s2, t4 = e4.buffer ? new Uint8Array(e4.buffer.buffer, 0, e4.bufferLength) : new Uint8Array(e4.bytes.buffer, e4.start, e4.end - e4.start);
                n2.update(t4);
              } else s2 instanceof i.Name && n2.update(s2.name);
              const r2 = e3.get("Widths") || t3.get("Widths");
              if (Array.isArray(r2)) {
                const e4 = [];
                for (const t4 of r2) ("number" == typeof t4 || t4 instanceof i.Ref) && e4.push(t4.toString());
                n2.update(e4.join());
              }
              if (o2) {
                n2.update("compositeFont");
                const a5 = e3.get("W") || t3.get("W");
                if (Array.isArray(a5)) {
                  const e4 = [];
                  for (const t4 of a5) if ("number" == typeof t4 || t4 instanceof i.Ref) e4.push(t4.toString());
                  else if (Array.isArray(t4)) {
                    const a6 = [];
                    for (const e5 of t4) ("number" == typeof e5 || e5 instanceof i.Ref) && a6.push(e5.toString());
                    e4.push(`[${a6.join()}]`);
                  }
                  n2.update(e4.join());
                }
                const r3 = e3.getRaw("CIDToGIDMap") || t3.getRaw("CIDToGIDMap");
                r3 instanceof i.Name ? n2.update(r3.name) : r3 instanceof i.Ref ? n2.update(r3.toString()) : r3 instanceof m.BaseStream && n2.update(r3.peekBytes());
              }
            }
            return { descriptor: h2, dict: e3, baseDict: t3, composite: o2, type: a3.name, firstChar: c2, lastChar: l2, toUnicode: s2, hash: n2 ? n2.hexdigest() : "" };
          }
          async translateFont({ descriptor: e3, dict: t3, baseDict: a3, composite: o2, type: l2, firstChar: u2, lastChar: d2, toUnicode: f2, cssFontInfo: g2 }) {
            const m2 = "Type3" === l2;
            let b2;
            if (!e3) {
              if (!m2) {
                let e4 = t3.get("BaseFont");
                if (!(e4 instanceof i.Name)) throw new r.FormatError("Base font is not specified");
                e4 = e4.name.replaceAll(/[,_]/g, "-");
                const n2 = this.getBaseFontMetrics(e4), o3 = e4.split("-")[0], h2 = (this.isSerifFont(o3) ? S.FontFlags.Serif : 0) | (n2.monospace ? S.FontFlags.FixedPitch : 0) | ((0, c.getSymbolsFonts)()[o3] ? S.FontFlags.Symbolic : S.FontFlags.Nonsymbolic);
                b2 = { type: l2, name: e4, loadedName: a3.loadedName, systemFontInfo: null, widths: n2.widths, defaultWidth: n2.defaultWidth, isSimulatedFlags: true, flags: h2, firstChar: u2, lastChar: d2, toUnicode: f2, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: m2 };
                const g3 = t3.get("Widths"), p2 = (0, c.getStandardFontName)(e4);
                let y3 = null;
                if (p2) {
                  y3 = await this.fetchStandardFontData(p2);
                  b2.isInternalFont = !!y3;
                }
                !b2.isInternalFont && this.options.useSystemFonts && (b2.systemFontInfo = (0, x.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e4, p2));
                return this.extractDataStructures(t3, t3, b2).then((t4) => {
                  if (g3) {
                    const e5 = [];
                    let a4 = u2;
                    for (const t5 of g3) e5[a4++] = this.xref.fetchIfRef(t5);
                    t4.widths = e5;
                  } else t4.widths = this.buildCharCodeToWidth(n2.widths, t4);
                  return new s.Font(e4, y3, t4);
                });
              }
              (e3 = new i.Dict(null)).set("FontName", i.Name.get(l2));
              e3.set("FontBBox", t3.getArray("FontBBox") || [0, 0, 0, 0]);
            }
            let y2 = e3.get("FontName"), w2 = t3.get("BaseFont");
            "string" == typeof y2 && (y2 = i.Name.get(y2));
            "string" == typeof w2 && (w2 = i.Name.get(w2));
            const C2 = y2 == null ? void 0 : y2.name, k2 = w2 == null ? void 0 : w2.name;
            if (!m2 && C2 !== k2) {
              (0, r.info)(`The FontDescriptor's FontName is "${C2}" but should be the same as the Font's BaseFont "${k2}".`);
              C2 && k2 && (k2.startsWith(C2) || !(0, c.isKnownFontName)(C2) && (0, c.isKnownFontName)(k2)) && (y2 = null);
            }
            y2 || (y2 = w2);
            if (!(y2 instanceof i.Name)) throw new r.FormatError("invalid font name");
            let v2, F2, O2, T2, M2;
            try {
              v2 = e3.get("FontFile", "FontFile2", "FontFile3");
            } catch (e4) {
              if (!this.options.ignoreErrors) throw e4;
              (0, r.warn)(`translateFont - fetching "${y2.name}" font file: "${e4}".`);
              v2 = new p.NullStream();
            }
            let D2 = false, E2 = null, N2 = null;
            if (v2) {
              if (v2.dict) {
                const e4 = v2.dict.get("Subtype");
                e4 instanceof i.Name && (F2 = e4.name);
                O2 = v2.dict.get("Length1");
                T2 = v2.dict.get("Length2");
                M2 = v2.dict.get("Length3");
              }
            } else if (g2) {
              const e4 = (0, h.getXfaFontName)(y2.name);
              if (e4) {
                g2.fontFamily = `${g2.fontFamily}-PdfJS-XFA`;
                g2.metrics = e4.metrics || null;
                E2 = e4.factors || null;
                v2 = await this.fetchStandardFontData(e4.name);
                D2 = !!v2;
                a3 = t3 = (0, h.getXfaFontDict)(y2.name);
                o2 = true;
              }
            } else if (!m2) {
              const e4 = (0, c.getStandardFontName)(y2.name);
              if (e4) {
                v2 = await this.fetchStandardFontData(e4);
                D2 = !!v2;
              }
              !D2 && this.options.useSystemFonts && (N2 = (0, x.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, y2.name, e4));
            }
            b2 = { type: l2, name: y2.name, subtype: F2, file: v2, length1: O2, length2: T2, length3: M2, isInternalFont: D2, loadedName: a3.loadedName, composite: o2, fixedPitch: false, fontMatrix: t3.getArray("FontMatrix") || r.FONT_IDENTITY_MATRIX, firstChar: u2, lastChar: d2, toUnicode: f2, bbox: e3.getArray("FontBBox") || t3.getArray("FontBBox"), ascent: e3.get("Ascent"), descent: e3.get("Descent"), xHeight: e3.get("XHeight") || 0, capHeight: e3.get("CapHeight") || 0, flags: e3.get("Flags"), italicAngle: e3.get("ItalicAngle") || 0, isType3Font: m2, cssFontInfo: g2, scaleFactors: E2, systemFontInfo: N2 };
            if (o2) {
              const e4 = a3.get("Encoding");
              e4 instanceof i.Name && (b2.cidEncoding = e4.name);
              const t4 = await n.CMapFactory.create({ encoding: e4, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
              b2.cMap = t4;
              b2.vertical = b2.cMap.vertical;
            }
            return this.extractDataStructures(t3, a3, b2).then((a4) => {
              this.extractWidths(t3, e3, a4);
              return new s.Font(y2.name, v2, a4);
            });
          }
          static buildFontPaths(e3, t3, a3, n2) {
            function buildPath(t4) {
              const i2 = `${e3.loadedName}_path_${t4}`;
              try {
                if (e3.renderer.hasBuiltPath(t4)) return;
                a3.send("commonobj", [i2, "FontPath", e3.renderer.getPathJs(t4)]);
              } catch (e4) {
                if (n2.ignoreErrors) {
                  (0, r.warn)(`buildFontPaths - ignoring ${i2} glyph: "${e4}".`);
                  return;
                }
                throw e4;
              }
            }
            for (const e4 of t3) {
              buildPath(e4.fontChar);
              const t4 = e4.accent;
              (t4 == null ? void 0 : t4.fontChar) && buildPath(t4.fontChar);
            }
          }
          static get fallbackFontDict() {
            const e3 = new i.Dict();
            e3.set("BaseFont", i.Name.get("Helvetica"));
            e3.set("Type", i.Name.get("FallbackType"));
            e3.set("Subtype", i.Name.get("FallbackType"));
            e3.set("Encoding", i.Name.get("WinAnsiEncoding"));
            return (0, r.shadow)(this, "fallbackFontDict", e3);
          }
        }
        t2.PartialEvaluator = PartialEvaluator;
        class TranslatedFont {
          constructor({ loadedName: e3, font: t3, dict: a3, evaluatorOptions: r2 }) {
            this.loadedName = e3;
            this.font = t3;
            this.dict = a3;
            this._evaluatorOptions = r2 || D;
            this.type3Loaded = null;
            this.type3Dependencies = t3.isType3Font ? /* @__PURE__ */ new Set() : null;
            this.sent = false;
          }
          send(e3) {
            if (!this.sent) {
              this.sent = true;
              e3.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]);
            }
          }
          fallback(e3) {
            if (this.font.data) {
              this.font.disableFontFace = true;
              PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e3, this._evaluatorOptions);
            }
          }
          loadType3Data(e3, t3, a3) {
            if (this.type3Loaded) return this.type3Loaded;
            if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
            const n2 = e3.clone({ ignoreErrors: false });
            n2.parsingType3Font = true;
            const s2 = new i.RefSet(e3.type3FontRefs);
            this.dict.objId && !s2.has(this.dict.objId) && s2.put(this.dict.objId);
            n2.type3FontRefs = s2;
            const o2 = this.font, c2 = this.type3Dependencies;
            let l2 = Promise.resolve();
            const h2 = this.dict.get("CharProcs"), u2 = this.dict.get("Resources") || t3, d2 = /* @__PURE__ */ Object.create(null), f2 = r.Util.normalizeRect(o2.bbox || [0, 0, 0, 0]), g2 = f2[2] - f2[0], p2 = f2[3] - f2[1], m2 = Math.hypot(g2, p2);
            for (const e4 of h2.getKeys()) l2 = l2.then(() => {
              const t4 = h2.get(e4), i2 = new T.OperatorList();
              return n2.getOperatorList({ stream: t4, task: a3, resources: u2, operatorList: i2 }).then(() => {
                i2.fnArray[0] === r.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(i2, m2);
                d2[e4] = i2.getIR();
                for (const e5 of i2.dependencies) c2.add(e5);
              }).catch(function(t5) {
                (0, r.warn)(`Type3 font resource "${e4}" is not available.`);
                const a4 = new T.OperatorList();
                d2[e4] = a4.getIR();
              });
            });
            this.type3Loaded = l2.then(() => {
              o2.charProcOperatorList = d2;
              if (this._bbox) {
                o2.isCharBBox = true;
                o2.bbox = this._bbox;
              }
            });
            return this.type3Loaded;
          }
          _removeType3ColorOperators(e3, t3 = NaN) {
            const a3 = r.Util.normalizeRect(e3.argsArray[0].slice(2)), n2 = a3[2] - a3[0], i2 = a3[3] - a3[1], s2 = Math.hypot(n2, i2);
            if (0 === n2 || 0 === i2) {
              e3.fnArray.splice(0, 1);
              e3.argsArray.splice(0, 1);
            } else if (0 === t3 || Math.round(s2 / t3) >= 10) {
              this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]);
              this._bbox[0] = Math.min(this._bbox[0], a3[0]);
              this._bbox[1] = Math.min(this._bbox[1], a3[1]);
              this._bbox[2] = Math.max(this._bbox[2], a3[2]);
              this._bbox[3] = Math.max(this._bbox[3], a3[3]);
            }
            let o2 = 0, c2 = e3.length;
            for (; o2 < c2; ) {
              switch (e3.fnArray[o2]) {
                case r.OPS.setCharWidthAndBounds:
                  break;
                case r.OPS.setStrokeColorSpace:
                case r.OPS.setFillColorSpace:
                case r.OPS.setStrokeColor:
                case r.OPS.setStrokeColorN:
                case r.OPS.setFillColor:
                case r.OPS.setFillColorN:
                case r.OPS.setStrokeGray:
                case r.OPS.setFillGray:
                case r.OPS.setStrokeRGBColor:
                case r.OPS.setFillRGBColor:
                case r.OPS.setStrokeCMYKColor:
                case r.OPS.setFillCMYKColor:
                case r.OPS.shadingFill:
                case r.OPS.setRenderingIntent:
                  e3.fnArray.splice(o2, 1);
                  e3.argsArray.splice(o2, 1);
                  c2--;
                  continue;
                case r.OPS.setGState:
                  const [t4] = e3.argsArray[o2];
                  let a4 = 0, n3 = t4.length;
                  for (; a4 < n3; ) {
                    const [e4] = t4[a4];
                    switch (e4) {
                      case "TR":
                      case "TR2":
                      case "HT":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                        t4.splice(a4, 1);
                        n3--;
                        continue;
                    }
                    a4++;
                  }
              }
              o2++;
            }
          }
        }
        class StateManager {
          constructor(e3 = new EvalState()) {
            this.state = e3;
            this.stateStack = [];
          }
          save() {
            const e3 = this.state;
            this.stateStack.push(this.state);
            this.state = e3.clone();
          }
          restore() {
            const e3 = this.stateStack.pop();
            e3 && (this.state = e3);
          }
          transform(e3) {
            this.state.ctm = r.Util.transform(this.state.ctm, e3);
          }
        }
        class TextState {
          constructor() {
            this.ctm = new Float32Array(r.IDENTITY_MATRIX);
            this.fontName = null;
            this.fontSize = 0;
            this.loadedName = null;
            this.font = null;
            this.fontMatrix = r.FONT_IDENTITY_MATRIX;
            this.textMatrix = r.IDENTITY_MATRIX.slice();
            this.textLineMatrix = r.IDENTITY_MATRIX.slice();
            this.charSpacing = 0;
            this.wordSpacing = 0;
            this.leading = 0;
            this.textHScale = 1;
            this.textRise = 0;
          }
          setTextMatrix(e3, t3, a3, r2, n2, i2) {
            const s2 = this.textMatrix;
            s2[0] = e3;
            s2[1] = t3;
            s2[2] = a3;
            s2[3] = r2;
            s2[4] = n2;
            s2[5] = i2;
          }
          setTextLineMatrix(e3, t3, a3, r2, n2, i2) {
            const s2 = this.textLineMatrix;
            s2[0] = e3;
            s2[1] = t3;
            s2[2] = a3;
            s2[3] = r2;
            s2[4] = n2;
            s2[5] = i2;
          }
          translateTextMatrix(e3, t3) {
            const a3 = this.textMatrix;
            a3[4] = a3[0] * e3 + a3[2] * t3 + a3[4];
            a3[5] = a3[1] * e3 + a3[3] * t3 + a3[5];
          }
          translateTextLineMatrix(e3, t3) {
            const a3 = this.textLineMatrix;
            a3[4] = a3[0] * e3 + a3[2] * t3 + a3[4];
            a3[5] = a3[1] * e3 + a3[3] * t3 + a3[5];
          }
          carriageReturn() {
            this.translateTextLineMatrix(0, -this.leading);
            this.textMatrix = this.textLineMatrix.slice();
          }
          clone() {
            const e3 = Object.create(this);
            e3.textMatrix = this.textMatrix.slice();
            e3.textLineMatrix = this.textLineMatrix.slice();
            e3.fontMatrix = this.fontMatrix.slice();
            return e3;
          }
        }
        class EvalState {
          constructor() {
            this.ctm = new Float32Array(r.IDENTITY_MATRIX);
            this.font = null;
            this.textRenderingMode = r.TextRenderingMode.FILL;
            this.fillColorSpace = y.ColorSpace.singletons.gray;
            this.strokeColorSpace = y.ColorSpace.singletons.gray;
          }
          clone() {
            return Object.create(this);
          }
        }
        const _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
          static get opMap() {
            return (0, r.shadow)(this, "opMap", { w: { id: r.OPS.setLineWidth, numArgs: 1, variableArgs: false }, J: { id: r.OPS.setLineCap, numArgs: 1, variableArgs: false }, j: { id: r.OPS.setLineJoin, numArgs: 1, variableArgs: false }, M: { id: r.OPS.setMiterLimit, numArgs: 1, variableArgs: false }, d: { id: r.OPS.setDash, numArgs: 2, variableArgs: false }, ri: { id: r.OPS.setRenderingIntent, numArgs: 1, variableArgs: false }, i: { id: r.OPS.setFlatness, numArgs: 1, variableArgs: false }, gs: { id: r.OPS.setGState, numArgs: 1, variableArgs: false }, q: { id: r.OPS.save, numArgs: 0, variableArgs: false }, Q: { id: r.OPS.restore, numArgs: 0, variableArgs: false }, cm: { id: r.OPS.transform, numArgs: 6, variableArgs: false }, m: { id: r.OPS.moveTo, numArgs: 2, variableArgs: false }, l: { id: r.OPS.lineTo, numArgs: 2, variableArgs: false }, c: { id: r.OPS.curveTo, numArgs: 6, variableArgs: false }, v: { id: r.OPS.curveTo2, numArgs: 4, variableArgs: false }, y: { id: r.OPS.curveTo3, numArgs: 4, variableArgs: false }, h: { id: r.OPS.closePath, numArgs: 0, variableArgs: false }, re: { id: r.OPS.rectangle, numArgs: 4, variableArgs: false }, S: { id: r.OPS.stroke, numArgs: 0, variableArgs: false }, s: { id: r.OPS.closeStroke, numArgs: 0, variableArgs: false }, f: { id: r.OPS.fill, numArgs: 0, variableArgs: false }, F: { id: r.OPS.fill, numArgs: 0, variableArgs: false }, "f*": { id: r.OPS.eoFill, numArgs: 0, variableArgs: false }, B: { id: r.OPS.fillStroke, numArgs: 0, variableArgs: false }, "B*": { id: r.OPS.eoFillStroke, numArgs: 0, variableArgs: false }, b: { id: r.OPS.closeFillStroke, numArgs: 0, variableArgs: false }, "b*": { id: r.OPS.closeEOFillStroke, numArgs: 0, variableArgs: false }, n: { id: r.OPS.endPath, numArgs: 0, variableArgs: false }, W: { id: r.OPS.clip, numArgs: 0, variableArgs: false }, "W*": { id: r.OPS.eoClip, numArgs: 0, variableArgs: false }, BT: { id: r.OPS.beginText, numArgs: 0, variableArgs: false }, ET: { id: r.OPS.endText, numArgs: 0, variableArgs: false }, Tc: { id: r.OPS.setCharSpacing, numArgs: 1, variableArgs: false }, Tw: { id: r.OPS.setWordSpacing, numArgs: 1, variableArgs: false }, Tz: { id: r.OPS.setHScale, numArgs: 1, variableArgs: false }, TL: { id: r.OPS.setLeading, numArgs: 1, variableArgs: false }, Tf: { id: r.OPS.setFont, numArgs: 2, variableArgs: false }, Tr: { id: r.OPS.setTextRenderingMode, numArgs: 1, variableArgs: false }, Ts: { id: r.OPS.setTextRise, numArgs: 1, variableArgs: false }, Td: { id: r.OPS.moveText, numArgs: 2, variableArgs: false }, TD: { id: r.OPS.setLeadingMoveText, numArgs: 2, variableArgs: false }, Tm: { id: r.OPS.setTextMatrix, numArgs: 6, variableArgs: false }, "T*": { id: r.OPS.nextLine, numArgs: 0, variableArgs: false }, Tj: { id: r.OPS.showText, numArgs: 1, variableArgs: false }, TJ: { id: r.OPS.showSpacedText, numArgs: 1, variableArgs: false }, "'": { id: r.OPS.nextLineShowText, numArgs: 1, variableArgs: false }, '"': { id: r.OPS.nextLineSetSpacingShowText, numArgs: 3, variableArgs: false }, d0: { id: r.OPS.setCharWidth, numArgs: 2, variableArgs: false }, d1: { id: r.OPS.setCharWidthAndBounds, numArgs: 6, variableArgs: false }, CS: { id: r.OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false }, cs: { id: r.OPS.setFillColorSpace, numArgs: 1, variableArgs: false }, SC: { id: r.OPS.setStrokeColor, numArgs: 4, variableArgs: true }, SCN: { id: r.OPS.setStrokeColorN, numArgs: 33, variableArgs: true }, sc: { id: r.OPS.setFillColor, numArgs: 4, variableArgs: true }, scn: { id: r.OPS.setFillColorN, numArgs: 33, variableArgs: true }, G: { id: r.OPS.setStrokeGray, numArgs: 1, variableArgs: false }, g: { id: r.OPS.setFillGray, numArgs: 1, variableArgs: false }, RG: { id: r.OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false }, rg: { id: r.OPS.setFillRGBColor, numArgs: 3, variableArgs: false }, K: { id: r.OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false }, k: { id: r.OPS.setFillCMYKColor, numArgs: 4, variableArgs: false }, sh: { id: r.OPS.shadingFill, numArgs: 1, variableArgs: false }, BI: { id: r.OPS.beginInlineImage, numArgs: 0, variableArgs: false }, ID: { id: r.OPS.beginImageData, numArgs: 0, variableArgs: false }, EI: { id: r.OPS.endInlineImage, numArgs: 1, variableArgs: false }, Do: { id: r.OPS.paintXObject, numArgs: 1, variableArgs: false }, MP: { id: r.OPS.markPoint, numArgs: 1, variableArgs: false }, DP: { id: r.OPS.markPointProps, numArgs: 2, variableArgs: false }, BMC: { id: r.OPS.beginMarkedContent, numArgs: 1, variableArgs: false }, BDC: { id: r.OPS.beginMarkedContentProps, numArgs: 2, variableArgs: false }, EMC: { id: r.OPS.endMarkedContent, numArgs: 0, variableArgs: false }, BX: { id: r.OPS.beginCompat, numArgs: 0, variableArgs: false }, EX: { id: r.OPS.endCompat, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null });
          }
          constructor(e3, t3, a3 = new StateManager()) {
            this.parser = new f.Parser({ lexer: new f.Lexer(e3, _EvaluatorPreprocessor.opMap), xref: t3 });
            this.stateManager = a3;
            this.nonProcessedArgs = [];
            this._isPathOp = false;
            this._numInvalidPathOPS = 0;
          }
          get savedStatesDepth() {
            return this.stateManager.stateStack.length;
          }
          read(e3) {
            let t3 = e3.args;
            for (; ; ) {
              const a3 = this.parser.getObj();
              if (a3 instanceof i.Cmd) {
                const n2 = a3.cmd, i2 = _EvaluatorPreprocessor.opMap[n2];
                if (!i2) {
                  (0, r.warn)(`Unknown command "${n2}".`);
                  continue;
                }
                const s2 = i2.id, o2 = i2.numArgs;
                let c2 = null !== t3 ? t3.length : 0;
                this._isPathOp || (this._numInvalidPathOPS = 0);
                this._isPathOp = s2 >= r.OPS.moveTo && s2 <= r.OPS.endPath;
                if (i2.variableArgs) c2 > o2 && (0, r.info)(`Command ${n2}: expected [0, ${o2}] args, but received ${c2} args.`);
                else {
                  if (c2 !== o2) {
                    const e4 = this.nonProcessedArgs;
                    for (; c2 > o2; ) {
                      e4.push(t3.shift());
                      c2--;
                    }
                    for (; c2 < o2 && 0 !== e4.length; ) {
                      null === t3 && (t3 = []);
                      t3.unshift(e4.pop());
                      c2++;
                    }
                  }
                  if (c2 < o2) {
                    const e4 = `command ${n2}: expected ${o2} args, but received ${c2} args.`;
                    if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new r.FormatError(`Invalid ${e4}`);
                    (0, r.warn)(`Skipping ${e4}`);
                    null !== t3 && (t3.length = 0);
                    continue;
                  }
                }
                this.preprocessCommand(s2, t3);
                e3.fn = s2;
                e3.args = t3;
                return true;
              }
              if (a3 === i.EOF) return false;
              if (null !== a3) {
                null === t3 && (t3 = []);
                t3.push(a3);
                if (t3.length > 33) throw new r.FormatError("Too many arguments");
              }
            }
          }
          preprocessCommand(e3, t3) {
            switch (0 | e3) {
              case r.OPS.save:
                this.stateManager.save();
                break;
              case r.OPS.restore:
                this.stateManager.restore();
                break;
              case r.OPS.transform:
                this.stateManager.transform(t3);
            }
          }
        };
        __publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
        let EvaluatorPreprocessor = _EvaluatorPreprocessor;
        t2.EvaluatorPreprocessor = EvaluatorPreprocessor;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.IdentityCMap = t2.CMapFactory = t2.CMap = void 0;
        var r = a2(2), n = a2(4), i = a2(5), s = a2(15), o = a2(16), c = a2(3), l = a2(8);
        const h = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], u = 2 ** 24 - 1;
        class CMap {
          constructor(e3 = false) {
            this.codespaceRanges = [[], [], [], []];
            this.numCodespaceRanges = 0;
            this._map = [];
            this.name = "";
            this.vertical = false;
            this.useCMap = null;
            this.builtInCMap = e3;
          }
          addCodespaceRange(e3, t3, a3) {
            this.codespaceRanges[e3 - 1].push(t3, a3);
            this.numCodespaceRanges++;
          }
          mapCidRange(e3, t3, a3) {
            if (t3 - e3 > u) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
            for (; e3 <= t3; ) this._map[e3++] = a3++;
          }
          mapBfRange(e3, t3, a3) {
            if (t3 - e3 > u) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
            const r2 = a3.length - 1;
            for (; e3 <= t3; ) {
              this._map[e3++] = a3;
              const t4 = a3.charCodeAt(r2) + 1;
              t4 > 255 ? a3 = a3.substring(0, r2 - 1) + String.fromCharCode(a3.charCodeAt(r2 - 1) + 1) + "\0" : a3 = a3.substring(0, r2) + String.fromCharCode(t4);
            }
          }
          mapBfRangeToArray(e3, t3, a3) {
            if (t3 - e3 > u) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
            const r2 = a3.length;
            let n2 = 0;
            for (; e3 <= t3 && n2 < r2; ) {
              this._map[e3] = a3[n2++];
              ++e3;
            }
          }
          mapOne(e3, t3) {
            this._map[e3] = t3;
          }
          lookup(e3) {
            return this._map[e3];
          }
          contains(e3) {
            return void 0 !== this._map[e3];
          }
          forEach(e3) {
            const t3 = this._map, a3 = t3.length;
            if (a3 <= 65536) for (let r2 = 0; r2 < a3; r2++) void 0 !== t3[r2] && e3(r2, t3[r2]);
            else for (const a4 in t3) e3(a4, t3[a4]);
          }
          charCodeOf(e3) {
            const t3 = this._map;
            if (t3.length <= 65536) return t3.indexOf(e3);
            for (const a3 in t3) if (t3[a3] === e3) return 0 | a3;
            return -1;
          }
          getMap() {
            return this._map;
          }
          readCharCode(e3, t3, a3) {
            let r2 = 0;
            const n2 = this.codespaceRanges;
            for (let i2 = 0, s2 = n2.length; i2 < s2; i2++) {
              r2 = (r2 << 8 | e3.charCodeAt(t3 + i2)) >>> 0;
              const s3 = n2[i2];
              for (let e4 = 0, t4 = s3.length; e4 < t4; ) {
                const t5 = s3[e4++], n3 = s3[e4++];
                if (r2 >= t5 && r2 <= n3) {
                  a3.charcode = r2;
                  a3.length = i2 + 1;
                  return;
                }
              }
            }
            a3.charcode = 0;
            a3.length = 1;
          }
          getCharCodeLength(e3) {
            const t3 = this.codespaceRanges;
            for (let a3 = 0, r2 = t3.length; a3 < r2; a3++) {
              const r3 = t3[a3];
              for (let t4 = 0, n2 = r3.length; t4 < n2; ) {
                const n3 = r3[t4++], i2 = r3[t4++];
                if (e3 >= n3 && e3 <= i2) return a3 + 1;
              }
            }
            return 1;
          }
          get length() {
            return this._map.length;
          }
          get isIdentityCMap() {
            if ("Identity-H" !== this.name && "Identity-V" !== this.name) return false;
            if (65536 !== this._map.length) return false;
            for (let e3 = 0; e3 < 65536; e3++) if (this._map[e3] !== e3) return false;
            return true;
          }
        }
        t2.CMap = CMap;
        class IdentityCMap extends CMap {
          constructor(e3, t3) {
            super();
            this.vertical = e3;
            this.addCodespaceRange(t3, 0, 65535);
          }
          mapCidRange(e3, t3, a3) {
            (0, r.unreachable)("should not call mapCidRange");
          }
          mapBfRange(e3, t3, a3) {
            (0, r.unreachable)("should not call mapBfRange");
          }
          mapBfRangeToArray(e3, t3, a3) {
            (0, r.unreachable)("should not call mapBfRangeToArray");
          }
          mapOne(e3, t3) {
            (0, r.unreachable)("should not call mapCidOne");
          }
          lookup(e3) {
            return Number.isInteger(e3) && e3 <= 65535 ? e3 : void 0;
          }
          contains(e3) {
            return Number.isInteger(e3) && e3 <= 65535;
          }
          forEach(e3) {
            for (let t3 = 0; t3 <= 65535; t3++) e3(t3, t3);
          }
          charCodeOf(e3) {
            return Number.isInteger(e3) && e3 <= 65535 ? e3 : -1;
          }
          getMap() {
            const e3 = new Array(65536);
            for (let t3 = 0; t3 <= 65535; t3++) e3[t3] = t3;
            return e3;
          }
          get length() {
            return 65536;
          }
          get isIdentityCMap() {
            (0, r.unreachable)("should not access .isIdentityCMap");
          }
        }
        t2.IdentityCMap = IdentityCMap;
        function strToInt(e3) {
          let t3 = 0;
          for (let a3 = 0; a3 < e3.length; a3++) t3 = t3 << 8 | e3.charCodeAt(a3);
          return t3 >>> 0;
        }
        function expectString(e3) {
          if ("string" != typeof e3) throw new r.FormatError("Malformed CMap: expected string.");
        }
        function expectInt(e3) {
          if (!Number.isInteger(e3)) throw new r.FormatError("Malformed CMap: expected int.");
        }
        function parseBfChar(e3, t3) {
          for (; ; ) {
            let a3 = t3.getObj();
            if (a3 === n.EOF) break;
            if ((0, n.isCmd)(a3, "endbfchar")) return;
            expectString(a3);
            const r2 = strToInt(a3);
            a3 = t3.getObj();
            expectString(a3);
            const i2 = a3;
            e3.mapOne(r2, i2);
          }
        }
        function parseBfRange(e3, t3) {
          for (; ; ) {
            let a3 = t3.getObj();
            if (a3 === n.EOF) break;
            if ((0, n.isCmd)(a3, "endbfrange")) return;
            expectString(a3);
            const r2 = strToInt(a3);
            a3 = t3.getObj();
            expectString(a3);
            const i2 = strToInt(a3);
            a3 = t3.getObj();
            if (Number.isInteger(a3) || "string" == typeof a3) {
              const t4 = Number.isInteger(a3) ? String.fromCharCode(a3) : a3;
              e3.mapBfRange(r2, i2, t4);
            } else {
              if (!(0, n.isCmd)(a3, "[")) break;
              {
                a3 = t3.getObj();
                const s2 = [];
                for (; !(0, n.isCmd)(a3, "]") && a3 !== n.EOF; ) {
                  s2.push(a3);
                  a3 = t3.getObj();
                }
                e3.mapBfRangeToArray(r2, i2, s2);
              }
            }
          }
          throw new r.FormatError("Invalid bf range.");
        }
        function parseCidChar(e3, t3) {
          for (; ; ) {
            let a3 = t3.getObj();
            if (a3 === n.EOF) break;
            if ((0, n.isCmd)(a3, "endcidchar")) return;
            expectString(a3);
            const r2 = strToInt(a3);
            a3 = t3.getObj();
            expectInt(a3);
            const i2 = a3;
            e3.mapOne(r2, i2);
          }
        }
        function parseCidRange(e3, t3) {
          for (; ; ) {
            let a3 = t3.getObj();
            if (a3 === n.EOF) break;
            if ((0, n.isCmd)(a3, "endcidrange")) return;
            expectString(a3);
            const r2 = strToInt(a3);
            a3 = t3.getObj();
            expectString(a3);
            const i2 = strToInt(a3);
            a3 = t3.getObj();
            expectInt(a3);
            const s2 = a3;
            e3.mapCidRange(r2, i2, s2);
          }
        }
        function parseCodespaceRange(e3, t3) {
          for (; ; ) {
            let a3 = t3.getObj();
            if (a3 === n.EOF) break;
            if ((0, n.isCmd)(a3, "endcodespacerange")) return;
            if ("string" != typeof a3) break;
            const r2 = strToInt(a3);
            a3 = t3.getObj();
            if ("string" != typeof a3) break;
            const i2 = strToInt(a3);
            e3.addCodespaceRange(a3.length, r2, i2);
          }
          throw new r.FormatError("Invalid codespace range.");
        }
        function parseWMode(e3, t3) {
          const a3 = t3.getObj();
          Number.isInteger(a3) && (e3.vertical = !!a3);
        }
        function parseCMapName(e3, t3) {
          const a3 = t3.getObj();
          a3 instanceof n.Name && (e3.name = a3.name);
        }
        async function parseCMap(e3, t3, a3, i2) {
          let s2, o2;
          e: for (; ; ) try {
            const a4 = t3.getObj();
            if (a4 === n.EOF) break;
            if (a4 instanceof n.Name) {
              "WMode" === a4.name ? parseWMode(e3, t3) : "CMapName" === a4.name && parseCMapName(e3, t3);
              s2 = a4;
            } else if (a4 instanceof n.Cmd) switch (a4.cmd) {
              case "endcmap":
                break e;
              case "usecmap":
                s2 instanceof n.Name && (o2 = s2.name);
                break;
              case "begincodespacerange":
                parseCodespaceRange(e3, t3);
                break;
              case "beginbfchar":
                parseBfChar(e3, t3);
                break;
              case "begincidchar":
                parseCidChar(e3, t3);
                break;
              case "beginbfrange":
                parseBfRange(e3, t3);
                break;
              case "begincidrange":
                parseCidRange(e3, t3);
            }
          } catch (e4) {
            if (e4 instanceof c.MissingDataException) throw e4;
            (0, r.warn)("Invalid cMap data: " + e4);
            continue;
          }
          !i2 && o2 && (i2 = o2);
          return i2 ? extendCMap(e3, a3, i2) : e3;
        }
        async function extendCMap(e3, t3, a3) {
          e3.useCMap = await createBuiltInCMap(a3, t3);
          if (0 === e3.numCodespaceRanges) {
            const t4 = e3.useCMap.codespaceRanges;
            for (let a4 = 0; a4 < t4.length; a4++) e3.codespaceRanges[a4] = t4[a4].slice();
            e3.numCodespaceRanges = e3.useCMap.numCodespaceRanges;
          }
          e3.useCMap.forEach(function(t4, a4) {
            e3.contains(t4) || e3.mapOne(t4, e3.useCMap.lookup(t4));
          });
          return e3;
        }
        async function createBuiltInCMap(e3, t3) {
          if ("Identity-H" === e3) return new IdentityCMap(false, 2);
          if ("Identity-V" === e3) return new IdentityCMap(true, 2);
          if (!h.includes(e3)) throw new Error("Unknown CMap name: " + e3);
          if (!t3) throw new Error("Built-in CMap parameters are not provided.");
          const { cMapData: a3, compressionType: n2 } = await t3(e3), i2 = new CMap(true);
          if (n2 === r.CMapCompressionType.BINARY) return new s.BinaryCMapReader().process(a3, i2, (e4) => extendCMap(i2, t3, e4));
          if (n2 === r.CMapCompressionType.NONE) {
            const e4 = new o.Lexer(new l.Stream(a3));
            return parseCMap(i2, e4, t3, null);
          }
          throw new Error(`Invalid CMap "compressionType" value: ${n2}`);
        }
        t2.CMapFactory = class CMapFactory {
          static async create({ encoding: e3, fetchBuiltInCMap: t3, useCMap: a3 }) {
            if (e3 instanceof n.Name) return createBuiltInCMap(e3.name, t3);
            if (e3 instanceof i.BaseStream) {
              const r2 = await parseCMap(new CMap(), new o.Lexer(e3), t3, a3);
              return r2.isIdentityCMap ? createBuiltInCMap(r2.name, t3) : r2;
            }
            throw new Error("Encoding required.");
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.BinaryCMapReader = void 0;
        var r = a2(2);
        function hexToInt(e3, t3) {
          let a3 = 0;
          for (let r2 = 0; r2 <= t3; r2++) a3 = a3 << 8 | e3[r2];
          return a3 >>> 0;
        }
        function hexToStr(e3, t3) {
          return 1 === t3 ? String.fromCharCode(e3[0], e3[1]) : 3 === t3 ? String.fromCharCode(e3[0], e3[1], e3[2], e3[3]) : String.fromCharCode(...e3.subarray(0, t3 + 1));
        }
        function addHex(e3, t3, a3) {
          let r2 = 0;
          for (let n2 = a3; n2 >= 0; n2--) {
            r2 += e3[n2] + t3[n2];
            e3[n2] = 255 & r2;
            r2 >>= 8;
          }
        }
        function incHex(e3, t3) {
          let a3 = 1;
          for (let r2 = t3; r2 >= 0 && a3 > 0; r2--) {
            a3 += e3[r2];
            e3[r2] = 255 & a3;
            a3 >>= 8;
          }
        }
        const n = 16;
        class BinaryCMapStream {
          constructor(e3) {
            this.buffer = e3;
            this.pos = 0;
            this.end = e3.length;
            this.tmpBuf = new Uint8Array(19);
          }
          readByte() {
            return this.pos >= this.end ? -1 : this.buffer[this.pos++];
          }
          readNumber() {
            let e3, t3 = 0;
            do {
              const a3 = this.readByte();
              if (a3 < 0) throw new r.FormatError("unexpected EOF in bcmap");
              e3 = !(128 & a3);
              t3 = t3 << 7 | 127 & a3;
            } while (!e3);
            return t3;
          }
          readSigned() {
            const e3 = this.readNumber();
            return 1 & e3 ? ~(e3 >>> 1) : e3 >>> 1;
          }
          readHex(e3, t3) {
            e3.set(this.buffer.subarray(this.pos, this.pos + t3 + 1));
            this.pos += t3 + 1;
          }
          readHexNumber(e3, t3) {
            let a3;
            const n2 = this.tmpBuf;
            let i = 0;
            do {
              const e4 = this.readByte();
              if (e4 < 0) throw new r.FormatError("unexpected EOF in bcmap");
              a3 = !(128 & e4);
              n2[i++] = 127 & e4;
            } while (!a3);
            let s = t3, o = 0, c = 0;
            for (; s >= 0; ) {
              for (; c < 8 && n2.length > 0; ) {
                o |= n2[--i] << c;
                c += 7;
              }
              e3[s] = 255 & o;
              s--;
              o >>= 8;
              c -= 8;
            }
          }
          readHexSigned(e3, t3) {
            this.readHexNumber(e3, t3);
            const a3 = 1 & e3[t3] ? 255 : 0;
            let r2 = 0;
            for (let n2 = 0; n2 <= t3; n2++) {
              r2 = (1 & r2) << 8 | e3[n2];
              e3[n2] = r2 >> 1 ^ a3;
            }
          }
          readString() {
            const e3 = this.readNumber(), t3 = new Array(e3);
            for (let a3 = 0; a3 < e3; a3++) t3[a3] = this.readNumber();
            return String.fromCharCode(...t3);
          }
        }
        t2.BinaryCMapReader = class BinaryCMapReader {
          async process(e3, t3, a3) {
            const r2 = new BinaryCMapStream(e3), i = r2.readByte();
            t3.vertical = !!(1 & i);
            let s = null;
            const o = new Uint8Array(n), c = new Uint8Array(n), l = new Uint8Array(n), h = new Uint8Array(n), u = new Uint8Array(n);
            let d, f;
            for (; (f = r2.readByte()) >= 0; ) {
              const e4 = f >> 5;
              if (7 === e4) {
                switch (31 & f) {
                  case 0:
                    r2.readString();
                    break;
                  case 1:
                    s = r2.readString();
                }
                continue;
              }
              const a4 = !!(16 & f), i2 = 15 & f;
              if (i2 + 1 > n) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
              const g = 1, p = r2.readNumber();
              switch (e4) {
                case 0:
                  r2.readHex(o, i2);
                  r2.readHexNumber(c, i2);
                  addHex(c, o, i2);
                  t3.addCodespaceRange(i2 + 1, hexToInt(o, i2), hexToInt(c, i2));
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(c, i2);
                    r2.readHexNumber(o, i2);
                    addHex(o, c, i2);
                    r2.readHexNumber(c, i2);
                    addHex(c, o, i2);
                    t3.addCodespaceRange(i2 + 1, hexToInt(o, i2), hexToInt(c, i2));
                  }
                  break;
                case 1:
                  r2.readHex(o, i2);
                  r2.readHexNumber(c, i2);
                  addHex(c, o, i2);
                  r2.readNumber();
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(c, i2);
                    r2.readHexNumber(o, i2);
                    addHex(o, c, i2);
                    r2.readHexNumber(c, i2);
                    addHex(c, o, i2);
                    r2.readNumber();
                  }
                  break;
                case 2:
                  r2.readHex(l, i2);
                  d = r2.readNumber();
                  t3.mapOne(hexToInt(l, i2), d);
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(l, i2);
                    if (!a4) {
                      r2.readHexNumber(u, i2);
                      addHex(l, u, i2);
                    }
                    d = r2.readSigned() + (d + 1);
                    t3.mapOne(hexToInt(l, i2), d);
                  }
                  break;
                case 3:
                  r2.readHex(o, i2);
                  r2.readHexNumber(c, i2);
                  addHex(c, o, i2);
                  d = r2.readNumber();
                  t3.mapCidRange(hexToInt(o, i2), hexToInt(c, i2), d);
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(c, i2);
                    if (a4) o.set(c);
                    else {
                      r2.readHexNumber(o, i2);
                      addHex(o, c, i2);
                    }
                    r2.readHexNumber(c, i2);
                    addHex(c, o, i2);
                    d = r2.readNumber();
                    t3.mapCidRange(hexToInt(o, i2), hexToInt(c, i2), d);
                  }
                  break;
                case 4:
                  r2.readHex(l, g);
                  r2.readHex(h, i2);
                  t3.mapOne(hexToInt(l, g), hexToStr(h, i2));
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(l, g);
                    if (!a4) {
                      r2.readHexNumber(u, g);
                      addHex(l, u, g);
                    }
                    incHex(h, i2);
                    r2.readHexSigned(u, i2);
                    addHex(h, u, i2);
                    t3.mapOne(hexToInt(l, g), hexToStr(h, i2));
                  }
                  break;
                case 5:
                  r2.readHex(o, g);
                  r2.readHexNumber(c, g);
                  addHex(c, o, g);
                  r2.readHex(h, i2);
                  t3.mapBfRange(hexToInt(o, g), hexToInt(c, g), hexToStr(h, i2));
                  for (let e5 = 1; e5 < p; e5++) {
                    incHex(c, g);
                    if (a4) o.set(c);
                    else {
                      r2.readHexNumber(o, g);
                      addHex(o, c, g);
                    }
                    r2.readHexNumber(c, g);
                    addHex(c, o, g);
                    r2.readHex(h, i2);
                    t3.mapBfRange(hexToInt(o, g), hexToInt(c, g), hexToStr(h, i2));
                  }
                  break;
                default:
                  throw new Error(`BinaryCMapReader.process - unknown type: ${e4}`);
              }
            }
            return s ? a3(s) : t3;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Parser = t2.Linearization = t2.Lexer = void 0;
        var r = a2(2), n = a2(4), i = a2(3), s = a2(8), o = a2(17), c = a2(19), l = a2(20), h = a2(22), u = a2(23), d = a2(26), f = a2(29), g = a2(31), p = a2(32), m = a2(33);
        class Parser {
          constructor({ lexer: e3, xref: t3, allowStreams: a3 = false, recoveryMode: r2 = false }) {
            this.lexer = e3;
            this.xref = t3;
            this.allowStreams = a3;
            this.recoveryMode = r2;
            this.imageCache = /* @__PURE__ */ Object.create(null);
            this._imageId = 0;
            this.refill();
          }
          refill() {
            this.buf1 = this.lexer.getObj();
            this.buf2 = this.lexer.getObj();
          }
          shift() {
            if (this.buf2 instanceof n.Cmd && "ID" === this.buf2.cmd) {
              this.buf1 = this.buf2;
              this.buf2 = null;
            } else {
              this.buf1 = this.buf2;
              this.buf2 = this.lexer.getObj();
            }
          }
          tryShift() {
            try {
              this.shift();
              return true;
            } catch (e3) {
              if (e3 instanceof i.MissingDataException) throw e3;
              return false;
            }
          }
          getObj(e3 = null) {
            const t3 = this.buf1;
            this.shift();
            if (t3 instanceof n.Cmd) switch (t3.cmd) {
              case "BI":
                return this.makeInlineImage(e3);
              case "[":
                const a3 = [];
                for (; !(0, n.isCmd)(this.buf1, "]") && this.buf1 !== n.EOF; ) a3.push(this.getObj(e3));
                if (this.buf1 === n.EOF) {
                  if (this.recoveryMode) return a3;
                  throw new i.ParserEOFException("End of file inside array.");
                }
                this.shift();
                return a3;
              case "<<":
                const s2 = new n.Dict(this.xref);
                for (; !(0, n.isCmd)(this.buf1, ">>") && this.buf1 !== n.EOF; ) {
                  if (!(this.buf1 instanceof n.Name)) {
                    (0, r.info)("Malformed dictionary: key must be a name object");
                    this.shift();
                    continue;
                  }
                  const t4 = this.buf1.name;
                  this.shift();
                  if (this.buf1 === n.EOF) break;
                  s2.set(t4, this.getObj(e3));
                }
                if (this.buf1 === n.EOF) {
                  if (this.recoveryMode) return s2;
                  throw new i.ParserEOFException("End of file inside dictionary.");
                }
                if ((0, n.isCmd)(this.buf2, "stream")) return this.allowStreams ? this.makeStream(s2, e3) : s2;
                this.shift();
                return s2;
              default:
                return t3;
            }
            if (Number.isInteger(t3)) {
              if (Number.isInteger(this.buf1) && (0, n.isCmd)(this.buf2, "R")) {
                const e4 = n.Ref.get(t3, this.buf1);
                this.shift();
                this.shift();
                return e4;
              }
              return t3;
            }
            return "string" == typeof t3 && e3 ? e3.decryptString(t3) : t3;
          }
          findDefaultInlineStreamEnd(e3) {
            const { knownCommands: t3 } = this.lexer, a3 = e3.pos;
            let o2, c2, l2 = 0;
            for (; -1 !== (o2 = e3.getByte()); ) if (0 === l2) l2 = 69 === o2 ? 1 : 0;
            else if (1 === l2) l2 = 73 === o2 ? 2 : 0;
            else if (32 === o2 || 10 === o2 || 13 === o2) {
              c2 = e3.pos;
              const a4 = e3.peekBytes(15), i2 = a4.length;
              if (0 === i2) break;
              for (let e4 = 0; e4 < i2; e4++) {
                o2 = a4[e4];
                if ((0 !== o2 || 0 === a4[e4 + 1]) && (10 !== o2 && 13 !== o2 && (o2 < 32 || o2 > 127))) {
                  l2 = 0;
                  break;
                }
              }
              if (2 !== l2) continue;
              if (!t3) {
                (0, r.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                continue;
              }
              const h3 = new Lexer(new s.Stream(a4.slice()), t3);
              h3._hexStringWarn = () => {
              };
              let u2 = 0;
              for (; ; ) {
                const e4 = h3.getObj();
                if (e4 === n.EOF) {
                  l2 = 0;
                  break;
                }
                if (e4 instanceof n.Cmd) {
                  const a5 = t3[e4.cmd];
                  if (!a5) {
                    l2 = 0;
                    break;
                  }
                  if (a5.variableArgs ? u2 <= a5.numArgs : u2 === a5.numArgs) break;
                  u2 = 0;
                } else u2++;
              }
              if (2 === l2) break;
            } else l2 = 0;
            if (-1 === o2) {
              (0, r.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
              if (c2) {
                (0, r.warn)('... trying to recover by using the last "EI" occurrence.');
                e3.skip(-(e3.pos - c2));
              }
            }
            let h2 = 4;
            e3.skip(-h2);
            o2 = e3.peekByte();
            e3.skip(h2);
            (0, i.isWhiteSpace)(o2) || h2--;
            return e3.pos - h2 - a3;
          }
          findDCTDecodeInlineStreamEnd(e3) {
            const t3 = e3.pos;
            let a3, n2, i2 = false;
            for (; -1 !== (a3 = e3.getByte()); ) if (255 === a3) {
              switch (e3.getByte()) {
                case 0:
                  break;
                case 255:
                  e3.skip(-1);
                  break;
                case 217:
                  i2 = true;
                  break;
                case 192:
                case 193:
                case 194:
                case 195:
                case 197:
                case 198:
                case 199:
                case 201:
                case 202:
                case 203:
                case 205:
                case 206:
                case 207:
                case 196:
                case 204:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                case 225:
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 238:
                case 239:
                case 254:
                  n2 = e3.getUint16();
                  n2 > 2 ? e3.skip(n2 - 2) : e3.skip(-2);
              }
              if (i2) break;
            }
            const s2 = e3.pos - t3;
            if (-1 === a3) {
              (0, r.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
              e3.skip(-s2);
              return this.findDefaultInlineStreamEnd(e3);
            }
            this.inlineStreamSkipEI(e3);
            return s2;
          }
          findASCII85DecodeInlineStreamEnd(e3) {
            const t3 = e3.pos;
            let a3;
            for (; -1 !== (a3 = e3.getByte()); ) if (126 === a3) {
              const t4 = e3.pos;
              a3 = e3.peekByte();
              for (; (0, i.isWhiteSpace)(a3); ) {
                e3.skip();
                a3 = e3.peekByte();
              }
              if (62 === a3) {
                e3.skip();
                break;
              }
              if (e3.pos > t4) {
                const t5 = e3.peekBytes(2);
                if (69 === t5[0] && 73 === t5[1]) break;
              }
            }
            const n2 = e3.pos - t3;
            if (-1 === a3) {
              (0, r.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
              e3.skip(-n2);
              return this.findDefaultInlineStreamEnd(e3);
            }
            this.inlineStreamSkipEI(e3);
            return n2;
          }
          findASCIIHexDecodeInlineStreamEnd(e3) {
            const t3 = e3.pos;
            let a3;
            for (; -1 !== (a3 = e3.getByte()) && 62 !== a3; ) ;
            const n2 = e3.pos - t3;
            if (-1 === a3) {
              (0, r.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
              e3.skip(-n2);
              return this.findDefaultInlineStreamEnd(e3);
            }
            this.inlineStreamSkipEI(e3);
            return n2;
          }
          inlineStreamSkipEI(e3) {
            let t3, a3 = 0;
            for (; -1 !== (t3 = e3.getByte()); ) if (0 === a3) a3 = 69 === t3 ? 1 : 0;
            else if (1 === a3) a3 = 73 === t3 ? 2 : 0;
            else if (2 === a3) break;
          }
          makeInlineImage(e3) {
            const t3 = this.lexer, a3 = t3.stream, i2 = /* @__PURE__ */ Object.create(null);
            let s2;
            for (; !(0, n.isCmd)(this.buf1, "ID") && this.buf1 !== n.EOF; ) {
              if (!(this.buf1 instanceof n.Name)) throw new r.FormatError("Dictionary key must be a name object");
              const t4 = this.buf1.name;
              this.shift();
              if (this.buf1 === n.EOF) break;
              i2[t4] = this.getObj(e3);
            }
            -1 !== t3.beginInlineImagePos && (s2 = a3.pos - t3.beginInlineImagePos);
            const o2 = this.xref.fetchIfRef(i2.F || i2.Filter);
            let c2;
            if (o2 instanceof n.Name) c2 = o2.name;
            else if (Array.isArray(o2)) {
              const e4 = this.xref.fetchIfRef(o2[0]);
              e4 instanceof n.Name && (c2 = e4.name);
            }
            const l2 = a3.pos;
            let h2, u2;
            switch (c2) {
              case "DCT":
              case "DCTDecode":
                h2 = this.findDCTDecodeInlineStreamEnd(a3);
                break;
              case "A85":
              case "ASCII85Decode":
                h2 = this.findASCII85DecodeInlineStreamEnd(a3);
                break;
              case "AHx":
              case "ASCIIHexDecode":
                h2 = this.findASCIIHexDecodeInlineStreamEnd(a3);
                break;
              default:
                h2 = this.findDefaultInlineStreamEnd(a3);
            }
            if (h2 < 1e3 && s2 > 0) {
              const e4 = a3.pos;
              a3.pos = t3.beginInlineImagePos;
              u2 = function getInlineImageCacheKey(e5) {
                const t4 = [], a4 = e5.length;
                let r3 = 0;
                for (; r3 < a4 - 1; ) t4.push(e5[r3++] << 8 | e5[r3++]);
                r3 < a4 && t4.push(e5[r3]);
                return a4 + "_" + String.fromCharCode.apply(null, t4);
              }(a3.getBytes(s2 + h2));
              a3.pos = e4;
              const r2 = this.imageCache[u2];
              if (void 0 !== r2) {
                this.buf2 = n.Cmd.get("EI");
                this.shift();
                r2.reset();
                return r2;
              }
            }
            const d2 = new n.Dict(this.xref);
            for (const e4 in i2) d2.set(e4, i2[e4]);
            let f2 = a3.makeSubStream(l2, h2, d2);
            e3 && (f2 = e3.createStream(f2, h2));
            f2 = this.filter(f2, d2, h2);
            f2.dict = d2;
            if (void 0 !== u2) {
              f2.cacheKey = "inline_img_" + ++this._imageId;
              this.imageCache[u2] = f2;
            }
            this.buf2 = n.Cmd.get("EI");
            this.shift();
            return f2;
          }
          _findStreamLength(e3, t3) {
            const { stream: a3 } = this.lexer;
            a3.pos = e3;
            const r2 = t3.length;
            for (; a3.pos < a3.end; ) {
              const n2 = a3.peekBytes(2048), i2 = n2.length - r2;
              if (i2 <= 0) break;
              let s2 = 0;
              for (; s2 < i2; ) {
                let i3 = 0;
                for (; i3 < r2 && n2[s2 + i3] === t3[i3]; ) i3++;
                if (i3 >= r2) {
                  a3.pos += s2;
                  return a3.pos - e3;
                }
                s2++;
              }
              a3.pos += i2;
            }
            return -1;
          }
          makeStream(e3, t3) {
            const a3 = this.lexer;
            let s2 = a3.stream;
            a3.skipToNextLine();
            const o2 = s2.pos - 1;
            let c2 = e3.get("Length");
            if (!Number.isInteger(c2)) {
              (0, r.info)(`Bad length "${c2 && c2.toString()}" in stream.`);
              c2 = 0;
            }
            s2.pos = o2 + c2;
            a3.nextChar();
            if (this.tryShift() && (0, n.isCmd)(this.buf2, "endstream")) this.shift();
            else {
              const e4 = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
              let t4 = this._findStreamLength(o2, e4);
              if (t4 < 0) {
                const a4 = 1;
                for (let n2 = 1; n2 <= a4; n2++) {
                  const a5 = e4.length - n2, c3 = e4.slice(0, a5), l2 = this._findStreamLength(o2, c3);
                  if (l2 >= 0) {
                    const e5 = s2.peekBytes(a5 + 1)[a5];
                    if (!(0, i.isWhiteSpace)(e5)) break;
                    (0, r.info)(`Found "${(0, r.bytesToString)(c3)}" when searching for endstream command.`);
                    t4 = l2;
                    break;
                  }
                }
                if (t4 < 0) throw new r.FormatError("Missing endstream command.");
              }
              c2 = t4;
              a3.nextChar();
              this.shift();
              this.shift();
            }
            this.shift();
            s2 = s2.makeSubStream(o2, c2, e3);
            t3 && (s2 = t3.createStream(s2, c2));
            s2 = this.filter(s2, e3, c2);
            s2.dict = e3;
            return s2;
          }
          filter(e3, t3, a3) {
            let i2 = t3.get("F", "Filter"), s2 = t3.get("DP", "DecodeParms");
            if (i2 instanceof n.Name) {
              Array.isArray(s2) && (0, r.warn)("/DecodeParms should not be an Array, when /Filter is a Name.");
              return this.makeFilter(e3, i2.name, a3, s2);
            }
            let o2 = a3;
            if (Array.isArray(i2)) {
              const t4 = i2, a4 = s2;
              for (let c2 = 0, l2 = t4.length; c2 < l2; ++c2) {
                i2 = this.xref.fetchIfRef(t4[c2]);
                if (!(i2 instanceof n.Name)) throw new r.FormatError(`Bad filter name "${i2}"`);
                s2 = null;
                Array.isArray(a4) && c2 in a4 && (s2 = this.xref.fetchIfRef(a4[c2]));
                e3 = this.makeFilter(e3, i2.name, o2, s2);
                o2 = null;
              }
            }
            return e3;
          }
          makeFilter(e3, t3, a3, n2) {
            if (0 === a3) {
              (0, r.warn)(`Empty "${t3}" stream.`);
              return new s.NullStream();
            }
            try {
              switch (t3) {
                case "Fl":
                case "FlateDecode":
                  return n2 ? new p.PredictorStream(new h.FlateStream(e3, a3), a3, n2) : new h.FlateStream(e3, a3);
                case "LZW":
                case "LZWDecode":
                  let t4 = 1;
                  if (n2) {
                    n2.has("EarlyChange") && (t4 = n2.get("EarlyChange"));
                    return new p.PredictorStream(new g.LZWStream(e3, a3, t4), a3, n2);
                  }
                  return new g.LZWStream(e3, a3, t4);
                case "DCT":
                case "DCTDecode":
                  return new d.JpegStream(e3, a3, n2);
                case "JPX":
                case "JPXDecode":
                  return new f.JpxStream(e3, a3, n2);
                case "A85":
                case "ASCII85Decode":
                  return new o.Ascii85Stream(e3, a3);
                case "AHx":
                case "ASCIIHexDecode":
                  return new c.AsciiHexStream(e3, a3);
                case "CCF":
                case "CCITTFaxDecode":
                  return new l.CCITTFaxStream(e3, a3, n2);
                case "RL":
                case "RunLengthDecode":
                  return new m.RunLengthStream(e3, a3);
                case "JBIG2Decode":
                  return new u.Jbig2Stream(e3, a3, n2);
              }
              (0, r.warn)(`Filter "${t3}" is not supported.`);
              return e3;
            } catch (e4) {
              if (e4 instanceof i.MissingDataException) throw e4;
              (0, r.warn)(`Invalid stream: "${e4}"`);
              return new s.NullStream();
            }
          }
        }
        t2.Parser = Parser;
        const b = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        function toHexDigit(e3) {
          return e3 >= 48 && e3 <= 57 ? 15 & e3 : e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 ? 9 + (15 & e3) : -1;
        }
        class Lexer {
          constructor(e3, t3 = null) {
            this.stream = e3;
            this.nextChar();
            this.strBuf = [];
            this.knownCommands = t3;
            this._hexStringNumWarn = 0;
            this.beginInlineImagePos = -1;
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          peekChar() {
            return this.stream.peekByte();
          }
          getNumber() {
            let e3 = this.currentChar, t3 = false, a3 = 0, n2 = 1;
            if (45 === e3) {
              n2 = -1;
              e3 = this.nextChar();
              45 === e3 && (e3 = this.nextChar());
            } else 43 === e3 && (e3 = this.nextChar());
            if (10 === e3 || 13 === e3) do {
              e3 = this.nextChar();
            } while (10 === e3 || 13 === e3);
            if (46 === e3) {
              a3 = 10;
              e3 = this.nextChar();
            }
            if (e3 < 48 || e3 > 57) {
              const t4 = `Invalid number: ${String.fromCharCode(e3)} (charCode ${e3})`;
              if ((0, i.isWhiteSpace)(e3) || -1 === e3) {
                (0, r.info)(`Lexer.getNumber - "${t4}".`);
                return 0;
              }
              throw new r.FormatError(t4);
            }
            let s2 = e3 - 48, o2 = 0, c2 = 1;
            for (; (e3 = this.nextChar()) >= 0; ) if (e3 >= 48 && e3 <= 57) {
              const r2 = e3 - 48;
              if (t3) o2 = 10 * o2 + r2;
              else {
                0 !== a3 && (a3 *= 10);
                s2 = 10 * s2 + r2;
              }
            } else if (46 === e3) {
              if (0 !== a3) break;
              a3 = 1;
            } else if (45 === e3) (0, r.warn)("Badly formatted number: minus sign in the middle");
            else {
              if (69 !== e3 && 101 !== e3) break;
              e3 = this.peekChar();
              if (43 === e3 || 45 === e3) {
                c2 = 45 === e3 ? -1 : 1;
                this.nextChar();
              } else if (e3 < 48 || e3 > 57) break;
              t3 = true;
            }
            0 !== a3 && (s2 /= a3);
            t3 && (s2 *= 10 ** (c2 * o2));
            return n2 * s2;
          }
          getString() {
            let e3 = 1, t3 = false;
            const a3 = this.strBuf;
            a3.length = 0;
            let n2 = this.nextChar();
            for (; ; ) {
              let i2 = false;
              switch (0 | n2) {
                case -1:
                  (0, r.warn)("Unterminated string");
                  t3 = true;
                  break;
                case 40:
                  ++e3;
                  a3.push("(");
                  break;
                case 41:
                  if (0 == --e3) {
                    this.nextChar();
                    t3 = true;
                  } else a3.push(")");
                  break;
                case 92:
                  n2 = this.nextChar();
                  switch (n2) {
                    case -1:
                      (0, r.warn)("Unterminated string");
                      t3 = true;
                      break;
                    case 110:
                      a3.push("\n");
                      break;
                    case 114:
                      a3.push("\r");
                      break;
                    case 116:
                      a3.push("	");
                      break;
                    case 98:
                      a3.push("\b");
                      break;
                    case 102:
                      a3.push("\f");
                      break;
                    case 92:
                    case 40:
                    case 41:
                      a3.push(String.fromCharCode(n2));
                      break;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                      let e4 = 15 & n2;
                      n2 = this.nextChar();
                      i2 = true;
                      if (n2 >= 48 && n2 <= 55) {
                        e4 = (e4 << 3) + (15 & n2);
                        n2 = this.nextChar();
                        if (n2 >= 48 && n2 <= 55) {
                          i2 = false;
                          e4 = (e4 << 3) + (15 & n2);
                        }
                      }
                      a3.push(String.fromCharCode(e4));
                      break;
                    case 13:
                      10 === this.peekChar() && this.nextChar();
                      break;
                    case 10:
                      break;
                    default:
                      a3.push(String.fromCharCode(n2));
                  }
                  break;
                default:
                  a3.push(String.fromCharCode(n2));
              }
              if (t3) break;
              i2 || (n2 = this.nextChar());
            }
            return a3.join("");
          }
          getName() {
            let e3, t3;
            const a3 = this.strBuf;
            a3.length = 0;
            for (; (e3 = this.nextChar()) >= 0 && !b[e3]; ) if (35 === e3) {
              e3 = this.nextChar();
              if (b[e3]) {
                (0, r.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                a3.push("#");
                break;
              }
              const n2 = toHexDigit(e3);
              if (-1 !== n2) {
                t3 = e3;
                e3 = this.nextChar();
                const i2 = toHexDigit(e3);
                if (-1 === i2) {
                  (0, r.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(e3)}) in hexadecimal number.`);
                  a3.push("#", String.fromCharCode(t3));
                  if (b[e3]) break;
                  a3.push(String.fromCharCode(e3));
                  continue;
                }
                a3.push(String.fromCharCode(n2 << 4 | i2));
              } else a3.push("#", String.fromCharCode(e3));
            } else a3.push(String.fromCharCode(e3));
            a3.length > 127 && (0, r.warn)(`Name token is longer than allowed by the spec: ${a3.length}`);
            return n.Name.get(a3.join(""));
          }
          _hexStringWarn(e3) {
            5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || (0, r.warn)(`getHexString - ignoring invalid character: ${e3}`) : (0, r.warn)("getHexString - ignoring additional invalid characters.");
          }
          getHexString() {
            const e3 = this.strBuf;
            e3.length = 0;
            let t3, a3, n2 = this.currentChar, i2 = true;
            this._hexStringNumWarn = 0;
            for (; ; ) {
              if (n2 < 0) {
                (0, r.warn)("Unterminated hex string");
                break;
              }
              if (62 === n2) {
                this.nextChar();
                break;
              }
              if (1 !== b[n2]) {
                if (i2) {
                  t3 = toHexDigit(n2);
                  if (-1 === t3) {
                    this._hexStringWarn(n2);
                    n2 = this.nextChar();
                    continue;
                  }
                } else {
                  a3 = toHexDigit(n2);
                  if (-1 === a3) {
                    this._hexStringWarn(n2);
                    n2 = this.nextChar();
                    continue;
                  }
                  e3.push(String.fromCharCode(t3 << 4 | a3));
                }
                i2 = !i2;
                n2 = this.nextChar();
              } else n2 = this.nextChar();
            }
            return e3.join("");
          }
          getObj() {
            let e3 = false, t3 = this.currentChar;
            for (; ; ) {
              if (t3 < 0) return n.EOF;
              if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
              else if (37 === t3) e3 = true;
              else if (1 !== b[t3]) break;
              t3 = this.nextChar();
            }
            switch (0 | t3) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 43:
              case 45:
              case 46:
                return this.getNumber();
              case 40:
                return this.getString();
              case 47:
                return this.getName();
              case 91:
                this.nextChar();
                return n.Cmd.get("[");
              case 93:
                this.nextChar();
                return n.Cmd.get("]");
              case 60:
                t3 = this.nextChar();
                if (60 === t3) {
                  this.nextChar();
                  return n.Cmd.get("<<");
                }
                return this.getHexString();
              case 62:
                t3 = this.nextChar();
                if (62 === t3) {
                  this.nextChar();
                  return n.Cmd.get(">>");
                }
                return n.Cmd.get(">");
              case 123:
                this.nextChar();
                return n.Cmd.get("{");
              case 125:
                this.nextChar();
                return n.Cmd.get("}");
              case 41:
                this.nextChar();
                throw new r.FormatError(`Illegal character: ${t3}`);
            }
            let a3 = String.fromCharCode(t3);
            if (t3 < 32 || t3 > 127) {
              const e4 = this.peekChar();
              if (e4 >= 32 && e4 <= 127) {
                this.nextChar();
                return n.Cmd.get(a3);
              }
            }
            const i2 = this.knownCommands;
            let s2 = void 0 !== (i2 == null ? void 0 : i2[a3]);
            for (; (t3 = this.nextChar()) >= 0 && !b[t3]; ) {
              const e4 = a3 + String.fromCharCode(t3);
              if (s2 && void 0 === i2[e4]) break;
              if (128 === a3.length) throw new r.FormatError(`Command token too long: ${a3.length}`);
              a3 = e4;
              s2 = void 0 !== (i2 == null ? void 0 : i2[a3]);
            }
            if ("true" === a3) return true;
            if ("false" === a3) return false;
            if ("null" === a3) return null;
            "BI" === a3 && (this.beginInlineImagePos = this.stream.pos);
            return n.Cmd.get(a3);
          }
          skipToNextLine() {
            let e3 = this.currentChar;
            for (; e3 >= 0; ) {
              if (13 === e3) {
                e3 = this.nextChar();
                10 === e3 && this.nextChar();
                break;
              }
              if (10 === e3) {
                this.nextChar();
                break;
              }
              e3 = this.nextChar();
            }
          }
        }
        t2.Lexer = Lexer;
        t2.Linearization = class Linearization {
          static create(e3) {
            function getInt(e4, t4, a4 = false) {
              const r3 = e4.get(t4);
              if (Number.isInteger(r3) && (a4 ? r3 >= 0 : r3 > 0)) return r3;
              throw new Error(`The "${t4}" parameter in the linearization dictionary is invalid.`);
            }
            const t3 = new Parser({ lexer: new Lexer(e3), xref: null }), a3 = t3.getObj(), r2 = t3.getObj(), i2 = t3.getObj(), s2 = t3.getObj();
            let o2, c2;
            if (!(Number.isInteger(a3) && Number.isInteger(r2) && (0, n.isCmd)(i2, "obj") && s2 instanceof n.Dict && "number" == typeof (o2 = s2.get("Linearized")) && o2 > 0)) return null;
            if ((c2 = getInt(s2, "L")) !== e3.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
            return { length: c2, hints: function getHints(e4) {
              const t4 = e4.get("H");
              let a4;
              if (Array.isArray(t4) && (2 === (a4 = t4.length) || 4 === a4)) {
                for (let e5 = 0; e5 < a4; e5++) {
                  const a5 = t4[e5];
                  if (!(Number.isInteger(a5) && a5 > 0)) throw new Error(`Hint (${e5}) in the linearization dictionary is invalid.`);
                }
                return t4;
              }
              throw new Error("Hint array in the linearization dictionary is invalid.");
            }(s2), objectNumberFirst: getInt(s2, "O"), endFirst: getInt(s2, "E"), numPages: getInt(s2, "N"), mainXRefEntriesOffset: getInt(s2, "T"), pageFirst: s2.has("P") ? getInt(s2, "P", true) : 0 };
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Ascii85Stream = void 0;
        var r = a2(18), n = a2(3);
        class Ascii85Stream extends r.DecodeStream {
          constructor(e3, t3) {
            t3 && (t3 *= 0.8);
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            this.input = new Uint8Array(5);
          }
          readBlock() {
            const e3 = this.str;
            let t3 = e3.getByte();
            for (; (0, n.isWhiteSpace)(t3); ) t3 = e3.getByte();
            if (-1 === t3 || 126 === t3) {
              this.eof = true;
              return;
            }
            const a3 = this.bufferLength;
            let r2, i;
            if (122 === t3) {
              r2 = this.ensureBuffer(a3 + 4);
              for (i = 0; i < 4; ++i) r2[a3 + i] = 0;
              this.bufferLength += 4;
            } else {
              const s = this.input;
              s[0] = t3;
              for (i = 1; i < 5; ++i) {
                t3 = e3.getByte();
                for (; (0, n.isWhiteSpace)(t3); ) t3 = e3.getByte();
                s[i] = t3;
                if (-1 === t3 || 126 === t3) break;
              }
              r2 = this.ensureBuffer(a3 + i - 1);
              this.bufferLength += i - 1;
              if (i < 5) {
                for (; i < 5; ++i) s[i] = 117;
                this.eof = true;
              }
              let o = 0;
              for (i = 0; i < 5; ++i) o = 85 * o + (s[i] - 33);
              for (i = 3; i >= 0; --i) {
                r2[a3 + i] = 255 & o;
                o >>= 8;
              }
            }
          }
        }
        t2.Ascii85Stream = Ascii85Stream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.StreamsSequenceStream = t2.DecodeStream = void 0;
        var r = a2(5), n = a2(8);
        const i = new Uint8Array(0);
        class DecodeStream extends r.BaseStream {
          constructor(e3) {
            super();
            this._rawMinBufferLength = e3 || 0;
            this.pos = 0;
            this.bufferLength = 0;
            this.eof = false;
            this.buffer = i;
            this.minBufferLength = 512;
            if (e3) for (; this.minBufferLength < e3; ) this.minBufferLength *= 2;
          }
          get isEmpty() {
            for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
            return 0 === this.bufferLength;
          }
          ensureBuffer(e3) {
            const t3 = this.buffer;
            if (e3 <= t3.byteLength) return t3;
            let a3 = this.minBufferLength;
            for (; a3 < e3; ) a3 *= 2;
            const r2 = new Uint8Array(a3);
            r2.set(t3);
            return this.buffer = r2;
          }
          getByte() {
            const e3 = this.pos;
            for (; this.bufferLength <= e3; ) {
              if (this.eof) return -1;
              this.readBlock();
            }
            return this.buffer[this.pos++];
          }
          getBytes(e3) {
            const t3 = this.pos;
            let a3;
            if (e3) {
              this.ensureBuffer(t3 + e3);
              a3 = t3 + e3;
              for (; !this.eof && this.bufferLength < a3; ) this.readBlock();
              const r2 = this.bufferLength;
              a3 > r2 && (a3 = r2);
            } else {
              for (; !this.eof; ) this.readBlock();
              a3 = this.bufferLength;
            }
            this.pos = a3;
            return this.buffer.subarray(t3, a3);
          }
          reset() {
            this.pos = 0;
          }
          makeSubStream(e3, t3, a3 = null) {
            if (void 0 === t3) for (; !this.eof; ) this.readBlock();
            else {
              const a4 = e3 + t3;
              for (; this.bufferLength <= a4 && !this.eof; ) this.readBlock();
            }
            return new n.Stream(this.buffer, e3, t3, a3);
          }
          getBaseStreams() {
            return this.str ? this.str.getBaseStreams() : null;
          }
        }
        t2.DecodeStream = DecodeStream;
        t2.StreamsSequenceStream = class StreamsSequenceStream extends DecodeStream {
          constructor(e3, t3 = null) {
            let a3 = 0;
            for (const t4 of e3) a3 += t4 instanceof DecodeStream ? t4._rawMinBufferLength : t4.length;
            super(a3);
            this.streams = e3;
            this._onError = t3;
          }
          readBlock() {
            var _a;
            const e3 = this.streams;
            if (0 === e3.length) {
              this.eof = true;
              return;
            }
            const t3 = e3.shift();
            let a3;
            try {
              a3 = t3.getBytes();
            } catch (e4) {
              if (this._onError) {
                this._onError(e4, (_a = t3.dict) == null ? void 0 : _a.objId);
                return;
              }
              throw e4;
            }
            const r2 = this.bufferLength, n2 = r2 + a3.length;
            this.ensureBuffer(n2).set(a3, r2);
            this.bufferLength = n2;
          }
          getBaseStreams() {
            const e3 = [];
            for (const t3 of this.streams) {
              const a3 = t3.getBaseStreams();
              a3 && e3.push(...a3);
            }
            return e3.length > 0 ? e3 : null;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.AsciiHexStream = void 0;
        var r = a2(18);
        class AsciiHexStream extends r.DecodeStream {
          constructor(e3, t3) {
            t3 && (t3 *= 0.5);
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            this.firstDigit = -1;
          }
          readBlock() {
            const e3 = this.str.getBytes(8e3);
            if (!e3.length) {
              this.eof = true;
              return;
            }
            const t3 = e3.length + 1 >> 1, a3 = this.ensureBuffer(this.bufferLength + t3);
            let r2 = this.bufferLength, n = this.firstDigit;
            for (const t4 of e3) {
              let e4;
              if (t4 >= 48 && t4 <= 57) e4 = 15 & t4;
              else {
                if (!(t4 >= 65 && t4 <= 70 || t4 >= 97 && t4 <= 102)) {
                  if (62 === t4) {
                    this.eof = true;
                    break;
                  }
                  continue;
                }
                e4 = 9 + (15 & t4);
              }
              if (n < 0) n = e4;
              else {
                a3[r2++] = n << 4 | e4;
                n = -1;
              }
            }
            if (n >= 0 && this.eof) {
              a3[r2++] = n << 4;
              n = -1;
            }
            this.firstDigit = n;
            this.bufferLength = r2;
          }
        }
        t2.AsciiHexStream = AsciiHexStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.CCITTFaxStream = void 0;
        var r = a2(21), n = a2(18), i = a2(4);
        class CCITTFaxStream extends n.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            a3 instanceof i.Dict || (a3 = i.Dict.empty);
            const n2 = { next: () => e3.getByte() };
            this.ccittFaxDecoder = new r.CCITTFaxDecoder(n2, { K: a3.get("K"), EndOfLine: a3.get("EndOfLine"), EncodedByteAlign: a3.get("EncodedByteAlign"), Columns: a3.get("Columns"), Rows: a3.get("Rows"), EndOfBlock: a3.get("EndOfBlock"), BlackIs1: a3.get("BlackIs1") });
          }
          readBlock() {
            for (; !this.eof; ) {
              const e3 = this.ccittFaxDecoder.readNextChar();
              if (-1 === e3) {
                this.eof = true;
                return;
              }
              this.ensureBuffer(this.bufferLength + 1);
              this.buffer[this.bufferLength++] = e3;
            }
          }
        }
        t2.CCITTFaxStream = CCITTFaxStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.CCITTFaxDecoder = void 0;
        var r = a2(2);
        const n = -1, i = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]], s = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], o = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], c = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], l = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], h = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
        t2.CCITTFaxDecoder = class CCITTFaxDecoder {
          constructor(e3, t3 = {}) {
            if (!e3 || "function" != typeof e3.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
            this.source = e3;
            this.eof = false;
            this.encoding = t3.K || 0;
            this.eoline = t3.EndOfLine || false;
            this.byteAlign = t3.EncodedByteAlign || false;
            this.columns = t3.Columns || 1728;
            this.rows = t3.Rows || 0;
            this.eoblock = t3.EndOfBlock ?? true;
            this.black = t3.BlackIs1 || false;
            this.codingLine = new Uint32Array(this.columns + 1);
            this.refLine = new Uint32Array(this.columns + 2);
            this.codingLine[0] = this.columns;
            this.codingPos = 0;
            this.row = 0;
            this.nextLine2D = this.encoding < 0;
            this.inputBits = 0;
            this.inputBuf = 0;
            this.outputBits = 0;
            this.rowsDone = false;
            let a3;
            for (; 0 === (a3 = this._lookBits(12)); ) this._eatBits(1);
            1 === a3 && this._eatBits(12);
            if (this.encoding > 0) {
              this.nextLine2D = !this._lookBits(1);
              this._eatBits(1);
            }
          }
          readNextChar() {
            if (this.eof) return -1;
            const e3 = this.refLine, t3 = this.codingLine, a3 = this.columns;
            let i2, s2, o2, c2, l2;
            if (0 === this.outputBits) {
              this.rowsDone && (this.eof = true);
              if (this.eof) return -1;
              this.err = false;
              let o3, l3, h2;
              if (this.nextLine2D) {
                for (c2 = 0; t3[c2] < a3; ++c2) e3[c2] = t3[c2];
                e3[c2++] = a3;
                e3[c2] = a3;
                t3[0] = 0;
                this.codingPos = 0;
                i2 = 0;
                s2 = 0;
                for (; t3[this.codingPos] < a3; ) {
                  o3 = this._getTwoDimCode();
                  switch (o3) {
                    case 0:
                      this._addPixels(e3[i2 + 1], s2);
                      e3[i2 + 1] < a3 && (i2 += 2);
                      break;
                    case 1:
                      o3 = l3 = 0;
                      if (s2) {
                        do {
                          o3 += h2 = this._getBlackCode();
                        } while (h2 >= 64);
                        do {
                          l3 += h2 = this._getWhiteCode();
                        } while (h2 >= 64);
                      } else {
                        do {
                          o3 += h2 = this._getWhiteCode();
                        } while (h2 >= 64);
                        do {
                          l3 += h2 = this._getBlackCode();
                        } while (h2 >= 64);
                      }
                      this._addPixels(t3[this.codingPos] + o3, s2);
                      t3[this.codingPos] < a3 && this._addPixels(t3[this.codingPos] + l3, 1 ^ s2);
                      for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      break;
                    case 7:
                      this._addPixels(e3[i2] + 3, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 5:
                      this._addPixels(e3[i2] + 2, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 3:
                      this._addPixels(e3[i2] + 1, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 2:
                      this._addPixels(e3[i2], s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 8:
                      this._addPixelsNeg(e3[i2] - 3, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        i2 > 0 ? --i2 : ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 6:
                      this._addPixelsNeg(e3[i2] - 2, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        i2 > 0 ? --i2 : ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case 4:
                      this._addPixelsNeg(e3[i2] - 1, s2);
                      s2 ^= 1;
                      if (t3[this.codingPos] < a3) {
                        i2 > 0 ? --i2 : ++i2;
                        for (; e3[i2] <= t3[this.codingPos] && e3[i2] < a3; ) i2 += 2;
                      }
                      break;
                    case n:
                      this._addPixels(a3, 0);
                      this.eof = true;
                      break;
                    default:
                      (0, r.info)("bad 2d code");
                      this._addPixels(a3, 0);
                      this.err = true;
                  }
                }
              } else {
                t3[0] = 0;
                this.codingPos = 0;
                s2 = 0;
                for (; t3[this.codingPos] < a3; ) {
                  o3 = 0;
                  if (s2) do {
                    o3 += h2 = this._getBlackCode();
                  } while (h2 >= 64);
                  else do {
                    o3 += h2 = this._getWhiteCode();
                  } while (h2 >= 64);
                  this._addPixels(t3[this.codingPos] + o3, s2);
                  s2 ^= 1;
                }
              }
              let u = false;
              this.byteAlign && (this.inputBits &= -8);
              if (this.eoblock || this.row !== this.rows - 1) {
                o3 = this._lookBits(12);
                if (this.eoline) for (; o3 !== n && 1 !== o3; ) {
                  this._eatBits(1);
                  o3 = this._lookBits(12);
                }
                else for (; 0 === o3; ) {
                  this._eatBits(1);
                  o3 = this._lookBits(12);
                }
                if (1 === o3) {
                  this._eatBits(12);
                  u = true;
                } else o3 === n && (this.eof = true);
              } else this.rowsDone = true;
              if (!this.eof && this.encoding > 0 && !this.rowsDone) {
                this.nextLine2D = !this._lookBits(1);
                this._eatBits(1);
              }
              if (this.eoblock && u && this.byteAlign) {
                o3 = this._lookBits(12);
                if (1 === o3) {
                  this._eatBits(12);
                  if (this.encoding > 0) {
                    this._lookBits(1);
                    this._eatBits(1);
                  }
                  if (this.encoding >= 0) for (c2 = 0; c2 < 4; ++c2) {
                    o3 = this._lookBits(12);
                    1 !== o3 && (0, r.info)("bad rtc code: " + o3);
                    this._eatBits(12);
                    if (this.encoding > 0) {
                      this._lookBits(1);
                      this._eatBits(1);
                    }
                  }
                  this.eof = true;
                }
              } else if (this.err && this.eoline) {
                for (; ; ) {
                  o3 = this._lookBits(13);
                  if (o3 === n) {
                    this.eof = true;
                    return -1;
                  }
                  if (o3 >> 1 == 1) break;
                  this._eatBits(1);
                }
                this._eatBits(12);
                if (this.encoding > 0) {
                  this._eatBits(1);
                  this.nextLine2D = !(1 & o3);
                }
              }
              this.outputBits = t3[0] > 0 ? t3[this.codingPos = 0] : t3[this.codingPos = 1];
              this.row++;
            }
            if (this.outputBits >= 8) {
              l2 = 1 & this.codingPos ? 0 : 255;
              this.outputBits -= 8;
              if (0 === this.outputBits && t3[this.codingPos] < a3) {
                this.codingPos++;
                this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1];
              }
            } else {
              o2 = 8;
              l2 = 0;
              do {
                if ("number" != typeof this.outputBits) throw new r.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                if (this.outputBits > o2) {
                  l2 <<= o2;
                  1 & this.codingPos || (l2 |= 255 >> 8 - o2);
                  this.outputBits -= o2;
                  o2 = 0;
                } else {
                  l2 <<= this.outputBits;
                  1 & this.codingPos || (l2 |= 255 >> 8 - this.outputBits);
                  o2 -= this.outputBits;
                  this.outputBits = 0;
                  if (t3[this.codingPos] < a3) {
                    this.codingPos++;
                    this.outputBits = t3[this.codingPos] - t3[this.codingPos - 1];
                  } else if (o2 > 0) {
                    l2 <<= o2;
                    o2 = 0;
                  }
                }
              } while (o2);
            }
            this.black && (l2 ^= 255);
            return l2;
          }
          _addPixels(e3, t3) {
            const a3 = this.codingLine;
            let n2 = this.codingPos;
            if (e3 > a3[n2]) {
              if (e3 > this.columns) {
                (0, r.info)("row is wrong length");
                this.err = true;
                e3 = this.columns;
              }
              1 & n2 ^ t3 && ++n2;
              a3[n2] = e3;
            }
            this.codingPos = n2;
          }
          _addPixelsNeg(e3, t3) {
            const a3 = this.codingLine;
            let n2 = this.codingPos;
            if (e3 > a3[n2]) {
              if (e3 > this.columns) {
                (0, r.info)("row is wrong length");
                this.err = true;
                e3 = this.columns;
              }
              1 & n2 ^ t3 && ++n2;
              a3[n2] = e3;
            } else if (e3 < a3[n2]) {
              if (e3 < 0) {
                (0, r.info)("invalid code");
                this.err = true;
                e3 = 0;
              }
              for (; n2 > 0 && e3 < a3[n2 - 1]; ) --n2;
              a3[n2] = e3;
            }
            this.codingPos = n2;
          }
          _findTableCode(e3, t3, a3, r2) {
            const i2 = r2 || 0;
            for (let r3 = e3; r3 <= t3; ++r3) {
              let e4 = this._lookBits(r3);
              if (e4 === n) return [true, 1, false];
              r3 < t3 && (e4 <<= t3 - r3);
              if (!i2 || e4 >= i2) {
                const t4 = a3[e4 - i2];
                if (t4[0] === r3) {
                  this._eatBits(r3);
                  return [true, t4[1], true];
                }
              }
            }
            return [false, 0, false];
          }
          _getTwoDimCode() {
            let e3, t3 = 0;
            if (this.eoblock) {
              t3 = this._lookBits(7);
              e3 = i[t3];
              if ((e3 == null ? void 0 : e3[0]) > 0) {
                this._eatBits(e3[0]);
                return e3[1];
              }
            } else {
              const e4 = this._findTableCode(1, 7, i);
              if (e4[0] && e4[2]) return e4[1];
            }
            (0, r.info)("Bad two dim code");
            return n;
          }
          _getWhiteCode() {
            let e3, t3 = 0;
            if (this.eoblock) {
              t3 = this._lookBits(12);
              if (t3 === n) return 1;
              e3 = t3 >> 5 == 0 ? s[t3] : o[t3 >> 3];
              if (e3[0] > 0) {
                this._eatBits(e3[0]);
                return e3[1];
              }
            } else {
              let e4 = this._findTableCode(1, 9, o);
              if (e4[0]) return e4[1];
              e4 = this._findTableCode(11, 12, s);
              if (e4[0]) return e4[1];
            }
            (0, r.info)("bad white code");
            this._eatBits(1);
            return 1;
          }
          _getBlackCode() {
            let e3, t3;
            if (this.eoblock) {
              e3 = this._lookBits(13);
              if (e3 === n) return 1;
              t3 = e3 >> 7 == 0 ? c[e3] : e3 >> 9 == 0 && e3 >> 7 != 0 ? l[(e3 >> 1) - 64] : h[e3 >> 7];
              if (t3[0] > 0) {
                this._eatBits(t3[0]);
                return t3[1];
              }
            } else {
              let e4 = this._findTableCode(2, 6, h);
              if (e4[0]) return e4[1];
              e4 = this._findTableCode(7, 12, l, 64);
              if (e4[0]) return e4[1];
              e4 = this._findTableCode(10, 13, c);
              if (e4[0]) return e4[1];
            }
            (0, r.info)("bad black code");
            this._eatBits(1);
            return 1;
          }
          _lookBits(e3) {
            let t3;
            for (; this.inputBits < e3; ) {
              if (-1 === (t3 = this.source.next())) return 0 === this.inputBits ? n : this.inputBuf << e3 - this.inputBits & 65535 >> 16 - e3;
              this.inputBuf = this.inputBuf << 8 | t3;
              this.inputBits += 8;
            }
            return this.inputBuf >> this.inputBits - e3 & 65535 >> 16 - e3;
          }
          _eatBits(e3) {
            (this.inputBits -= e3) < 0 && (this.inputBits = 0);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.FlateStream = void 0;
        var r = a2(18), n = a2(2);
        const i = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), s = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), o = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), c = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], l = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
        class FlateStream extends r.DecodeStream {
          constructor(e3, t3) {
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            const a3 = e3.getByte(), r2 = e3.getByte();
            if (-1 === a3 || -1 === r2) throw new n.FormatError(`Invalid header in flate stream: ${a3}, ${r2}`);
            if (8 != (15 & a3)) throw new n.FormatError(`Unknown compression method in flate stream: ${a3}, ${r2}`);
            if (((a3 << 8) + r2) % 31 != 0) throw new n.FormatError(`Bad FCHECK in flate stream: ${a3}, ${r2}`);
            if (32 & r2) throw new n.FormatError(`FDICT bit set in flate stream: ${a3}, ${r2}`);
            this.codeSize = 0;
            this.codeBuf = 0;
          }
          getBits(e3) {
            const t3 = this.str;
            let a3, r2 = this.codeSize, i2 = this.codeBuf;
            for (; r2 < e3; ) {
              if (-1 === (a3 = t3.getByte())) throw new n.FormatError("Bad encoding in flate stream");
              i2 |= a3 << r2;
              r2 += 8;
            }
            a3 = i2 & (1 << e3) - 1;
            this.codeBuf = i2 >> e3;
            this.codeSize = r2 -= e3;
            return a3;
          }
          getCode(e3) {
            const t3 = this.str, a3 = e3[0], r2 = e3[1];
            let i2, s2 = this.codeSize, o2 = this.codeBuf;
            for (; s2 < r2 && -1 !== (i2 = t3.getByte()); ) {
              o2 |= i2 << s2;
              s2 += 8;
            }
            const c2 = a3[o2 & (1 << r2) - 1], l2 = c2 >> 16, h = 65535 & c2;
            if (l2 < 1 || s2 < l2) throw new n.FormatError("Bad encoding in flate stream");
            this.codeBuf = o2 >> l2;
            this.codeSize = s2 - l2;
            return h;
          }
          generateHuffmanTable(e3) {
            const t3 = e3.length;
            let a3, r2 = 0;
            for (a3 = 0; a3 < t3; ++a3) e3[a3] > r2 && (r2 = e3[a3]);
            const n2 = 1 << r2, i2 = new Int32Array(n2);
            for (let s2 = 1, o2 = 0, c2 = 2; s2 <= r2; ++s2, o2 <<= 1, c2 <<= 1) for (let r3 = 0; r3 < t3; ++r3) if (e3[r3] === s2) {
              let e4 = 0, t4 = o2;
              for (a3 = 0; a3 < s2; ++a3) {
                e4 = e4 << 1 | 1 & t4;
                t4 >>= 1;
              }
              for (a3 = e4; a3 < n2; a3 += c2) i2[a3] = s2 << 16 | r3;
              ++o2;
            }
            return [i2, r2];
          }
          readBlock() {
            let e3, t3;
            const a3 = this.str;
            let r2, h, u = this.getBits(3);
            1 & u && (this.eof = true);
            u >>= 1;
            if (0 === u) {
              let t4;
              if (-1 === (t4 = a3.getByte())) throw new n.FormatError("Bad block header in flate stream");
              let r3 = t4;
              if (-1 === (t4 = a3.getByte())) throw new n.FormatError("Bad block header in flate stream");
              r3 |= t4 << 8;
              if (-1 === (t4 = a3.getByte())) throw new n.FormatError("Bad block header in flate stream");
              let i2 = t4;
              if (-1 === (t4 = a3.getByte())) throw new n.FormatError("Bad block header in flate stream");
              i2 |= t4 << 8;
              if (i2 !== (65535 & ~r3) && (0 !== r3 || 0 !== i2)) throw new n.FormatError("Bad uncompressed block length in flate stream");
              this.codeBuf = 0;
              this.codeSize = 0;
              const s2 = this.bufferLength, o2 = s2 + r3;
              e3 = this.ensureBuffer(o2);
              this.bufferLength = o2;
              if (0 === r3) -1 === a3.peekByte() && (this.eof = true);
              else {
                const t5 = a3.getBytes(r3);
                e3.set(t5, s2);
                t5.length < r3 && (this.eof = true);
              }
              return;
            }
            if (1 === u) {
              r2 = c;
              h = l;
            } else {
              if (2 !== u) throw new n.FormatError("Unknown block type in flate stream");
              {
                const e4 = this.getBits(5) + 257, a4 = this.getBits(5) + 1, n2 = this.getBits(4) + 4, s2 = new Uint8Array(i.length);
                let o2;
                for (o2 = 0; o2 < n2; ++o2) s2[i[o2]] = this.getBits(3);
                const c2 = this.generateHuffmanTable(s2);
                t3 = 0;
                o2 = 0;
                const l2 = e4 + a4, u2 = new Uint8Array(l2);
                let d2, f2, g;
                for (; o2 < l2; ) {
                  const e5 = this.getCode(c2);
                  if (16 === e5) {
                    d2 = 2;
                    f2 = 3;
                    g = t3;
                  } else if (17 === e5) {
                    d2 = 3;
                    f2 = 3;
                    g = t3 = 0;
                  } else {
                    if (18 !== e5) {
                      u2[o2++] = t3 = e5;
                      continue;
                    }
                    d2 = 7;
                    f2 = 11;
                    g = t3 = 0;
                  }
                  let a5 = this.getBits(d2) + f2;
                  for (; a5-- > 0; ) u2[o2++] = g;
                }
                r2 = this.generateHuffmanTable(u2.subarray(0, e4));
                h = this.generateHuffmanTable(u2.subarray(e4, l2));
              }
            }
            e3 = this.buffer;
            let d = e3 ? e3.length : 0, f = this.bufferLength;
            for (; ; ) {
              let a4 = this.getCode(r2);
              if (a4 < 256) {
                if (f + 1 >= d) {
                  e3 = this.ensureBuffer(f + 1);
                  d = e3.length;
                }
                e3[f++] = a4;
                continue;
              }
              if (256 === a4) {
                this.bufferLength = f;
                return;
              }
              a4 -= 257;
              a4 = s[a4];
              let n2 = a4 >> 16;
              n2 > 0 && (n2 = this.getBits(n2));
              t3 = (65535 & a4) + n2;
              a4 = this.getCode(h);
              a4 = o[a4];
              n2 = a4 >> 16;
              n2 > 0 && (n2 = this.getBits(n2));
              const i2 = (65535 & a4) + n2;
              if (f + t3 >= d) {
                e3 = this.ensureBuffer(f + t3);
                d = e3.length;
              }
              for (let a5 = 0; a5 < t3; ++a5, ++f) e3[f] = e3[f - i2];
            }
          }
        }
        t2.FlateStream = FlateStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Jbig2Stream = void 0;
        var r = a2(5), n = a2(18), i = a2(4), s = a2(24), o = a2(2);
        class Jbig2Stream extends n.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            this.stream = e3;
            this.dict = e3.dict;
            this.maybeLength = t3;
            this.params = a3;
          }
          get bytes() {
            return (0, o.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(e3) {
          }
          readBlock() {
            if (this.eof) return;
            const e3 = new s.Jbig2Image(), t3 = [];
            if (this.params instanceof i.Dict) {
              const e4 = this.params.get("JBIG2Globals");
              if (e4 instanceof r.BaseStream) {
                const a4 = e4.getBytes();
                t3.push({ data: a4, start: 0, end: a4.length });
              }
            }
            t3.push({ data: this.bytes, start: 0, end: this.bytes.length });
            const a3 = e3.parseChunks(t3), n2 = a3.length;
            for (let e4 = 0; e4 < n2; e4++) a3[e4] ^= 255;
            this.buffer = a3;
            this.bufferLength = n2;
            this.eof = true;
          }
        }
        t2.Jbig2Stream = Jbig2Stream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Jbig2Image = void 0;
        var r = a2(2), n = a2(3), i = a2(25), s = a2(21);
        class Jbig2Error extends r.BaseException {
          constructor(e3) {
            super(`JBIG2 error: ${e3}`, "Jbig2Error");
          }
        }
        class ContextCache {
          getContexts(e3) {
            return e3 in this ? this[e3] : this[e3] = new Int8Array(65536);
          }
        }
        class DecodingContext {
          constructor(e3, t3, a3) {
            this.data = e3;
            this.start = t3;
            this.end = a3;
          }
          get decoder() {
            const e3 = new i.ArithmeticDecoder(this.data, this.start, this.end);
            return (0, r.shadow)(this, "decoder", e3);
          }
          get contextCache() {
            const e3 = new ContextCache();
            return (0, r.shadow)(this, "contextCache", e3);
          }
        }
        const o = 2 ** 31 - 1, c = -(2 ** 31);
        function decodeInteger(e3, t3, a3) {
          const r2 = e3.getContexts(t3);
          let n2 = 1;
          function readBits(e4) {
            let t4 = 0;
            for (let i3 = 0; i3 < e4; i3++) {
              const e5 = a3.readBit(r2, n2);
              n2 = n2 < 256 ? n2 << 1 | e5 : 511 & (n2 << 1 | e5) | 256;
              t4 = t4 << 1 | e5;
            }
            return t4 >>> 0;
          }
          const i2 = readBits(1), s2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
          let l2;
          0 === i2 ? l2 = s2 : s2 > 0 && (l2 = -s2);
          return l2 >= c && l2 <= o ? l2 : null;
        }
        function decodeIAID(e3, t3, a3) {
          const r2 = e3.getContexts("IAID");
          let n2 = 1;
          for (let e4 = 0; e4 < a3; e4++) {
            n2 = n2 << 1 | t3.readBit(r2, n2);
          }
          return a3 < 31 ? n2 & (1 << a3) - 1 : 2147483647 & n2;
        }
        const l = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], h = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]], u = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }], d = [39717, 1941, 229, 405], f = [32, 8];
        function decodeBitmap(e3, t3, a3, r2, n2, i2, s2, o2) {
          if (e3) {
            return decodeMMRBitmap(new Reader(o2.data, o2.start, o2.end), t3, a3, false);
          }
          if (0 === r2 && !i2 && !n2 && 4 === s2.length && 3 === s2[0].x && -1 === s2[0].y && -3 === s2[1].x && -1 === s2[1].y && 2 === s2[2].x && -2 === s2[2].y && -2 === s2[3].x && -2 === s2[3].y) return function decodeBitmapTemplate0(e4, t4, a4) {
            const r3 = a4.decoder, n3 = a4.contextCache.getContexts("GB"), i3 = [];
            let s3, o3, c3, l3, h2, u3, d2;
            for (o3 = 0; o3 < t4; o3++) {
              h2 = i3[o3] = new Uint8Array(e4);
              u3 = o3 < 1 ? h2 : i3[o3 - 1];
              d2 = o3 < 2 ? h2 : i3[o3 - 2];
              s3 = d2[0] << 13 | d2[1] << 12 | d2[2] << 11 | u3[0] << 7 | u3[1] << 6 | u3[2] << 5 | u3[3] << 4;
              for (c3 = 0; c3 < e4; c3++) {
                h2[c3] = l3 = r3.readBit(n3, s3);
                s3 = (31735 & s3) << 1 | (c3 + 3 < e4 ? d2[c3 + 3] << 11 : 0) | (c3 + 4 < e4 ? u3[c3 + 4] << 4 : 0) | l3;
              }
            }
            return i3;
          }(t3, a3, o2);
          const c2 = !!i2, l2 = h[r2].concat(s2);
          l2.sort(function(e4, t4) {
            return e4.y - t4.y || e4.x - t4.x;
          });
          const u2 = l2.length, f2 = new Int8Array(u2), g2 = new Int8Array(u2), p2 = [];
          let m, b, y = 0, w = 0, S = 0, x = 0;
          for (b = 0; b < u2; b++) {
            f2[b] = l2[b].x;
            g2[b] = l2[b].y;
            w = Math.min(w, l2[b].x);
            S = Math.max(S, l2[b].x);
            x = Math.min(x, l2[b].y);
            b < u2 - 1 && l2[b].y === l2[b + 1].y && l2[b].x === l2[b + 1].x - 1 ? y |= 1 << u2 - 1 - b : p2.push(b);
          }
          const C = p2.length, k = new Int8Array(C), v = new Int8Array(C), F = new Uint16Array(C);
          for (m = 0; m < C; m++) {
            b = p2[m];
            k[m] = l2[b].x;
            v[m] = l2[b].y;
            F[m] = 1 << u2 - 1 - b;
          }
          const O = -w, T = -x, M = t3 - S, D = d[r2];
          let E = new Uint8Array(t3);
          const N = [], R = o2.decoder, L = o2.contextCache.getContexts("GB");
          let $, _, j, U, X, H = 0, q = 0;
          for (let e4 = 0; e4 < a3; e4++) {
            if (n2) {
              H ^= R.readBit(L, D);
              if (H) {
                N.push(E);
                continue;
              }
            }
            E = new Uint8Array(E);
            N.push(E);
            for ($ = 0; $ < t3; $++) {
              if (c2 && i2[e4][$]) {
                E[$] = 0;
                continue;
              }
              if ($ >= O && $ < M && e4 >= T) {
                q = q << 1 & y;
                for (b = 0; b < C; b++) {
                  _ = e4 + v[b];
                  j = $ + k[b];
                  U = N[_][j];
                  if (U) {
                    U = F[b];
                    q |= U;
                  }
                }
              } else {
                q = 0;
                X = u2 - 1;
                for (b = 0; b < u2; b++, X--) {
                  j = $ + f2[b];
                  if (j >= 0 && j < t3) {
                    _ = e4 + g2[b];
                    if (_ >= 0) {
                      U = N[_][j];
                      U && (q |= U << X);
                    }
                  }
                }
              }
              const a4 = R.readBit(L, q);
              E[$] = a4;
            }
          }
          return N;
        }
        function decodeRefinement(e3, t3, a3, r2, n2, i2, s2, o2, c2) {
          let l2 = u[a3].coding;
          0 === a3 && (l2 = l2.concat([o2[0]]));
          const h2 = l2.length, d2 = new Int32Array(h2), g2 = new Int32Array(h2);
          let p2;
          for (p2 = 0; p2 < h2; p2++) {
            d2[p2] = l2[p2].x;
            g2[p2] = l2[p2].y;
          }
          let m = u[a3].reference;
          0 === a3 && (m = m.concat([o2[1]]));
          const b = m.length, y = new Int32Array(b), w = new Int32Array(b);
          for (p2 = 0; p2 < b; p2++) {
            y[p2] = m[p2].x;
            w[p2] = m[p2].y;
          }
          const S = r2[0].length, x = r2.length, C = f[a3], k = [], v = c2.decoder, F = c2.contextCache.getContexts("GR");
          let O = 0;
          for (let a4 = 0; a4 < t3; a4++) {
            if (s2) {
              O ^= v.readBit(F, C);
              if (O) throw new Jbig2Error("prediction is not supported");
            }
            const t4 = new Uint8Array(e3);
            k.push(t4);
            for (let s3 = 0; s3 < e3; s3++) {
              let o3, c3, l3 = 0;
              for (p2 = 0; p2 < h2; p2++) {
                o3 = a4 + g2[p2];
                c3 = s3 + d2[p2];
                o3 < 0 || c3 < 0 || c3 >= e3 ? l3 <<= 1 : l3 = l3 << 1 | k[o3][c3];
              }
              for (p2 = 0; p2 < b; p2++) {
                o3 = a4 + w[p2] - i2;
                c3 = s3 + y[p2] - n2;
                o3 < 0 || o3 >= x || c3 < 0 || c3 >= S ? l3 <<= 1 : l3 = l3 << 1 | r2[o3][c3];
              }
              const u2 = v.readBit(F, l3);
              t4[s3] = u2;
            }
          }
          return k;
        }
        function decodeTextRegion(e3, t3, a3, r2, n2, i2, s2, o2, c2, l2, h2, u2, d2, f2, g2, p2, m, b, y) {
          if (e3 && t3) throw new Jbig2Error("refinement with Huffman is not supported");
          const w = [];
          let S, x;
          for (S = 0; S < r2; S++) {
            x = new Uint8Array(a3);
            if (n2) for (let e4 = 0; e4 < a3; e4++) x[e4] = n2;
            w.push(x);
          }
          const C = m.decoder, k = m.contextCache;
          let v = e3 ? -f2.tableDeltaT.decode(y) : -decodeInteger(k, "IADT", C), F = 0;
          S = 0;
          for (; S < i2; ) {
            v += e3 ? f2.tableDeltaT.decode(y) : decodeInteger(k, "IADT", C);
            F += e3 ? f2.tableFirstS.decode(y) : decodeInteger(k, "IAFS", C);
            let r3 = F;
            for (; ; ) {
              let n3 = 0;
              s2 > 1 && (n3 = e3 ? y.readBits(b) : decodeInteger(k, "IAIT", C));
              const i3 = s2 * v + n3, F2 = e3 ? f2.symbolIDTable.decode(y) : decodeIAID(k, C, c2), O = t3 && (e3 ? y.readBit() : decodeInteger(k, "IARI", C));
              let T = o2[F2], M = T[0].length, D = T.length;
              if (O) {
                const e4 = decodeInteger(k, "IARDW", C), t4 = decodeInteger(k, "IARDH", C);
                M += e4;
                D += t4;
                T = decodeRefinement(M, D, g2, T, (e4 >> 1) + decodeInteger(k, "IARDX", C), (t4 >> 1) + decodeInteger(k, "IARDY", C), false, p2, m);
              }
              const E = i3 - (1 & u2 ? 0 : D - 1), N = r3 - (2 & u2 ? M - 1 : 0);
              let R, L, $;
              if (l2) {
                for (R = 0; R < D; R++) {
                  x = w[N + R];
                  if (!x) continue;
                  $ = T[R];
                  const e4 = Math.min(a3 - E, M);
                  switch (d2) {
                    case 0:
                      for (L = 0; L < e4; L++) x[E + L] |= $[L];
                      break;
                    case 2:
                      for (L = 0; L < e4; L++) x[E + L] ^= $[L];
                      break;
                    default:
                      throw new Jbig2Error(`operator ${d2} is not supported`);
                  }
                }
                r3 += D - 1;
              } else {
                for (L = 0; L < D; L++) {
                  x = w[E + L];
                  if (x) {
                    $ = T[L];
                    switch (d2) {
                      case 0:
                        for (R = 0; R < M; R++) x[N + R] |= $[R];
                        break;
                      case 2:
                        for (R = 0; R < M; R++) x[N + R] ^= $[R];
                        break;
                      default:
                        throw new Jbig2Error(`operator ${d2} is not supported`);
                    }
                  }
                }
                r3 += M - 1;
              }
              S++;
              const _ = e3 ? f2.tableDeltaS.decode(y) : decodeInteger(k, "IADS", C);
              if (null === _) break;
              r3 += _ + h2;
            }
          }
          return w;
        }
        function readSegmentHeader(e3, t3) {
          const a3 = {};
          a3.number = (0, n.readUint32)(e3, t3);
          const r2 = e3[t3 + 4], i2 = 63 & r2;
          if (!l[i2]) throw new Jbig2Error("invalid segment type: " + i2);
          a3.type = i2;
          a3.typeName = l[i2];
          a3.deferredNonRetain = !!(128 & r2);
          const s2 = !!(64 & r2), o2 = e3[t3 + 5];
          let c2 = o2 >> 5 & 7;
          const h2 = [31 & o2];
          let u2 = t3 + 6;
          if (7 === o2) {
            c2 = 536870911 & (0, n.readUint32)(e3, u2 - 1);
            u2 += 3;
            let t4 = c2 + 7 >> 3;
            h2[0] = e3[u2++];
            for (; --t4 > 0; ) h2.push(e3[u2++]);
          } else if (5 === o2 || 6 === o2) throw new Jbig2Error("invalid referred-to flags");
          a3.retainBits = h2;
          let d2 = 4;
          a3.number <= 256 ? d2 = 1 : a3.number <= 65536 && (d2 = 2);
          const f2 = [];
          let p2, m;
          for (p2 = 0; p2 < c2; p2++) {
            let t4;
            t4 = 1 === d2 ? e3[u2] : 2 === d2 ? (0, n.readUint16)(e3, u2) : (0, n.readUint32)(e3, u2);
            f2.push(t4);
            u2 += d2;
          }
          a3.referredTo = f2;
          if (s2) {
            a3.pageAssociation = (0, n.readUint32)(e3, u2);
            u2 += 4;
          } else a3.pageAssociation = e3[u2++];
          a3.length = (0, n.readUint32)(e3, u2);
          u2 += 4;
          if (4294967295 === a3.length) {
            if (38 !== i2) throw new Jbig2Error("invalid unknown segment length");
            {
              const t4 = readRegionSegmentInformation(e3, u2), r3 = !!(1 & e3[u2 + g]), n2 = 6, i3 = new Uint8Array(n2);
              if (!r3) {
                i3[0] = 255;
                i3[1] = 172;
              }
              i3[2] = t4.height >>> 24 & 255;
              i3[3] = t4.height >> 16 & 255;
              i3[4] = t4.height >> 8 & 255;
              i3[5] = 255 & t4.height;
              for (p2 = u2, m = e3.length; p2 < m; p2++) {
                let t5 = 0;
                for (; t5 < n2 && i3[t5] === e3[p2 + t5]; ) t5++;
                if (t5 === n2) {
                  a3.length = p2 + n2;
                  break;
                }
              }
              if (4294967295 === a3.length) throw new Jbig2Error("segment end was not found");
            }
          }
          a3.headerEnd = u2;
          return a3;
        }
        function readSegments(e3, t3, a3, r2) {
          const n2 = [];
          let i2 = a3;
          for (; i2 < r2; ) {
            const a4 = readSegmentHeader(t3, i2);
            i2 = a4.headerEnd;
            const r3 = { header: a4, data: t3 };
            if (!e3.randomAccess) {
              r3.start = i2;
              i2 += a4.length;
              r3.end = i2;
            }
            n2.push(r3);
            if (51 === a4.type) break;
          }
          if (e3.randomAccess) for (let e4 = 0, t4 = n2.length; e4 < t4; e4++) {
            n2[e4].start = i2;
            i2 += n2[e4].header.length;
            n2[e4].end = i2;
          }
          return n2;
        }
        function readRegionSegmentInformation(e3, t3) {
          return { width: (0, n.readUint32)(e3, t3), height: (0, n.readUint32)(e3, t3 + 4), x: (0, n.readUint32)(e3, t3 + 8), y: (0, n.readUint32)(e3, t3 + 12), combinationOperator: 7 & e3[t3 + 16] };
        }
        const g = 17;
        function processSegment(e3, t3) {
          const a3 = e3.header, r2 = e3.data, i2 = e3.end;
          let s2, o2, c2, l2, h2 = e3.start;
          switch (a3.type) {
            case 0:
              const e4 = {}, t4 = (0, n.readUint16)(r2, h2);
              e4.huffman = !!(1 & t4);
              e4.refinement = !!(2 & t4);
              e4.huffmanDHSelector = t4 >> 2 & 3;
              e4.huffmanDWSelector = t4 >> 4 & 3;
              e4.bitmapSizeSelector = t4 >> 6 & 1;
              e4.aggregationInstancesSelector = t4 >> 7 & 1;
              e4.bitmapCodingContextUsed = !!(256 & t4);
              e4.bitmapCodingContextRetained = !!(512 & t4);
              e4.template = t4 >> 10 & 3;
              e4.refinementTemplate = t4 >> 12 & 1;
              h2 += 2;
              if (!e4.huffman) {
                l2 = 0 === e4.template ? 4 : 1;
                o2 = [];
                for (c2 = 0; c2 < l2; c2++) {
                  o2.push({ x: (0, n.readInt8)(r2, h2), y: (0, n.readInt8)(r2, h2 + 1) });
                  h2 += 2;
                }
                e4.at = o2;
              }
              if (e4.refinement && !e4.refinementTemplate) {
                o2 = [];
                for (c2 = 0; c2 < 2; c2++) {
                  o2.push({ x: (0, n.readInt8)(r2, h2), y: (0, n.readInt8)(r2, h2 + 1) });
                  h2 += 2;
                }
                e4.refinementAt = o2;
              }
              e4.numberOfExportedSymbols = (0, n.readUint32)(r2, h2);
              h2 += 4;
              e4.numberOfNewSymbols = (0, n.readUint32)(r2, h2);
              h2 += 4;
              s2 = [e4, a3.number, a3.referredTo, r2, h2, i2];
              break;
            case 6:
            case 7:
              const u3 = {};
              u3.info = readRegionSegmentInformation(r2, h2);
              h2 += g;
              const d2 = (0, n.readUint16)(r2, h2);
              h2 += 2;
              u3.huffman = !!(1 & d2);
              u3.refinement = !!(2 & d2);
              u3.logStripSize = d2 >> 2 & 3;
              u3.stripSize = 1 << u3.logStripSize;
              u3.referenceCorner = d2 >> 4 & 3;
              u3.transposed = !!(64 & d2);
              u3.combinationOperator = d2 >> 7 & 3;
              u3.defaultPixelValue = d2 >> 9 & 1;
              u3.dsOffset = d2 << 17 >> 27;
              u3.refinementTemplate = d2 >> 15 & 1;
              if (u3.huffman) {
                const e5 = (0, n.readUint16)(r2, h2);
                h2 += 2;
                u3.huffmanFS = 3 & e5;
                u3.huffmanDS = e5 >> 2 & 3;
                u3.huffmanDT = e5 >> 4 & 3;
                u3.huffmanRefinementDW = e5 >> 6 & 3;
                u3.huffmanRefinementDH = e5 >> 8 & 3;
                u3.huffmanRefinementDX = e5 >> 10 & 3;
                u3.huffmanRefinementDY = e5 >> 12 & 3;
                u3.huffmanRefinementSizeSelector = !!(16384 & e5);
              }
              if (u3.refinement && !u3.refinementTemplate) {
                o2 = [];
                for (c2 = 0; c2 < 2; c2++) {
                  o2.push({ x: (0, n.readInt8)(r2, h2), y: (0, n.readInt8)(r2, h2 + 1) });
                  h2 += 2;
                }
                u3.refinementAt = o2;
              }
              u3.numberOfSymbolInstances = (0, n.readUint32)(r2, h2);
              h2 += 4;
              s2 = [u3, a3.referredTo, r2, h2, i2];
              break;
            case 16:
              const f2 = {}, p2 = r2[h2++];
              f2.mmr = !!(1 & p2);
              f2.template = p2 >> 1 & 3;
              f2.patternWidth = r2[h2++];
              f2.patternHeight = r2[h2++];
              f2.maxPatternIndex = (0, n.readUint32)(r2, h2);
              h2 += 4;
              s2 = [f2, a3.number, r2, h2, i2];
              break;
            case 22:
            case 23:
              const m = {};
              m.info = readRegionSegmentInformation(r2, h2);
              h2 += g;
              const b = r2[h2++];
              m.mmr = !!(1 & b);
              m.template = b >> 1 & 3;
              m.enableSkip = !!(8 & b);
              m.combinationOperator = b >> 4 & 7;
              m.defaultPixelValue = b >> 7 & 1;
              m.gridWidth = (0, n.readUint32)(r2, h2);
              h2 += 4;
              m.gridHeight = (0, n.readUint32)(r2, h2);
              h2 += 4;
              m.gridOffsetX = 4294967295 & (0, n.readUint32)(r2, h2);
              h2 += 4;
              m.gridOffsetY = 4294967295 & (0, n.readUint32)(r2, h2);
              h2 += 4;
              m.gridVectorX = (0, n.readUint16)(r2, h2);
              h2 += 2;
              m.gridVectorY = (0, n.readUint16)(r2, h2);
              h2 += 2;
              s2 = [m, a3.referredTo, r2, h2, i2];
              break;
            case 38:
            case 39:
              const y = {};
              y.info = readRegionSegmentInformation(r2, h2);
              h2 += g;
              const w = r2[h2++];
              y.mmr = !!(1 & w);
              y.template = w >> 1 & 3;
              y.prediction = !!(8 & w);
              if (!y.mmr) {
                l2 = 0 === y.template ? 4 : 1;
                o2 = [];
                for (c2 = 0; c2 < l2; c2++) {
                  o2.push({ x: (0, n.readInt8)(r2, h2), y: (0, n.readInt8)(r2, h2 + 1) });
                  h2 += 2;
                }
                y.at = o2;
              }
              s2 = [y, r2, h2, i2];
              break;
            case 48:
              const S = { width: (0, n.readUint32)(r2, h2), height: (0, n.readUint32)(r2, h2 + 4), resolutionX: (0, n.readUint32)(r2, h2 + 8), resolutionY: (0, n.readUint32)(r2, h2 + 12) };
              4294967295 === S.height && delete S.height;
              const x = r2[h2 + 16];
              (0, n.readUint16)(r2, h2 + 17);
              S.lossless = !!(1 & x);
              S.refinement = !!(2 & x);
              S.defaultPixelValue = x >> 2 & 1;
              S.combinationOperator = x >> 3 & 3;
              S.requiresBuffer = !!(32 & x);
              S.combinationOperatorOverride = !!(64 & x);
              s2 = [S];
              break;
            case 49:
            case 50:
            case 51:
            case 62:
              break;
            case 53:
              s2 = [a3.number, r2, h2, i2];
              break;
            default:
              throw new Jbig2Error(`segment type ${a3.typeName}(${a3.type}) is not implemented`);
          }
          const u2 = "on" + a3.typeName;
          u2 in t3 && t3[u2].apply(t3, s2);
        }
        function processSegments(e3, t3) {
          for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) processSegment(e3[a3], t3);
        }
        class SimpleSegmentVisitor {
          onPageInformation(e3) {
            this.currentPageInfo = e3;
            const t3 = e3.width + 7 >> 3, a3 = new Uint8ClampedArray(t3 * e3.height);
            e3.defaultPixelValue && a3.fill(255);
            this.buffer = a3;
          }
          drawBitmap(e3, t3) {
            const a3 = this.currentPageInfo, r2 = e3.width, n2 = e3.height, i2 = a3.width + 7 >> 3, s2 = a3.combinationOperatorOverride ? e3.combinationOperator : a3.combinationOperator, o2 = this.buffer, c2 = 128 >> (7 & e3.x);
            let l2, h2, u2, d2, f2 = e3.y * i2 + (e3.x >> 3);
            switch (s2) {
              case 0:
                for (l2 = 0; l2 < n2; l2++) {
                  u2 = c2;
                  d2 = f2;
                  for (h2 = 0; h2 < r2; h2++) {
                    t3[l2][h2] && (o2[d2] |= u2);
                    u2 >>= 1;
                    if (!u2) {
                      u2 = 128;
                      d2++;
                    }
                  }
                  f2 += i2;
                }
                break;
              case 2:
                for (l2 = 0; l2 < n2; l2++) {
                  u2 = c2;
                  d2 = f2;
                  for (h2 = 0; h2 < r2; h2++) {
                    t3[l2][h2] && (o2[d2] ^= u2);
                    u2 >>= 1;
                    if (!u2) {
                      u2 = 128;
                      d2++;
                    }
                  }
                  f2 += i2;
                }
                break;
              default:
                throw new Jbig2Error(`operator ${s2} is not supported`);
            }
          }
          onImmediateGenericRegion(e3, t3, a3, r2) {
            const n2 = e3.info, i2 = new DecodingContext(t3, a3, r2), s2 = decodeBitmap(e3.mmr, n2.width, n2.height, e3.template, e3.prediction, null, e3.at, i2);
            this.drawBitmap(n2, s2);
          }
          onImmediateLosslessGenericRegion() {
            this.onImmediateGenericRegion(...arguments);
          }
          onSymbolDictionary(e3, t3, a3, r2, i2, s2) {
            let o2, c2;
            if (e3.huffman) {
              o2 = function getSymbolDictionaryHuffmanTables(e4, t4, a4) {
                let r3, n2, i3, s3, o3 = 0;
                switch (e4.huffmanDHSelector) {
                  case 0:
                  case 1:
                    r3 = getStandardTable(e4.huffmanDHSelector + 4);
                    break;
                  case 3:
                    r3 = getCustomHuffmanTable(o3, t4, a4);
                    o3++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DH selector");
                }
                switch (e4.huffmanDWSelector) {
                  case 0:
                  case 1:
                    n2 = getStandardTable(e4.huffmanDWSelector + 2);
                    break;
                  case 3:
                    n2 = getCustomHuffmanTable(o3, t4, a4);
                    o3++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DW selector");
                }
                if (e4.bitmapSizeSelector) {
                  i3 = getCustomHuffmanTable(o3, t4, a4);
                  o3++;
                } else i3 = getStandardTable(1);
                s3 = e4.aggregationInstancesSelector ? getCustomHuffmanTable(o3, t4, a4) : getStandardTable(1);
                return { tableDeltaHeight: r3, tableDeltaWidth: n2, tableBitmapSize: i3, tableAggregateInstances: s3 };
              }(e3, a3, this.customTables);
              c2 = new Reader(r2, i2, s2);
            }
            let l2 = this.symbols;
            l2 || (this.symbols = l2 = {});
            const h2 = [];
            for (const e4 of a3) {
              const t4 = l2[e4];
              t4 && h2.push(...t4);
            }
            const u2 = new DecodingContext(r2, i2, s2);
            l2[t3] = function decodeSymbolDictionary(e4, t4, a4, r3, i3, s3, o3, c3, l3, h3, u3, d2) {
              if (e4 && t4) throw new Jbig2Error("symbol refinement with Huffman is not supported");
              const f2 = [];
              let g2 = 0, p2 = (0, n.log2)(a4.length + r3);
              const m = u3.decoder, b = u3.contextCache;
              let y, w;
              if (e4) {
                y = getStandardTable(1);
                w = [];
                p2 = Math.max(p2, 1);
              }
              for (; f2.length < r3; ) {
                g2 += e4 ? s3.tableDeltaHeight.decode(d2) : decodeInteger(b, "IADH", m);
                let r4 = 0, n2 = 0;
                const i4 = e4 ? w.length : 0;
                for (; ; ) {
                  const i5 = e4 ? s3.tableDeltaWidth.decode(d2) : decodeInteger(b, "IADW", m);
                  if (null === i5) break;
                  r4 += i5;
                  n2 += r4;
                  let y2;
                  if (t4) {
                    const n3 = decodeInteger(b, "IAAI", m);
                    if (n3 > 1) y2 = decodeTextRegion(e4, t4, r4, g2, 0, n3, 1, a4.concat(f2), p2, 0, 0, 1, 0, s3, l3, h3, u3, 0, d2);
                    else {
                      const e5 = decodeIAID(b, m, p2), t5 = decodeInteger(b, "IARDX", m), n4 = decodeInteger(b, "IARDY", m);
                      y2 = decodeRefinement(r4, g2, l3, e5 < a4.length ? a4[e5] : f2[e5 - a4.length], t5, n4, false, h3, u3);
                    }
                    f2.push(y2);
                  } else if (e4) w.push(r4);
                  else {
                    y2 = decodeBitmap(false, r4, g2, o3, false, null, c3, u3);
                    f2.push(y2);
                  }
                }
                if (e4 && !t4) {
                  const e5 = s3.tableBitmapSize.decode(d2);
                  d2.byteAlign();
                  let t5;
                  if (0 === e5) t5 = readUncompressedBitmap(d2, n2, g2);
                  else {
                    const a6 = d2.end, r5 = d2.position + e5;
                    d2.end = r5;
                    t5 = decodeMMRBitmap(d2, n2, g2, false);
                    d2.end = a6;
                    d2.position = r5;
                  }
                  const a5 = w.length;
                  if (i4 === a5 - 1) f2.push(t5);
                  else {
                    let e6, r5, n3, s4, o4, c4 = 0;
                    for (e6 = i4; e6 < a5; e6++) {
                      s4 = w[e6];
                      n3 = c4 + s4;
                      o4 = [];
                      for (r5 = 0; r5 < g2; r5++) o4.push(t5[r5].subarray(c4, n3));
                      f2.push(o4);
                      c4 = n3;
                    }
                  }
                }
              }
              const S = [], x = [];
              let C, k, v = false;
              const F = a4.length + r3;
              for (; x.length < F; ) {
                let t5 = e4 ? y.decode(d2) : decodeInteger(b, "IAEX", m);
                for (; t5--; ) x.push(v);
                v = !v;
              }
              for (C = 0, k = a4.length; C < k; C++) x[C] && S.push(a4[C]);
              for (let e5 = 0; e5 < r3; C++, e5++) x[C] && S.push(f2[e5]);
              return S;
            }(e3.huffman, e3.refinement, h2, e3.numberOfNewSymbols, e3.numberOfExportedSymbols, o2, e3.template, e3.at, e3.refinementTemplate, e3.refinementAt, u2, c2);
          }
          onImmediateTextRegion(e3, t3, a3, r2, i2) {
            const s2 = e3.info;
            let o2, c2;
            const l2 = this.symbols, h2 = [];
            for (const e4 of t3) {
              const t4 = l2[e4];
              t4 && h2.push(...t4);
            }
            const u2 = (0, n.log2)(h2.length);
            if (e3.huffman) {
              c2 = new Reader(a3, r2, i2);
              o2 = function getTextRegionHuffmanTables(e4, t4, a4, r3, n2) {
                const i3 = [];
                for (let e5 = 0; e5 <= 34; e5++) {
                  const t5 = n2.readBits(4);
                  i3.push(new HuffmanLine([e5, t5, 0, 0]));
                }
                const s3 = new HuffmanTable(i3, false);
                i3.length = 0;
                for (let e5 = 0; e5 < r3; ) {
                  const t5 = s3.decode(n2);
                  if (t5 >= 32) {
                    let a5, r4, s4;
                    switch (t5) {
                      case 32:
                        if (0 === e5) throw new Jbig2Error("no previous value in symbol ID table");
                        r4 = n2.readBits(2) + 3;
                        a5 = i3[e5 - 1].prefixLength;
                        break;
                      case 33:
                        r4 = n2.readBits(3) + 3;
                        a5 = 0;
                        break;
                      case 34:
                        r4 = n2.readBits(7) + 11;
                        a5 = 0;
                        break;
                      default:
                        throw new Jbig2Error("invalid code length in symbol ID table");
                    }
                    for (s4 = 0; s4 < r4; s4++) {
                      i3.push(new HuffmanLine([e5, a5, 0, 0]));
                      e5++;
                    }
                  } else {
                    i3.push(new HuffmanLine([e5, t5, 0, 0]));
                    e5++;
                  }
                }
                n2.byteAlign();
                const o3 = new HuffmanTable(i3, false);
                let c3, l3, h3, u3 = 0;
                switch (e4.huffmanFS) {
                  case 0:
                  case 1:
                    c3 = getStandardTable(e4.huffmanFS + 6);
                    break;
                  case 3:
                    c3 = getCustomHuffmanTable(u3, t4, a4);
                    u3++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman FS selector");
                }
                switch (e4.huffmanDS) {
                  case 0:
                  case 1:
                  case 2:
                    l3 = getStandardTable(e4.huffmanDS + 8);
                    break;
                  case 3:
                    l3 = getCustomHuffmanTable(u3, t4, a4);
                    u3++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DS selector");
                }
                switch (e4.huffmanDT) {
                  case 0:
                  case 1:
                  case 2:
                    h3 = getStandardTable(e4.huffmanDT + 11);
                    break;
                  case 3:
                    h3 = getCustomHuffmanTable(u3, t4, a4);
                    u3++;
                    break;
                  default:
                    throw new Jbig2Error("invalid Huffman DT selector");
                }
                if (e4.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
                return { symbolIDTable: o3, tableFirstS: c3, tableDeltaS: l3, tableDeltaT: h3 };
              }(e3, t3, this.customTables, h2.length, c2);
            }
            const d2 = new DecodingContext(a3, r2, i2), f2 = decodeTextRegion(e3.huffman, e3.refinement, s2.width, s2.height, e3.defaultPixelValue, e3.numberOfSymbolInstances, e3.stripSize, h2, u2, e3.transposed, e3.dsOffset, e3.referenceCorner, e3.combinationOperator, o2, e3.refinementTemplate, e3.refinementAt, d2, e3.logStripSize, c2);
            this.drawBitmap(s2, f2);
          }
          onImmediateLosslessTextRegion() {
            this.onImmediateTextRegion(...arguments);
          }
          onPatternDictionary(e3, t3, a3, r2, n2) {
            let i2 = this.patterns;
            i2 || (this.patterns = i2 = {});
            const s2 = new DecodingContext(a3, r2, n2);
            i2[t3] = function decodePatternDictionary(e4, t4, a4, r3, n3, i3) {
              const s3 = [];
              if (!e4) {
                s3.push({ x: -t4, y: 0 });
                0 === n3 && s3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
              }
              const o2 = decodeBitmap(e4, (r3 + 1) * t4, a4, n3, false, null, s3, i3), c2 = [];
              for (let e5 = 0; e5 <= r3; e5++) {
                const r4 = [], n4 = t4 * e5, i4 = n4 + t4;
                for (let e6 = 0; e6 < a4; e6++) r4.push(o2[e6].subarray(n4, i4));
                c2.push(r4);
              }
              return c2;
            }(e3.mmr, e3.patternWidth, e3.patternHeight, e3.maxPatternIndex, e3.template, s2);
          }
          onImmediateHalftoneRegion(e3, t3, a3, r2, i2) {
            const s2 = this.patterns[t3[0]], o2 = e3.info, c2 = new DecodingContext(a3, r2, i2), l2 = function decodeHalftoneRegion(e4, t4, a4, r3, i3, s3, o3, c3, l3, h2, u2, d2, f2, g2, p2) {
              if (o3) throw new Jbig2Error("skip is not supported");
              if (0 !== c3) throw new Jbig2Error(`operator "${c3}" is not supported in halftone region`);
              const m = [];
              let b, y, w;
              for (b = 0; b < i3; b++) {
                w = new Uint8Array(r3);
                if (s3) for (y = 0; y < r3; y++) w[y] = s3;
                m.push(w);
              }
              const S = t4.length, x = t4[0], C = x[0].length, k = x.length, v = (0, n.log2)(S), F = [];
              if (!e4) {
                F.push({ x: a4 <= 1 ? 3 : 2, y: -1 });
                0 === a4 && F.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
              }
              const O = [];
              let T, M, D, E, N, R, L, $, _, j, U;
              e4 && (T = new Reader(p2.data, p2.start, p2.end));
              for (b = v - 1; b >= 0; b--) {
                M = e4 ? decodeMMRBitmap(T, l3, h2, true) : decodeBitmap(false, l3, h2, a4, false, null, F, p2);
                O[b] = M;
              }
              for (D = 0; D < h2; D++) for (E = 0; E < l3; E++) {
                N = 0;
                R = 0;
                for (y = v - 1; y >= 0; y--) {
                  N ^= O[y][D][E];
                  R |= N << y;
                }
                L = t4[R];
                $ = u2 + D * g2 + E * f2 >> 8;
                _ = d2 + D * f2 - E * g2 >> 8;
                if ($ >= 0 && $ + C <= r3 && _ >= 0 && _ + k <= i3) for (b = 0; b < k; b++) {
                  U = m[_ + b];
                  j = L[b];
                  for (y = 0; y < C; y++) U[$ + y] |= j[y];
                }
                else {
                  let e5, t5;
                  for (b = 0; b < k; b++) {
                    t5 = _ + b;
                    if (!(t5 < 0 || t5 >= i3)) {
                      U = m[t5];
                      j = L[b];
                      for (y = 0; y < C; y++) {
                        e5 = $ + y;
                        e5 >= 0 && e5 < r3 && (U[e5] |= j[y]);
                      }
                    }
                  }
                }
              }
              return m;
            }(e3.mmr, s2, e3.template, o2.width, o2.height, e3.defaultPixelValue, e3.enableSkip, e3.combinationOperator, e3.gridWidth, e3.gridHeight, e3.gridOffsetX, e3.gridOffsetY, e3.gridVectorX, e3.gridVectorY, c2);
            this.drawBitmap(o2, l2);
          }
          onImmediateLosslessHalftoneRegion() {
            this.onImmediateHalftoneRegion(...arguments);
          }
          onTables(e3, t3, a3, r2) {
            let i2 = this.customTables;
            i2 || (this.customTables = i2 = {});
            i2[e3] = function decodeTablesSegment(e4, t4, a4) {
              const r3 = e4[t4], i3 = 4294967295 & (0, n.readUint32)(e4, t4 + 1), s2 = 4294967295 & (0, n.readUint32)(e4, t4 + 5), o2 = new Reader(e4, t4 + 9, a4), c2 = 1 + (r3 >> 1 & 7), l2 = 1 + (r3 >> 4 & 7), h2 = [];
              let u2, d2, f2 = i3;
              do {
                u2 = o2.readBits(c2);
                d2 = o2.readBits(l2);
                h2.push(new HuffmanLine([f2, u2, d2, 0]));
                f2 += 1 << d2;
              } while (f2 < s2);
              u2 = o2.readBits(c2);
              h2.push(new HuffmanLine([i3 - 1, u2, 32, 0, "lower"]));
              u2 = o2.readBits(c2);
              h2.push(new HuffmanLine([s2, u2, 32, 0]));
              if (1 & r3) {
                u2 = o2.readBits(c2);
                h2.push(new HuffmanLine([u2, 0]));
              }
              return new HuffmanTable(h2, false);
            }(t3, a3, r2);
          }
        }
        class HuffmanLine {
          constructor(e3) {
            if (2 === e3.length) {
              this.isOOB = true;
              this.rangeLow = 0;
              this.prefixLength = e3[0];
              this.rangeLength = 0;
              this.prefixCode = e3[1];
              this.isLowerRange = false;
            } else {
              this.isOOB = false;
              this.rangeLow = e3[0];
              this.prefixLength = e3[1];
              this.rangeLength = e3[2];
              this.prefixCode = e3[3];
              this.isLowerRange = "lower" === e3[4];
            }
          }
        }
        class HuffmanTreeNode {
          constructor(e3) {
            this.children = [];
            if (e3) {
              this.isLeaf = true;
              this.rangeLength = e3.rangeLength;
              this.rangeLow = e3.rangeLow;
              this.isLowerRange = e3.isLowerRange;
              this.isOOB = e3.isOOB;
            } else this.isLeaf = false;
          }
          buildTree(e3, t3) {
            const a3 = e3.prefixCode >> t3 & 1;
            if (t3 <= 0) this.children[a3] = new HuffmanTreeNode(e3);
            else {
              let r2 = this.children[a3];
              r2 || (this.children[a3] = r2 = new HuffmanTreeNode(null));
              r2.buildTree(e3, t3 - 1);
            }
          }
          decodeNode(e3) {
            if (this.isLeaf) {
              if (this.isOOB) return null;
              const t4 = e3.readBits(this.rangeLength);
              return this.rangeLow + (this.isLowerRange ? -t4 : t4);
            }
            const t3 = this.children[e3.readBit()];
            if (!t3) throw new Jbig2Error("invalid Huffman data");
            return t3.decodeNode(e3);
          }
        }
        class HuffmanTable {
          constructor(e3, t3) {
            t3 || this.assignPrefixCodes(e3);
            this.rootNode = new HuffmanTreeNode(null);
            for (let t4 = 0, a3 = e3.length; t4 < a3; t4++) {
              const a4 = e3[t4];
              a4.prefixLength > 0 && this.rootNode.buildTree(a4, a4.prefixLength - 1);
            }
          }
          decode(e3) {
            return this.rootNode.decodeNode(e3);
          }
          assignPrefixCodes(e3) {
            const t3 = e3.length;
            let a3 = 0;
            for (let r3 = 0; r3 < t3; r3++) a3 = Math.max(a3, e3[r3].prefixLength);
            const r2 = new Uint32Array(a3 + 1);
            for (let a4 = 0; a4 < t3; a4++) r2[e3[a4].prefixLength]++;
            let n2, i2, s2, o2 = 1, c2 = 0;
            r2[0] = 0;
            for (; o2 <= a3; ) {
              c2 = c2 + r2[o2 - 1] << 1;
              n2 = c2;
              i2 = 0;
              for (; i2 < t3; ) {
                s2 = e3[i2];
                if (s2.prefixLength === o2) {
                  s2.prefixCode = n2;
                  n2++;
                }
                i2++;
              }
              o2++;
            }
          }
        }
        const p = {};
        function getStandardTable(e3) {
          let t3, a3 = p[e3];
          if (a3) return a3;
          switch (e3) {
            case 1:
              t3 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
              break;
            case 2:
              t3 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
              break;
            case 3:
              t3 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
              break;
            case 4:
              t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
              break;
            case 5:
              t3 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
              break;
            case 6:
              t3 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
              break;
            case 7:
              t3 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
              break;
            case 8:
              t3 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
              break;
            case 9:
              t3 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
              break;
            case 10:
              t3 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
              break;
            case 11:
              t3 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
              break;
            case 12:
              t3 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
              break;
            case 13:
              t3 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
              break;
            case 14:
              t3 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
              break;
            case 15:
              t3 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
              break;
            default:
              throw new Jbig2Error(`standard table B.${e3} does not exist`);
          }
          for (let e4 = 0, a4 = t3.length; e4 < a4; e4++) t3[e4] = new HuffmanLine(t3[e4]);
          a3 = new HuffmanTable(t3, true);
          p[e3] = a3;
          return a3;
        }
        class Reader {
          constructor(e3, t3, a3) {
            this.data = e3;
            this.start = t3;
            this.end = a3;
            this.position = t3;
            this.shift = -1;
            this.currentByte = 0;
          }
          readBit() {
            if (this.shift < 0) {
              if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
              this.currentByte = this.data[this.position++];
              this.shift = 7;
            }
            const e3 = this.currentByte >> this.shift & 1;
            this.shift--;
            return e3;
          }
          readBits(e3) {
            let t3, a3 = 0;
            for (t3 = e3 - 1; t3 >= 0; t3--) a3 |= this.readBit() << t3;
            return a3;
          }
          byteAlign() {
            this.shift = -1;
          }
          next() {
            return this.position >= this.end ? -1 : this.data[this.position++];
          }
        }
        function getCustomHuffmanTable(e3, t3, a3) {
          let r2 = 0;
          for (let n2 = 0, i2 = t3.length; n2 < i2; n2++) {
            const i3 = a3[t3[n2]];
            if (i3) {
              if (e3 === r2) return i3;
              r2++;
            }
          }
          throw new Jbig2Error("can't find custom Huffman table");
        }
        function readUncompressedBitmap(e3, t3, a3) {
          const r2 = [];
          for (let n2 = 0; n2 < a3; n2++) {
            const a4 = new Uint8Array(t3);
            r2.push(a4);
            for (let r3 = 0; r3 < t3; r3++) a4[r3] = e3.readBit();
            e3.byteAlign();
          }
          return r2;
        }
        function decodeMMRBitmap(e3, t3, a3, r2) {
          const n2 = { K: -1, Columns: t3, Rows: a3, BlackIs1: true, EndOfBlock: r2 }, i2 = new s.CCITTFaxDecoder(e3, n2), o2 = [];
          let c2, l2 = false;
          for (let e4 = 0; e4 < a3; e4++) {
            const e5 = new Uint8Array(t3);
            o2.push(e5);
            let a4 = -1;
            for (let r3 = 0; r3 < t3; r3++) {
              if (a4 < 0) {
                c2 = i2.readNextChar();
                if (-1 === c2) {
                  c2 = 0;
                  l2 = true;
                }
                a4 = 7;
              }
              e5[r3] = c2 >> a4 & 1;
              a4--;
            }
          }
          if (r2 && !l2) {
            const e4 = 5;
            for (let t4 = 0; t4 < e4 && -1 !== i2.readNextChar(); t4++) ;
          }
          return o2;
        }
        t2.Jbig2Image = class Jbig2Image {
          parseChunks(e3) {
            return function parseJbig2Chunks(e4) {
              const t3 = new SimpleSegmentVisitor();
              for (let a3 = 0, r2 = e4.length; a3 < r2; a3++) {
                const r3 = e4[a3];
                processSegments(readSegments({}, r3.data, r3.start, r3.end), t3);
              }
              return t3.buffer;
            }(e3);
          }
          parse(e3) {
            throw new Error("Not implemented: Jbig2Image.parse");
          }
        };
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ArithmeticDecoder = void 0;
        const a2 = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
        t2.ArithmeticDecoder = class ArithmeticDecoder {
          constructor(e3, t3, a3) {
            this.data = e3;
            this.bp = t3;
            this.dataEnd = a3;
            this.chigh = e3[t3];
            this.clow = 0;
            this.byteIn();
            this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
            this.clow = this.clow << 7 & 65535;
            this.ct -= 7;
            this.a = 32768;
          }
          byteIn() {
            const e3 = this.data;
            let t3 = this.bp;
            if (255 === e3[t3]) if (e3[t3 + 1] > 143) {
              this.clow += 65280;
              this.ct = 8;
            } else {
              t3++;
              this.clow += e3[t3] << 9;
              this.ct = 7;
              this.bp = t3;
            }
            else {
              t3++;
              this.clow += t3 < this.dataEnd ? e3[t3] << 8 : 65280;
              this.ct = 8;
              this.bp = t3;
            }
            if (this.clow > 65535) {
              this.chigh += this.clow >> 16;
              this.clow &= 65535;
            }
          }
          readBit(e3, t3) {
            let r = e3[t3] >> 1, n = 1 & e3[t3];
            const i = a2[r], s = i.qe;
            let o, c = this.a - s;
            if (this.chigh < s) if (c < s) {
              c = s;
              o = n;
              r = i.nmps;
            } else {
              c = s;
              o = 1 ^ n;
              1 === i.switchFlag && (n = o);
              r = i.nlps;
            }
            else {
              this.chigh -= s;
              if (0 != (32768 & c)) {
                this.a = c;
                return n;
              }
              if (c < s) {
                o = 1 ^ n;
                1 === i.switchFlag && (n = o);
                r = i.nlps;
              } else {
                o = n;
                r = i.nmps;
              }
            }
            do {
              0 === this.ct && this.byteIn();
              c <<= 1;
              this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
              this.clow = this.clow << 1 & 65535;
              this.ct--;
            } while (0 == (32768 & c));
            this.a = c;
            e3[t3] = r << 1 | n;
            return o;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.JpegStream = void 0;
        var r = a2(18), n = a2(4), i = a2(27), s = a2(2);
        class JpegStream extends r.DecodeStream {
          constructor(e3, t3, a3) {
            let r2;
            for (; -1 !== (r2 = e3.getByte()); ) if (255 === r2) {
              e3.skip(-1);
              break;
            }
            super(t3);
            this.stream = e3;
            this.dict = e3.dict;
            this.maybeLength = t3;
            this.params = a3;
          }
          get bytes() {
            return (0, s.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(e3) {
          }
          readBlock() {
            if (this.eof) return;
            const e3 = { decodeTransform: void 0, colorTransform: void 0 }, t3 = this.dict.getArray("D", "Decode");
            if ((this.forceRGBA || this.forceRGB) && Array.isArray(t3)) {
              const a4 = this.dict.get("BPC", "BitsPerComponent") || 8, r3 = t3.length, n2 = new Int32Array(r3);
              let i2 = false;
              const s2 = (1 << a4) - 1;
              for (let e4 = 0; e4 < r3; e4 += 2) {
                n2[e4] = 256 * (t3[e4 + 1] - t3[e4]) | 0;
                n2[e4 + 1] = t3[e4] * s2 | 0;
                256 === n2[e4] && 0 === n2[e4 + 1] || (i2 = true);
              }
              i2 && (e3.decodeTransform = n2);
            }
            if (this.params instanceof n.Dict) {
              const t4 = this.params.get("ColorTransform");
              Number.isInteger(t4) && (e3.colorTransform = t4);
            }
            const a3 = new i.JpegImage(e3);
            a3.parse(this.bytes);
            const r2 = a3.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
            this.buffer = r2;
            this.bufferLength = r2.length;
            this.eof = true;
          }
        }
        t2.JpegStream = JpegStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.JpegImage = void 0;
        var r = a2(2), n = a2(28), i = a2(3);
        class JpegError extends r.BaseException {
          constructor(e3) {
            super(`JPEG error: ${e3}`, "JpegError");
          }
        }
        class DNLMarkerError extends r.BaseException {
          constructor(e3, t3) {
            super(e3, "DNLMarkerError");
            this.scanLines = t3;
          }
        }
        class EOIMarkerError extends r.BaseException {
          constructor(e3) {
            super(e3, "EOIMarkerError");
          }
        }
        const s = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), o = 4017, c = 799, l = 3406, h = 2276, u = 1567, d = 3784, f = 5793, g = 2896;
        function buildHuffmanTable(e3, t3) {
          let a3, r2, n2 = 0, i2 = 16;
          for (; i2 > 0 && !e3[i2 - 1]; ) i2--;
          const s2 = [{ children: [], index: 0 }];
          let o2, c2 = s2[0];
          for (a3 = 0; a3 < i2; a3++) {
            for (r2 = 0; r2 < e3[a3]; r2++) {
              c2 = s2.pop();
              c2.children[c2.index] = t3[n2];
              for (; c2.index > 0; ) c2 = s2.pop();
              c2.index++;
              s2.push(c2);
              for (; s2.length <= a3; ) {
                s2.push(o2 = { children: [], index: 0 });
                c2.children[c2.index] = o2.children;
                c2 = o2;
              }
              n2++;
            }
            if (a3 + 1 < i2) {
              s2.push(o2 = { children: [], index: 0 });
              c2.children[c2.index] = o2.children;
              c2 = o2;
            }
          }
          return s2[0].children;
        }
        function getBlockBufferOffset(e3, t3, a3) {
          return 64 * ((e3.blocksPerLine + 1) * t3 + a3);
        }
        function decodeScan(e3, t3, a3, n2, o2, c2, l2, h2, u2, d2 = false) {
          const f2 = a3.mcusPerLine, g2 = a3.progressive, p = t3;
          let m = 0, b = 0;
          function readBit() {
            if (b > 0) {
              b--;
              return m >> b & 1;
            }
            m = e3[t3++];
            if (255 === m) {
              const r2 = e3[t3++];
              if (r2) {
                if (220 === r2 && d2) {
                  t3 += 2;
                  const r3 = (0, i.readUint16)(e3, t3);
                  t3 += 2;
                  if (r3 > 0 && r3 !== a3.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", r3);
                } else if (217 === r2) {
                  if (d2) {
                    const e4 = x * (8 === a3.precision ? 8 : 0);
                    if (e4 > 0 && Math.round(a3.scanLines / e4) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e4);
                  }
                  throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                }
                throw new JpegError(`unexpected marker ${(m << 8 | r2).toString(16)}`);
              }
            }
            b = 7;
            return m >>> 7;
          }
          function decodeHuffman(e4) {
            let t4 = e4;
            for (; ; ) {
              t4 = t4[readBit()];
              switch (typeof t4) {
                case "number":
                  return t4;
                case "object":
                  continue;
              }
              throw new JpegError("invalid huffman sequence");
            }
          }
          function receive(e4) {
            let t4 = 0;
            for (; e4 > 0; ) {
              t4 = t4 << 1 | readBit();
              e4--;
            }
            return t4;
          }
          function receiveAndExtend(e4) {
            if (1 === e4) return 1 === readBit() ? 1 : -1;
            const t4 = receive(e4);
            return t4 >= 1 << e4 - 1 ? t4 : t4 + (-1 << e4) + 1;
          }
          let y = 0;
          let w, S = 0;
          let x = 0;
          function decodeMcu(e4, t4, a4, r2, n3) {
            const i2 = a4 % f2;
            x = (a4 / f2 | 0) * e4.v + r2;
            const s2 = i2 * e4.h + n3;
            t4(e4, getBlockBufferOffset(e4, x, s2));
          }
          function decodeBlock(e4, t4, a4) {
            x = a4 / e4.blocksPerLine | 0;
            const r2 = a4 % e4.blocksPerLine;
            t4(e4, getBlockBufferOffset(e4, x, r2));
          }
          const C = n2.length;
          let k, v, F, O, T, M;
          M = g2 ? 0 === c2 ? 0 === h2 ? function decodeDCFirst(e4, t4) {
            const a4 = decodeHuffman(e4.huffmanTableDC), r2 = 0 === a4 ? 0 : receiveAndExtend(a4) << u2;
            e4.blockData[t4] = e4.pred += r2;
          } : function decodeDCSuccessive(e4, t4) {
            e4.blockData[t4] |= readBit() << u2;
          } : 0 === h2 ? function decodeACFirst(e4, t4) {
            if (y > 0) {
              y--;
              return;
            }
            let a4 = c2;
            const r2 = l2;
            for (; a4 <= r2; ) {
              const r3 = decodeHuffman(e4.huffmanTableAC), n3 = 15 & r3, i2 = r3 >> 4;
              if (0 === n3) {
                if (i2 < 15) {
                  y = receive(i2) + (1 << i2) - 1;
                  break;
                }
                a4 += 16;
                continue;
              }
              a4 += i2;
              const o3 = s[a4];
              e4.blockData[t4 + o3] = receiveAndExtend(n3) * (1 << u2);
              a4++;
            }
          } : function decodeACSuccessive(e4, t4) {
            let a4 = c2;
            const r2 = l2;
            let n3, i2, o3 = 0;
            for (; a4 <= r2; ) {
              const r3 = t4 + s[a4], c3 = e4.blockData[r3] < 0 ? -1 : 1;
              switch (S) {
                case 0:
                  i2 = decodeHuffman(e4.huffmanTableAC);
                  n3 = 15 & i2;
                  o3 = i2 >> 4;
                  if (0 === n3) if (o3 < 15) {
                    y = receive(o3) + (1 << o3);
                    S = 4;
                  } else {
                    o3 = 16;
                    S = 1;
                  }
                  else {
                    if (1 !== n3) throw new JpegError("invalid ACn encoding");
                    w = receiveAndExtend(n3);
                    S = o3 ? 2 : 3;
                  }
                  continue;
                case 1:
                case 2:
                  if (e4.blockData[r3]) e4.blockData[r3] += c3 * (readBit() << u2);
                  else {
                    o3--;
                    0 === o3 && (S = 2 === S ? 3 : 0);
                  }
                  break;
                case 3:
                  if (e4.blockData[r3]) e4.blockData[r3] += c3 * (readBit() << u2);
                  else {
                    e4.blockData[r3] = w << u2;
                    S = 0;
                  }
                  break;
                case 4:
                  e4.blockData[r3] && (e4.blockData[r3] += c3 * (readBit() << u2));
              }
              a4++;
            }
            if (4 === S) {
              y--;
              0 === y && (S = 0);
            }
          } : function decodeBaseline(e4, t4) {
            const a4 = decodeHuffman(e4.huffmanTableDC), r2 = 0 === a4 ? 0 : receiveAndExtend(a4);
            e4.blockData[t4] = e4.pred += r2;
            let n3 = 1;
            for (; n3 < 64; ) {
              const a5 = decodeHuffman(e4.huffmanTableAC), r3 = 15 & a5, i2 = a5 >> 4;
              if (0 === r3) {
                if (i2 < 15) break;
                n3 += 16;
                continue;
              }
              n3 += i2;
              const o3 = s[n3];
              e4.blockData[t4 + o3] = receiveAndExtend(r3);
              n3++;
            }
          };
          let D, E = 0;
          const N = 1 === C ? n2[0].blocksPerLine * n2[0].blocksPerColumn : f2 * a3.mcusPerColumn;
          let R, L;
          for (; E <= N; ) {
            const a4 = o2 ? Math.min(N - E, o2) : N;
            if (a4 > 0) {
              for (v = 0; v < C; v++) n2[v].pred = 0;
              y = 0;
              if (1 === C) {
                k = n2[0];
                for (T = 0; T < a4; T++) {
                  decodeBlock(k, M, E);
                  E++;
                }
              } else for (T = 0; T < a4; T++) {
                for (v = 0; v < C; v++) {
                  k = n2[v];
                  R = k.h;
                  L = k.v;
                  for (F = 0; F < L; F++) for (O = 0; O < R; O++) decodeMcu(k, M, E, F, O);
                }
                E++;
              }
            }
            b = 0;
            D = findNextFileMarker(e3, t3);
            if (!D) break;
            if (D.invalid) {
              const e4 = a4 > 0 ? "unexpected" : "excessive";
              (0, r.warn)(`decodeScan - ${e4} MCU data, current marker is: ${D.invalid}`);
              t3 = D.offset;
            }
            if (!(D.marker >= 65488 && D.marker <= 65495)) break;
            t3 += 2;
          }
          return t3 - p;
        }
        function quantizeAndInverse(e3, t3, a3) {
          const r2 = e3.quantizationTable, n2 = e3.blockData;
          let i2, s2, p, m, b, y, w, S, x, C, k, v, F, O, T, M, D;
          if (!r2) throw new JpegError("missing required Quantization Table.");
          for (let e4 = 0; e4 < 64; e4 += 8) {
            x = n2[t3 + e4];
            C = n2[t3 + e4 + 1];
            k = n2[t3 + e4 + 2];
            v = n2[t3 + e4 + 3];
            F = n2[t3 + e4 + 4];
            O = n2[t3 + e4 + 5];
            T = n2[t3 + e4 + 6];
            M = n2[t3 + e4 + 7];
            x *= r2[e4];
            if (0 != (C | k | v | F | O | T | M)) {
              C *= r2[e4 + 1];
              k *= r2[e4 + 2];
              v *= r2[e4 + 3];
              F *= r2[e4 + 4];
              O *= r2[e4 + 5];
              T *= r2[e4 + 6];
              M *= r2[e4 + 7];
              i2 = f * x + 128 >> 8;
              s2 = f * F + 128 >> 8;
              p = k;
              m = T;
              b = g * (C - M) + 128 >> 8;
              S = g * (C + M) + 128 >> 8;
              y = v << 4;
              w = O << 4;
              i2 = i2 + s2 + 1 >> 1;
              s2 = i2 - s2;
              D = p * d + m * u + 128 >> 8;
              p = p * u - m * d + 128 >> 8;
              m = D;
              b = b + w + 1 >> 1;
              w = b - w;
              S = S + y + 1 >> 1;
              y = S - y;
              i2 = i2 + m + 1 >> 1;
              m = i2 - m;
              s2 = s2 + p + 1 >> 1;
              p = s2 - p;
              D = b * h + S * l + 2048 >> 12;
              b = b * l - S * h + 2048 >> 12;
              S = D;
              D = y * c + w * o + 2048 >> 12;
              y = y * o - w * c + 2048 >> 12;
              w = D;
              a3[e4] = i2 + S;
              a3[e4 + 7] = i2 - S;
              a3[e4 + 1] = s2 + w;
              a3[e4 + 6] = s2 - w;
              a3[e4 + 2] = p + y;
              a3[e4 + 5] = p - y;
              a3[e4 + 3] = m + b;
              a3[e4 + 4] = m - b;
            } else {
              D = f * x + 512 >> 10;
              a3[e4] = D;
              a3[e4 + 1] = D;
              a3[e4 + 2] = D;
              a3[e4 + 3] = D;
              a3[e4 + 4] = D;
              a3[e4 + 5] = D;
              a3[e4 + 6] = D;
              a3[e4 + 7] = D;
            }
          }
          for (let e4 = 0; e4 < 8; ++e4) {
            x = a3[e4];
            C = a3[e4 + 8];
            k = a3[e4 + 16];
            v = a3[e4 + 24];
            F = a3[e4 + 32];
            O = a3[e4 + 40];
            T = a3[e4 + 48];
            M = a3[e4 + 56];
            if (0 != (C | k | v | F | O | T | M)) {
              i2 = f * x + 2048 >> 12;
              s2 = f * F + 2048 >> 12;
              p = k;
              m = T;
              b = g * (C - M) + 2048 >> 12;
              S = g * (C + M) + 2048 >> 12;
              y = v;
              w = O;
              i2 = 4112 + (i2 + s2 + 1 >> 1);
              s2 = i2 - s2;
              D = p * d + m * u + 2048 >> 12;
              p = p * u - m * d + 2048 >> 12;
              m = D;
              b = b + w + 1 >> 1;
              w = b - w;
              S = S + y + 1 >> 1;
              y = S - y;
              i2 = i2 + m + 1 >> 1;
              m = i2 - m;
              s2 = s2 + p + 1 >> 1;
              p = s2 - p;
              D = b * h + S * l + 2048 >> 12;
              b = b * l - S * h + 2048 >> 12;
              S = D;
              D = y * c + w * o + 2048 >> 12;
              y = y * o - w * c + 2048 >> 12;
              w = D;
              x = i2 + S;
              M = i2 - S;
              C = s2 + w;
              T = s2 - w;
              k = p + y;
              O = p - y;
              v = m + b;
              F = m - b;
              x < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4;
              C < 16 ? C = 0 : C >= 4080 ? C = 255 : C >>= 4;
              k < 16 ? k = 0 : k >= 4080 ? k = 255 : k >>= 4;
              v < 16 ? v = 0 : v >= 4080 ? v = 255 : v >>= 4;
              F < 16 ? F = 0 : F >= 4080 ? F = 255 : F >>= 4;
              O < 16 ? O = 0 : O >= 4080 ? O = 255 : O >>= 4;
              T < 16 ? T = 0 : T >= 4080 ? T = 255 : T >>= 4;
              M < 16 ? M = 0 : M >= 4080 ? M = 255 : M >>= 4;
              n2[t3 + e4] = x;
              n2[t3 + e4 + 8] = C;
              n2[t3 + e4 + 16] = k;
              n2[t3 + e4 + 24] = v;
              n2[t3 + e4 + 32] = F;
              n2[t3 + e4 + 40] = O;
              n2[t3 + e4 + 48] = T;
              n2[t3 + e4 + 56] = M;
            } else {
              D = f * x + 8192 >> 14;
              D = D < -2040 ? 0 : D >= 2024 ? 255 : D + 2056 >> 4;
              n2[t3 + e4] = D;
              n2[t3 + e4 + 8] = D;
              n2[t3 + e4 + 16] = D;
              n2[t3 + e4 + 24] = D;
              n2[t3 + e4 + 32] = D;
              n2[t3 + e4 + 40] = D;
              n2[t3 + e4 + 48] = D;
              n2[t3 + e4 + 56] = D;
            }
          }
        }
        function buildComponentData(e3, t3) {
          const a3 = t3.blocksPerLine, r2 = t3.blocksPerColumn, n2 = new Int16Array(64);
          for (let e4 = 0; e4 < r2; e4++) for (let r3 = 0; r3 < a3; r3++) {
            quantizeAndInverse(t3, getBlockBufferOffset(t3, e4, r3), n2);
          }
          return t3.blockData;
        }
        function findNextFileMarker(e3, t3, a3 = t3) {
          const r2 = e3.length - 1;
          let n2 = a3 < t3 ? a3 : t3;
          if (t3 >= r2) return null;
          const s2 = (0, i.readUint16)(e3, t3);
          if (s2 >= 65472 && s2 <= 65534) return { invalid: null, marker: s2, offset: t3 };
          let o2 = (0, i.readUint16)(e3, n2);
          for (; !(o2 >= 65472 && o2 <= 65534); ) {
            if (++n2 >= r2) return null;
            o2 = (0, i.readUint16)(e3, n2);
          }
          return { invalid: s2.toString(16), marker: o2, offset: n2 };
        }
        t2.JpegImage = class JpegImage {
          constructor({ decodeTransform: e3 = null, colorTransform: t3 = -1 } = {}) {
            this._decodeTransform = e3;
            this._colorTransform = t3;
          }
          parse(e3, { dnlScanLines: t3 = null } = {}) {
            function readDataBlock() {
              const t4 = (0, i.readUint16)(e3, o2);
              o2 += 2;
              let a4 = o2 + t4 - 2;
              const n3 = findNextFileMarker(e3, a4, o2);
              if (n3 == null ? void 0 : n3.invalid) {
                (0, r.warn)("readDataBlock - incorrect length, current marker is: " + n3.invalid);
                a4 = n3.offset;
              }
              const s2 = e3.subarray(o2, a4);
              o2 += s2.length;
              return s2;
            }
            function prepareComponents(e4) {
              const t4 = Math.ceil(e4.samplesPerLine / 8 / e4.maxH), a4 = Math.ceil(e4.scanLines / 8 / e4.maxV);
              for (const r2 of e4.components) {
                const n3 = Math.ceil(Math.ceil(e4.samplesPerLine / 8) * r2.h / e4.maxH), i2 = Math.ceil(Math.ceil(e4.scanLines / 8) * r2.v / e4.maxV), s2 = t4 * r2.h, o3 = 64 * (a4 * r2.v) * (s2 + 1);
                r2.blockData = new Int16Array(o3);
                r2.blocksPerLine = n3;
                r2.blocksPerColumn = i2;
              }
              e4.mcusPerLine = t4;
              e4.mcusPerColumn = a4;
            }
            let a3, n2, o2 = 0, c2 = null, l2 = null, h2 = 0;
            const u2 = [], d2 = [], f2 = [];
            let g2 = (0, i.readUint16)(e3, o2);
            o2 += 2;
            if (65496 !== g2) throw new JpegError("SOI not found");
            g2 = (0, i.readUint16)(e3, o2);
            o2 += 2;
            e: for (; 65497 !== g2; ) {
              let p, m, b;
              switch (g2) {
                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  const y = readDataBlock();
                  65504 === g2 && 74 === y[0] && 70 === y[1] && 73 === y[2] && 70 === y[3] && 0 === y[4] && (c2 = { version: { major: y[5], minor: y[6] }, densityUnits: y[7], xDensity: y[8] << 8 | y[9], yDensity: y[10] << 8 | y[11], thumbWidth: y[12], thumbHeight: y[13], thumbData: y.subarray(14, 14 + 3 * y[12] * y[13]) });
                  65518 === g2 && 65 === y[0] && 100 === y[1] && 111 === y[2] && 98 === y[3] && 101 === y[4] && (l2 = { version: y[5] << 8 | y[6], flags0: y[7] << 8 | y[8], flags1: y[9] << 8 | y[10], transformCode: y[11] });
                  break;
                case 65499:
                  const w = (0, i.readUint16)(e3, o2);
                  o2 += 2;
                  const S = w + o2 - 2;
                  let x;
                  for (; o2 < S; ) {
                    const t4 = e3[o2++], a4 = new Uint16Array(64);
                    if (t4 >> 4 == 0) for (m = 0; m < 64; m++) {
                      x = s[m];
                      a4[x] = e3[o2++];
                    }
                    else {
                      if (t4 >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                      for (m = 0; m < 64; m++) {
                        x = s[m];
                        a4[x] = (0, i.readUint16)(e3, o2);
                        o2 += 2;
                      }
                    }
                    u2[15 & t4] = a4;
                  }
                  break;
                case 65472:
                case 65473:
                case 65474:
                  if (a3) throw new JpegError("Only single frame JPEGs supported");
                  o2 += 2;
                  a3 = {};
                  a3.extended = 65473 === g2;
                  a3.progressive = 65474 === g2;
                  a3.precision = e3[o2++];
                  const C = (0, i.readUint16)(e3, o2);
                  o2 += 2;
                  a3.scanLines = t3 || C;
                  a3.samplesPerLine = (0, i.readUint16)(e3, o2);
                  o2 += 2;
                  a3.components = [];
                  a3.componentIds = {};
                  const k = e3[o2++];
                  let v = 0, F = 0;
                  for (p = 0; p < k; p++) {
                    const t4 = e3[o2], r2 = e3[o2 + 1] >> 4, n3 = 15 & e3[o2 + 1];
                    v < r2 && (v = r2);
                    F < n3 && (F = n3);
                    const i2 = e3[o2 + 2];
                    b = a3.components.push({ h: r2, v: n3, quantizationId: i2, quantizationTable: null });
                    a3.componentIds[t4] = b - 1;
                    o2 += 3;
                  }
                  a3.maxH = v;
                  a3.maxV = F;
                  prepareComponents(a3);
                  break;
                case 65476:
                  const O = (0, i.readUint16)(e3, o2);
                  o2 += 2;
                  for (p = 2; p < O; ) {
                    const t4 = e3[o2++], a4 = new Uint8Array(16);
                    let r2 = 0;
                    for (m = 0; m < 16; m++, o2++) r2 += a4[m] = e3[o2];
                    const n3 = new Uint8Array(r2);
                    for (m = 0; m < r2; m++, o2++) n3[m] = e3[o2];
                    p += 17 + r2;
                    (t4 >> 4 == 0 ? f2 : d2)[15 & t4] = buildHuffmanTable(a4, n3);
                  }
                  break;
                case 65501:
                  o2 += 2;
                  n2 = (0, i.readUint16)(e3, o2);
                  o2 += 2;
                  break;
                case 65498:
                  const T = 1 == ++h2 && !t3;
                  o2 += 2;
                  const M = e3[o2++], D = [];
                  for (p = 0; p < M; p++) {
                    const t4 = e3[o2++], r2 = a3.componentIds[t4], n3 = a3.components[r2];
                    n3.index = t4;
                    const i2 = e3[o2++];
                    n3.huffmanTableDC = f2[i2 >> 4];
                    n3.huffmanTableAC = d2[15 & i2];
                    D.push(n3);
                  }
                  const E = e3[o2++], N = e3[o2++], R = e3[o2++];
                  try {
                    const t4 = decodeScan(e3, o2, a3, D, n2, E, N, R >> 4, 15 & R, T);
                    o2 += t4;
                  } catch (t4) {
                    if (t4 instanceof DNLMarkerError) {
                      (0, r.warn)(`${t4.message} -- attempting to re-parse the JPEG image.`);
                      return this.parse(e3, { dnlScanLines: t4.scanLines });
                    }
                    if (t4 instanceof EOIMarkerError) {
                      (0, r.warn)(`${t4.message} -- ignoring the rest of the image data.`);
                      break e;
                    }
                    throw t4;
                  }
                  break;
                case 65500:
                  o2 += 4;
                  break;
                case 65535:
                  255 !== e3[o2] && o2--;
                  break;
                default:
                  const L = findNextFileMarker(e3, o2 - 2, o2 - 3);
                  if (L == null ? void 0 : L.invalid) {
                    (0, r.warn)("JpegImage.parse - unexpected data, current marker is: " + L.invalid);
                    o2 = L.offset;
                    break;
                  }
                  if (!L || o2 >= e3.length - 1) {
                    (0, r.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                    break e;
                  }
                  throw new JpegError("JpegImage.parse - unknown marker: " + g2.toString(16));
              }
              g2 = (0, i.readUint16)(e3, o2);
              o2 += 2;
            }
            this.width = a3.samplesPerLine;
            this.height = a3.scanLines;
            this.jfif = c2;
            this.adobe = l2;
            this.components = [];
            for (const e4 of a3.components) {
              const t4 = u2[e4.quantizationId];
              t4 && (e4.quantizationTable = t4);
              this.components.push({ index: e4.index, output: buildComponentData(0, e4), scaleX: e4.h / a3.maxH, scaleY: e4.v / a3.maxV, blocksPerLine: e4.blocksPerLine, blocksPerColumn: e4.blocksPerColumn });
            }
            this.numComponents = this.components.length;
          }
          _getLinearizedBlockData(e3, t3, a3 = false) {
            const r2 = this.width / e3, n2 = this.height / t3;
            let i2, s2, o2, c2, l2, h2, u2, d2, f2, g2, p, m = 0;
            const b = this.components.length, y = e3 * t3 * b, w = new Uint8ClampedArray(y), S = new Uint32Array(e3), x = 4294967288;
            let C;
            for (u2 = 0; u2 < b; u2++) {
              i2 = this.components[u2];
              s2 = i2.scaleX * r2;
              o2 = i2.scaleY * n2;
              m = u2;
              p = i2.output;
              c2 = i2.blocksPerLine + 1 << 3;
              if (s2 !== C) {
                for (l2 = 0; l2 < e3; l2++) {
                  d2 = 0 | l2 * s2;
                  S[l2] = (d2 & x) << 3 | 7 & d2;
                }
                C = s2;
              }
              for (h2 = 0; h2 < t3; h2++) {
                d2 = 0 | h2 * o2;
                g2 = c2 * (d2 & x) | (7 & d2) << 3;
                for (l2 = 0; l2 < e3; l2++) {
                  w[m] = p[g2 + S[l2]];
                  m += b;
                }
              }
            }
            let k = this._decodeTransform;
            a3 || 4 !== b || k || (k = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]));
            if (k) for (u2 = 0; u2 < y; ) for (d2 = 0, f2 = 0; d2 < b; d2++, u2++, f2 += 2) w[u2] = (w[u2] * k[f2] >> 8) + k[f2 + 1];
            return w;
          }
          get _isColorConversionNeeded() {
            return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
          }
          _convertYccToRgb(e3) {
            let t3, a3, r2;
            for (let n2 = 0, i2 = e3.length; n2 < i2; n2 += 3) {
              t3 = e3[n2];
              a3 = e3[n2 + 1];
              r2 = e3[n2 + 2];
              e3[n2] = t3 - 179.456 + 1.402 * r2;
              e3[n2 + 1] = t3 + 135.459 - 0.344 * a3 - 0.714 * r2;
              e3[n2 + 2] = t3 - 226.816 + 1.772 * a3;
            }
            return e3;
          }
          _convertYccToRgba(e3, t3) {
            for (let a3 = 0, r2 = 0, n2 = e3.length; a3 < n2; a3 += 3, r2 += 4) {
              const n3 = e3[a3], i2 = e3[a3 + 1], s2 = e3[a3 + 2];
              t3[r2] = n3 - 179.456 + 1.402 * s2;
              t3[r2 + 1] = n3 + 135.459 - 0.344 * i2 - 0.714 * s2;
              t3[r2 + 2] = n3 - 226.816 + 1.772 * i2;
              t3[r2 + 3] = 255;
            }
            return t3;
          }
          _convertYcckToRgb(e3) {
            let t3, a3, r2, n2, i2 = 0;
            for (let s2 = 0, o2 = e3.length; s2 < o2; s2 += 4) {
              t3 = e3[s2];
              a3 = e3[s2 + 1];
              r2 = e3[s2 + 2];
              n2 = e3[s2 + 3];
              e3[i2++] = a3 * (-660635669420364e-19 * a3 + 437130475926232e-18 * r2 - 54080610064599e-18 * t3 + 48449797120281e-17 * n2 - 0.154362151871126) - 122.67195406894 + r2 * (-957964378445773e-18 * r2 + 817076911346625e-18 * t3 - 0.00477271405408747 * n2 + 1.53380253221734) + t3 * (961250184130688e-18 * t3 - 0.00266257332283933 * n2 + 0.48357088451265) + n2 * (-336197177618394e-18 * n2 + 0.484791561490776);
              e3[i2++] = 107.268039397724 + a3 * (219927104525741e-19 * a3 - 640992018297945e-18 * r2 + 659397001245577e-18 * t3 + 426105652938837e-18 * n2 - 0.176491792462875) + r2 * (-778269941513683e-18 * r2 + 0.00130872261408275 * t3 + 770482631801132e-18 * n2 - 0.151051492775562) + t3 * (0.00126935368114843 * t3 - 0.00265090189010898 * n2 + 0.25802910206845) + n2 * (-318913117588328e-18 * n2 - 0.213742400323665);
              e3[i2++] = a3 * (-570115196973677e-18 * a3 - 263409051004589e-19 * r2 + 0.0020741088115012 * t3 - 0.00288260236853442 * n2 + 0.814272968359295) - 20.810012546947 + r2 * (-153496057440975e-19 * r2 - 132689043961446e-18 * t3 + 560833691242812e-18 * n2 - 0.195152027534049) + t3 * (0.00174418132927582 * t3 - 0.00255243321439347 * n2 + 0.116935020465145) + n2 * (-343531996510555e-18 * n2 + 0.24165260232407);
            }
            return e3.subarray(0, i2);
          }
          _convertYcckToRgba(e3) {
            for (let t3 = 0, a3 = e3.length; t3 < a3; t3 += 4) {
              const a4 = e3[t3], r2 = e3[t3 + 1], n2 = e3[t3 + 2], i2 = e3[t3 + 3];
              e3[t3] = r2 * (-660635669420364e-19 * r2 + 437130475926232e-18 * n2 - 54080610064599e-18 * a4 + 48449797120281e-17 * i2 - 0.154362151871126) - 122.67195406894 + n2 * (-957964378445773e-18 * n2 + 817076911346625e-18 * a4 - 0.00477271405408747 * i2 + 1.53380253221734) + a4 * (961250184130688e-18 * a4 - 0.00266257332283933 * i2 + 0.48357088451265) + i2 * (-336197177618394e-18 * i2 + 0.484791561490776);
              e3[t3 + 1] = 107.268039397724 + r2 * (219927104525741e-19 * r2 - 640992018297945e-18 * n2 + 659397001245577e-18 * a4 + 426105652938837e-18 * i2 - 0.176491792462875) + n2 * (-778269941513683e-18 * n2 + 0.00130872261408275 * a4 + 770482631801132e-18 * i2 - 0.151051492775562) + a4 * (0.00126935368114843 * a4 - 0.00265090189010898 * i2 + 0.25802910206845) + i2 * (-318913117588328e-18 * i2 - 0.213742400323665);
              e3[t3 + 2] = r2 * (-570115196973677e-18 * r2 - 263409051004589e-19 * n2 + 0.0020741088115012 * a4 - 0.00288260236853442 * i2 + 0.814272968359295) - 20.810012546947 + n2 * (-153496057440975e-19 * n2 - 132689043961446e-18 * a4 + 560833691242812e-18 * i2 - 0.195152027534049) + a4 * (0.00174418132927582 * a4 - 0.00255243321439347 * i2 + 0.116935020465145) + i2 * (-343531996510555e-18 * i2 + 0.24165260232407);
              e3[t3 + 3] = 255;
            }
            return e3;
          }
          _convertYcckToCmyk(e3) {
            let t3, a3, r2;
            for (let n2 = 0, i2 = e3.length; n2 < i2; n2 += 4) {
              t3 = e3[n2];
              a3 = e3[n2 + 1];
              r2 = e3[n2 + 2];
              e3[n2] = 434.456 - t3 - 1.402 * r2;
              e3[n2 + 1] = 119.541 - t3 + 0.344 * a3 + 0.714 * r2;
              e3[n2 + 2] = 481.816 - t3 - 1.772 * a3;
            }
            return e3;
          }
          _convertCmykToRgb(e3) {
            let t3, a3, r2, n2, i2 = 0;
            for (let s2 = 0, o2 = e3.length; s2 < o2; s2 += 4) {
              t3 = e3[s2];
              a3 = e3[s2 + 1];
              r2 = e3[s2 + 2];
              n2 = e3[s2 + 3];
              e3[i2++] = 255 + t3 * (-6747147073602441e-20 * t3 + 8379262121013727e-19 * a3 + 2894718188643294e-19 * r2 + 0.003264231057537806 * n2 - 1.1185611867203937) + a3 * (26374107616089405e-21 * a3 - 8626949158638572e-20 * r2 - 2748769067499491e-19 * n2 - 0.02155688794978967) + r2 * (-3878099212869363e-20 * r2 - 3267808279485286e-19 * n2 + 0.0686742238595345) - n2 * (3361971776183937e-19 * n2 + 0.7430659151342254);
              e3[i2++] = 255 + t3 * (13596372813588848e-20 * t3 + 924537132573585e-18 * a3 + 10567359618683593e-20 * r2 + 4791864687436512e-19 * n2 - 0.3109689587515875) + a3 * (-23545346108370344e-20 * a3 + 2702845253534714e-19 * r2 + 0.0020200308977307156 * n2 - 0.7488052167015494) + r2 * (6834815998235662e-20 * r2 + 15168452363460973e-20 * n2 - 0.09751927774728933) - n2 * (3189131175883281e-19 * n2 + 0.7364883807733168);
              e3[i2++] = 255 + t3 * (13598650411385307e-21 * t3 + 12423956175490851e-20 * a3 + 4751985097583589e-19 * r2 - 36729317476630422e-22 * n2 - 0.05562186980264034) + a3 * (16141380598724676e-20 * a3 + 9692239130725186e-19 * r2 + 7782692450036253e-19 * n2 - 0.44015232367526463) + r2 * (5068882914068769e-22 * r2 + 0.0017778369011375071 * n2 - 0.7591454649749609) - n2 * (3435319965105553e-19 * n2 + 0.7063770186160144);
            }
            return e3.subarray(0, i2);
          }
          _convertCmykToRgba(e3) {
            for (let t3 = 0, a3 = e3.length; t3 < a3; t3 += 4) {
              const a4 = e3[t3], r2 = e3[t3 + 1], n2 = e3[t3 + 2], i2 = e3[t3 + 3];
              e3[t3] = 255 + a4 * (-6747147073602441e-20 * a4 + 8379262121013727e-19 * r2 + 2894718188643294e-19 * n2 + 0.003264231057537806 * i2 - 1.1185611867203937) + r2 * (26374107616089405e-21 * r2 - 8626949158638572e-20 * n2 - 2748769067499491e-19 * i2 - 0.02155688794978967) + n2 * (-3878099212869363e-20 * n2 - 3267808279485286e-19 * i2 + 0.0686742238595345) - i2 * (3361971776183937e-19 * i2 + 0.7430659151342254);
              e3[t3 + 1] = 255 + a4 * (13596372813588848e-20 * a4 + 924537132573585e-18 * r2 + 10567359618683593e-20 * n2 + 4791864687436512e-19 * i2 - 0.3109689587515875) + r2 * (-23545346108370344e-20 * r2 + 2702845253534714e-19 * n2 + 0.0020200308977307156 * i2 - 0.7488052167015494) + n2 * (6834815998235662e-20 * n2 + 15168452363460973e-20 * i2 - 0.09751927774728933) - i2 * (3189131175883281e-19 * i2 + 0.7364883807733168);
              e3[t3 + 2] = 255 + a4 * (13598650411385307e-21 * a4 + 12423956175490851e-20 * r2 + 4751985097583589e-19 * n2 - 36729317476630422e-22 * i2 - 0.05562186980264034) + r2 * (16141380598724676e-20 * r2 + 9692239130725186e-19 * n2 + 7782692450036253e-19 * i2 - 0.44015232367526463) + n2 * (5068882914068769e-22 * n2 + 0.0017778369011375071 * i2 - 0.7591454649749609) - i2 * (3435319965105553e-19 * i2 + 0.7063770186160144);
              e3[t3 + 3] = 255;
            }
            return e3;
          }
          getData({ width: e3, height: t3, forceRGBA: a3 = false, forceRGB: r2 = false, isSourcePDF: i2 = false }) {
            if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
            const s2 = this._getLinearizedBlockData(e3, t3, i2);
            if (1 === this.numComponents && (a3 || r2)) {
              const e4 = s2.length * (a3 ? 4 : 3), t4 = new Uint8ClampedArray(e4);
              let r3 = 0;
              if (a3) (0, n.grayToRGBA)(s2, new Uint32Array(t4.buffer));
              else for (const e5 of s2) {
                t4[r3++] = e5;
                t4[r3++] = e5;
                t4[r3++] = e5;
              }
              return t4;
            }
            if (3 === this.numComponents && this._isColorConversionNeeded) {
              if (a3) {
                const e4 = new Uint8ClampedArray(s2.length / 3 * 4);
                return this._convertYccToRgba(s2, e4);
              }
              return this._convertYccToRgb(s2);
            }
            if (4 === this.numComponents) {
              if (this._isColorConversionNeeded) return a3 ? this._convertYcckToRgba(s2) : r2 ? this._convertYcckToRgb(s2) : this._convertYcckToCmyk(s2);
              if (a3) return this._convertCmykToRgba(s2);
              if (r2) return this._convertCmykToRgb(s2);
            }
            return s2;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;
        t2.convertToRGBA = function convertToRGBA(e3) {
          switch (e3.kind) {
            case r.ImageKind.GRAYSCALE_1BPP:
              return convertBlackAndWhiteToRGBA(e3);
            case r.ImageKind.RGB_24BPP:
              return function convertRGBToRGBA({ src: e4, srcPos: t3 = 0, dest: a3, destPos: n = 0, width: i, height: s }) {
                let o = 0;
                const c = e4.length >> 2, l = new Uint32Array(e4.buffer, t3, c);
                if (r.FeatureTest.isLittleEndian) {
                  for (; o < c - 2; o += 3, n += 4) {
                    const e5 = l[o], t4 = l[o + 1], r2 = l[o + 2];
                    a3[n] = 4278190080 | e5;
                    a3[n + 1] = e5 >>> 24 | t4 << 8 | 4278190080;
                    a3[n + 2] = t4 >>> 16 | r2 << 16 | 4278190080;
                    a3[n + 3] = r2 >>> 8 | 4278190080;
                  }
                  for (let t4 = 4 * o, r2 = e4.length; t4 < r2; t4 += 3) a3[n++] = e4[t4] | e4[t4 + 1] << 8 | e4[t4 + 2] << 16 | 4278190080;
                } else {
                  for (; o < c - 2; o += 3, n += 4) {
                    const e5 = l[o], t4 = l[o + 1], r2 = l[o + 2];
                    a3[n] = 255 | e5;
                    a3[n + 1] = e5 << 24 | t4 >>> 8 | 255;
                    a3[n + 2] = t4 << 16 | r2 >>> 16 | 255;
                    a3[n + 3] = r2 << 8 | 255;
                  }
                  for (let t4 = 4 * o, r2 = e4.length; t4 < r2; t4 += 3) a3[n++] = e4[t4] << 24 | e4[t4 + 1] << 16 | e4[t4 + 2] << 8 | 255;
                }
                return { srcPos: t3, destPos: n };
              }(e3);
          }
          return null;
        };
        t2.grayToRGBA = function grayToRGBA(e3, t3) {
          if (r.FeatureTest.isLittleEndian) for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) t3[a3] = 65793 * e3[a3] | 4278190080;
          else for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) t3[a3] = 16843008 * e3[a3] | 255;
        };
        var r = a2(2);
        function convertBlackAndWhiteToRGBA({ src: e3, srcPos: t3 = 0, dest: a3, width: n, height: i, nonBlackColor: s = 4294967295, inverseDecode: o = false }) {
          const c = r.FeatureTest.isLittleEndian ? 4278190080 : 255, [l, h] = o ? [s, c] : [c, s], u = n >> 3, d = 7 & n, f = e3.length;
          a3 = new Uint32Array(a3.buffer);
          let g = 0;
          for (let r2 = 0; r2 < i; r2++) {
            for (const r4 = t3 + u; t3 < r4; t3++) {
              const r5 = t3 < f ? e3[t3] : 255;
              a3[g++] = 128 & r5 ? h : l;
              a3[g++] = 64 & r5 ? h : l;
              a3[g++] = 32 & r5 ? h : l;
              a3[g++] = 16 & r5 ? h : l;
              a3[g++] = 8 & r5 ? h : l;
              a3[g++] = 4 & r5 ? h : l;
              a3[g++] = 2 & r5 ? h : l;
              a3[g++] = 1 & r5 ? h : l;
            }
            if (0 === d) continue;
            const r3 = t3 < f ? e3[t3++] : 255;
            for (let e4 = 0; e4 < d; e4++) a3[g++] = r3 & 1 << 7 - e4 ? h : l;
          }
          return { srcPos: t3, destPos: g };
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.JpxStream = void 0;
        var r = a2(18), n = a2(30), i = a2(2);
        class JpxStream extends r.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            this.stream = e3;
            this.dict = e3.dict;
            this.maybeLength = t3;
            this.params = a3;
          }
          get bytes() {
            return (0, i.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
          }
          ensureBuffer(e3) {
          }
          readBlock() {
            if (this.eof) return;
            const e3 = new n.JpxImage();
            e3.parse(this.bytes);
            const t3 = e3.width, a3 = e3.height, r2 = e3.componentsCount, i2 = e3.tiles.length;
            if (1 === i2) this.buffer = e3.tiles[0].items;
            else {
              const n2 = new Uint8ClampedArray(t3 * a3 * r2);
              for (let a4 = 0; a4 < i2; a4++) {
                const i3 = e3.tiles[a4], s = i3.width, o = i3.height, c = i3.left, l = i3.top, h = i3.items;
                let u = 0, d = (t3 * l + c) * r2;
                const f = t3 * r2, g = s * r2;
                for (let e4 = 0; e4 < o; e4++) {
                  const e5 = h.subarray(u, u + g);
                  n2.set(e5, d);
                  u += g;
                  d += f;
                }
              }
              this.buffer = n2;
            }
            this.bufferLength = this.buffer.length;
            this.eof = true;
          }
        }
        t2.JpxStream = JpxStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.JpxImage = void 0;
        var r = a2(2), n = a2(3), i = a2(25);
        class JpxError extends r.BaseException {
          constructor(e3) {
            super(`JPX error: ${e3}`, "JpxError");
          }
        }
        const s = { LL: 0, LH: 1, HL: 1, HH: 2 };
        t2.JpxImage = class JpxImage {
          constructor() {
            this.failOnCorruptedImage = false;
          }
          parse(e3) {
            if (65359 === (0, n.readUint16)(e3, 0)) {
              this.parseCodestream(e3, 0, e3.length);
              return;
            }
            const t3 = e3.length;
            let a3 = 0;
            for (; a3 < t3; ) {
              let i2 = 8, s2 = (0, n.readUint32)(e3, a3);
              const o = (0, n.readUint32)(e3, a3 + 4);
              a3 += i2;
              if (1 === s2) {
                s2 = 4294967296 * (0, n.readUint32)(e3, a3) + (0, n.readUint32)(e3, a3 + 4);
                a3 += 8;
                i2 += 8;
              }
              0 === s2 && (s2 = t3 - a3 + i2);
              if (s2 < i2) throw new JpxError("Invalid box field size");
              const c = s2 - i2;
              let l = true;
              switch (o) {
                case 1785737832:
                  l = false;
                  break;
                case 1668246642:
                  const t4 = e3[a3];
                  if (1 === t4) {
                    const t5 = (0, n.readUint32)(e3, a3 + 3);
                    switch (t5) {
                      case 16:
                      case 17:
                      case 18:
                        break;
                      default:
                        (0, r.warn)("Unknown colorspace " + t5);
                    }
                  } else 2 === t4 && (0, r.info)("ICC profile not supported");
                  break;
                case 1785737827:
                  this.parseCodestream(e3, a3, a3 + c);
                  break;
                case 1783636e3:
                  218793738 !== (0, n.readUint32)(e3, a3) && (0, r.warn)("Invalid JP2 signature");
                  break;
                case 1783634458:
                case 1718909296:
                case 1920099697:
                case 1919251232:
                case 1768449138:
                  break;
                default:
                  const i3 = String.fromCharCode(o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o);
                  (0, r.warn)(`Unsupported header type ${o} (${i3}).`);
              }
              l && (a3 += c);
            }
          }
          parseImageProperties(e3) {
            let t3 = e3.getByte();
            for (; t3 >= 0; ) {
              const a3 = t3;
              t3 = e3.getByte();
              if (65361 === (a3 << 8 | t3)) {
                e3.skip(4);
                const t4 = e3.getInt32() >>> 0, a4 = e3.getInt32() >>> 0, r2 = e3.getInt32() >>> 0, n2 = e3.getInt32() >>> 0;
                e3.skip(16);
                const i2 = e3.getUint16();
                this.width = t4 - r2;
                this.height = a4 - n2;
                this.componentsCount = i2;
                this.bitsPerComponent = 8;
                return;
              }
            }
            throw new JpxError("No size marker found in JPX stream");
          }
          parseCodestream(e3, t3, a3) {
            const i2 = {};
            let s2 = false;
            try {
              let o = t3;
              for (; o + 1 < a3; ) {
                const t4 = (0, n.readUint16)(e3, o);
                o += 2;
                let a4, c, l, h, u, d, f = 0;
                switch (t4) {
                  case 65359:
                    i2.mainHeader = true;
                    break;
                  case 65497:
                    break;
                  case 65361:
                    f = (0, n.readUint16)(e3, o);
                    const g = {};
                    g.Xsiz = (0, n.readUint32)(e3, o + 4);
                    g.Ysiz = (0, n.readUint32)(e3, o + 8);
                    g.XOsiz = (0, n.readUint32)(e3, o + 12);
                    g.YOsiz = (0, n.readUint32)(e3, o + 16);
                    g.XTsiz = (0, n.readUint32)(e3, o + 20);
                    g.YTsiz = (0, n.readUint32)(e3, o + 24);
                    g.XTOsiz = (0, n.readUint32)(e3, o + 28);
                    g.YTOsiz = (0, n.readUint32)(e3, o + 32);
                    const p = (0, n.readUint16)(e3, o + 36);
                    g.Csiz = p;
                    const m = [];
                    a4 = o + 38;
                    for (let t5 = 0; t5 < p; t5++) {
                      const t6 = { precision: 1 + (127 & e3[a4]), isSigned: !!(128 & e3[a4]), XRsiz: e3[a4 + 1], YRsiz: e3[a4 + 2] };
                      a4 += 3;
                      calculateComponentDimensions(t6, g);
                      m.push(t6);
                    }
                    i2.SIZ = g;
                    i2.components = m;
                    calculateTileGrids(i2, m);
                    i2.QCC = [];
                    i2.COC = [];
                    break;
                  case 65372:
                    f = (0, n.readUint16)(e3, o);
                    const b = {};
                    a4 = o + 2;
                    c = e3[a4++];
                    switch (31 & c) {
                      case 0:
                        h = 8;
                        u = true;
                        break;
                      case 1:
                        h = 16;
                        u = false;
                        break;
                      case 2:
                        h = 16;
                        u = true;
                        break;
                      default:
                        throw new Error("Invalid SQcd value " + c);
                    }
                    b.noQuantization = 8 === h;
                    b.scalarExpounded = u;
                    b.guardBits = c >> 5;
                    l = [];
                    for (; a4 < f + o; ) {
                      const t5 = {};
                      if (8 === h) {
                        t5.epsilon = e3[a4++] >> 3;
                        t5.mu = 0;
                      } else {
                        t5.epsilon = e3[a4] >> 3;
                        t5.mu = (7 & e3[a4]) << 8 | e3[a4 + 1];
                        a4 += 2;
                      }
                      l.push(t5);
                    }
                    b.SPqcds = l;
                    if (i2.mainHeader) i2.QCD = b;
                    else {
                      i2.currentTile.QCD = b;
                      i2.currentTile.QCC = [];
                    }
                    break;
                  case 65373:
                    f = (0, n.readUint16)(e3, o);
                    const y = {};
                    a4 = o + 2;
                    let w;
                    if (i2.SIZ.Csiz < 257) w = e3[a4++];
                    else {
                      w = (0, n.readUint16)(e3, a4);
                      a4 += 2;
                    }
                    c = e3[a4++];
                    switch (31 & c) {
                      case 0:
                        h = 8;
                        u = true;
                        break;
                      case 1:
                        h = 16;
                        u = false;
                        break;
                      case 2:
                        h = 16;
                        u = true;
                        break;
                      default:
                        throw new Error("Invalid SQcd value " + c);
                    }
                    y.noQuantization = 8 === h;
                    y.scalarExpounded = u;
                    y.guardBits = c >> 5;
                    l = [];
                    for (; a4 < f + o; ) {
                      const t5 = {};
                      if (8 === h) {
                        t5.epsilon = e3[a4++] >> 3;
                        t5.mu = 0;
                      } else {
                        t5.epsilon = e3[a4] >> 3;
                        t5.mu = (7 & e3[a4]) << 8 | e3[a4 + 1];
                        a4 += 2;
                      }
                      l.push(t5);
                    }
                    y.SPqcds = l;
                    i2.mainHeader ? i2.QCC[w] = y : i2.currentTile.QCC[w] = y;
                    break;
                  case 65362:
                    f = (0, n.readUint16)(e3, o);
                    const S = {};
                    a4 = o + 2;
                    const x = e3[a4++];
                    S.entropyCoderWithCustomPrecincts = !!(1 & x);
                    S.sopMarkerUsed = !!(2 & x);
                    S.ephMarkerUsed = !!(4 & x);
                    S.progressionOrder = e3[a4++];
                    S.layersCount = (0, n.readUint16)(e3, a4);
                    a4 += 2;
                    S.multipleComponentTransform = e3[a4++];
                    S.decompositionLevelsCount = e3[a4++];
                    S.xcb = 2 + (15 & e3[a4++]);
                    S.ycb = 2 + (15 & e3[a4++]);
                    const C = e3[a4++];
                    S.selectiveArithmeticCodingBypass = !!(1 & C);
                    S.resetContextProbabilities = !!(2 & C);
                    S.terminationOnEachCodingPass = !!(4 & C);
                    S.verticallyStripe = !!(8 & C);
                    S.predictableTermination = !!(16 & C);
                    S.segmentationSymbolUsed = !!(32 & C);
                    S.reversibleTransformation = e3[a4++];
                    if (S.entropyCoderWithCustomPrecincts) {
                      const t5 = [];
                      for (; a4 < f + o; ) {
                        const r2 = e3[a4++];
                        t5.push({ PPx: 15 & r2, PPy: r2 >> 4 });
                      }
                      S.precinctsSizes = t5;
                    }
                    const k = [];
                    S.selectiveArithmeticCodingBypass && k.push("selectiveArithmeticCodingBypass");
                    S.terminationOnEachCodingPass && k.push("terminationOnEachCodingPass");
                    S.verticallyStripe && k.push("verticallyStripe");
                    S.predictableTermination && k.push("predictableTermination");
                    if (k.length > 0) {
                      s2 = true;
                      (0, r.warn)(`JPX: Unsupported COD options (${k.join(", ")}).`);
                    }
                    if (i2.mainHeader) i2.COD = S;
                    else {
                      i2.currentTile.COD = S;
                      i2.currentTile.COC = [];
                    }
                    break;
                  case 65424:
                    f = (0, n.readUint16)(e3, o);
                    d = {};
                    d.index = (0, n.readUint16)(e3, o + 2);
                    d.length = (0, n.readUint32)(e3, o + 4);
                    d.dataEnd = d.length + o - 2;
                    d.partIndex = e3[o + 8];
                    d.partsCount = e3[o + 9];
                    i2.mainHeader = false;
                    if (0 === d.partIndex) {
                      d.COD = i2.COD;
                      d.COC = i2.COC.slice(0);
                      d.QCD = i2.QCD;
                      d.QCC = i2.QCC.slice(0);
                    }
                    i2.currentTile = d;
                    break;
                  case 65427:
                    d = i2.currentTile;
                    if (0 === d.partIndex) {
                      initializeTile(i2, d.index);
                      buildPackets(i2);
                    }
                    f = d.dataEnd - o;
                    parseTilePackets(i2, e3, o, f);
                    break;
                  case 65363:
                    (0, r.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                  case 65365:
                  case 65367:
                  case 65368:
                  case 65380:
                    f = (0, n.readUint16)(e3, o);
                    break;
                  default:
                    throw new Error("Unknown codestream code: " + t4.toString(16));
                }
                o += f;
              }
            } catch (e4) {
              if (s2 || this.failOnCorruptedImage) throw new JpxError(e4.message);
              (0, r.warn)(`JPX: Trying to recover from: "${e4.message}".`);
            }
            this.tiles = function transformComponents(e4) {
              const t4 = e4.SIZ, a4 = e4.components, r2 = t4.Csiz, n2 = [];
              for (let t5 = 0, i3 = e4.tiles.length; t5 < i3; t5++) {
                const i4 = e4.tiles[t5], s3 = [];
                for (let t6 = 0; t6 < r2; t6++) s3[t6] = transformTile(e4, i4, t6);
                const o = s3[0], c = new Uint8ClampedArray(o.items.length * r2), l = { left: o.left, top: o.top, width: o.width, height: o.height, items: c };
                let h, u, d, f, g, p, m, b = 0;
                if (i4.codingStyleDefaultParameters.multipleComponentTransform) {
                  const e5 = 4 === r2, t6 = s3[0].items, n3 = s3[1].items, o2 = s3[2].items, l2 = e5 ? s3[3].items : null;
                  h = a4[0].precision - 8;
                  u = 0.5 + (128 << h);
                  const y = i4.components[0], w = r2 - 3;
                  f = t6.length;
                  if (y.codingStyleParameters.reversibleTransformation) for (d = 0; d < f; d++, b += w) {
                    g = t6[d] + u;
                    p = n3[d];
                    m = o2[d];
                    const e6 = g - (m + p >> 2);
                    c[b++] = e6 + m >> h;
                    c[b++] = e6 >> h;
                    c[b++] = e6 + p >> h;
                  }
                  else for (d = 0; d < f; d++, b += w) {
                    g = t6[d] + u;
                    p = n3[d];
                    m = o2[d];
                    c[b++] = g + 1.402 * m >> h;
                    c[b++] = g - 0.34413 * p - 0.71414 * m >> h;
                    c[b++] = g + 1.772 * p >> h;
                  }
                  if (e5) for (d = 0, b = 3; d < f; d++, b += 4) c[b] = l2[d] + u >> h;
                } else for (let e5 = 0; e5 < r2; e5++) {
                  const t6 = s3[e5].items;
                  h = a4[e5].precision - 8;
                  u = 0.5 + (128 << h);
                  for (b = e5, d = 0, f = t6.length; d < f; d++) {
                    c[b] = t6[d] + u >> h;
                    b += r2;
                  }
                }
                n2.push(l);
              }
              return n2;
            }(i2);
            this.width = i2.SIZ.Xsiz - i2.SIZ.XOsiz;
            this.height = i2.SIZ.Ysiz - i2.SIZ.YOsiz;
            this.componentsCount = i2.SIZ.Csiz;
          }
        };
        function calculateComponentDimensions(e3, t3) {
          e3.x0 = Math.ceil(t3.XOsiz / e3.XRsiz);
          e3.x1 = Math.ceil(t3.Xsiz / e3.XRsiz);
          e3.y0 = Math.ceil(t3.YOsiz / e3.YRsiz);
          e3.y1 = Math.ceil(t3.Ysiz / e3.YRsiz);
          e3.width = e3.x1 - e3.x0;
          e3.height = e3.y1 - e3.y0;
        }
        function calculateTileGrids(e3, t3) {
          const a3 = e3.SIZ, r2 = [];
          let n2;
          const i2 = Math.ceil((a3.Xsiz - a3.XTOsiz) / a3.XTsiz), s2 = Math.ceil((a3.Ysiz - a3.YTOsiz) / a3.YTsiz);
          for (let e4 = 0; e4 < s2; e4++) for (let t4 = 0; t4 < i2; t4++) {
            n2 = {};
            n2.tx0 = Math.max(a3.XTOsiz + t4 * a3.XTsiz, a3.XOsiz);
            n2.ty0 = Math.max(a3.YTOsiz + e4 * a3.YTsiz, a3.YOsiz);
            n2.tx1 = Math.min(a3.XTOsiz + (t4 + 1) * a3.XTsiz, a3.Xsiz);
            n2.ty1 = Math.min(a3.YTOsiz + (e4 + 1) * a3.YTsiz, a3.Ysiz);
            n2.width = n2.tx1 - n2.tx0;
            n2.height = n2.ty1 - n2.ty0;
            n2.components = [];
            r2.push(n2);
          }
          e3.tiles = r2;
          for (let e4 = 0, i3 = a3.Csiz; e4 < i3; e4++) {
            const a4 = t3[e4];
            for (let t4 = 0, i4 = r2.length; t4 < i4; t4++) {
              const i5 = {};
              n2 = r2[t4];
              i5.tcx0 = Math.ceil(n2.tx0 / a4.XRsiz);
              i5.tcy0 = Math.ceil(n2.ty0 / a4.YRsiz);
              i5.tcx1 = Math.ceil(n2.tx1 / a4.XRsiz);
              i5.tcy1 = Math.ceil(n2.ty1 / a4.YRsiz);
              i5.width = i5.tcx1 - i5.tcx0;
              i5.height = i5.tcy1 - i5.tcy0;
              n2.components[e4] = i5;
            }
          }
        }
        function getBlocksDimensions(e3, t3, a3) {
          const r2 = t3.codingStyleParameters, n2 = {};
          if (r2.entropyCoderWithCustomPrecincts) {
            n2.PPx = r2.precinctsSizes[a3].PPx;
            n2.PPy = r2.precinctsSizes[a3].PPy;
          } else {
            n2.PPx = 15;
            n2.PPy = 15;
          }
          n2.xcb_ = a3 > 0 ? Math.min(r2.xcb, n2.PPx - 1) : Math.min(r2.xcb, n2.PPx);
          n2.ycb_ = a3 > 0 ? Math.min(r2.ycb, n2.PPy - 1) : Math.min(r2.ycb, n2.PPy);
          return n2;
        }
        function buildPrecincts(e3, t3, a3) {
          const r2 = 1 << a3.PPx, n2 = 1 << a3.PPy, i2 = 0 === t3.resLevel, s2 = 1 << a3.PPx + (i2 ? 0 : -1), o = 1 << a3.PPy + (i2 ? 0 : -1), c = t3.trx1 > t3.trx0 ? Math.ceil(t3.trx1 / r2) - Math.floor(t3.trx0 / r2) : 0, l = t3.try1 > t3.try0 ? Math.ceil(t3.try1 / n2) - Math.floor(t3.try0 / n2) : 0, h = c * l;
          t3.precinctParameters = { precinctWidth: r2, precinctHeight: n2, numprecinctswide: c, numprecinctshigh: l, numprecincts: h, precinctWidthInSubband: s2, precinctHeightInSubband: o };
        }
        function buildCodeblocks(e3, t3, a3) {
          const r2 = a3.xcb_, n2 = a3.ycb_, i2 = 1 << r2, s2 = 1 << n2, o = t3.tbx0 >> r2, c = t3.tby0 >> n2, l = t3.tbx1 + i2 - 1 >> r2, h = t3.tby1 + s2 - 1 >> n2, u = t3.resolution.precinctParameters, d = [], f = [];
          let g, p, m, b;
          for (p = c; p < h; p++) for (g = o; g < l; g++) {
            m = { cbx: g, cby: p, tbx0: i2 * g, tby0: s2 * p, tbx1: i2 * (g + 1), tby1: s2 * (p + 1) };
            m.tbx0_ = Math.max(t3.tbx0, m.tbx0);
            m.tby0_ = Math.max(t3.tby0, m.tby0);
            m.tbx1_ = Math.min(t3.tbx1, m.tbx1);
            m.tby1_ = Math.min(t3.tby1, m.tby1);
            b = Math.floor((m.tbx0_ - t3.tbx0) / u.precinctWidthInSubband) + Math.floor((m.tby0_ - t3.tby0) / u.precinctHeightInSubband) * u.numprecinctswide;
            m.precinctNumber = b;
            m.subbandType = t3.type;
            m.Lblock = 3;
            if (m.tbx1_ <= m.tbx0_ || m.tby1_ <= m.tby0_) continue;
            d.push(m);
            let e4 = f[b];
            if (void 0 !== e4) {
              g < e4.cbxMin ? e4.cbxMin = g : g > e4.cbxMax && (e4.cbxMax = g);
              p < e4.cbyMin ? e4.cbxMin = p : p > e4.cbyMax && (e4.cbyMax = p);
            } else f[b] = e4 = { cbxMin: g, cbyMin: p, cbxMax: g, cbyMax: p };
            m.precinct = e4;
          }
          t3.codeblockParameters = { codeblockWidth: r2, codeblockHeight: n2, numcodeblockwide: l - o + 1, numcodeblockhigh: h - c + 1 };
          t3.codeblocks = d;
          t3.precincts = f;
        }
        function createPacket(e3, t3, a3) {
          const r2 = [], n2 = e3.subbands;
          for (let e4 = 0, a4 = n2.length; e4 < a4; e4++) {
            const a5 = n2[e4].codeblocks;
            for (let e5 = 0, n3 = a5.length; e5 < n3; e5++) {
              const n4 = a5[e5];
              n4.precinctNumber === t3 && r2.push(n4);
            }
          }
          return { layerNumber: a3, codeblocks: r2 };
        }
        function LayerResolutionComponentPositionIterator(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = r2.codingStyleDefaultParameters.layersCount, i2 = t3.Csiz;
          let s2 = 0;
          for (let e4 = 0; e4 < i2; e4++) s2 = Math.max(s2, r2.components[e4].codingStyleParameters.decompositionLevelsCount);
          let o = 0, c = 0, l = 0, h = 0;
          this.nextPacket = function JpxImage_nextPacket() {
            for (; o < n2; o++) {
              for (; c <= s2; c++) {
                for (; l < i2; l++) {
                  const e4 = r2.components[l];
                  if (c > e4.codingStyleParameters.decompositionLevelsCount) continue;
                  const t4 = e4.resolutions[c], a4 = t4.precinctParameters.numprecincts;
                  for (; h < a4; ) {
                    const e5 = createPacket(t4, h, o);
                    h++;
                    return e5;
                  }
                  h = 0;
                }
                l = 0;
              }
              c = 0;
            }
            throw new JpxError("Out of packets");
          };
        }
        function ResolutionLayerComponentPositionIterator(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = r2.codingStyleDefaultParameters.layersCount, i2 = t3.Csiz;
          let s2 = 0;
          for (let e4 = 0; e4 < i2; e4++) s2 = Math.max(s2, r2.components[e4].codingStyleParameters.decompositionLevelsCount);
          let o = 0, c = 0, l = 0, h = 0;
          this.nextPacket = function JpxImage_nextPacket() {
            for (; o <= s2; o++) {
              for (; c < n2; c++) {
                for (; l < i2; l++) {
                  const e4 = r2.components[l];
                  if (o > e4.codingStyleParameters.decompositionLevelsCount) continue;
                  const t4 = e4.resolutions[o], a4 = t4.precinctParameters.numprecincts;
                  for (; h < a4; ) {
                    const e5 = createPacket(t4, h, c);
                    h++;
                    return e5;
                  }
                  h = 0;
                }
                l = 0;
              }
              c = 0;
            }
            throw new JpxError("Out of packets");
          };
        }
        function ResolutionPositionComponentLayerIterator(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = r2.codingStyleDefaultParameters.layersCount, i2 = t3.Csiz;
          let s2, o, c, l, h = 0;
          for (c = 0; c < i2; c++) {
            const e4 = r2.components[c];
            h = Math.max(h, e4.codingStyleParameters.decompositionLevelsCount);
          }
          const u = new Int32Array(h + 1);
          for (o = 0; o <= h; ++o) {
            let e4 = 0;
            for (c = 0; c < i2; ++c) {
              const t4 = r2.components[c].resolutions;
              o < t4.length && (e4 = Math.max(e4, t4[o].precinctParameters.numprecincts));
            }
            u[o] = e4;
          }
          s2 = 0;
          o = 0;
          c = 0;
          l = 0;
          this.nextPacket = function JpxImage_nextPacket() {
            for (; o <= h; o++) {
              for (; l < u[o]; l++) {
                for (; c < i2; c++) {
                  const e4 = r2.components[c];
                  if (o > e4.codingStyleParameters.decompositionLevelsCount) continue;
                  const t4 = e4.resolutions[o], a4 = t4.precinctParameters.numprecincts;
                  if (!(l >= a4)) {
                    for (; s2 < n2; ) {
                      const e5 = createPacket(t4, l, s2);
                      s2++;
                      return e5;
                    }
                    s2 = 0;
                  }
                }
                c = 0;
              }
              l = 0;
            }
            throw new JpxError("Out of packets");
          };
        }
        function PositionComponentResolutionLayerIterator(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = r2.codingStyleDefaultParameters.layersCount, i2 = t3.Csiz, s2 = getPrecinctSizesInImageScale(r2), o = s2;
          let c = 0, l = 0, h = 0, u = 0, d = 0;
          this.nextPacket = function JpxImage_nextPacket() {
            for (; d < o.maxNumHigh; d++) {
              for (; u < o.maxNumWide; u++) {
                for (; h < i2; h++) {
                  const e4 = r2.components[h], t4 = e4.codingStyleParameters.decompositionLevelsCount;
                  for (; l <= t4; l++) {
                    const t5 = e4.resolutions[l], a4 = s2.components[h].resolutions[l], r3 = getPrecinctIndexIfExist(u, d, a4, o, t5);
                    if (null !== r3) {
                      for (; c < n2; ) {
                        const e5 = createPacket(t5, r3, c);
                        c++;
                        return e5;
                      }
                      c = 0;
                    }
                  }
                  l = 0;
                }
                h = 0;
              }
              u = 0;
            }
            throw new JpxError("Out of packets");
          };
        }
        function ComponentPositionResolutionLayerIterator(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = r2.codingStyleDefaultParameters.layersCount, i2 = t3.Csiz, s2 = getPrecinctSizesInImageScale(r2);
          let o = 0, c = 0, l = 0, h = 0, u = 0;
          this.nextPacket = function JpxImage_nextPacket() {
            for (; l < i2; ++l) {
              const e4 = r2.components[l], t4 = s2.components[l], a4 = e4.codingStyleParameters.decompositionLevelsCount;
              for (; u < t4.maxNumHigh; u++) {
                for (; h < t4.maxNumWide; h++) {
                  for (; c <= a4; c++) {
                    const a5 = e4.resolutions[c], r3 = t4.resolutions[c], i3 = getPrecinctIndexIfExist(h, u, r3, t4, a5);
                    if (null !== i3) {
                      for (; o < n2; ) {
                        const e5 = createPacket(a5, i3, o);
                        o++;
                        return e5;
                      }
                      o = 0;
                    }
                  }
                  c = 0;
                }
                h = 0;
              }
              u = 0;
            }
            throw new JpxError("Out of packets");
          };
        }
        function getPrecinctIndexIfExist(e3, t3, a3, r2, n2) {
          const i2 = e3 * r2.minWidth, s2 = t3 * r2.minHeight;
          if (i2 % a3.width != 0 || s2 % a3.height != 0) return null;
          const o = s2 / a3.width * n2.precinctParameters.numprecinctswide;
          return i2 / a3.height + o;
        }
        function getPrecinctSizesInImageScale(e3) {
          const t3 = e3.components.length;
          let a3 = Number.MAX_VALUE, r2 = Number.MAX_VALUE, n2 = 0, i2 = 0;
          const s2 = new Array(t3);
          for (let o = 0; o < t3; o++) {
            const t4 = e3.components[o], c = t4.codingStyleParameters.decompositionLevelsCount, l = new Array(c + 1);
            let h = Number.MAX_VALUE, u = Number.MAX_VALUE, d = 0, f = 0, g = 1;
            for (let e4 = c; e4 >= 0; --e4) {
              const a4 = t4.resolutions[e4], r3 = g * a4.precinctParameters.precinctWidth, n3 = g * a4.precinctParameters.precinctHeight;
              h = Math.min(h, r3);
              u = Math.min(u, n3);
              d = Math.max(d, a4.precinctParameters.numprecinctswide);
              f = Math.max(f, a4.precinctParameters.numprecinctshigh);
              l[e4] = { width: r3, height: n3 };
              g <<= 1;
            }
            a3 = Math.min(a3, h);
            r2 = Math.min(r2, u);
            n2 = Math.max(n2, d);
            i2 = Math.max(i2, f);
            s2[o] = { resolutions: l, minWidth: h, minHeight: u, maxNumWide: d, maxNumHigh: f };
          }
          return { components: s2, minWidth: a3, minHeight: r2, maxNumWide: n2, maxNumHigh: i2 };
        }
        function buildPackets(e3) {
          const t3 = e3.SIZ, a3 = e3.currentTile.index, r2 = e3.tiles[a3], n2 = t3.Csiz;
          for (let e4 = 0; e4 < n2; e4++) {
            const t4 = r2.components[e4], a4 = t4.codingStyleParameters.decompositionLevelsCount, n3 = [], i3 = [];
            for (let e5 = 0; e5 <= a4; e5++) {
              const r3 = getBlocksDimensions(0, t4, e5), s2 = {}, o = 1 << a4 - e5;
              s2.trx0 = Math.ceil(t4.tcx0 / o);
              s2.try0 = Math.ceil(t4.tcy0 / o);
              s2.trx1 = Math.ceil(t4.tcx1 / o);
              s2.try1 = Math.ceil(t4.tcy1 / o);
              s2.resLevel = e5;
              buildPrecincts(0, s2, r3);
              n3.push(s2);
              let c;
              if (0 === e5) {
                c = {};
                c.type = "LL";
                c.tbx0 = Math.ceil(t4.tcx0 / o);
                c.tby0 = Math.ceil(t4.tcy0 / o);
                c.tbx1 = Math.ceil(t4.tcx1 / o);
                c.tby1 = Math.ceil(t4.tcy1 / o);
                c.resolution = s2;
                buildCodeblocks(0, c, r3);
                i3.push(c);
                s2.subbands = [c];
              } else {
                const n4 = 1 << a4 - e5 + 1, o2 = [];
                c = {};
                c.type = "HL";
                c.tbx0 = Math.ceil(t4.tcx0 / n4 - 0.5);
                c.tby0 = Math.ceil(t4.tcy0 / n4);
                c.tbx1 = Math.ceil(t4.tcx1 / n4 - 0.5);
                c.tby1 = Math.ceil(t4.tcy1 / n4);
                c.resolution = s2;
                buildCodeblocks(0, c, r3);
                i3.push(c);
                o2.push(c);
                c = {};
                c.type = "LH";
                c.tbx0 = Math.ceil(t4.tcx0 / n4);
                c.tby0 = Math.ceil(t4.tcy0 / n4 - 0.5);
                c.tbx1 = Math.ceil(t4.tcx1 / n4);
                c.tby1 = Math.ceil(t4.tcy1 / n4 - 0.5);
                c.resolution = s2;
                buildCodeblocks(0, c, r3);
                i3.push(c);
                o2.push(c);
                c = {};
                c.type = "HH";
                c.tbx0 = Math.ceil(t4.tcx0 / n4 - 0.5);
                c.tby0 = Math.ceil(t4.tcy0 / n4 - 0.5);
                c.tbx1 = Math.ceil(t4.tcx1 / n4 - 0.5);
                c.tby1 = Math.ceil(t4.tcy1 / n4 - 0.5);
                c.resolution = s2;
                buildCodeblocks(0, c, r3);
                i3.push(c);
                o2.push(c);
                s2.subbands = o2;
              }
            }
            t4.resolutions = n3;
            t4.subbands = i3;
          }
          const i2 = r2.codingStyleDefaultParameters.progressionOrder;
          switch (i2) {
            case 0:
              r2.packetsIterator = new LayerResolutionComponentPositionIterator(e3);
              break;
            case 1:
              r2.packetsIterator = new ResolutionLayerComponentPositionIterator(e3);
              break;
            case 2:
              r2.packetsIterator = new ResolutionPositionComponentLayerIterator(e3);
              break;
            case 3:
              r2.packetsIterator = new PositionComponentResolutionLayerIterator(e3);
              break;
            case 4:
              r2.packetsIterator = new ComponentPositionResolutionLayerIterator(e3);
              break;
            default:
              throw new JpxError(`Unsupported progression order ${i2}`);
          }
        }
        function parseTilePackets(e3, t3, a3, r2) {
          let i2, s2 = 0, o = 0, c = false;
          function readBits(e4) {
            for (; o < e4; ) {
              const e5 = t3[a3 + s2];
              s2++;
              if (c) {
                i2 = i2 << 7 | e5;
                o += 7;
                c = false;
              } else {
                i2 = i2 << 8 | e5;
                o += 8;
              }
              255 === e5 && (c = true);
            }
            o -= e4;
            return i2 >>> o & (1 << e4) - 1;
          }
          function skipMarkerIfEqual(e4) {
            if (255 === t3[a3 + s2 - 1] && t3[a3 + s2] === e4) {
              skipBytes(1);
              return true;
            }
            if (255 === t3[a3 + s2] && t3[a3 + s2 + 1] === e4) {
              skipBytes(2);
              return true;
            }
            return false;
          }
          function skipBytes(e4) {
            s2 += e4;
          }
          function alignToByte() {
            o = 0;
            if (c) {
              s2++;
              c = false;
            }
          }
          function readCodingpasses() {
            if (0 === readBits(1)) return 1;
            if (0 === readBits(1)) return 2;
            let e4 = readBits(2);
            if (e4 < 3) return e4 + 3;
            e4 = readBits(5);
            if (e4 < 31) return e4 + 6;
            e4 = readBits(7);
            return e4 + 37;
          }
          const l = e3.currentTile.index, h = e3.tiles[l], u = e3.COD.sopMarkerUsed, d = e3.COD.ephMarkerUsed, f = h.packetsIterator;
          for (; s2 < r2; ) {
            alignToByte();
            u && skipMarkerIfEqual(145) && skipBytes(4);
            const e4 = f.nextPacket();
            if (!readBits(1)) continue;
            const r3 = e4.layerNumber, i3 = [];
            let o2;
            for (let t4 = 0, a4 = e4.codeblocks.length; t4 < a4; t4++) {
              o2 = e4.codeblocks[t4];
              let a5 = o2.precinct;
              const s3 = o2.cbx - a5.cbxMin, c2 = o2.cby - a5.cbyMin;
              let l2, h2, u2 = false, d2 = false;
              if (void 0 !== o2.included) u2 = !!readBits(1);
              else {
                a5 = o2.precinct;
                let e5;
                if (void 0 !== a5.inclusionTree) e5 = a5.inclusionTree;
                else {
                  const t5 = a5.cbxMax - a5.cbxMin + 1, n2 = a5.cbyMax - a5.cbyMin + 1;
                  e5 = new InclusionTree(t5, n2, r3);
                  h2 = new TagTree(t5, n2);
                  a5.inclusionTree = e5;
                  a5.zeroBitPlanesTree = h2;
                  for (let e6 = 0; e6 < r3; e6++) if (0 !== readBits(1)) throw new JpxError("Invalid tag tree");
                }
                if (e5.reset(s3, c2, r3)) for (; ; ) {
                  if (!readBits(1)) {
                    e5.incrementValue(r3);
                    break;
                  }
                  l2 = !e5.nextLevel();
                  if (l2) {
                    o2.included = true;
                    u2 = d2 = true;
                    break;
                  }
                }
              }
              if (!u2) continue;
              if (d2) {
                h2 = a5.zeroBitPlanesTree;
                h2.reset(s3, c2);
                for (; ; ) if (readBits(1)) {
                  l2 = !h2.nextLevel();
                  if (l2) break;
                } else h2.incrementValue();
                o2.zeroBitPlanes = h2.value;
              }
              const f2 = readCodingpasses();
              for (; readBits(1); ) o2.Lblock++;
              const g = (0, n.log2)(f2), p = readBits((f2 < 1 << g ? g - 1 : g) + o2.Lblock);
              i3.push({ codeblock: o2, codingpasses: f2, dataLength: p });
            }
            alignToByte();
            d && skipMarkerIfEqual(146);
            for (; i3.length > 0; ) {
              const e5 = i3.shift();
              o2 = e5.codeblock;
              void 0 === o2.data && (o2.data = []);
              o2.data.push({ data: t3, start: a3 + s2, end: a3 + s2 + e5.dataLength, codingpasses: e5.codingpasses });
              s2 += e5.dataLength;
            }
          }
          return s2;
        }
        function copyCoefficients(e3, t3, a3, r2, n2, s2, o, c, l) {
          const h = r2.tbx0, u = r2.tby0, d = r2.tbx1 - r2.tbx0, f = r2.codeblocks, g = "H" === r2.type.charAt(0) ? 1 : 0, p = "H" === r2.type.charAt(1) ? t3 : 0;
          for (let a4 = 0, m = f.length; a4 < m; ++a4) {
            const m2 = f[a4], b = m2.tbx1_ - m2.tbx0_, y = m2.tby1_ - m2.tby0_;
            if (0 === b || 0 === y) continue;
            if (void 0 === m2.data) continue;
            const w = new BitModel(b, y, m2.subbandType, m2.zeroBitPlanes, s2);
            let S = 2;
            const x = m2.data;
            let C, k, v, F = 0, O = 0;
            for (C = 0, k = x.length; C < k; C++) {
              v = x[C];
              F += v.end - v.start;
              O += v.codingpasses;
            }
            const T = new Uint8Array(F);
            let M = 0;
            for (C = 0, k = x.length; C < k; C++) {
              v = x[C];
              const e4 = v.data.subarray(v.start, v.end);
              T.set(e4, M);
              M += e4.length;
            }
            const D = new i.ArithmeticDecoder(T, 0, F);
            w.setDecoder(D);
            for (C = 0; C < O; C++) {
              switch (S) {
                case 0:
                  w.runSignificancePropagationPass();
                  break;
                case 1:
                  w.runMagnitudeRefinementPass();
                  break;
                case 2:
                  w.runCleanupPass();
                  c && w.checkSegmentationSymbol();
              }
              l && w.reset();
              S = (S + 1) % 3;
            }
            let E = m2.tbx0_ - h + (m2.tby0_ - u) * d;
            const N = w.coefficentsSign, R = w.coefficentsMagnitude, L = w.bitsDecoded, $ = o ? 0 : 0.5;
            let _, j, U;
            M = 0;
            const X = "LL" !== r2.type;
            for (C = 0; C < y; C++) {
              const a5 = 2 * (E / d | 0) * (t3 - d) + g + p;
              for (_ = 0; _ < b; _++) {
                j = R[M];
                if (0 !== j) {
                  j = (j + $) * n2;
                  0 !== N[M] && (j = -j);
                  U = L[M];
                  e3[X ? a5 + (E << 1) : E] = o && U >= s2 ? j : j * (1 << s2 - U);
                }
                E++;
                M++;
              }
              E += d - b;
            }
          }
        }
        function transformTile(e3, t3, a3) {
          const r2 = t3.components[a3], n2 = r2.codingStyleParameters, i2 = r2.quantizationParameters, o = n2.decompositionLevelsCount, c = i2.SPqcds, l = i2.scalarExpounded, h = i2.guardBits, u = n2.segmentationSymbolUsed, d = n2.resetContextProbabilities, f = e3.components[a3].precision, g = n2.reversibleTransformation, p = g ? new ReversibleTransform() : new IrreversibleTransform(), m = [];
          let b = 0;
          for (let e4 = 0; e4 <= o; e4++) {
            const t4 = r2.resolutions[e4], a4 = t4.trx1 - t4.trx0, n3 = t4.try1 - t4.try0, i3 = new Float32Array(a4 * n3);
            for (let r3 = 0, n4 = t4.subbands.length; r3 < n4; r3++) {
              let n5, o2;
              if (l) {
                n5 = c[b].mu;
                o2 = c[b].epsilon;
                b++;
              } else {
                n5 = c[0].mu;
                o2 = c[0].epsilon + (e4 > 0 ? 1 - e4 : 0);
              }
              const p2 = t4.subbands[r3], m2 = s[p2.type];
              copyCoefficients(i3, a4, 0, p2, g ? 1 : 2 ** (f + m2 - o2) * (1 + n5 / 2048), h + o2 - 1, g, u, d);
            }
            m.push({ width: a4, height: n3, items: i3 });
          }
          const y = p.calculate(m, r2.tcx0, r2.tcy0);
          return { left: r2.tcx0, top: r2.tcy0, width: y.width, height: y.height, items: y.items };
        }
        function initializeTile(e3, t3) {
          const a3 = e3.SIZ.Csiz, r2 = e3.tiles[t3];
          for (let t4 = 0; t4 < a3; t4++) {
            const a4 = r2.components[t4], n2 = void 0 !== e3.currentTile.QCC[t4] ? e3.currentTile.QCC[t4] : e3.currentTile.QCD;
            a4.quantizationParameters = n2;
            const i2 = void 0 !== e3.currentTile.COC[t4] ? e3.currentTile.COC[t4] : e3.currentTile.COD;
            a4.codingStyleParameters = i2;
          }
          r2.codingStyleDefaultParameters = e3.currentTile.COD;
        }
        class TagTree {
          constructor(e3, t3) {
            const a3 = (0, n.log2)(Math.max(e3, t3)) + 1;
            this.levels = [];
            for (let r2 = 0; r2 < a3; r2++) {
              const a4 = { width: e3, height: t3, items: [] };
              this.levels.push(a4);
              e3 = Math.ceil(e3 / 2);
              t3 = Math.ceil(t3 / 2);
            }
          }
          reset(e3, t3) {
            let a3, r2 = 0, n2 = 0;
            for (; r2 < this.levels.length; ) {
              a3 = this.levels[r2];
              const i2 = e3 + t3 * a3.width;
              if (void 0 !== a3.items[i2]) {
                n2 = a3.items[i2];
                break;
              }
              a3.index = i2;
              e3 >>= 1;
              t3 >>= 1;
              r2++;
            }
            r2--;
            a3 = this.levels[r2];
            a3.items[a3.index] = n2;
            this.currentLevel = r2;
            delete this.value;
          }
          incrementValue() {
            const e3 = this.levels[this.currentLevel];
            e3.items[e3.index]++;
          }
          nextLevel() {
            let e3 = this.currentLevel, t3 = this.levels[e3];
            const a3 = t3.items[t3.index];
            e3--;
            if (e3 < 0) {
              this.value = a3;
              return false;
            }
            this.currentLevel = e3;
            t3 = this.levels[e3];
            t3.items[t3.index] = a3;
            return true;
          }
        }
        class InclusionTree {
          constructor(e3, t3, a3) {
            const r2 = (0, n.log2)(Math.max(e3, t3)) + 1;
            this.levels = [];
            for (let n2 = 0; n2 < r2; n2++) {
              const r3 = new Uint8Array(e3 * t3);
              for (let e4 = 0, t4 = r3.length; e4 < t4; e4++) r3[e4] = a3;
              const n3 = { width: e3, height: t3, items: r3 };
              this.levels.push(n3);
              e3 = Math.ceil(e3 / 2);
              t3 = Math.ceil(t3 / 2);
            }
          }
          reset(e3, t3, a3) {
            let r2 = 0;
            for (; r2 < this.levels.length; ) {
              const n2 = this.levels[r2], i2 = e3 + t3 * n2.width;
              n2.index = i2;
              const s2 = n2.items[i2];
              if (255 === s2) break;
              if (s2 > a3) {
                this.currentLevel = r2;
                this.propagateValues();
                return false;
              }
              e3 >>= 1;
              t3 >>= 1;
              r2++;
            }
            this.currentLevel = r2 - 1;
            return true;
          }
          incrementValue(e3) {
            const t3 = this.levels[this.currentLevel];
            t3.items[t3.index] = e3 + 1;
            this.propagateValues();
          }
          propagateValues() {
            let e3 = this.currentLevel, t3 = this.levels[e3];
            const a3 = t3.items[t3.index];
            for (; --e3 >= 0; ) {
              t3 = this.levels[e3];
              t3.items[t3.index] = a3;
            }
          }
          nextLevel() {
            let e3 = this.currentLevel, t3 = this.levels[e3];
            const a3 = t3.items[t3.index];
            t3.items[t3.index] = 255;
            e3--;
            if (e3 < 0) return false;
            this.currentLevel = e3;
            t3 = this.levels[e3];
            t3.items[t3.index] = a3;
            return true;
          }
        }
        const _BitModel = class _BitModel {
          constructor(e3, t3, a3, r2, n2) {
            this.width = e3;
            this.height = t3;
            let i2;
            i2 = "HH" === a3 ? _BitModel.HHContextLabel : "HL" === a3 ? _BitModel.HLContextLabel : _BitModel.LLAndLHContextsLabel;
            this.contextLabelTable = i2;
            const s2 = e3 * t3;
            this.neighborsSignificance = new Uint8Array(s2);
            this.coefficentsSign = new Uint8Array(s2);
            let o;
            o = n2 > 14 ? new Uint32Array(s2) : n2 > 6 ? new Uint16Array(s2) : new Uint8Array(s2);
            this.coefficentsMagnitude = o;
            this.processingFlags = new Uint8Array(s2);
            const c = new Uint8Array(s2);
            if (0 !== r2) for (let e4 = 0; e4 < s2; e4++) c[e4] = r2;
            this.bitsDecoded = c;
            this.reset();
          }
          setDecoder(e3) {
            this.decoder = e3;
          }
          reset() {
            this.contexts = new Int8Array(19);
            this.contexts[0] = 8;
            this.contexts[_BitModel.UNIFORM_CONTEXT] = 92;
            this.contexts[_BitModel.RUNLENGTH_CONTEXT] = 6;
          }
          setNeighborsSignificance(e3, t3, a3) {
            const r2 = this.neighborsSignificance, n2 = this.width, i2 = this.height, s2 = t3 > 0, o = t3 + 1 < n2;
            let c;
            if (e3 > 0) {
              c = a3 - n2;
              s2 && (r2[c - 1] += 16);
              o && (r2[c + 1] += 16);
              r2[c] += 4;
            }
            if (e3 + 1 < i2) {
              c = a3 + n2;
              s2 && (r2[c - 1] += 16);
              o && (r2[c + 1] += 16);
              r2[c] += 4;
            }
            s2 && (r2[a3 - 1] += 1);
            o && (r2[a3 + 1] += 1);
            r2[a3] |= 128;
          }
          runSignificancePropagationPass() {
            const e3 = this.decoder, t3 = this.width, a3 = this.height, r2 = this.coefficentsMagnitude, n2 = this.coefficentsSign, i2 = this.neighborsSignificance, s2 = this.processingFlags, o = this.contexts, c = this.contextLabelTable, l = this.bitsDecoded;
            for (let h = 0; h < a3; h += 4) for (let u = 0; u < t3; u++) {
              let d = h * t3 + u;
              for (let f = 0; f < 4; f++, d += t3) {
                const t4 = h + f;
                if (t4 >= a3) break;
                s2[d] &= -2;
                if (r2[d] || !i2[d]) continue;
                const g = c[i2[d]];
                if (e3.readBit(o, g)) {
                  const e4 = this.decodeSignBit(t4, u, d);
                  n2[d] = e4;
                  r2[d] = 1;
                  this.setNeighborsSignificance(t4, u, d);
                  s2[d] |= 2;
                }
                l[d]++;
                s2[d] |= 1;
              }
            }
          }
          decodeSignBit(e3, t3, a3) {
            const r2 = this.width, n2 = this.height, i2 = this.coefficentsMagnitude, s2 = this.coefficentsSign;
            let o, c, l, h, u, d;
            h = t3 > 0 && 0 !== i2[a3 - 1];
            if (t3 + 1 < r2 && 0 !== i2[a3 + 1]) {
              l = s2[a3 + 1];
              if (h) {
                c = s2[a3 - 1];
                o = 1 - l - c;
              } else o = 1 - l - l;
            } else if (h) {
              c = s2[a3 - 1];
              o = 1 - c - c;
            } else o = 0;
            const f = 3 * o;
            h = e3 > 0 && 0 !== i2[a3 - r2];
            if (e3 + 1 < n2 && 0 !== i2[a3 + r2]) {
              l = s2[a3 + r2];
              if (h) {
                c = s2[a3 - r2];
                o = 1 - l - c + f;
              } else o = 1 - l - l + f;
            } else if (h) {
              c = s2[a3 - r2];
              o = 1 - c - c + f;
            } else o = f;
            if (o >= 0) {
              u = 9 + o;
              d = this.decoder.readBit(this.contexts, u);
            } else {
              u = 9 - o;
              d = 1 ^ this.decoder.readBit(this.contexts, u);
            }
            return d;
          }
          runMagnitudeRefinementPass() {
            const e3 = this.decoder, t3 = this.width, a3 = this.height, r2 = this.coefficentsMagnitude, n2 = this.neighborsSignificance, i2 = this.contexts, s2 = this.bitsDecoded, o = this.processingFlags, c = t3 * a3, l = 4 * t3;
            for (let a4, h = 0; h < c; h = a4) {
              a4 = Math.min(c, h + l);
              for (let c2 = 0; c2 < t3; c2++) for (let l2 = h + c2; l2 < a4; l2 += t3) {
                if (!r2[l2] || 0 != (1 & o[l2])) continue;
                let t4 = 16;
                if (0 != (2 & o[l2])) {
                  o[l2] ^= 2;
                  t4 = 0 === (127 & n2[l2]) ? 15 : 14;
                }
                const a5 = e3.readBit(i2, t4);
                r2[l2] = r2[l2] << 1 | a5;
                s2[l2]++;
                o[l2] |= 1;
              }
            }
          }
          runCleanupPass() {
            const e3 = this.decoder, t3 = this.width, a3 = this.height, r2 = this.neighborsSignificance, n2 = this.coefficentsMagnitude, i2 = this.coefficentsSign, s2 = this.contexts, o = this.contextLabelTable, c = this.bitsDecoded, l = this.processingFlags, h = t3, u = 2 * t3, d = 3 * t3;
            let f;
            for (let g = 0; g < a3; g = f) {
              f = Math.min(g + 4, a3);
              const p = g * t3, m = g + 3 < a3;
              for (let a4 = 0; a4 < t3; a4++) {
                const b = p + a4;
                let y, w = 0, S = b, x = g;
                if (m && 0 === l[b] && 0 === l[b + h] && 0 === l[b + u] && 0 === l[b + d] && 0 === r2[b] && 0 === r2[b + h] && 0 === r2[b + u] && 0 === r2[b + d]) {
                  if (!e3.readBit(s2, _BitModel.RUNLENGTH_CONTEXT)) {
                    c[b]++;
                    c[b + h]++;
                    c[b + u]++;
                    c[b + d]++;
                    continue;
                  }
                  w = e3.readBit(s2, _BitModel.UNIFORM_CONTEXT) << 1 | e3.readBit(s2, _BitModel.UNIFORM_CONTEXT);
                  if (0 !== w) {
                    x = g + w;
                    S += w * t3;
                  }
                  y = this.decodeSignBit(x, a4, S);
                  i2[S] = y;
                  n2[S] = 1;
                  this.setNeighborsSignificance(x, a4, S);
                  l[S] |= 2;
                  S = b;
                  for (let e4 = g; e4 <= x; e4++, S += t3) c[S]++;
                  w++;
                }
                for (x = g + w; x < f; x++, S += t3) {
                  if (n2[S] || 0 != (1 & l[S])) continue;
                  const t4 = o[r2[S]];
                  if (1 === e3.readBit(s2, t4)) {
                    y = this.decodeSignBit(x, a4, S);
                    i2[S] = y;
                    n2[S] = 1;
                    this.setNeighborsSignificance(x, a4, S);
                    l[S] |= 2;
                  }
                  c[S]++;
                }
              }
            }
          }
          checkSegmentationSymbol() {
            const e3 = this.decoder, t3 = this.contexts;
            if (10 !== (e3.readBit(t3, _BitModel.UNIFORM_CONTEXT) << 3 | e3.readBit(t3, _BitModel.UNIFORM_CONTEXT) << 2 | e3.readBit(t3, _BitModel.UNIFORM_CONTEXT) << 1 | e3.readBit(t3, _BitModel.UNIFORM_CONTEXT))) throw new JpxError("Invalid segmentation symbol");
          }
        };
        __publicField(_BitModel, "UNIFORM_CONTEXT", 17);
        __publicField(_BitModel, "RUNLENGTH_CONTEXT", 18);
        __publicField(_BitModel, "LLAndLHContextsLabel", new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]));
        __publicField(_BitModel, "HLContextLabel", new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]));
        __publicField(_BitModel, "HHContextLabel", new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]));
        let BitModel = _BitModel;
        class Transform {
          constructor() {
            this.constructor === Transform && (0, r.unreachable)("Cannot initialize Transform.");
          }
          calculate(e3, t3, a3) {
            let r2 = e3[0];
            for (let n2 = 1, i2 = e3.length; n2 < i2; n2++) r2 = this.iterate(r2, e3[n2], t3, a3);
            return r2;
          }
          extend(e3, t3, a3) {
            let r2 = t3 - 1, n2 = t3 + 1, i2 = t3 + a3 - 2, s2 = t3 + a3;
            e3[r2--] = e3[n2++];
            e3[s2++] = e3[i2--];
            e3[r2--] = e3[n2++];
            e3[s2++] = e3[i2--];
            e3[r2--] = e3[n2++];
            e3[s2++] = e3[i2--];
            e3[r2] = e3[n2];
            e3[s2] = e3[i2];
          }
          filter(e3, t3, a3) {
            (0, r.unreachable)("Abstract method `filter` called");
          }
          iterate(e3, t3, a3, r2) {
            const n2 = e3.width, i2 = e3.height;
            let s2 = e3.items;
            const o = t3.width, c = t3.height, l = t3.items;
            let h, u, d, f, g, p;
            for (d = 0, h = 0; h < i2; h++) {
              f = 2 * h * o;
              for (u = 0; u < n2; u++, d++, f += 2) l[f] = s2[d];
            }
            s2 = e3.items = null;
            const m = new Float32Array(o + 8);
            if (1 === o) {
              if (0 != (1 & a3)) for (p = 0, d = 0; p < c; p++, d += o) l[d] *= 0.5;
            } else for (p = 0, d = 0; p < c; p++, d += o) {
              m.set(l.subarray(d, d + o), 4);
              this.extend(m, 4, o);
              this.filter(m, 4, o);
              l.set(m.subarray(4, 4 + o), d);
            }
            let b = 16;
            const y = [];
            for (h = 0; h < b; h++) y.push(new Float32Array(c + 8));
            let w, S = 0;
            e3 = 4 + c;
            if (1 === c) {
              if (0 != (1 & r2)) for (g = 0; g < o; g++) l[g] *= 0.5;
            } else for (g = 0; g < o; g++) {
              if (0 === S) {
                b = Math.min(o - g, b);
                for (d = g, f = 4; f < e3; d += o, f++) for (w = 0; w < b; w++) y[w][f] = l[d + w];
                S = b;
              }
              S--;
              const t4 = y[S];
              this.extend(t4, 4, c);
              this.filter(t4, 4, c);
              if (0 === S) {
                d = g - b + 1;
                for (f = 4; f < e3; d += o, f++) for (w = 0; w < b; w++) l[d + w] = y[w][f];
              }
            }
            return { width: o, height: c, items: l };
          }
        }
        class IrreversibleTransform extends Transform {
          filter(e3, t3, a3) {
            const r2 = a3 >> 1;
            let n2, i2, s2, o;
            const c = -1.586134342059924, l = -0.052980118572961, h = 0.882911075530934, u = 0.443506852043971, d = 1.230174104914001;
            n2 = (t3 |= 0) - 3;
            for (i2 = r2 + 4; i2--; n2 += 2) e3[n2] *= 0.8128930661159609;
            n2 = t3 - 2;
            s2 = u * e3[n2 - 1];
            for (i2 = r2 + 3; i2--; n2 += 2) {
              o = u * e3[n2 + 1];
              e3[n2] = d * e3[n2] - s2 - o;
              if (!i2--) break;
              n2 += 2;
              s2 = u * e3[n2 + 1];
              e3[n2] = d * e3[n2] - s2 - o;
            }
            n2 = t3 - 1;
            s2 = h * e3[n2 - 1];
            for (i2 = r2 + 2; i2--; n2 += 2) {
              o = h * e3[n2 + 1];
              e3[n2] -= s2 + o;
              if (!i2--) break;
              n2 += 2;
              s2 = h * e3[n2 + 1];
              e3[n2] -= s2 + o;
            }
            n2 = t3;
            s2 = l * e3[n2 - 1];
            for (i2 = r2 + 1; i2--; n2 += 2) {
              o = l * e3[n2 + 1];
              e3[n2] -= s2 + o;
              if (!i2--) break;
              n2 += 2;
              s2 = l * e3[n2 + 1];
              e3[n2] -= s2 + o;
            }
            if (0 !== r2) {
              n2 = t3 + 1;
              s2 = c * e3[n2 - 1];
              for (i2 = r2; i2--; n2 += 2) {
                o = c * e3[n2 + 1];
                e3[n2] -= s2 + o;
                if (!i2--) break;
                n2 += 2;
                s2 = c * e3[n2 + 1];
                e3[n2] -= s2 + o;
              }
            }
          }
        }
        class ReversibleTransform extends Transform {
          filter(e3, t3, a3) {
            const r2 = a3 >> 1;
            let n2, i2;
            for (n2 = t3 |= 0, i2 = r2 + 1; i2--; n2 += 2) e3[n2] -= e3[n2 - 1] + e3[n2 + 1] + 2 >> 2;
            for (n2 = t3 + 1, i2 = r2; i2--; n2 += 2) e3[n2] += e3[n2 - 1] + e3[n2 + 1] >> 1;
          }
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.LZWStream = void 0;
        var r = a2(18);
        class LZWStream extends r.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            this.cachedData = 0;
            this.bitsCached = 0;
            const r2 = 4096, n = { earlyChange: a3, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(r2), dictionaryLengths: new Uint16Array(r2), dictionaryPrevCodes: new Uint16Array(r2), currentSequence: new Uint8Array(r2), currentSequenceLength: 0 };
            for (let e4 = 0; e4 < 256; ++e4) {
              n.dictionaryValues[e4] = e4;
              n.dictionaryLengths[e4] = 1;
            }
            this.lzwState = n;
          }
          readBits(e3) {
            let t3 = this.bitsCached, a3 = this.cachedData;
            for (; t3 < e3; ) {
              const e4 = this.str.getByte();
              if (-1 === e4) {
                this.eof = true;
                return null;
              }
              a3 = a3 << 8 | e4;
              t3 += 8;
            }
            this.bitsCached = t3 -= e3;
            this.cachedData = a3;
            this.lastCode = null;
            return a3 >>> t3 & (1 << e3) - 1;
          }
          readBlock() {
            let e3, t3, a3, r2 = 1024;
            const n = this.lzwState;
            if (!n) return;
            const i = n.earlyChange;
            let s = n.nextCode;
            const o = n.dictionaryValues, c = n.dictionaryLengths, l = n.dictionaryPrevCodes;
            let h = n.codeLength, u = n.prevCode;
            const d = n.currentSequence;
            let f = n.currentSequenceLength, g = 0, p = this.bufferLength, m = this.ensureBuffer(this.bufferLength + r2);
            for (e3 = 0; e3 < 512; e3++) {
              const e4 = this.readBits(h), n2 = f > 0;
              if (e4 < 256) {
                d[0] = e4;
                f = 1;
              } else {
                if (!(e4 >= 258)) {
                  if (256 === e4) {
                    h = 9;
                    s = 258;
                    f = 0;
                    continue;
                  }
                  this.eof = true;
                  delete this.lzwState;
                  break;
                }
                if (e4 < s) {
                  f = c[e4];
                  for (t3 = f - 1, a3 = e4; t3 >= 0; t3--) {
                    d[t3] = o[a3];
                    a3 = l[a3];
                  }
                } else d[f++] = d[0];
              }
              if (n2) {
                l[s] = u;
                c[s] = c[u] + 1;
                o[s] = d[0];
                s++;
                h = s + i & s + i - 1 ? h : 0 | Math.min(Math.log(s + i) / 0.6931471805599453 + 1, 12);
              }
              u = e4;
              g += f;
              if (r2 < g) {
                do {
                  r2 += 512;
                } while (r2 < g);
                m = this.ensureBuffer(this.bufferLength + r2);
              }
              for (t3 = 0; t3 < f; t3++) m[p++] = d[t3];
            }
            n.nextCode = s;
            n.codeLength = h;
            n.prevCode = u;
            n.currentSequenceLength = f;
            this.bufferLength = p;
          }
        }
        t2.LZWStream = LZWStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PredictorStream = void 0;
        var r = a2(18), n = a2(4), i = a2(2);
        class PredictorStream extends r.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            if (!(a3 instanceof n.Dict)) return e3;
            const r2 = this.predictor = a3.get("Predictor") || 1;
            if (r2 <= 1) return e3;
            if (2 !== r2 && (r2 < 10 || r2 > 15)) throw new i.FormatError(`Unsupported predictor: ${r2}`);
            this.readBlock = 2 === r2 ? this.readBlockTiff : this.readBlockPng;
            this.str = e3;
            this.dict = e3.dict;
            const s = this.colors = a3.get("Colors") || 1, o = this.bits = a3.get("BPC", "BitsPerComponent") || 8, c = this.columns = a3.get("Columns") || 1;
            this.pixBytes = s * o + 7 >> 3;
            this.rowBytes = c * s * o + 7 >> 3;
            return this;
          }
          readBlockTiff() {
            const e3 = this.rowBytes, t3 = this.bufferLength, a3 = this.ensureBuffer(t3 + e3), r2 = this.bits, n2 = this.colors, i2 = this.str.getBytes(e3);
            this.eof = !i2.length;
            if (this.eof) return;
            let s, o = 0, c = 0, l = 0, h = 0, u = t3;
            if (1 === r2 && 1 === n2) for (s = 0; s < e3; ++s) {
              let e4 = i2[s] ^ o;
              e4 ^= e4 >> 1;
              e4 ^= e4 >> 2;
              e4 ^= e4 >> 4;
              o = (1 & e4) << 7;
              a3[u++] = e4;
            }
            else if (8 === r2) {
              for (s = 0; s < n2; ++s) a3[u++] = i2[s];
              for (; s < e3; ++s) {
                a3[u] = a3[u - n2] + i2[s];
                u++;
              }
            } else if (16 === r2) {
              const t4 = 2 * n2;
              for (s = 0; s < t4; ++s) a3[u++] = i2[s];
              for (; s < e3; s += 2) {
                const e4 = ((255 & i2[s]) << 8) + (255 & i2[s + 1]) + ((255 & a3[u - t4]) << 8) + (255 & a3[u - t4 + 1]);
                a3[u++] = e4 >> 8 & 255;
                a3[u++] = 255 & e4;
              }
            } else {
              const e4 = new Uint8Array(n2 + 1), u2 = (1 << r2) - 1;
              let d = 0, f = t3;
              const g = this.columns;
              for (s = 0; s < g; ++s) for (let t4 = 0; t4 < n2; ++t4) {
                if (l < r2) {
                  o = o << 8 | 255 & i2[d++];
                  l += 8;
                }
                e4[t4] = e4[t4] + (o >> l - r2) & u2;
                l -= r2;
                c = c << r2 | e4[t4];
                h += r2;
                if (h >= 8) {
                  a3[f++] = c >> h - 8 & 255;
                  h -= 8;
                }
              }
              h > 0 && (a3[f++] = (c << 8 - h) + (o & (1 << 8 - h) - 1));
            }
            this.bufferLength += e3;
          }
          readBlockPng() {
            const e3 = this.rowBytes, t3 = this.pixBytes, a3 = this.str.getByte(), r2 = this.str.getBytes(e3);
            this.eof = !r2.length;
            if (this.eof) return;
            const n2 = this.bufferLength, s = this.ensureBuffer(n2 + e3);
            let o = s.subarray(n2 - e3, n2);
            0 === o.length && (o = new Uint8Array(e3));
            let c, l, h, u = n2;
            switch (a3) {
              case 0:
                for (c = 0; c < e3; ++c) s[u++] = r2[c];
                break;
              case 1:
                for (c = 0; c < t3; ++c) s[u++] = r2[c];
                for (; c < e3; ++c) {
                  s[u] = s[u - t3] + r2[c] & 255;
                  u++;
                }
                break;
              case 2:
                for (c = 0; c < e3; ++c) s[u++] = o[c] + r2[c] & 255;
                break;
              case 3:
                for (c = 0; c < t3; ++c) s[u++] = (o[c] >> 1) + r2[c];
                for (; c < e3; ++c) {
                  s[u] = (o[c] + s[u - t3] >> 1) + r2[c] & 255;
                  u++;
                }
                break;
              case 4:
                for (c = 0; c < t3; ++c) {
                  l = o[c];
                  h = r2[c];
                  s[u++] = l + h;
                }
                for (; c < e3; ++c) {
                  l = o[c];
                  const e4 = o[c - t3], a4 = s[u - t3], n3 = a4 + l - e4;
                  let i2 = n3 - a4;
                  i2 < 0 && (i2 = -i2);
                  let d = n3 - l;
                  d < 0 && (d = -d);
                  let f = n3 - e4;
                  f < 0 && (f = -f);
                  h = r2[c];
                  s[u++] = i2 <= d && i2 <= f ? a4 + h : d <= f ? l + h : e4 + h;
                }
                break;
              default:
                throw new i.FormatError(`Unsupported predictor: ${a3}`);
            }
            this.bufferLength += e3;
          }
        }
        t2.PredictorStream = PredictorStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.RunLengthStream = void 0;
        var r = a2(18);
        class RunLengthStream extends r.DecodeStream {
          constructor(e3, t3) {
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
          }
          readBlock() {
            const e3 = this.str.getBytes(2);
            if (!e3 || e3.length < 2 || 128 === e3[0]) {
              this.eof = true;
              return;
            }
            let t3, a3 = this.bufferLength, r2 = e3[0];
            if (r2 < 128) {
              t3 = this.ensureBuffer(a3 + r2 + 1);
              t3[a3++] = e3[1];
              if (r2 > 0) {
                const e4 = this.str.getBytes(r2);
                t3.set(e4, a3);
                a3 += r2;
              }
            } else {
              r2 = 257 - r2;
              const n = e3[1];
              t3 = this.ensureBuffer(a3 + r2 + 1);
              for (let e4 = 0; e4 < r2; e4++) t3[a3++] = n;
            }
            this.bufferLength = a3;
          }
        }
        t2.RunLengthStream = RunLengthStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Font = t2.ErrorFont = void 0;
        var r = a2(2), n = a2(35), i = a2(38), s = a2(40), o = a2(39), c = a2(37), l = a2(41), h = a2(42), u = a2(43), d = a2(44), f = a2(45), g = a2(46), p = a2(14), m = a2(47), b = a2(3), y = a2(8), w = a2(48);
        const S = [[57344, 63743], [1048576, 1114109]], x = 1e3, C = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], k = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
        function adjustWidths(e3) {
          if (!e3.fontMatrix) return;
          if (e3.fontMatrix[0] === r.FONT_IDENTITY_MATRIX[0]) return;
          const t3 = 1e-3 / e3.fontMatrix[0], a3 = e3.widths;
          for (const e4 in a3) a3[e4] *= t3;
          e3.defaultWidth *= t3;
        }
        function amendFallbackToUnicode(e3) {
          if (!e3.fallbackToUnicode) return;
          if (e3.toUnicode instanceof h.IdentityToUnicodeMap) return;
          const t3 = [];
          for (const a3 in e3.fallbackToUnicode) e3.toUnicode.has(a3) || (t3[a3] = e3.fallbackToUnicode[a3]);
          t3.length > 0 && e3.toUnicode.amend(t3);
        }
        class Glyph {
          constructor(e3, t3, a3, r2, n2, i2, s2, o2, c2) {
            this.originalCharCode = e3;
            this.fontChar = t3;
            this.unicode = a3;
            this.accent = r2;
            this.width = n2;
            this.vmetric = i2;
            this.operatorListId = s2;
            this.isSpace = o2;
            this.isInFont = c2;
          }
          get category() {
            return (0, r.shadow)(this, "category", (0, s.getCharUnicodeCategory)(this.unicode), true);
          }
        }
        function int16(e3, t3) {
          return (e3 << 8) + t3;
        }
        function writeSignedInt16(e3, t3, a3) {
          e3[t3 + 1] = a3;
          e3[t3] = a3 >>> 8;
        }
        function signedInt16(e3, t3) {
          const a3 = (e3 << 8) + t3;
          return 32768 & a3 ? a3 - 65536 : a3;
        }
        function string16(e3) {
          return String.fromCharCode(e3 >> 8 & 255, 255 & e3);
        }
        function safeString16(e3) {
          e3 > 32767 ? e3 = 32767 : e3 < -32768 && (e3 = -32768);
          return String.fromCharCode(e3 >> 8 & 255, 255 & e3);
        }
        function isTrueTypeCollectionFile(e3) {
          const t3 = e3.peekBytes(4);
          return "ttcf" === (0, r.bytesToString)(t3);
        }
        function getFontFileType(e3, { type: t3, subtype: a3, composite: n2 }) {
          let i2, s2;
          if (function isTrueTypeFile(e4) {
            const t4 = e4.peekBytes(4);
            return 65536 === (0, b.readUint32)(t4, 0) || "true" === (0, r.bytesToString)(t4);
          }(e3) || isTrueTypeCollectionFile(e3)) i2 = n2 ? "CIDFontType2" : "TrueType";
          else if (function isOpenTypeFile(e4) {
            const t4 = e4.peekBytes(4);
            return "OTTO" === (0, r.bytesToString)(t4);
          }(e3)) i2 = n2 ? "CIDFontType2" : "OpenType";
          else if (function isType1File(e4) {
            const t4 = e4.peekBytes(2);
            return 37 === t4[0] && 33 === t4[1] || 128 === t4[0] && 1 === t4[1];
          }(e3)) i2 = n2 ? "CIDFontType0" : "MMType1" === t3 ? "MMType1" : "Type1";
          else if (function isCFFFile(e4) {
            const t4 = e4.peekBytes(4);
            return t4[0] >= 1 && t4[3] >= 1 && t4[3] <= 4;
          }(e3)) if (n2) {
            i2 = "CIDFontType0";
            s2 = "CIDFontType0C";
          } else {
            i2 = "MMType1" === t3 ? "MMType1" : "Type1";
            s2 = "Type1C";
          }
          else {
            (0, r.warn)("getFontFileType: Unable to detect correct font file Type/Subtype.");
            i2 = t3;
            s2 = a3;
          }
          return [i2, s2];
        }
        function applyStandardFontGlyphMap(e3, t3) {
          for (const a3 in t3) e3[+a3] = t3[a3];
        }
        function buildToFontChar(e3, t3, a3) {
          const r2 = [];
          let n2;
          for (let a4 = 0, i2 = e3.length; a4 < i2; a4++) {
            n2 = (0, s.getUnicodeForGlyph)(e3[a4], t3);
            -1 !== n2 && (r2[a4] = n2);
          }
          for (const e4 in a3) {
            n2 = (0, s.getUnicodeForGlyph)(a3[e4], t3);
            -1 !== n2 && (r2[+e4] = n2);
          }
          return r2;
        }
        function isMacNameRecord(e3) {
          return 1 === e3.platform && 0 === e3.encoding && 0 === e3.language;
        }
        function isWinNameRecord(e3) {
          return 3 === e3.platform && 1 === e3.encoding && 1033 === e3.language;
        }
        function convertCidString(e3, t3, a3 = false) {
          switch (t3.length) {
            case 1:
              return t3.charCodeAt(0);
            case 2:
              return t3.charCodeAt(0) << 8 | t3.charCodeAt(1);
          }
          const n2 = `Unsupported CID string (charCode ${e3}): "${t3}".`;
          if (a3) throw new r.FormatError(n2);
          (0, r.warn)(n2);
          return t3;
        }
        function adjustMapping(e3, t3, a3, n2) {
          const i2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), o2 = [], c2 = /* @__PURE__ */ new Set();
          let l2 = 0;
          let h2 = S[l2][0], u2 = S[l2][1];
          for (let f2 in e3) {
            f2 |= 0;
            let g2 = e3[f2];
            if (!t3(g2)) continue;
            if (h2 > u2) {
              l2++;
              if (l2 >= S.length) {
                (0, r.warn)("Ran out of space in font private use area.");
                break;
              }
              h2 = S[l2][0];
              u2 = S[l2][1];
            }
            const p2 = h2++;
            0 === g2 && (g2 = a3);
            let m2 = n2.get(f2);
            "string" == typeof m2 && (m2 = m2.codePointAt(0));
            if (m2 && !(d2 = m2, S[0][0] <= d2 && d2 <= S[0][1] || S[1][0] <= d2 && d2 <= S[1][1]) && !c2.has(g2)) {
              s2.set(m2, g2);
              c2.add(g2);
            }
            i2[p2] = g2;
            o2[f2] = p2;
          }
          var d2;
          return { toFontChar: o2, charCodeToGlyphId: i2, toUnicodeExtraMap: s2, nextAvailableFontCharCode: h2 };
        }
        function createCmapTable(e3, t3, a3) {
          const n2 = function getRanges(e4, t4, a4) {
            const r2 = [];
            for (const t5 in e4) e4[t5] >= a4 || r2.push({ fontCharCode: 0 | t5, glyphId: e4[t5] });
            if (t4) for (const [e5, n4] of t4) n4 >= a4 || r2.push({ fontCharCode: e5, glyphId: n4 });
            0 === r2.length && r2.push({ fontCharCode: 0, glyphId: 0 });
            r2.sort(function fontGetRangesSort(e5, t5) {
              return e5.fontCharCode - t5.fontCharCode;
            });
            const n3 = [], i3 = r2.length;
            for (let e5 = 0; e5 < i3; ) {
              const t5 = r2[e5].fontCharCode, a5 = [r2[e5].glyphId];
              ++e5;
              let s3 = t5;
              for (; e5 < i3 && s3 + 1 === r2[e5].fontCharCode; ) {
                a5.push(r2[e5].glyphId);
                ++s3;
                ++e5;
                if (65535 === s3) break;
              }
              n3.push([t5, s3, a5]);
            }
            return n3;
          }(e3, t3, a3), i2 = n2.at(-1)[1] > 65535 ? 2 : 1;
          let s2, o2, c2, l2, h2 = "\0\0" + string16(i2) + "\0\0" + (0, r.string32)(4 + 8 * i2);
          for (s2 = n2.length - 1; s2 >= 0 && !(n2[s2][0] <= 65535); --s2) ;
          const u2 = s2 + 1;
          n2[s2][0] < 65535 && 65535 === n2[s2][1] && (n2[s2][1] = 65534);
          const d2 = n2[s2][1] < 65535 ? 1 : 0, f2 = u2 + d2, g2 = m.OpenTypeFileBuilder.getSearchParams(f2, 2);
          let p2, b2, y2, w2, S2 = "", x2 = "", C2 = "", k2 = "", v = "", F = 0;
          for (s2 = 0, o2 = u2; s2 < o2; s2++) {
            p2 = n2[s2];
            b2 = p2[0];
            y2 = p2[1];
            S2 += string16(b2);
            x2 += string16(y2);
            w2 = p2[2];
            let e4 = true;
            for (c2 = 1, l2 = w2.length; c2 < l2; ++c2) if (w2[c2] !== w2[c2 - 1] + 1) {
              e4 = false;
              break;
            }
            if (e4) {
              C2 += string16(w2[0] - b2 & 65535);
              k2 += string16(0);
            } else {
              const e5 = 2 * (f2 - s2) + 2 * F;
              F += y2 - b2 + 1;
              C2 += string16(0);
              k2 += string16(e5);
              for (c2 = 0, l2 = w2.length; c2 < l2; ++c2) v += string16(w2[c2]);
            }
          }
          if (d2 > 0) {
            x2 += "ÿÿ";
            S2 += "ÿÿ";
            C2 += "\0";
            k2 += "\0\0";
          }
          const O = "\0\0" + string16(2 * f2) + string16(g2.range) + string16(g2.entry) + string16(g2.rangeShift) + x2 + "\0\0" + S2 + C2 + k2 + v;
          let T = "", M = "";
          if (i2 > 1) {
            h2 += "\0\0\n" + (0, r.string32)(4 + 8 * i2 + 4 + O.length);
            T = "";
            for (s2 = 0, o2 = n2.length; s2 < o2; s2++) {
              p2 = n2[s2];
              b2 = p2[0];
              w2 = p2[2];
              let e4 = w2[0];
              for (c2 = 1, l2 = w2.length; c2 < l2; ++c2) if (w2[c2] !== w2[c2 - 1] + 1) {
                y2 = p2[0] + c2 - 1;
                T += (0, r.string32)(b2) + (0, r.string32)(y2) + (0, r.string32)(e4);
                b2 = y2 + 1;
                e4 = w2[c2];
              }
              T += (0, r.string32)(b2) + (0, r.string32)(p2[1]) + (0, r.string32)(e4);
            }
            M = "\0\f\0\0" + (0, r.string32)(T.length + 16) + "\0\0\0\0" + (0, r.string32)(T.length / 12);
          }
          return h2 + "\0" + string16(O.length + 4) + O + M + T;
        }
        function createOS2Table(e3, t3, a3) {
          a3 || (a3 = { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 });
          let n2 = 0, i2 = 0, o2 = 0, c2 = 0, l2 = null, h2 = 0, u2 = -1;
          if (t3) {
            for (let e4 in t3) {
              e4 |= 0;
              (l2 > e4 || !l2) && (l2 = e4);
              h2 < e4 && (h2 = e4);
              u2 = (0, s.getUnicodeRangeFor)(e4, u2);
              if (u2 < 32) n2 |= 1 << u2;
              else if (u2 < 64) i2 |= 1 << u2 - 32;
              else if (u2 < 96) o2 |= 1 << u2 - 64;
              else {
                if (!(u2 < 123)) throw new r.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
                c2 |= 1 << u2 - 96;
              }
            }
            h2 > 65535 && (h2 = 65535);
          } else {
            l2 = 0;
            h2 = 255;
          }
          const d2 = e3.bbox || [0, 0, 0, 0], f2 = a3.unitsPerEm || 1 / (e3.fontMatrix || r.FONT_IDENTITY_MATRIX)[0], g2 = e3.ascentScaled ? 1 : f2 / x, p2 = a3.ascent || Math.round(g2 * (e3.ascent || d2[3]));
          let m2 = a3.descent || Math.round(g2 * (e3.descent || d2[1]));
          m2 > 0 && e3.descent > 0 && d2[1] < 0 && (m2 = -m2);
          const b2 = a3.yMax || p2, y2 = -a3.yMin || -m2;
          return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e3.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, r.string32)(n2) + (0, r.string32)(i2) + (0, r.string32)(o2) + (0, r.string32)(c2) + "*21*" + string16(e3.italicAngle ? 1 : 0) + string16(l2 || e3.firstChar) + string16(h2 || e3.lastChar) + string16(p2) + string16(m2) + "\0d" + string16(b2) + string16(y2) + "\0\0\0\0\0\0\0\0" + string16(e3.xHeight) + string16(e3.capHeight) + string16(0) + string16(l2 || e3.firstChar) + "\0";
        }
        function createPostTable(e3) {
          const t3 = Math.floor(65536 * e3.italicAngle);
          return "\0\0\0" + (0, r.string32)(t3) + "\0\0\0\0" + (0, r.string32)(e3.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
        }
        function createPostscriptName(e3) {
          return e3.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
        }
        function createNameTable(e3, t3) {
          t3 || (t3 = [[], []]);
          const a3 = [t3[0][0] || "Original licence", t3[0][1] || e3, t3[0][2] || "Unknown", t3[0][3] || "uniqueID", t3[0][4] || e3, t3[0][5] || "Version 0.11", t3[0][6] || createPostscriptName(e3), t3[0][7] || "Unknown", t3[0][8] || "Unknown", t3[0][9] || "Unknown"], r2 = [];
          let n2, i2, s2, o2, c2;
          for (n2 = 0, i2 = a3.length; n2 < i2; n2++) {
            c2 = t3[1][n2] || a3[n2];
            const e4 = [];
            for (s2 = 0, o2 = c2.length; s2 < o2; s2++) e4.push(string16(c2.charCodeAt(s2)));
            r2.push(e4.join(""));
          }
          const l2 = [a3, r2], h2 = ["\0", "\0"], u2 = ["\0\0", "\0"], d2 = ["\0\0", "	"], f2 = a3.length * h2.length;
          let g2 = "\0\0" + string16(f2) + string16(12 * f2 + 6), p2 = 0;
          for (n2 = 0, i2 = h2.length; n2 < i2; n2++) {
            const e4 = l2[n2];
            for (s2 = 0, o2 = e4.length; s2 < o2; s2++) {
              c2 = e4[s2];
              g2 += h2[n2] + u2[n2] + d2[n2] + string16(s2) + string16(c2.length) + string16(p2);
              p2 += c2.length;
            }
          }
          g2 += a3.join("") + r2.join("");
          return g2;
        }
        t2.Font = class Font {
          constructor(e3, t3, a3) {
            var _a;
            this.name = e3;
            this.psName = null;
            this.mimetype = null;
            this.disableFontFace = false;
            this.loadedName = a3.loadedName;
            this.isType3Font = a3.isType3Font;
            this.missingFile = false;
            this.cssFontInfo = a3.cssFontInfo;
            this._charsCache = /* @__PURE__ */ Object.create(null);
            this._glyphCache = /* @__PURE__ */ Object.create(null);
            let n2 = !!(a3.flags & i.FontFlags.Serif);
            if (!n2 && !a3.isSimulatedFlags) {
              const t4 = e3.replaceAll(/[,_]/g, "-").split("-")[0], a4 = (0, l.getSerifFonts)();
              for (const e4 of t4.split("+")) if (a4[e4]) {
                n2 = true;
                break;
              }
            }
            this.isSerifFont = n2;
            this.isSymbolicFont = !!(a3.flags & i.FontFlags.Symbolic);
            this.isMonospace = !!(a3.flags & i.FontFlags.FixedPitch);
            let { type: s2, subtype: o2 } = a3;
            this.type = s2;
            this.subtype = o2;
            this.systemFontInfo = a3.systemFontInfo;
            const c2 = e3.match(/^InvalidPDFjsFont_(.*)_\d+$/);
            this.isInvalidPDFjsFont = !!c2;
            this.isInvalidPDFjsFont ? this.fallbackName = c2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
            if ((_a = this.systemFontInfo) == null ? void 0 : _a.guessFallback) {
              this.systemFontInfo.guessFallback = false;
              this.systemFontInfo.css += `,${this.fallbackName}`;
            }
            this.differences = a3.differences;
            this.widths = a3.widths;
            this.defaultWidth = a3.defaultWidth;
            this.composite = a3.composite;
            this.cMap = a3.cMap;
            this.capHeight = a3.capHeight / x;
            this.ascent = a3.ascent / x;
            this.descent = a3.descent / x;
            this.lineHeight = this.ascent - this.descent;
            this.fontMatrix = a3.fontMatrix;
            this.bbox = a3.bbox;
            this.defaultEncoding = a3.defaultEncoding;
            this.toUnicode = a3.toUnicode;
            this.toFontChar = [];
            if ("Type3" === a3.type) {
              for (let e4 = 0; e4 < 256; e4++) this.toFontChar[e4] = this.differences[e4] || a3.defaultEncoding[e4];
              return;
            }
            this.cidEncoding = a3.cidEncoding || "";
            this.vertical = !!a3.vertical;
            if (this.vertical) {
              this.vmetrics = a3.vmetrics;
              this.defaultVMetrics = a3.defaultVMetrics;
            }
            if (!t3 || t3.isEmpty) {
              t3 && (0, r.warn)('Font file is empty in "' + e3 + '" (' + this.loadedName + ")");
              this.fallbackToSystemFont(a3);
              return;
            }
            [s2, o2] = getFontFileType(t3, a3);
            s2 === this.type && o2 === this.subtype || (0, r.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s2}/${o2}.`);
            let h2;
            try {
              switch (s2) {
                case "MMType1":
                  (0, r.info)("MMType1 font (" + e3 + "), falling back to Type1.");
                case "Type1":
                case "CIDFontType0":
                  this.mimetype = "font/opentype";
                  const n3 = "Type1C" === o2 || "CIDFontType0C" === o2 ? new u.CFFFont(t3, a3) : new w.Type1Font(e3, t3, a3);
                  adjustWidths(a3);
                  h2 = this.convert(e3, n3, a3);
                  break;
                case "OpenType":
                case "TrueType":
                case "CIDFontType2":
                  this.mimetype = "font/opentype";
                  h2 = this.checkAndRepair(e3, t3, a3);
                  if (this.isOpenType) {
                    adjustWidths(a3);
                    s2 = "OpenType";
                  }
                  break;
                default:
                  throw new r.FormatError(`Font ${s2} is not supported`);
              }
            } catch (e4) {
              (0, r.warn)(e4);
              this.fallbackToSystemFont(a3);
              return;
            }
            amendFallbackToUnicode(a3);
            this.data = h2;
            this.type = s2;
            this.subtype = o2;
            this.fontMatrix = a3.fontMatrix;
            this.widths = a3.widths;
            this.defaultWidth = a3.defaultWidth;
            this.toUnicode = a3.toUnicode;
            this.seacMap = a3.seacMap;
          }
          get renderer() {
            const e3 = d.FontRendererFactory.create(this, i.SEAC_ANALYSIS_ENABLED);
            return (0, r.shadow)(this, "renderer", e3);
          }
          exportData(e3 = false) {
            const t3 = e3 ? [...C, ...k] : C, a3 = /* @__PURE__ */ Object.create(null);
            let r2, n2;
            for (r2 of t3) {
              n2 = this[r2];
              void 0 !== n2 && (a3[r2] = n2);
            }
            return a3;
          }
          fallbackToSystemFont(e3) {
            this.missingFile = true;
            const { name: t3, type: a3 } = this;
            let r2 = (0, i.normalizeFontName)(t3);
            const n2 = (0, l.getStdFontMap)(), u2 = (0, l.getNonStdFontMap)(), d2 = !!n2[r2], g2 = !(!u2[r2] || !n2[u2[r2]]);
            r2 = n2[r2] || u2[r2] || r2;
            const p2 = (0, f.getFontBasicMetrics)()[r2];
            if (p2) {
              isNaN(this.ascent) && (this.ascent = p2.ascent / x);
              isNaN(this.descent) && (this.descent = p2.descent / x);
              isNaN(this.capHeight) && (this.capHeight = p2.capHeight / x);
            }
            this.bold = /bold/gi.test(r2);
            this.italic = /oblique|italic/gi.test(r2);
            this.black = /Black/g.test(t3);
            const m2 = /Narrow/g.test(t3);
            this.remeasure = (!d2 || m2) && Object.keys(this.widths).length > 0;
            if ((d2 || g2) && "CIDFontType2" === a3 && this.cidEncoding.startsWith("Identity-")) {
              const a4 = e3.cidToGidMap, r3 = [];
              applyStandardFontGlyphMap(r3, (0, l.getGlyphMapForStandardFonts)());
              /Arial-?Black/i.test(t3) ? applyStandardFontGlyphMap(r3, (0, l.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(t3) && applyStandardFontGlyphMap(r3, (0, l.getSupplementalGlyphMapForCalibri)());
              if (a4) {
                for (const e4 in r3) {
                  const t4 = r3[e4];
                  void 0 !== a4[t4] && (r3[+e4] = a4[t4]);
                }
                a4.length !== this.toUnicode.length && e3.hasIncludedToUnicodeMap && this.toUnicode instanceof h.IdentityToUnicodeMap && this.toUnicode.forEach(function(e4, t4) {
                  const n3 = r3[e4];
                  void 0 === a4[n3] && (r3[+e4] = t4);
                });
              }
              this.toUnicode instanceof h.IdentityToUnicodeMap || this.toUnicode.forEach(function(e4, t4) {
                r3[+e4] = t4;
              });
              this.toFontChar = r3;
              this.toUnicode = new h.ToUnicodeMap(r3);
            } else if (/Symbol/i.test(r2)) this.toFontChar = buildToFontChar(c.SymbolSetEncoding, (0, o.getGlyphsUnicode)(), this.differences);
            else if (/Dingbats/i.test(r2)) this.toFontChar = buildToFontChar(c.ZapfDingbatsEncoding, (0, o.getDingbatsGlyphsUnicode)(), this.differences);
            else if (d2) {
              const e4 = buildToFontChar(this.defaultEncoding, (0, o.getGlyphsUnicode)(), this.differences);
              "CIDFontType2" !== a3 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof h.IdentityToUnicodeMap || this.toUnicode.forEach(function(t4, a4) {
                e4[+t4] = a4;
              });
              this.toFontChar = e4;
            } else {
              const e4 = (0, o.getGlyphsUnicode)(), a4 = [];
              this.toUnicode.forEach((t4, r3) => {
                if (!this.composite) {
                  const a5 = this.differences[t4] || this.defaultEncoding[t4], n3 = (0, s.getUnicodeForGlyph)(a5, e4);
                  -1 !== n3 && (r3 = n3);
                }
                a4[+t4] = r3;
              });
              this.composite && this.toUnicode instanceof h.IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t3) && applyStandardFontGlyphMap(a4, (0, l.getGlyphMapForStandardFonts)());
              this.toFontChar = a4;
            }
            amendFallbackToUnicode(e3);
            this.loadedName = r2.split("-")[0];
          }
          checkAndRepair(e3, t3, a3) {
            var _a, _b, _c;
            const s2 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
            function readTables(e4, t4) {
              const a4 = /* @__PURE__ */ Object.create(null);
              a4["OS/2"] = null;
              a4.cmap = null;
              a4.head = null;
              a4.hhea = null;
              a4.hmtx = null;
              a4.maxp = null;
              a4.name = null;
              a4.post = null;
              for (let r2 = 0; r2 < t4; r2++) {
                const t5 = readTableEntry(e4);
                s2.includes(t5.tag) && (0 !== t5.length && (a4[t5.tag] = t5));
              }
              return a4;
            }
            function readTableEntry(e4) {
              const t4 = e4.getString(4), a4 = e4.getInt32() >>> 0, r2 = e4.getInt32() >>> 0, n2 = e4.getInt32() >>> 0, i2 = e4.pos;
              e4.pos = e4.start || 0;
              e4.skip(r2);
              const s3 = e4.getBytes(n2);
              e4.pos = i2;
              if ("head" === t4) {
                s3[8] = s3[9] = s3[10] = s3[11] = 0;
                s3[17] |= 32;
              }
              return { tag: t4, checksum: a4, length: n2, offset: r2, data: s3 };
            }
            function readOpenTypeHeader(e4) {
              return { version: e4.getString(4), numTables: e4.getUint16(), searchRange: e4.getUint16(), entrySelector: e4.getUint16(), rangeShift: e4.getUint16() };
            }
            function sanitizeGlyph(e4, t4, a4, r2, n2, i2) {
              const s3 = { length: 0, sizeOfInstructions: 0 };
              if (t4 < 0 || t4 >= e4.length || a4 > e4.length || a4 - t4 <= 12) return s3;
              const o2 = e4.subarray(t4, a4), c2 = signedInt16(o2[2], o2[3]), l3 = signedInt16(o2[4], o2[5]), h2 = signedInt16(o2[6], o2[7]), u2 = signedInt16(o2[8], o2[9]);
              if (c2 > h2) {
                writeSignedInt16(o2, 2, h2);
                writeSignedInt16(o2, 6, c2);
              }
              if (l3 > u2) {
                writeSignedInt16(o2, 4, u2);
                writeSignedInt16(o2, 8, l3);
              }
              const d3 = signedInt16(o2[0], o2[1]);
              if (d3 < 0) {
                if (d3 < -1) return s3;
                r2.set(o2, n2);
                s3.length = o2.length;
                return s3;
              }
              let f3, g2 = 10, p2 = 0;
              for (f3 = 0; f3 < d3; f3++) {
                p2 = (o2[g2] << 8 | o2[g2 + 1]) + 1;
                g2 += 2;
              }
              const m2 = g2, b3 = o2[g2] << 8 | o2[g2 + 1];
              s3.sizeOfInstructions = b3;
              g2 += 2 + b3;
              const y2 = g2;
              let w3 = 0;
              for (f3 = 0; f3 < p2; f3++) {
                const e5 = o2[g2++];
                192 & e5 && (o2[g2 - 1] = 63 & e5);
                let t5 = 2;
                2 & e5 ? t5 = 1 : 16 & e5 && (t5 = 0);
                let a5 = 2;
                4 & e5 ? a5 = 1 : 32 & e5 && (a5 = 0);
                const r3 = t5 + a5;
                w3 += r3;
                if (8 & e5) {
                  const e6 = o2[g2++];
                  0 === e6 && (o2[g2 - 1] ^= 8);
                  f3 += e6;
                  w3 += e6 * r3;
                }
              }
              if (0 === w3) return s3;
              let S3 = g2 + w3;
              if (S3 > o2.length) return s3;
              if (!i2 && b3 > 0) {
                r2.set(o2.subarray(0, m2), n2);
                r2.set([0, 0], n2 + m2);
                r2.set(o2.subarray(y2, S3), n2 + m2 + 2);
                S3 -= b3;
                o2.length - S3 > 3 && (S3 = S3 + 3 & -4);
                s3.length = S3;
                return s3;
              }
              if (o2.length - S3 > 3) {
                S3 = S3 + 3 & -4;
                r2.set(o2.subarray(0, S3), n2);
                s3.length = S3;
                return s3;
              }
              r2.set(o2, n2);
              s3.length = o2.length;
              return s3;
            }
            function readNameTable(e4) {
              const a4 = (t3.start || 0) + e4.offset;
              t3.pos = a4;
              const r2 = [[], []], n2 = [], i2 = e4.length, s3 = a4 + i2;
              if (0 !== t3.getUint16() || i2 < 6) return [r2, n2];
              const o2 = t3.getUint16(), c2 = t3.getUint16();
              let l3, h2;
              for (l3 = 0; l3 < o2 && t3.pos + 12 <= s3; l3++) {
                const e5 = { platform: t3.getUint16(), encoding: t3.getUint16(), language: t3.getUint16(), name: t3.getUint16(), length: t3.getUint16(), offset: t3.getUint16() };
                (isMacNameRecord(e5) || isWinNameRecord(e5)) && n2.push(e5);
              }
              for (l3 = 0, h2 = n2.length; l3 < h2; l3++) {
                const e5 = n2[l3];
                if (e5.length <= 0) continue;
                const i3 = a4 + c2 + e5.offset;
                if (i3 + e5.length > s3) continue;
                t3.pos = i3;
                const o3 = e5.name;
                if (e5.encoding) {
                  let a5 = "";
                  for (let r3 = 0, n3 = e5.length; r3 < n3; r3 += 2) a5 += String.fromCharCode(t3.getUint16());
                  r2[1][o3] = a5;
                } else r2[0][o3] = t3.getString(e5.length);
              }
              return [r2, n2];
            }
            const l2 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
            function sanitizeTTProgram(e4, t4) {
              let a4, n2, i2, s3, o2, c2 = e4.data, h2 = 0, u2 = 0, d3 = 0;
              const f3 = [], g2 = [], p2 = [];
              let m2 = t4.tooComplexToFollowFunctions, b3 = false, y2 = 0, w3 = 0;
              for (let e5 = c2.length; h2 < e5; ) {
                const e6 = c2[h2++];
                if (64 === e6) {
                  n2 = c2[h2++];
                  if (b3 || w3) h2 += n2;
                  else for (a4 = 0; a4 < n2; a4++) f3.push(c2[h2++]);
                } else if (65 === e6) {
                  n2 = c2[h2++];
                  if (b3 || w3) h2 += 2 * n2;
                  else for (a4 = 0; a4 < n2; a4++) {
                    i2 = c2[h2++];
                    f3.push(i2 << 8 | c2[h2++]);
                  }
                } else if (176 == (248 & e6)) {
                  n2 = e6 - 176 + 1;
                  if (b3 || w3) h2 += n2;
                  else for (a4 = 0; a4 < n2; a4++) f3.push(c2[h2++]);
                } else if (184 == (248 & e6)) {
                  n2 = e6 - 184 + 1;
                  if (b3 || w3) h2 += 2 * n2;
                  else for (a4 = 0; a4 < n2; a4++) {
                    i2 = c2[h2++];
                    f3.push(i2 << 8 | c2[h2++]);
                  }
                } else if (43 !== e6 || m2) if (44 !== e6 || m2) {
                  if (45 === e6) if (b3) {
                    b3 = false;
                    u2 = h2;
                  } else {
                    o2 = g2.pop();
                    if (!o2) {
                      (0, r.warn)("TT: ENDF bad stack");
                      t4.hintsValid = false;
                      return;
                    }
                    s3 = p2.pop();
                    c2 = o2.data;
                    h2 = o2.i;
                    t4.functionsStackDeltas[s3] = f3.length - o2.stackTop;
                  }
                  else if (137 === e6) {
                    if (b3 || w3) {
                      (0, r.warn)("TT: nested IDEFs not allowed");
                      m2 = true;
                    }
                    b3 = true;
                    d3 = h2;
                  } else if (88 === e6) ++y2;
                  else if (27 === e6) w3 = y2;
                  else if (89 === e6) {
                    w3 === y2 && (w3 = 0);
                    --y2;
                  } else if (28 === e6 && !b3 && !w3) {
                    const e7 = f3.at(-1);
                    e7 > 0 && (h2 += e7 - 1);
                  }
                } else {
                  if (b3 || w3) {
                    (0, r.warn)("TT: nested FDEFs not allowed");
                    m2 = true;
                  }
                  b3 = true;
                  d3 = h2;
                  s3 = f3.pop();
                  t4.functionsDefined[s3] = { data: c2, i: h2 };
                }
                else if (!b3 && !w3) {
                  s3 = f3.at(-1);
                  if (isNaN(s3)) (0, r.info)("TT: CALL empty stack (or invalid entry).");
                  else {
                    t4.functionsUsed[s3] = true;
                    if (s3 in t4.functionsStackDeltas) {
                      const e7 = f3.length + t4.functionsStackDeltas[s3];
                      if (e7 < 0) {
                        (0, r.warn)("TT: CALL invalid functions stack delta.");
                        t4.hintsValid = false;
                        return;
                      }
                      f3.length = e7;
                    } else if (s3 in t4.functionsDefined && !p2.includes(s3)) {
                      g2.push({ data: c2, i: h2, stackTop: f3.length - 1 });
                      p2.push(s3);
                      o2 = t4.functionsDefined[s3];
                      if (!o2) {
                        (0, r.warn)("TT: CALL non-existent function");
                        t4.hintsValid = false;
                        return;
                      }
                      c2 = o2.data;
                      h2 = o2.i;
                    }
                  }
                }
                if (!b3 && !w3) {
                  let t5 = 0;
                  e6 <= 142 ? t5 = l2[e6] : e6 >= 192 && e6 <= 223 ? t5 = -1 : e6 >= 224 && (t5 = -2);
                  if (e6 >= 113 && e6 <= 117) {
                    n2 = f3.pop();
                    isNaN(n2) || (t5 = 2 * -n2);
                  }
                  for (; t5 < 0 && f3.length > 0; ) {
                    f3.pop();
                    t5++;
                  }
                  for (; t5 > 0; ) {
                    f3.push(NaN);
                    t5--;
                  }
                }
              }
              t4.tooComplexToFollowFunctions = m2;
              const S3 = [c2];
              h2 > c2.length && S3.push(new Uint8Array(h2 - c2.length));
              if (d3 > u2) {
                (0, r.warn)("TT: complementing a missing function tail");
                S3.push(new Uint8Array([34, 45]));
              }
              !function foldTTTable(e5, t5) {
                if (t5.length > 1) {
                  let a5, r2, n3 = 0;
                  for (a5 = 0, r2 = t5.length; a5 < r2; a5++) n3 += t5[a5].length;
                  n3 = n3 + 3 & -4;
                  const i3 = new Uint8Array(n3);
                  let s4 = 0;
                  for (a5 = 0, r2 = t5.length; a5 < r2; a5++) {
                    i3.set(t5[a5], s4);
                    s4 += t5[a5].length;
                  }
                  e5.data = i3;
                  e5.length = n3;
                }
              }(e4, S3);
            }
            let d2, f2, b2, w2;
            if (isTrueTypeCollectionFile(t3 = new y.Stream(new Uint8Array(t3.getBytes())))) {
              const e4 = function readTrueTypeCollectionData(e5, t4) {
                var _a2;
                const { numFonts: a4, offsetTable: n2 } = function readTrueTypeCollectionHeader(e6) {
                  const t5 = e6.getString(4);
                  (0, r.assert)("ttcf" === t5, "Must be a TrueType Collection font.");
                  const a5 = e6.getUint16(), n3 = e6.getUint16(), i3 = e6.getInt32() >>> 0, s4 = [];
                  for (let t6 = 0; t6 < i3; t6++) s4.push(e6.getInt32() >>> 0);
                  const o2 = { ttcTag: t5, majorVersion: a5, minorVersion: n3, numFonts: i3, offsetTable: s4 };
                  switch (a5) {
                    case 1:
                      return o2;
                    case 2:
                      o2.dsigTag = e6.getInt32() >>> 0;
                      o2.dsigLength = e6.getInt32() >>> 0;
                      o2.dsigOffset = e6.getInt32() >>> 0;
                      return o2;
                  }
                  throw new r.FormatError(`Invalid TrueType Collection majorVersion: ${a5}.`);
                }(e5), i2 = t4.split("+");
                let s3;
                for (let o2 = 0; o2 < a4; o2++) {
                  e5.pos = (e5.start || 0) + n2[o2];
                  const a5 = readOpenTypeHeader(e5), c2 = readTables(e5, a5.numTables);
                  if (!c2.name) throw new r.FormatError('TrueType Collection font must contain a "name" table.');
                  const [l3] = readNameTable(c2.name);
                  for (let e6 = 0, r2 = l3.length; e6 < r2; e6++) for (let r3 = 0, n3 = l3[e6].length; r3 < n3; r3++) {
                    const n4 = (_a2 = l3[e6][r3]) == null ? void 0 : _a2.replaceAll(/\s/g, "");
                    if (n4) {
                      if (n4 === t4) return { header: a5, tables: c2 };
                      if (!(i2.length < 2)) for (const e7 of i2) n4 === e7 && (s3 = { name: e7, header: a5, tables: c2 });
                    }
                  }
                }
                if (s3) {
                  (0, r.warn)(`TrueType Collection does not contain "${t4}" font, falling back to "${s3.name}" font instead.`);
                  return { header: s3.header, tables: s3.tables };
                }
                throw new r.FormatError(`TrueType Collection does not contain "${t4}" font.`);
              }(t3, this.name);
              d2 = e4.header;
              f2 = e4.tables;
            } else {
              d2 = readOpenTypeHeader(t3);
              f2 = readTables(t3, d2.numTables);
            }
            const S2 = !f2["CFF "];
            if (S2) {
              if (!f2.loca) throw new r.FormatError('Required "loca" table is not found');
              if (!f2.glyf) {
                (0, r.warn)('Required "glyf" table is not found -- trying to recover.');
                f2.glyf = { tag: "glyf", data: new Uint8Array(0) };
              }
              this.isOpenType = false;
            } else {
              const t4 = a3.composite && (((_a = a3.cidToGidMap) == null ? void 0 : _a.length) > 0 || !(a3.cMap instanceof p.IdentityCMap));
              if ("OTTO" === d2.version && !t4 || !f2.head || !f2.hhea || !f2.maxp || !f2.post) {
                w2 = new y.Stream(f2["CFF "].data);
                b2 = new u.CFFFont(w2, a3);
                adjustWidths(a3);
                return this.convert(e3, b2, a3);
              }
              delete f2.glyf;
              delete f2.loca;
              delete f2.fpgm;
              delete f2.prep;
              delete f2["cvt "];
              this.isOpenType = true;
            }
            if (!f2.maxp) throw new r.FormatError('Required "maxp" table is not found');
            t3.pos = (t3.start || 0) + f2.maxp.offset;
            const x2 = t3.getInt32(), C2 = t3.getUint16();
            if (((_b = a3.scaleFactors) == null ? void 0 : _b.length) === C2 && S2) {
              const { scaleFactors: e4 } = a3, t4 = int16(f2.head.data[50], f2.head.data[51]), r2 = new g.GlyfTable({ glyfTable: f2.glyf.data, isGlyphLocationsLong: t4, locaTable: f2.loca.data, numGlyphs: C2 });
              r2.scale(e4);
              const { glyf: n2, loca: i2, isLocationLong: s3 } = r2.write();
              f2.glyf.data = n2;
              f2.loca.data = i2;
              if (s3 !== !!t4) {
                f2.head.data[50] = 0;
                f2.head.data[51] = s3 ? 1 : 0;
              }
              const o2 = f2.hmtx.data;
              for (let t5 = 0; t5 < C2; t5++) {
                const a4 = 4 * t5, r3 = Math.round(e4[t5] * int16(o2[a4], o2[a4 + 1]));
                o2[a4] = r3 >> 8 & 255;
                o2[a4 + 1] = 255 & r3;
                writeSignedInt16(o2, a4 + 2, Math.round(e4[t5] * signedInt16(o2[a4 + 2], o2[a4 + 3])));
              }
            }
            let k2 = C2 + 1, v = true;
            if (k2 > 65535) {
              v = false;
              k2 = C2;
              (0, r.warn)("Not enough space in glyfs to duplicate first glyph.");
            }
            let F = 0, O = 0;
            if (x2 >= 65536 && f2.maxp.length >= 22) {
              t3.pos += 8;
              if (t3.getUint16() > 2) {
                f2.maxp.data[14] = 0;
                f2.maxp.data[15] = 2;
              }
              t3.pos += 4;
              F = t3.getUint16();
              t3.pos += 4;
              O = t3.getUint16();
            }
            f2.maxp.data[4] = k2 >> 8;
            f2.maxp.data[5] = 255 & k2;
            const T = function sanitizeTTPrograms(e4, t4, a4, n2) {
              const i2 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
              e4 && sanitizeTTProgram(e4, i2);
              t4 && sanitizeTTProgram(t4, i2);
              e4 && function checkInvalidFunctions(e5, t5) {
                if (!e5.tooComplexToFollowFunctions) if (e5.functionsDefined.length > t5) {
                  (0, r.warn)("TT: more functions defined than expected");
                  e5.hintsValid = false;
                } else for (let a5 = 0, n3 = e5.functionsUsed.length; a5 < n3; a5++) {
                  if (a5 > t5) {
                    (0, r.warn)("TT: invalid function id: " + a5);
                    e5.hintsValid = false;
                    return;
                  }
                  if (e5.functionsUsed[a5] && !e5.functionsDefined[a5]) {
                    (0, r.warn)("TT: undefined function: " + a5);
                    e5.hintsValid = false;
                    return;
                  }
                }
              }(i2, n2);
              if (a4 && 1 & a4.length) {
                const e5 = new Uint8Array(a4.length + 1);
                e5.set(a4.data);
                a4.data = e5;
              }
              return i2.hintsValid;
            }(f2.fpgm, f2.prep, f2["cvt "], F);
            if (!T) {
              delete f2.fpgm;
              delete f2.prep;
              delete f2["cvt "];
            }
            !function sanitizeMetrics(e4, t4, a4, n2, i2, s3) {
              if (!t4) {
                a4 && (a4.data = null);
                return;
              }
              e4.pos = (e4.start || 0) + t4.offset;
              e4.pos += 4;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              e4.pos += 2;
              const o2 = e4.getUint16();
              e4.pos += 8;
              e4.pos += 2;
              let c2 = e4.getUint16();
              if (0 !== o2) {
                if (!(2 & int16(n2.data[44], n2.data[45]))) {
                  t4.data[22] = 0;
                  t4.data[23] = 0;
                }
              }
              if (c2 > i2) {
                (0, r.info)(`The numOfMetrics (${c2}) should not be greater than the numGlyphs (${i2}).`);
                c2 = i2;
                t4.data[34] = (65280 & c2) >> 8;
                t4.data[35] = 255 & c2;
              }
              const l3 = i2 - c2 - (a4.length - 4 * c2 >> 1);
              if (l3 > 0) {
                const e5 = new Uint8Array(a4.length + 2 * l3);
                e5.set(a4.data);
                if (s3) {
                  e5[a4.length] = a4.data[2];
                  e5[a4.length + 1] = a4.data[3];
                }
                a4.data = e5;
              }
            }(t3, f2.hhea, f2.hmtx, f2.head, k2, v);
            if (!f2.head) throw new r.FormatError('Required "head" table is not found');
            !function sanitizeHead(e4, t4, a4) {
              const n2 = e4.data, i2 = function int32(e5, t5, a5, r2) {
                return (e5 << 24) + (t5 << 16) + (a5 << 8) + r2;
              }(n2[0], n2[1], n2[2], n2[3]);
              if (i2 >> 16 != 1) {
                (0, r.info)("Attempting to fix invalid version in head table: " + i2);
                n2[0] = 0;
                n2[1] = 1;
                n2[2] = 0;
                n2[3] = 0;
              }
              const s3 = int16(n2[50], n2[51]);
              if (s3 < 0 || s3 > 1) {
                (0, r.info)("Attempting to fix invalid indexToLocFormat in head table: " + s3);
                const e5 = t4 + 1;
                if (a4 === e5 << 1) {
                  n2[50] = 0;
                  n2[51] = 0;
                } else {
                  if (a4 !== e5 << 2) throw new r.FormatError("Could not fix indexToLocFormat: " + s3);
                  n2[50] = 0;
                  n2[51] = 1;
                }
              }
            }(f2.head, C2, S2 ? f2.loca.length : 0);
            let M = /* @__PURE__ */ Object.create(null);
            if (S2) {
              const e4 = int16(f2.head.data[50], f2.head.data[51]), t4 = function sanitizeGlyphLocations(e5, t5, a4, r2, n2, i2, s3) {
                let o2, c2, l3;
                if (r2) {
                  o2 = 4;
                  c2 = function fontItemDecodeLong(e6, t6) {
                    return e6[t6] << 24 | e6[t6 + 1] << 16 | e6[t6 + 2] << 8 | e6[t6 + 3];
                  };
                  l3 = function fontItemEncodeLong(e6, t6, a5) {
                    e6[t6] = a5 >>> 24 & 255;
                    e6[t6 + 1] = a5 >> 16 & 255;
                    e6[t6 + 2] = a5 >> 8 & 255;
                    e6[t6 + 3] = 255 & a5;
                  };
                } else {
                  o2 = 2;
                  c2 = function fontItemDecode(e6, t6) {
                    return e6[t6] << 9 | e6[t6 + 1] << 1;
                  };
                  l3 = function fontItemEncode(e6, t6, a5) {
                    e6[t6] = a5 >> 9 & 255;
                    e6[t6 + 1] = a5 >> 1 & 255;
                  };
                }
                const h2 = i2 ? a4 + 1 : a4, u2 = o2 * (1 + h2), d3 = new Uint8Array(u2);
                d3.set(e5.data.subarray(0, u2));
                e5.data = d3;
                const f3 = t5.data, g2 = f3.length, p2 = new Uint8Array(g2);
                let m2, b3;
                const y2 = [];
                for (m2 = 0, b3 = 0; m2 < a4 + 1; m2++, b3 += o2) {
                  let e6 = c2(d3, b3);
                  e6 > g2 && (e6 = g2);
                  y2.push({ index: m2, offset: e6, endOffset: 0 });
                }
                y2.sort((e6, t6) => e6.offset - t6.offset);
                for (m2 = 0; m2 < a4; m2++) y2[m2].endOffset = y2[m2 + 1].offset;
                y2.sort((e6, t6) => e6.index - t6.index);
                for (m2 = 0; m2 < a4; m2++) {
                  const { offset: e6, endOffset: t6 } = y2[m2];
                  if (0 !== e6 || 0 !== t6) break;
                  const a5 = y2[m2 + 1].offset;
                  if (0 !== a5) {
                    y2[m2].endOffset = a5;
                    break;
                  }
                }
                const w3 = /* @__PURE__ */ Object.create(null);
                let S3 = 0;
                l3(d3, 0, S3);
                for (m2 = 0, b3 = o2; m2 < a4; m2++, b3 += o2) {
                  const e6 = sanitizeGlyph(f3, y2[m2].offset, y2[m2].endOffset, p2, S3, n2), t6 = e6.length;
                  0 === t6 && (w3[m2] = true);
                  e6.sizeOfInstructions > s3 && (s3 = e6.sizeOfInstructions);
                  S3 += t6;
                  l3(d3, b3, S3);
                }
                if (0 === S3) {
                  const e6 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                  for (m2 = 0, b3 = o2; m2 < h2; m2++, b3 += o2) l3(d3, b3, e6.length);
                  t5.data = e6;
                } else if (i2) {
                  const a5 = c2(d3, o2);
                  if (p2.length > a5 + S3) t5.data = p2.subarray(0, a5 + S3);
                  else {
                    t5.data = new Uint8Array(a5 + S3);
                    t5.data.set(p2.subarray(0, S3));
                  }
                  t5.data.set(p2.subarray(0, a5), S3);
                  l3(e5.data, d3.length - o2, S3 + a5);
                } else t5.data = p2.subarray(0, S3);
                return { missingGlyphs: w3, maxSizeOfInstructions: s3 };
              }(f2.loca, f2.glyf, C2, e4, T, v, O);
              M = t4.missingGlyphs;
              if (x2 >= 65536 && f2.maxp.length >= 22) {
                f2.maxp.data[26] = t4.maxSizeOfInstructions >> 8;
                f2.maxp.data[27] = 255 & t4.maxSizeOfInstructions;
              }
            }
            if (!f2.hhea) throw new r.FormatError('Required "hhea" table is not found');
            if (0 === f2.hhea.data[10] && 0 === f2.hhea.data[11]) {
              f2.hhea.data[10] = 255;
              f2.hhea.data[11] = 255;
            }
            const D = { unitsPerEm: int16(f2.head.data[18], f2.head.data[19]), yMax: signedInt16(f2.head.data[42], f2.head.data[43]), yMin: signedInt16(f2.head.data[38], f2.head.data[39]), ascent: signedInt16(f2.hhea.data[4], f2.hhea.data[5]), descent: signedInt16(f2.hhea.data[6], f2.hhea.data[7]), lineGap: signedInt16(f2.hhea.data[8], f2.hhea.data[9]) };
            this.ascent = D.ascent / D.unitsPerEm;
            this.descent = D.descent / D.unitsPerEm;
            this.lineGap = D.lineGap / D.unitsPerEm;
            if ((_c = this.cssFontInfo) == null ? void 0 : _c.lineHeight) {
              this.lineHeight = this.cssFontInfo.metrics.lineHeight;
              this.lineGap = this.cssFontInfo.metrics.lineGap;
            } else this.lineHeight = this.ascent - this.descent + this.lineGap;
            f2.post && function readPostScriptTable(e4, a4, n2) {
              const s3 = (t3.start || 0) + e4.offset;
              t3.pos = s3;
              const o2 = s3 + e4.length, c2 = t3.getInt32();
              t3.skip(28);
              let l3, h2, u2 = true;
              switch (c2) {
                case 65536:
                  l3 = i.MacStandardGlyphOrdering;
                  break;
                case 131072:
                  const e5 = t3.getUint16();
                  if (e5 !== n2) {
                    u2 = false;
                    break;
                  }
                  const s4 = [];
                  for (h2 = 0; h2 < e5; ++h2) {
                    const e6 = t3.getUint16();
                    if (e6 >= 32768) {
                      u2 = false;
                      break;
                    }
                    s4.push(e6);
                  }
                  if (!u2) break;
                  const d3 = [], f3 = [];
                  for (; t3.pos < o2; ) {
                    const e6 = t3.getByte();
                    f3.length = e6;
                    for (h2 = 0; h2 < e6; ++h2) f3[h2] = String.fromCharCode(t3.getByte());
                    d3.push(f3.join(""));
                  }
                  l3 = [];
                  for (h2 = 0; h2 < e5; ++h2) {
                    const e6 = s4[h2];
                    e6 < 258 ? l3.push(i.MacStandardGlyphOrdering[e6]) : l3.push(d3[e6 - 258]);
                  }
                  break;
                case 196608:
                  break;
                default:
                  (0, r.warn)("Unknown/unsupported post table version " + c2);
                  u2 = false;
                  a4.defaultEncoding && (l3 = a4.defaultEncoding);
              }
              a4.glyphNames = l3;
              return u2;
            }(f2.post, a3, C2);
            f2.post = { tag: "post", data: createPostTable(a3) };
            const E = [];
            function hasGlyph(e4) {
              return !M[e4];
            }
            if (a3.composite) {
              const e4 = a3.cidToGidMap || [], t4 = 0 === e4.length;
              a3.cMap.forEach(function(a4, n2) {
                "string" == typeof n2 && (n2 = convertCidString(a4, n2, true));
                if (n2 > 65535) throw new r.FormatError("Max size of CID is 65,535");
                let i2 = -1;
                t4 ? i2 = n2 : void 0 !== e4[n2] && (i2 = e4[n2]);
                i2 >= 0 && i2 < C2 && hasGlyph(i2) && (E[a4] = i2);
              });
            } else {
              const e4 = function readCmapTable(e5, t4, a4, n3) {
                if (!e5) {
                  (0, r.warn)("No cmap table available.");
                  return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                }
                let i2, s4 = (t4.start || 0) + e5.offset;
                t4.pos = s4;
                t4.skip(2);
                const o2 = t4.getUint16();
                let c2, l4 = false;
                for (let e6 = 0; e6 < o2; e6++) {
                  const r2 = t4.getUint16(), i3 = t4.getUint16(), s5 = t4.getInt32() >>> 0;
                  let h3 = false;
                  if ((c2 == null ? void 0 : c2.platformId) !== r2 || (c2 == null ? void 0 : c2.encodingId) !== i3) {
                    if (0 !== r2 || 0 !== i3 && 1 !== i3 && 3 !== i3) if (1 === r2 && 0 === i3) h3 = true;
                    else if (3 !== r2 || 1 !== i3 || !n3 && c2) {
                      if (a4 && 3 === r2 && 0 === i3) {
                        h3 = true;
                        let a5 = true;
                        if (e6 < o2 - 1) {
                          const e7 = t4.peekBytes(2);
                          int16(e7[0], e7[1]) < r2 && (a5 = false);
                        }
                        a5 && (l4 = true);
                      }
                    } else {
                      h3 = true;
                      a4 || (l4 = true);
                    }
                    else h3 = true;
                    h3 && (c2 = { platformId: r2, encodingId: i3, offset: s5 });
                    if (l4) break;
                  }
                }
                c2 && (t4.pos = s4 + c2.offset);
                if (!c2 || -1 === t4.peekByte()) {
                  (0, r.warn)("Could not find a preferred cmap table.");
                  return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                }
                const h2 = t4.getUint16();
                let u3 = false;
                const d4 = [];
                let f3, g2;
                if (0 === h2) {
                  t4.skip(4);
                  for (f3 = 0; f3 < 256; f3++) {
                    const e6 = t4.getByte();
                    e6 && d4.push({ charCode: f3, glyphId: e6 });
                  }
                  u3 = true;
                } else if (2 === h2) {
                  t4.skip(4);
                  const e6 = [];
                  let a5 = 0;
                  for (let r3 = 0; r3 < 256; r3++) {
                    const r4 = t4.getUint16() >> 3;
                    e6.push(r4);
                    a5 = Math.max(r4, a5);
                  }
                  const r2 = [];
                  for (let e7 = 0; e7 <= a5; e7++) r2.push({ firstCode: t4.getUint16(), entryCount: t4.getUint16(), idDelta: signedInt16(t4.getByte(), t4.getByte()), idRangePos: t4.pos + t4.getUint16() });
                  for (let a6 = 0; a6 < 256; a6++) if (0 === e6[a6]) {
                    t4.pos = r2[0].idRangePos + 2 * a6;
                    g2 = t4.getUint16();
                    d4.push({ charCode: a6, glyphId: g2 });
                  } else {
                    const n4 = r2[e6[a6]];
                    for (f3 = 0; f3 < n4.entryCount; f3++) {
                      const e7 = (a6 << 8) + f3 + n4.firstCode;
                      t4.pos = n4.idRangePos + 2 * f3;
                      g2 = t4.getUint16();
                      0 !== g2 && (g2 = (g2 + n4.idDelta) % 65536);
                      d4.push({ charCode: e7, glyphId: g2 });
                    }
                  }
                } else if (4 === h2) {
                  t4.skip(4);
                  const e6 = t4.getUint16() >> 1;
                  t4.skip(6);
                  const a5 = [];
                  let r2;
                  for (r2 = 0; r2 < e6; r2++) a5.push({ end: t4.getUint16() });
                  t4.skip(2);
                  for (r2 = 0; r2 < e6; r2++) a5[r2].start = t4.getUint16();
                  for (r2 = 0; r2 < e6; r2++) a5[r2].delta = t4.getUint16();
                  let n4, o3 = 0;
                  for (r2 = 0; r2 < e6; r2++) {
                    i2 = a5[r2];
                    const s5 = t4.getUint16();
                    if (s5) {
                      n4 = (s5 >> 1) - (e6 - r2);
                      i2.offsetIndex = n4;
                      o3 = Math.max(o3, n4 + i2.end - i2.start + 1);
                    } else i2.offsetIndex = -1;
                  }
                  const c3 = [];
                  for (f3 = 0; f3 < o3; f3++) c3.push(t4.getUint16());
                  for (r2 = 0; r2 < e6; r2++) {
                    i2 = a5[r2];
                    s4 = i2.start;
                    const e7 = i2.end, t5 = i2.delta;
                    n4 = i2.offsetIndex;
                    for (f3 = s4; f3 <= e7; f3++) if (65535 !== f3) {
                      g2 = n4 < 0 ? f3 : c3[n4 + f3 - s4];
                      g2 = g2 + t5 & 65535;
                      d4.push({ charCode: f3, glyphId: g2 });
                    }
                  }
                } else if (6 === h2) {
                  t4.skip(4);
                  const e6 = t4.getUint16(), a5 = t4.getUint16();
                  for (f3 = 0; f3 < a5; f3++) {
                    g2 = t4.getUint16();
                    const a6 = e6 + f3;
                    d4.push({ charCode: a6, glyphId: g2 });
                  }
                } else {
                  if (12 !== h2) {
                    (0, r.warn)("cmap table has unsupported format: " + h2);
                    return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
                  }
                  {
                    t4.skip(10);
                    const e6 = t4.getInt32() >>> 0;
                    for (f3 = 0; f3 < e6; f3++) {
                      const e7 = t4.getInt32() >>> 0, a5 = t4.getInt32() >>> 0;
                      let r2 = t4.getInt32() >>> 0;
                      for (let t5 = e7; t5 <= a5; t5++) d4.push({ charCode: t5, glyphId: r2++ });
                    }
                  }
                }
                d4.sort(function(e6, t5) {
                  return e6.charCode - t5.charCode;
                });
                for (let e6 = 1; e6 < d4.length; e6++) if (d4[e6 - 1].charCode === d4[e6].charCode) {
                  d4.splice(e6, 1);
                  e6--;
                }
                return { platformId: c2.platformId, encodingId: c2.encodingId, mappings: d4, hasShortCmap: u3 };
              }(f2.cmap, t3, this.isSymbolicFont, a3.hasEncoding), n2 = e4.platformId, s3 = e4.encodingId, l3 = e4.mappings;
              let u2 = [], d3 = false;
              !a3.hasEncoding || "MacRomanEncoding" !== a3.baseEncodingName && "WinAnsiEncoding" !== a3.baseEncodingName || (u2 = (0, c.getEncoding)(a3.baseEncodingName));
              if (a3.hasEncoding && !this.isSymbolicFont && (3 === n2 && 1 === s3 || 1 === n2 && 0 === s3)) {
                const e5 = (0, o.getGlyphsUnicode)();
                for (let t4 = 0; t4 < 256; t4++) {
                  let r2;
                  r2 = void 0 !== this.differences[t4] ? this.differences[t4] : u2.length && "" !== u2[t4] ? u2[t4] : c.StandardEncoding[t4];
                  if (!r2) continue;
                  const o2 = (0, i.recoverGlyphName)(r2, e5);
                  let d4;
                  3 === n2 && 1 === s3 ? d4 = e5[o2] : 1 === n2 && 0 === s3 && (d4 = c.MacRomanEncoding.indexOf(o2));
                  if (void 0 === d4) {
                    if (!a3.glyphNames && a3.hasIncludedToUnicodeMap && !(this.toUnicode instanceof h.IdentityToUnicodeMap)) {
                      const e6 = this.toUnicode.get(t4);
                      e6 && (d4 = e6.codePointAt(0));
                    }
                    if (void 0 === d4) continue;
                  }
                  for (const e6 of l3) if (e6.charCode === d4) {
                    E[t4] = e6.glyphId;
                    break;
                  }
                }
              } else if (0 === n2) {
                for (const e5 of l3) E[e5.charCode] = e5.glyphId;
                d3 = true;
              } else for (const e5 of l3) {
                let t4 = e5.charCode;
                3 === n2 && t4 >= 61440 && t4 <= 61695 && (t4 &= 255);
                E[t4] = e5.glyphId;
              }
              if (a3.glyphNames && (u2.length || this.differences.length)) for (let e5 = 0; e5 < 256; ++e5) {
                if (!d3 && void 0 !== E[e5]) continue;
                const t4 = this.differences[e5] || u2[e5];
                if (!t4) continue;
                const r2 = a3.glyphNames.indexOf(t4);
                r2 > 0 && hasGlyph(r2) && (E[e5] = r2);
              }
            }
            0 === E.length && (E[0] = 0);
            let N = k2 - 1;
            v || (N = 0);
            if (!a3.cssFontInfo) {
              const e4 = adjustMapping(E, hasGlyph, N, this.toUnicode);
              this.toFontChar = e4.toFontChar;
              f2.cmap = { tag: "cmap", data: createCmapTable(e4.charCodeToGlyphId, e4.toUnicodeExtraMap, k2) };
              f2["OS/2"] && function validateOS2Table(e5, t4) {
                t4.pos = (t4.start || 0) + e5.offset;
                const a4 = t4.getUint16();
                t4.skip(60);
                const r2 = t4.getUint16();
                if (a4 < 4 && 768 & r2) return false;
                if (t4.getUint16() > t4.getUint16()) return false;
                t4.skip(6);
                if (0 === t4.getUint16()) return false;
                e5.data[8] = e5.data[9] = 0;
                return true;
              }(f2["OS/2"], t3) || (f2["OS/2"] = { tag: "OS/2", data: createOS2Table(a3, e4.charCodeToGlyphId, D) });
            }
            if (!S2) try {
              w2 = new y.Stream(f2["CFF "].data);
              b2 = new n.CFFParser(w2, a3, i.SEAC_ANALYSIS_ENABLED).parse();
              b2.duplicateFirstGlyph();
              const e4 = new n.CFFCompiler(b2);
              f2["CFF "].data = e4.compile();
            } catch {
              (0, r.warn)("Failed to compile font " + a3.loadedName);
            }
            if (f2.name) {
              const [t4, r2] = readNameTable(f2.name);
              f2.name.data = createNameTable(e3, t4);
              this.psName = t4[0][6] || null;
              a3.composite || function adjustTrueTypeToUnicode(e4, t5, a4) {
                if (e4.isInternalFont) return;
                if (e4.hasIncludedToUnicodeMap) return;
                if (e4.hasEncoding) return;
                if (e4.toUnicode instanceof h.IdentityToUnicodeMap) return;
                if (!t5) return;
                if (0 === a4.length) return;
                if (e4.defaultEncoding === c.WinAnsiEncoding) return;
                for (const e5 of a4) if (!isWinNameRecord(e5)) return;
                const r3 = c.WinAnsiEncoding, n2 = [], i2 = (0, o.getGlyphsUnicode)();
                for (const e5 in r3) {
                  const t6 = r3[e5];
                  if ("" === t6) continue;
                  const a5 = i2[t6];
                  void 0 !== a5 && (n2[e5] = String.fromCharCode(a5));
                }
                n2.length > 0 && e4.toUnicode.amend(n2);
              }(a3, this.isSymbolicFont, r2);
            } else f2.name = { tag: "name", data: createNameTable(this.name) };
            const R = new m.OpenTypeFileBuilder(d2.version);
            for (const e4 in f2) R.addTable(e4, f2[e4].data);
            return R.toArray();
          }
          convert(e3, t3, a3) {
            a3.fixedPitch = false;
            a3.builtInEncoding && function adjustType1ToUnicode(e4, t4) {
              if (e4.isInternalFont) return;
              if (e4.hasIncludedToUnicodeMap) return;
              if (t4 === e4.defaultEncoding) return;
              if (e4.toUnicode instanceof h.IdentityToUnicodeMap) return;
              const a4 = [], r2 = (0, o.getGlyphsUnicode)();
              for (const n3 in t4) {
                if (e4.hasEncoding && (e4.baseEncodingName || void 0 !== e4.differences[n3])) continue;
                const i2 = t4[n3], o2 = (0, s.getUnicodeForGlyph)(i2, r2);
                -1 !== o2 && (a4[n3] = String.fromCharCode(o2));
              }
              a4.length > 0 && e4.toUnicode.amend(a4);
            }(a3, a3.builtInEncoding);
            let n2 = 1;
            t3 instanceof u.CFFFont && (n2 = t3.numGlyphs - 1);
            const l2 = t3.getGlyphMapping(a3);
            let d2 = null, f2 = l2, g2 = null;
            if (!a3.cssFontInfo) {
              d2 = adjustMapping(l2, t3.hasGlyphId.bind(t3), n2, this.toUnicode);
              this.toFontChar = d2.toFontChar;
              f2 = d2.charCodeToGlyphId;
              g2 = d2.toUnicodeExtraMap;
            }
            const p2 = t3.numGlyphs;
            function getCharCodes(e4, t4) {
              let a4 = null;
              for (const r2 in e4) t4 === e4[r2] && (a4 || (a4 = [])).push(0 | r2);
              return a4;
            }
            function createCharCode(e4, t4) {
              for (const a4 in e4) if (t4 === e4[a4]) return 0 | a4;
              d2.charCodeToGlyphId[d2.nextAvailableFontCharCode] = t4;
              return d2.nextAvailableFontCharCode++;
            }
            const b2 = t3.seacs;
            if (d2 && i.SEAC_ANALYSIS_ENABLED && (b2 == null ? void 0 : b2.length)) {
              const e4 = a3.fontMatrix || r.FONT_IDENTITY_MATRIX, n3 = t3.getCharset(), i2 = /* @__PURE__ */ Object.create(null);
              for (let t4 in b2) {
                t4 |= 0;
                const a4 = b2[t4], r2 = c.StandardEncoding[a4[2]], s2 = c.StandardEncoding[a4[3]], o2 = n3.indexOf(r2), h2 = n3.indexOf(s2);
                if (o2 < 0 || h2 < 0) continue;
                const u2 = { x: a4[0] * e4[0] + a4[1] * e4[2] + e4[4], y: a4[0] * e4[1] + a4[1] * e4[3] + e4[5] }, f3 = getCharCodes(l2, t4);
                if (f3) for (const e5 of f3) {
                  const t5 = d2.charCodeToGlyphId, a5 = createCharCode(t5, o2), r3 = createCharCode(t5, h2);
                  i2[e5] = { baseFontCharCode: a5, accentFontCharCode: r3, accentOffset: u2 };
                }
              }
              a3.seacMap = i2;
            }
            const y2 = 1 / (a3.fontMatrix || r.FONT_IDENTITY_MATRIX)[0], w2 = new m.OpenTypeFileBuilder("OTTO");
            w2.addTable("CFF ", t3.data);
            w2.addTable("OS/2", createOS2Table(a3, f2));
            w2.addTable("cmap", createCmapTable(f2, g2, p2));
            w2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(y2) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(a3.descent) + "ÿ" + safeString16(a3.ascent) + string16(a3.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
            w2.addTable("hhea", "\0\0\0" + safeString16(a3.ascent) + safeString16(a3.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(a3.capHeight) + safeString16(Math.tan(a3.italicAngle) * a3.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(p2));
            w2.addTable("hmtx", function fontFieldsHmtx() {
              const e4 = t3.charstrings, a4 = t3.cff ? t3.cff.widths : null;
              let r2 = "\0\0\0\0";
              for (let t4 = 1, n3 = p2; t4 < n3; t4++) {
                let n4 = 0;
                if (e4) {
                  const a5 = e4[t4 - 1];
                  n4 = "width" in a5 ? a5.width : 0;
                } else a4 && (n4 = Math.ceil(a4[t4] || 0));
                r2 += string16(n4) + string16(0);
              }
              return r2;
            }());
            w2.addTable("maxp", "\0\0P\0" + string16(p2));
            w2.addTable("name", createNameTable(e3));
            w2.addTable("post", createPostTable(a3));
            return w2.toArray();
          }
          get spaceWidth() {
            const e3 = ["space", "minus", "one", "i", "I"];
            let t3;
            for (const a3 of e3) {
              if (a3 in this.widths) {
                t3 = this.widths[a3];
                break;
              }
              const e4 = (0, o.getGlyphsUnicode)()[a3];
              let r2 = 0;
              if (this.composite && this.cMap.contains(e4)) {
                r2 = this.cMap.lookup(e4);
                "string" == typeof r2 && (r2 = convertCidString(e4, r2));
              }
              !r2 && this.toUnicode && (r2 = this.toUnicode.charCodeOf(e4));
              r2 <= 0 && (r2 = e4);
              t3 = this.widths[r2];
              if (t3) break;
            }
            return (0, r.shadow)(this, "spaceWidth", t3 || this.defaultWidth);
          }
          _charToGlyph(e3, t3 = false) {
            var _a, _b, _c;
            let a3, n2, i2, o2 = this._glyphCache[e3];
            if ((o2 == null ? void 0 : o2.isSpace) === t3) return o2;
            let c2 = e3;
            if ((_a = this.cMap) == null ? void 0 : _a.contains(e3)) {
              c2 = this.cMap.lookup(e3);
              "string" == typeof c2 && (c2 = convertCidString(e3, c2));
            }
            n2 = this.widths[c2];
            "number" != typeof n2 && (n2 = this.defaultWidth);
            const l2 = (_b = this.vmetrics) == null ? void 0 : _b[c2];
            let h2 = this.toUnicode.get(e3) || e3;
            "number" == typeof h2 && (h2 = String.fromCharCode(h2));
            let u2 = void 0 !== this.toFontChar[e3];
            a3 = this.toFontChar[e3] || e3;
            if (this.missingFile) {
              const t4 = this.differences[e3] || this.defaultEncoding[e3];
              ".notdef" !== t4 && "" !== t4 || "Type1" !== this.type || (a3 = 32);
              a3 = (0, s.mapSpecialUnicodeValues)(a3);
            }
            this.isType3Font && (i2 = a3);
            let d2 = null;
            if ((_c = this.seacMap) == null ? void 0 : _c[e3]) {
              u2 = true;
              const t4 = this.seacMap[e3];
              a3 = t4.baseFontCharCode;
              d2 = { fontChar: String.fromCodePoint(t4.accentFontCharCode), offset: t4.accentOffset };
            }
            let f2 = "";
            "number" == typeof a3 && (a3 <= 1114111 ? f2 = String.fromCodePoint(a3) : (0, r.warn)(`charToGlyph - invalid fontCharCode: ${a3}`));
            o2 = new Glyph(e3, f2, h2, d2, n2, l2, i2, t3, u2);
            return this._glyphCache[e3] = o2;
          }
          charsToGlyphs(e3) {
            let t3 = this._charsCache[e3];
            if (t3) return t3;
            t3 = [];
            if (this.cMap) {
              const a3 = /* @__PURE__ */ Object.create(null), r2 = e3.length;
              let n2 = 0;
              for (; n2 < r2; ) {
                this.cMap.readCharCode(e3, n2, a3);
                const { charcode: r3, length: i2 } = a3;
                n2 += i2;
                const s2 = this._charToGlyph(r3, 1 === i2 && 32 === e3.charCodeAt(n2 - 1));
                t3.push(s2);
              }
            } else for (let a3 = 0, r2 = e3.length; a3 < r2; ++a3) {
              const r3 = e3.charCodeAt(a3), n2 = this._charToGlyph(r3, 32 === r3);
              t3.push(n2);
            }
            return this._charsCache[e3] = t3;
          }
          getCharPositions(e3) {
            const t3 = [];
            if (this.cMap) {
              const a3 = /* @__PURE__ */ Object.create(null);
              let r2 = 0;
              for (; r2 < e3.length; ) {
                this.cMap.readCharCode(e3, r2, a3);
                const n2 = a3.length;
                t3.push([r2, r2 + n2]);
                r2 += n2;
              }
            } else for (let a3 = 0, r2 = e3.length; a3 < r2; ++a3) t3.push([a3, a3 + 1]);
            return t3;
          }
          get glyphCacheValues() {
            return Object.values(this._glyphCache);
          }
          encodeString(e3) {
            const t3 = [], a3 = [], hasCurrentBufErrors = () => t3.length % 2 == 1, r2 = this.toUnicode instanceof h.IdentityToUnicodeMap ? (e4) => this.toUnicode.charCodeOf(e4) : (e4) => this.toUnicode.charCodeOf(String.fromCodePoint(e4));
            for (let n2 = 0, i2 = e3.length; n2 < i2; n2++) {
              const i3 = e3.codePointAt(n2);
              i3 > 55295 && (i3 < 57344 || i3 > 65533) && n2++;
              if (this.toUnicode) {
                const e4 = r2(i3);
                if (-1 !== e4) {
                  if (hasCurrentBufErrors()) {
                    t3.push(a3.join(""));
                    a3.length = 0;
                  }
                  for (let t4 = (this.cMap ? this.cMap.getCharCodeLength(e4) : 1) - 1; t4 >= 0; t4--) a3.push(String.fromCharCode(e4 >> 8 * t4 & 255));
                  continue;
                }
              }
              if (!hasCurrentBufErrors()) {
                t3.push(a3.join(""));
                a3.length = 0;
              }
              a3.push(String.fromCodePoint(i3));
            }
            t3.push(a3.join(""));
            return t3;
          }
        };
        t2.ErrorFont = class ErrorFont {
          constructor(e3) {
            this.error = e3;
            this.loadedName = "g_font_error";
            this.missingFile = true;
          }
          charsToGlyphs() {
            return [];
          }
          encodeString(e3) {
            return [e3];
          }
          exportData(e3 = false) {
            return { error: this.error };
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.CFFTopDict = t2.CFFStrings = t2.CFFStandardStrings = t2.CFFPrivateDict = t2.CFFParser = t2.CFFIndex = t2.CFFHeader = t2.CFFFDSelect = t2.CFFCompiler = t2.CFFCharset = t2.CFF = void 0;
        var r = a2(2), n = a2(36), i = a2(37);
        const s = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
        t2.CFFStandardStrings = s;
        const o = 391, c = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }], l = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e3, t3) {
          e3[t3 - 2] = e3[t3 - 2] + e3[t3 - 1];
        } }, { id: "sub", min: 2, stackDelta: -1, stackFn(e3, t3) {
          e3[t3 - 2] = e3[t3 - 2] - e3[t3 - 1];
        } }, { id: "div", min: 2, stackDelta: -1, stackFn(e3, t3) {
          e3[t3 - 2] = e3[t3 - 2] / e3[t3 - 1];
        } }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e3, t3) {
          e3[t3 - 1] = -e3[t3 - 1];
        } }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e3, t3) {
          e3[t3 - 2] = e3[t3 - 2] * e3[t3 - 1];
        } }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
        t2.CFFParser = class CFFParser {
          constructor(e3, t3, a3) {
            this.bytes = e3.getBytes();
            this.properties = t3;
            this.seacAnalysisEnabled = !!a3;
          }
          parse() {
            const e3 = this.properties, t3 = new CFF();
            this.cff = t3;
            const a3 = this.parseHeader(), r2 = this.parseIndex(a3.endPos), n2 = this.parseIndex(r2.endPos), i2 = this.parseIndex(n2.endPos), s2 = this.parseIndex(i2.endPos), o2 = this.parseDict(n2.obj.get(0)), c2 = this.createDict(CFFTopDict, o2, t3.strings);
            t3.header = a3.obj;
            t3.names = this.parseNameIndex(r2.obj);
            t3.strings = this.parseStringIndex(i2.obj);
            t3.topDict = c2;
            t3.globalSubrIndex = s2.obj;
            this.parsePrivateDict(t3.topDict);
            t3.isCIDFont = c2.hasName("ROS");
            const l2 = c2.getByName("CharStrings"), h2 = this.parseIndex(l2).obj, u2 = c2.getByName("FontMatrix");
            u2 && (e3.fontMatrix = u2);
            const d2 = c2.getByName("FontBBox");
            if (d2) {
              e3.ascent = Math.max(d2[3], d2[1]);
              e3.descent = Math.min(d2[1], d2[3]);
              e3.ascentScaled = true;
            }
            let f, g;
            if (t3.isCIDFont) {
              const e4 = this.parseIndex(c2.getByName("FDArray")).obj;
              for (let a4 = 0, r3 = e4.count; a4 < r3; ++a4) {
                const r4 = e4.get(a4), n3 = this.createDict(CFFTopDict, this.parseDict(r4), t3.strings);
                this.parsePrivateDict(n3);
                t3.fdArray.push(n3);
              }
              g = null;
              f = this.parseCharsets(c2.getByName("charset"), h2.count, t3.strings, true);
              t3.fdSelect = this.parseFDSelect(c2.getByName("FDSelect"), h2.count);
            } else {
              f = this.parseCharsets(c2.getByName("charset"), h2.count, t3.strings, false);
              g = this.parseEncoding(c2.getByName("Encoding"), e3, t3.strings, f.charset);
            }
            t3.charset = f;
            t3.encoding = g;
            const p = this.parseCharStrings({ charStrings: h2, localSubrIndex: c2.privateDict.subrsIndex, globalSubrIndex: s2.obj, fdSelect: t3.fdSelect, fdArray: t3.fdArray, privateDict: c2.privateDict });
            t3.charStrings = p.charStrings;
            t3.seacs = p.seacs;
            t3.widths = p.widths;
            return t3;
          }
          parseHeader() {
            let e3 = this.bytes;
            const t3 = e3.length;
            let a3 = 0;
            for (; a3 < t3 && 1 !== e3[a3]; ) ++a3;
            if (a3 >= t3) throw new r.FormatError("Invalid CFF header");
            if (0 !== a3) {
              (0, r.info)("cff data is shifted");
              e3 = e3.subarray(a3);
              this.bytes = e3;
            }
            const n2 = e3[0], i2 = e3[1], s2 = e3[2], o2 = e3[3];
            return { obj: new CFFHeader(n2, i2, s2, o2), endPos: s2 };
          }
          parseDict(e3) {
            let t3 = 0;
            function parseOperand() {
              let a4 = e3[t3++];
              if (30 === a4) return function parseFloatOperand() {
                let a5 = "";
                const r2 = 15, n3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], i3 = e3.length;
                for (; t3 < i3; ) {
                  const i4 = e3[t3++], s2 = i4 >> 4, o2 = 15 & i4;
                  if (s2 === r2) break;
                  a5 += n3[s2];
                  if (o2 === r2) break;
                  a5 += n3[o2];
                }
                return parseFloat(a5);
              }();
              if (28 === a4) {
                a4 = e3[t3++];
                a4 = (a4 << 24 | e3[t3++] << 16) >> 16;
                return a4;
              }
              if (29 === a4) {
                a4 = e3[t3++];
                a4 = a4 << 8 | e3[t3++];
                a4 = a4 << 8 | e3[t3++];
                a4 = a4 << 8 | e3[t3++];
                return a4;
              }
              if (a4 >= 32 && a4 <= 246) return a4 - 139;
              if (a4 >= 247 && a4 <= 250) return 256 * (a4 - 247) + e3[t3++] + 108;
              if (a4 >= 251 && a4 <= 254) return -256 * (a4 - 251) - e3[t3++] - 108;
              (0, r.warn)('CFFParser_parseDict: "' + a4 + '" is a reserved command.');
              return NaN;
            }
            let a3 = [];
            const n2 = [];
            t3 = 0;
            const i2 = e3.length;
            for (; t3 < i2; ) {
              let r2 = e3[t3];
              if (r2 <= 21) {
                12 === r2 && (r2 = r2 << 8 | e3[++t3]);
                n2.push([r2, a3]);
                a3 = [];
                ++t3;
              } else a3.push(parseOperand());
            }
            return n2;
          }
          parseIndex(e3) {
            const t3 = new CFFIndex(), a3 = this.bytes, r2 = a3[e3++] << 8 | a3[e3++], n2 = [];
            let i2, s2, o2 = e3;
            if (0 !== r2) {
              const t4 = a3[e3++], c2 = e3 + (r2 + 1) * t4 - 1;
              for (i2 = 0, s2 = r2 + 1; i2 < s2; ++i2) {
                let r3 = 0;
                for (let n3 = 0; n3 < t4; ++n3) {
                  r3 <<= 8;
                  r3 += a3[e3++];
                }
                n2.push(c2 + r3);
              }
              o2 = n2[r2];
            }
            for (i2 = 0, s2 = n2.length - 1; i2 < s2; ++i2) {
              const e4 = n2[i2], r3 = n2[i2 + 1];
              t3.add(a3.subarray(e4, r3));
            }
            return { obj: t3, endPos: o2 };
          }
          parseNameIndex(e3) {
            const t3 = [];
            for (let a3 = 0, n2 = e3.count; a3 < n2; ++a3) {
              const n3 = e3.get(a3);
              t3.push((0, r.bytesToString)(n3));
            }
            return t3;
          }
          parseStringIndex(e3) {
            const t3 = new CFFStrings();
            for (let a3 = 0, n2 = e3.count; a3 < n2; ++a3) {
              const n3 = e3.get(a3);
              t3.add((0, r.bytesToString)(n3));
            }
            return t3;
          }
          createDict(e3, t3, a3) {
            const r2 = new e3(a3);
            for (const [e4, a4] of t3) r2.setByKey(e4, a4);
            return r2;
          }
          parseCharString(e3, t3, a3, n2) {
            if (!t3 || e3.callDepth > 10) return false;
            let i2 = e3.stackSize;
            const s2 = e3.stack;
            let o2 = t3.length;
            for (let h2 = 0; h2 < o2; ) {
              const u2 = t3[h2++];
              let d2 = null;
              if (12 === u2) {
                const e4 = t3[h2++];
                if (0 === e4) {
                  t3[h2 - 2] = 139;
                  t3[h2 - 1] = 22;
                  i2 = 0;
                } else d2 = l[e4];
              } else if (28 === u2) {
                s2[i2] = (t3[h2] << 24 | t3[h2 + 1] << 16) >> 16;
                h2 += 2;
                i2++;
              } else if (14 === u2) {
                if (i2 >= 4) {
                  i2 -= 4;
                  if (this.seacAnalysisEnabled) {
                    e3.seac = s2.slice(i2, i2 + 4);
                    return false;
                  }
                }
                d2 = c[u2];
              } else if (u2 >= 32 && u2 <= 246) {
                s2[i2] = u2 - 139;
                i2++;
              } else if (u2 >= 247 && u2 <= 254) {
                s2[i2] = u2 < 251 ? (u2 - 247 << 8) + t3[h2] + 108 : -(u2 - 251 << 8) - t3[h2] - 108;
                h2++;
                i2++;
              } else if (255 === u2) {
                s2[i2] = (t3[h2] << 24 | t3[h2 + 1] << 16 | t3[h2 + 2] << 8 | t3[h2 + 3]) / 65536;
                h2 += 4;
                i2++;
              } else if (19 === u2 || 20 === u2) {
                e3.hints += i2 >> 1;
                if (0 === e3.hints) {
                  t3.copyWithin(h2 - 1, h2, -1);
                  h2 -= 1;
                  o2 -= 1;
                  continue;
                }
                h2 += e3.hints + 7 >> 3;
                i2 %= 2;
                d2 = c[u2];
              } else {
                if (10 === u2 || 29 === u2) {
                  const t4 = 10 === u2 ? a3 : n2;
                  if (!t4) {
                    d2 = c[u2];
                    (0, r.warn)("Missing subrsIndex for " + d2.id);
                    return false;
                  }
                  let o3 = 32768;
                  t4.count < 1240 ? o3 = 107 : t4.count < 33900 && (o3 = 1131);
                  const l2 = s2[--i2] + o3;
                  if (l2 < 0 || l2 >= t4.count || isNaN(l2)) {
                    d2 = c[u2];
                    (0, r.warn)("Out of bounds subrIndex for " + d2.id);
                    return false;
                  }
                  e3.stackSize = i2;
                  e3.callDepth++;
                  if (!this.parseCharString(e3, t4.get(l2), a3, n2)) return false;
                  e3.callDepth--;
                  i2 = e3.stackSize;
                  continue;
                }
                if (11 === u2) {
                  e3.stackSize = i2;
                  return true;
                }
                if (0 === u2 && h2 === t3.length) {
                  t3[h2 - 1] = 14;
                  d2 = c[14];
                } else {
                  if (9 === u2) {
                    t3.copyWithin(h2 - 1, h2, -1);
                    h2 -= 1;
                    o2 -= 1;
                    continue;
                  }
                  d2 = c[u2];
                }
              }
              if (d2) {
                if (d2.stem) {
                  e3.hints += i2 >> 1;
                  if (3 === u2 || 23 === u2) e3.hasVStems = true;
                  else if (e3.hasVStems && (1 === u2 || 18 === u2)) {
                    (0, r.warn)("CFF stem hints are in wrong order");
                    t3[h2 - 1] = 1 === u2 ? 3 : 23;
                  }
                }
                if ("min" in d2 && !e3.undefStack && i2 < d2.min) {
                  (0, r.warn)("Not enough parameters for " + d2.id + "; actual: " + i2 + ", expected: " + d2.min);
                  if (0 === i2) {
                    t3[h2 - 1] = 14;
                    return true;
                  }
                  return false;
                }
                if (e3.firstStackClearing && d2.stackClearing) {
                  e3.firstStackClearing = false;
                  i2 -= d2.min;
                  i2 >= 2 && d2.stem ? i2 %= 2 : i2 > 1 && (0, r.warn)("Found too many parameters for stack-clearing command");
                  i2 > 0 && (e3.width = s2[i2 - 1]);
                }
                if ("stackDelta" in d2) {
                  "stackFn" in d2 && d2.stackFn(s2, i2);
                  i2 += d2.stackDelta;
                } else if (d2.stackClearing) i2 = 0;
                else if (d2.resetStack) {
                  i2 = 0;
                  e3.undefStack = false;
                } else if (d2.undefStack) {
                  i2 = 0;
                  e3.undefStack = true;
                  e3.firstStackClearing = false;
                }
              }
            }
            o2 < t3.length && t3.fill(14, o2);
            e3.stackSize = i2;
            return true;
          }
          parseCharStrings({ charStrings: e3, localSubrIndex: t3, globalSubrIndex: a3, fdSelect: n2, fdArray: i2, privateDict: s2 }) {
            const o2 = [], c2 = [], l2 = e3.count;
            for (let h2 = 0; h2 < l2; h2++) {
              const l3 = e3.get(h2), u2 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
              let d2 = true, f = null, g = s2;
              if (n2 && i2.length) {
                const e4 = n2.getFDIndex(h2);
                if (-1 === e4) {
                  (0, r.warn)("Glyph index is not in fd select.");
                  d2 = false;
                }
                if (e4 >= i2.length) {
                  (0, r.warn)("Invalid fd index for glyph index.");
                  d2 = false;
                }
                if (d2) {
                  g = i2[e4].privateDict;
                  f = g.subrsIndex;
                }
              } else t3 && (f = t3);
              d2 && (d2 = this.parseCharString(u2, l3, f, a3));
              if (null !== u2.width) {
                const e4 = g.getByName("nominalWidthX");
                c2[h2] = e4 + u2.width;
              } else {
                const e4 = g.getByName("defaultWidthX");
                c2[h2] = e4;
              }
              null !== u2.seac && (o2[h2] = u2.seac);
              d2 || e3.set(h2, new Uint8Array([14]));
            }
            return { charStrings: e3, seacs: o2, widths: c2 };
          }
          emptyPrivateDictionary(e3) {
            const t3 = this.createDict(CFFPrivateDict, [], e3.strings);
            e3.setByKey(18, [0, 0]);
            e3.privateDict = t3;
          }
          parsePrivateDict(e3) {
            if (!e3.hasName("Private")) {
              this.emptyPrivateDictionary(e3);
              return;
            }
            const t3 = e3.getByName("Private");
            if (!Array.isArray(t3) || 2 !== t3.length) {
              e3.removeByName("Private");
              return;
            }
            const a3 = t3[0], r2 = t3[1];
            if (0 === a3 || r2 >= this.bytes.length) {
              this.emptyPrivateDictionary(e3);
              return;
            }
            const n2 = r2 + a3, i2 = this.bytes.subarray(r2, n2), s2 = this.parseDict(i2), o2 = this.createDict(CFFPrivateDict, s2, e3.strings);
            e3.privateDict = o2;
            0 === o2.getByName("ExpansionFactor") && o2.setByName("ExpansionFactor", 0.06);
            if (!o2.getByName("Subrs")) return;
            const c2 = o2.getByName("Subrs"), l2 = r2 + c2;
            if (0 === c2 || l2 >= this.bytes.length) {
              this.emptyPrivateDictionary(e3);
              return;
            }
            const h2 = this.parseIndex(l2);
            o2.subrsIndex = h2.obj;
          }
          parseCharsets(e3, t3, a3, i2) {
            if (0 === e3) return new CFFCharset(true, d.ISO_ADOBE, n.ISOAdobeCharset);
            if (1 === e3) return new CFFCharset(true, d.EXPERT, n.ExpertCharset);
            if (2 === e3) return new CFFCharset(true, d.EXPERT_SUBSET, n.ExpertSubsetCharset);
            const s2 = this.bytes, o2 = e3, c2 = s2[e3++], l2 = [i2 ? 0 : ".notdef"];
            let h2, u2, f;
            t3 -= 1;
            switch (c2) {
              case 0:
                for (f = 0; f < t3; f++) {
                  h2 = s2[e3++] << 8 | s2[e3++];
                  l2.push(i2 ? h2 : a3.get(h2));
                }
                break;
              case 1:
                for (; l2.length <= t3; ) {
                  h2 = s2[e3++] << 8 | s2[e3++];
                  u2 = s2[e3++];
                  for (f = 0; f <= u2; f++) l2.push(i2 ? h2++ : a3.get(h2++));
                }
                break;
              case 2:
                for (; l2.length <= t3; ) {
                  h2 = s2[e3++] << 8 | s2[e3++];
                  u2 = s2[e3++] << 8 | s2[e3++];
                  for (f = 0; f <= u2; f++) l2.push(i2 ? h2++ : a3.get(h2++));
                }
                break;
              default:
                throw new r.FormatError("Unknown charset format");
            }
            const g = e3, p = s2.subarray(o2, g);
            return new CFFCharset(false, c2, l2, p);
          }
          parseEncoding(e3, t3, a3, n2) {
            const s2 = /* @__PURE__ */ Object.create(null), o2 = this.bytes;
            let c2, l2, h2, u2 = false, d2 = null;
            if (0 === e3 || 1 === e3) {
              u2 = true;
              c2 = e3;
              const t4 = e3 ? i.ExpertEncoding : i.StandardEncoding;
              for (l2 = 0, h2 = n2.length; l2 < h2; l2++) {
                const e4 = t4.indexOf(n2[l2]);
                -1 !== e4 && (s2[e4] = l2);
              }
            } else {
              const t4 = e3;
              c2 = o2[e3++];
              switch (127 & c2) {
                case 0:
                  const t5 = o2[e3++];
                  for (l2 = 1; l2 <= t5; l2++) s2[o2[e3++]] = l2;
                  break;
                case 1:
                  const a4 = o2[e3++];
                  let n3 = 1;
                  for (l2 = 0; l2 < a4; l2++) {
                    const t6 = o2[e3++], a5 = o2[e3++];
                    for (let e4 = t6; e4 <= t6 + a5; e4++) s2[e4] = n3++;
                  }
                  break;
                default:
                  throw new r.FormatError(`Unknown encoding format: ${c2} in CFF`);
              }
              const i2 = e3;
              if (128 & c2) {
                o2[t4] &= 127;
                !function readSupplement() {
                  const t5 = o2[e3++];
                  for (l2 = 0; l2 < t5; l2++) {
                    const t6 = o2[e3++], r2 = (o2[e3++] << 8) + (255 & o2[e3++]);
                    s2[t6] = n2.indexOf(a3.get(r2));
                  }
                }();
              }
              d2 = o2.subarray(t4, i2);
            }
            c2 &= 127;
            return new CFFEncoding(u2, c2, s2, d2);
          }
          parseFDSelect(e3, t3) {
            const a3 = this.bytes, n2 = a3[e3++], i2 = [];
            let s2;
            switch (n2) {
              case 0:
                for (s2 = 0; s2 < t3; ++s2) {
                  const t4 = a3[e3++];
                  i2.push(t4);
                }
                break;
              case 3:
                const o2 = a3[e3++] << 8 | a3[e3++];
                for (s2 = 0; s2 < o2; ++s2) {
                  let t4 = a3[e3++] << 8 | a3[e3++];
                  if (0 === s2 && 0 !== t4) {
                    (0, r.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
                    t4 = 0;
                  }
                  const n3 = a3[e3++], o3 = a3[e3] << 8 | a3[e3 + 1];
                  for (let e4 = t4; e4 < o3; ++e4) i2.push(n3);
                }
                e3 += 2;
                break;
              default:
                throw new r.FormatError(`parseFDSelect: Unknown format "${n2}".`);
            }
            if (i2.length !== t3) throw new r.FormatError("parseFDSelect: Invalid font data.");
            return new CFFFDSelect(n2, i2);
          }
        };
        class CFF {
          constructor() {
            this.header = null;
            this.names = [];
            this.topDict = null;
            this.strings = new CFFStrings();
            this.globalSubrIndex = null;
            this.encoding = null;
            this.charset = null;
            this.charStrings = null;
            this.fdArray = [];
            this.fdSelect = null;
            this.isCIDFont = false;
          }
          duplicateFirstGlyph() {
            if (this.charStrings.count >= 65535) {
              (0, r.warn)("Not enough space in charstrings to duplicate first glyph.");
              return;
            }
            const e3 = this.charStrings.get(0);
            this.charStrings.add(e3);
            this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
          }
          hasGlyphId(e3) {
            if (e3 < 0 || e3 >= this.charStrings.count) return false;
            return this.charStrings.get(e3).length > 0;
          }
        }
        t2.CFF = CFF;
        class CFFHeader {
          constructor(e3, t3, a3, r2) {
            this.major = e3;
            this.minor = t3;
            this.hdrSize = a3;
            this.offSize = r2;
          }
        }
        t2.CFFHeader = CFFHeader;
        class CFFStrings {
          constructor() {
            this.strings = [];
          }
          get(e3) {
            return e3 >= 0 && e3 <= 390 ? s[e3] : e3 - o <= this.strings.length ? this.strings[e3 - o] : s[0];
          }
          getSID(e3) {
            let t3 = s.indexOf(e3);
            if (-1 !== t3) return t3;
            t3 = this.strings.indexOf(e3);
            return -1 !== t3 ? t3 + o : -1;
          }
          add(e3) {
            this.strings.push(e3);
          }
          get count() {
            return this.strings.length;
          }
        }
        t2.CFFStrings = CFFStrings;
        class CFFIndex {
          constructor() {
            this.objects = [];
            this.length = 0;
          }
          add(e3) {
            this.length += e3.length;
            this.objects.push(e3);
          }
          set(e3, t3) {
            this.length += t3.length - this.objects[e3].length;
            this.objects[e3] = t3;
          }
          get(e3) {
            return this.objects[e3];
          }
          get count() {
            return this.objects.length;
          }
        }
        t2.CFFIndex = CFFIndex;
        class CFFDict {
          constructor(e3, t3) {
            this.keyToNameMap = e3.keyToNameMap;
            this.nameToKeyMap = e3.nameToKeyMap;
            this.defaults = e3.defaults;
            this.types = e3.types;
            this.opcodes = e3.opcodes;
            this.order = e3.order;
            this.strings = t3;
            this.values = /* @__PURE__ */ Object.create(null);
          }
          setByKey(e3, t3) {
            if (!(e3 in this.keyToNameMap)) return false;
            if (0 === t3.length) return true;
            for (const a4 of t3) if (isNaN(a4)) {
              (0, r.warn)(`Invalid CFFDict value: "${t3}" for key "${e3}".`);
              return true;
            }
            const a3 = this.types[e3];
            "num" !== a3 && "sid" !== a3 && "offset" !== a3 || (t3 = t3[0]);
            this.values[e3] = t3;
            return true;
          }
          setByName(e3, t3) {
            if (!(e3 in this.nameToKeyMap)) throw new r.FormatError(`Invalid dictionary name "${e3}"`);
            this.values[this.nameToKeyMap[e3]] = t3;
          }
          hasName(e3) {
            return this.nameToKeyMap[e3] in this.values;
          }
          getByName(e3) {
            if (!(e3 in this.nameToKeyMap)) throw new r.FormatError(`Invalid dictionary name ${e3}"`);
            const t3 = this.nameToKeyMap[e3];
            return t3 in this.values ? this.values[t3] : this.defaults[t3];
          }
          removeByName(e3) {
            delete this.values[this.nameToKeyMap[e3]];
          }
          static createTables(e3) {
            const t3 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
            for (const a3 of e3) {
              const e4 = Array.isArray(a3[0]) ? (a3[0][0] << 8) + a3[0][1] : a3[0];
              t3.keyToNameMap[e4] = a3[1];
              t3.nameToKeyMap[a3[1]] = e4;
              t3.types[e4] = a3[2];
              t3.defaults[e4] = a3[3];
              t3.opcodes[e4] = Array.isArray(a3[0]) ? a3[0] : [a3[0]];
              t3.order.push(e4);
            }
            return t3;
          }
        }
        const h = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
        class CFFTopDict extends CFFDict {
          static get tables() {
            return (0, r.shadow)(this, "tables", this.createTables(h));
          }
          constructor(e3) {
            super(CFFTopDict.tables, e3);
            this.privateDict = null;
          }
        }
        t2.CFFTopDict = CFFTopDict;
        const u = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
        class CFFPrivateDict extends CFFDict {
          static get tables() {
            return (0, r.shadow)(this, "tables", this.createTables(u));
          }
          constructor(e3) {
            super(CFFPrivateDict.tables, e3);
            this.subrsIndex = null;
          }
        }
        t2.CFFPrivateDict = CFFPrivateDict;
        const d = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
        class CFFCharset {
          constructor(e3, t3, a3, r2) {
            this.predefined = e3;
            this.format = t3;
            this.charset = a3;
            this.raw = r2;
          }
        }
        t2.CFFCharset = CFFCharset;
        class CFFEncoding {
          constructor(e3, t3, a3, r2) {
            this.predefined = e3;
            this.format = t3;
            this.encoding = a3;
            this.raw = r2;
          }
        }
        class CFFFDSelect {
          constructor(e3, t3) {
            this.format = e3;
            this.fdSelect = t3;
          }
          getFDIndex(e3) {
            return e3 < 0 || e3 >= this.fdSelect.length ? -1 : this.fdSelect[e3];
          }
        }
        t2.CFFFDSelect = CFFFDSelect;
        class CFFOffsetTracker {
          constructor() {
            this.offsets = /* @__PURE__ */ Object.create(null);
          }
          isTracking(e3) {
            return e3 in this.offsets;
          }
          track(e3, t3) {
            if (e3 in this.offsets) throw new r.FormatError(`Already tracking location of ${e3}`);
            this.offsets[e3] = t3;
          }
          offset(e3) {
            for (const t3 in this.offsets) this.offsets[t3] += e3;
          }
          setEntryLocation(e3, t3, a3) {
            if (!(e3 in this.offsets)) throw new r.FormatError(`Not tracking location of ${e3}`);
            const n2 = a3.data, i2 = this.offsets[e3];
            for (let e4 = 0, a4 = t3.length; e4 < a4; ++e4) {
              const a5 = 5 * e4 + i2, s2 = a5 + 1, o2 = a5 + 2, c2 = a5 + 3, l2 = a5 + 4;
              if (29 !== n2[a5] || 0 !== n2[s2] || 0 !== n2[o2] || 0 !== n2[c2] || 0 !== n2[l2]) throw new r.FormatError("writing to an offset that is not empty");
              const h2 = t3[e4];
              n2[a5] = 29;
              n2[s2] = h2 >> 24 & 255;
              n2[o2] = h2 >> 16 & 255;
              n2[c2] = h2 >> 8 & 255;
              n2[l2] = 255 & h2;
            }
          }
        }
        class CFFCompiler {
          constructor(e3) {
            this.cff = e3;
          }
          compile() {
            const e3 = this.cff, t3 = { data: [], length: 0, add(e4) {
              try {
                this.data.push(...e4);
              } catch {
                this.data = this.data.concat(e4);
              }
              this.length = this.data.length;
            } }, a3 = this.compileHeader(e3.header);
            t3.add(a3);
            const n2 = this.compileNameIndex(e3.names);
            t3.add(n2);
            if (e3.isCIDFont && e3.topDict.hasName("FontMatrix")) {
              const t4 = e3.topDict.getByName("FontMatrix");
              e3.topDict.removeByName("FontMatrix");
              for (const a4 of e3.fdArray) {
                let e4 = t4.slice(0);
                a4.hasName("FontMatrix") && (e4 = r.Util.transform(e4, a4.getByName("FontMatrix")));
                a4.setByName("FontMatrix", e4);
              }
            }
            const i2 = e3.topDict.getByName("XUID");
            (i2 == null ? void 0 : i2.length) > 16 && e3.topDict.removeByName("XUID");
            e3.topDict.setByName("charset", 0);
            let s2 = this.compileTopDicts([e3.topDict], t3.length, e3.isCIDFont);
            t3.add(s2.output);
            const o2 = s2.trackers[0], c2 = this.compileStringIndex(e3.strings.strings);
            t3.add(c2);
            const l2 = this.compileIndex(e3.globalSubrIndex);
            t3.add(l2);
            if (e3.encoding && e3.topDict.hasName("Encoding")) if (e3.encoding.predefined) o2.setEntryLocation("Encoding", [e3.encoding.format], t3);
            else {
              const a4 = this.compileEncoding(e3.encoding);
              o2.setEntryLocation("Encoding", [t3.length], t3);
              t3.add(a4);
            }
            const h2 = this.compileCharset(e3.charset, e3.charStrings.count, e3.strings, e3.isCIDFont);
            o2.setEntryLocation("charset", [t3.length], t3);
            t3.add(h2);
            const u2 = this.compileCharStrings(e3.charStrings);
            o2.setEntryLocation("CharStrings", [t3.length], t3);
            t3.add(u2);
            if (e3.isCIDFont) {
              o2.setEntryLocation("FDSelect", [t3.length], t3);
              const a4 = this.compileFDSelect(e3.fdSelect);
              t3.add(a4);
              s2 = this.compileTopDicts(e3.fdArray, t3.length, true);
              o2.setEntryLocation("FDArray", [t3.length], t3);
              t3.add(s2.output);
              const r2 = s2.trackers;
              this.compilePrivateDicts(e3.fdArray, r2, t3);
            }
            this.compilePrivateDicts([e3.topDict], [o2], t3);
            t3.add([0]);
            return t3.data;
          }
          encodeNumber(e3) {
            return Number.isInteger(e3) ? this.encodeInteger(e3) : this.encodeFloat(e3);
          }
          static get EncodeFloatRegExp() {
            return (0, r.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
          }
          encodeFloat(e3) {
            let t3 = e3.toString();
            const a3 = CFFCompiler.EncodeFloatRegExp.exec(t3);
            if (a3) {
              const r3 = parseFloat("1e" + ((a3[2] ? +a3[2] : 0) + a3[1].length));
              t3 = (Math.round(e3 * r3) / r3).toString();
            }
            let r2, n2, i2 = "";
            for (r2 = 0, n2 = t3.length; r2 < n2; ++r2) {
              const e4 = t3[r2];
              i2 += "e" === e4 ? "-" === t3[++r2] ? "c" : "b" : "." === e4 ? "a" : "-" === e4 ? "e" : e4;
            }
            i2 += 1 & i2.length ? "f" : "ff";
            const s2 = [30];
            for (r2 = 0, n2 = i2.length; r2 < n2; r2 += 2) s2.push(parseInt(i2.substring(r2, r2 + 2), 16));
            return s2;
          }
          encodeInteger(e3) {
            let t3;
            t3 = e3 >= -107 && e3 <= 107 ? [e3 + 139] : e3 >= 108 && e3 <= 1131 ? [247 + ((e3 -= 108) >> 8), 255 & e3] : e3 >= -1131 && e3 <= -108 ? [251 + ((e3 = -e3 - 108) >> 8), 255 & e3] : e3 >= -32768 && e3 <= 32767 ? [28, e3 >> 8 & 255, 255 & e3] : [29, e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3];
            return t3;
          }
          compileHeader(e3) {
            return [e3.major, e3.minor, 4, e3.offSize];
          }
          compileNameIndex(e3) {
            const t3 = new CFFIndex();
            for (const a3 of e3) {
              const e4 = Math.min(a3.length, 127);
              let n2 = new Array(e4);
              for (let t4 = 0; t4 < e4; t4++) {
                let e5 = a3[t4];
                (e5 < "!" || e5 > "~" || "[" === e5 || "]" === e5 || "(" === e5 || ")" === e5 || "{" === e5 || "}" === e5 || "<" === e5 || ">" === e5 || "/" === e5 || "%" === e5) && (e5 = "_");
                n2[t4] = e5;
              }
              n2 = n2.join("");
              "" === n2 && (n2 = "Bad_Font_Name");
              t3.add((0, r.stringToBytes)(n2));
            }
            return this.compileIndex(t3);
          }
          compileTopDicts(e3, t3, a3) {
            const r2 = [];
            let n2 = new CFFIndex();
            for (const i2 of e3) {
              if (a3) {
                i2.removeByName("CIDFontVersion");
                i2.removeByName("CIDFontRevision");
                i2.removeByName("CIDFontType");
                i2.removeByName("CIDCount");
                i2.removeByName("UIDBase");
              }
              const e4 = new CFFOffsetTracker(), s2 = this.compileDict(i2, e4);
              r2.push(e4);
              n2.add(s2);
              e4.offset(t3);
            }
            n2 = this.compileIndex(n2, r2);
            return { trackers: r2, output: n2 };
          }
          compilePrivateDicts(e3, t3, a3) {
            for (let n2 = 0, i2 = e3.length; n2 < i2; ++n2) {
              const i3 = e3[n2], s2 = i3.privateDict;
              if (!s2 || !i3.hasName("Private")) throw new r.FormatError("There must be a private dictionary.");
              const o2 = new CFFOffsetTracker(), c2 = this.compileDict(s2, o2);
              let l2 = a3.length;
              o2.offset(l2);
              c2.length || (l2 = 0);
              t3[n2].setEntryLocation("Private", [c2.length, l2], a3);
              a3.add(c2);
              if (s2.subrsIndex && s2.hasName("Subrs")) {
                const e4 = this.compileIndex(s2.subrsIndex);
                o2.setEntryLocation("Subrs", [c2.length], a3);
                a3.add(e4);
              }
            }
          }
          compileDict(e3, t3) {
            const a3 = [];
            for (const n2 of e3.order) {
              if (!(n2 in e3.values)) continue;
              let i2 = e3.values[n2], s2 = e3.types[n2];
              Array.isArray(s2) || (s2 = [s2]);
              Array.isArray(i2) || (i2 = [i2]);
              if (0 !== i2.length) {
                for (let o2 = 0, c2 = s2.length; o2 < c2; ++o2) {
                  const c3 = s2[o2], l2 = i2[o2];
                  switch (c3) {
                    case "num":
                    case "sid":
                      a3.push(...this.encodeNumber(l2));
                      break;
                    case "offset":
                      const s3 = e3.keyToNameMap[n2];
                      t3.isTracking(s3) || t3.track(s3, a3.length);
                      a3.push(29, 0, 0, 0, 0);
                      break;
                    case "array":
                    case "delta":
                      a3.push(...this.encodeNumber(l2));
                      for (let e4 = 1, t4 = i2.length; e4 < t4; ++e4) a3.push(...this.encodeNumber(i2[e4]));
                      break;
                    default:
                      throw new r.FormatError(`Unknown data type of ${c3}`);
                  }
                }
                a3.push(...e3.opcodes[n2]);
              }
            }
            return a3;
          }
          compileStringIndex(e3) {
            const t3 = new CFFIndex();
            for (const a3 of e3) t3.add((0, r.stringToBytes)(a3));
            return this.compileIndex(t3);
          }
          compileCharStrings(e3) {
            const t3 = new CFFIndex();
            for (let a3 = 0; a3 < e3.count; a3++) {
              const r2 = e3.get(a3);
              0 !== r2.length ? t3.add(r2) : t3.add(new Uint8Array([139, 14]));
            }
            return this.compileIndex(t3);
          }
          compileCharset(e3, t3, a3, n2) {
            let i2;
            const s2 = t3 - 1;
            if (n2) i2 = new Uint8Array([2, 0, 0, s2 >> 8 & 255, 255 & s2]);
            else {
              i2 = new Uint8Array(1 + 2 * s2);
              i2[0] = 0;
              let t4 = 0;
              const n3 = e3.charset.length;
              let o2 = false;
              for (let s3 = 1; s3 < i2.length; s3 += 2) {
                let c2 = 0;
                if (t4 < n3) {
                  const n4 = e3.charset[t4++];
                  c2 = a3.getSID(n4);
                  if (-1 === c2) {
                    c2 = 0;
                    if (!o2) {
                      o2 = true;
                      (0, r.warn)(`Couldn't find ${n4} in CFF strings`);
                    }
                  }
                }
                i2[s3] = c2 >> 8 & 255;
                i2[s3 + 1] = 255 & c2;
              }
            }
            return this.compileTypedArray(i2);
          }
          compileEncoding(e3) {
            return this.compileTypedArray(e3.raw);
          }
          compileFDSelect(e3) {
            const t3 = e3.format;
            let a3, r2;
            switch (t3) {
              case 0:
                a3 = new Uint8Array(1 + e3.fdSelect.length);
                a3[0] = t3;
                for (r2 = 0; r2 < e3.fdSelect.length; r2++) a3[r2 + 1] = e3.fdSelect[r2];
                break;
              case 3:
                const n2 = 0;
                let i2 = e3.fdSelect[0];
                const s2 = [t3, 0, 0, n2 >> 8 & 255, 255 & n2, i2];
                for (r2 = 1; r2 < e3.fdSelect.length; r2++) {
                  const t4 = e3.fdSelect[r2];
                  if (t4 !== i2) {
                    s2.push(r2 >> 8 & 255, 255 & r2, t4);
                    i2 = t4;
                  }
                }
                const o2 = (s2.length - 3) / 3;
                s2[1] = o2 >> 8 & 255;
                s2[2] = 255 & o2;
                s2.push(r2 >> 8 & 255, 255 & r2);
                a3 = new Uint8Array(s2);
            }
            return this.compileTypedArray(a3);
          }
          compileTypedArray(e3) {
            return Array.from(e3);
          }
          compileIndex(e3, t3 = []) {
            const a3 = e3.objects, r2 = a3.length;
            if (0 === r2) return [0, 0];
            const n2 = [r2 >> 8 & 255, 255 & r2];
            let i2, s2, o2 = 1;
            for (i2 = 0; i2 < r2; ++i2) o2 += a3[i2].length;
            s2 = o2 < 256 ? 1 : o2 < 65536 ? 2 : o2 < 16777216 ? 3 : 4;
            n2.push(s2);
            let c2 = 1;
            for (i2 = 0; i2 < r2 + 1; i2++) {
              1 === s2 ? n2.push(255 & c2) : 2 === s2 ? n2.push(c2 >> 8 & 255, 255 & c2) : 3 === s2 ? n2.push(c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2) : n2.push(c2 >>> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2);
              a3[i2] && (c2 += a3[i2].length);
            }
            for (i2 = 0; i2 < r2; i2++) {
              t3[i2] && t3[i2].offset(n2.length);
              n2.push(...a3[i2]);
            }
            return n2;
          }
        }
        t2.CFFCompiler = CFFCompiler;
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ISOAdobeCharset = t2.ExpertSubsetCharset = t2.ExpertCharset = void 0;
        t2.ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
        t2.ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
        t2.ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ZapfDingbatsEncoding = t2.WinAnsiEncoding = t2.SymbolSetEncoding = t2.StandardEncoding = t2.MacRomanEncoding = t2.ExpertEncoding = void 0;
        t2.getEncoding = function getEncoding(e3) {
          switch (e3) {
            case "WinAnsiEncoding":
              return s;
            case "StandardEncoding":
              return i;
            case "MacRomanEncoding":
              return n;
            case "SymbolSetEncoding":
              return o;
            case "ZapfDingbatsEncoding":
              return c;
            case "ExpertEncoding":
              return a2;
            case "MacExpertEncoding":
              return r;
            default:
              return null;
          }
        };
        const a2 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
        t2.ExpertEncoding = a2;
        const r = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], n = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
        t2.MacRomanEncoding = n;
        const i = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
        t2.StandardEncoding = i;
        const s = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
        t2.WinAnsiEncoding = s;
        const o = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
        t2.SymbolSetEncoding = o;
        const c = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
        t2.ZapfDingbatsEncoding = c;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SEAC_ANALYSIS_ENABLED = t2.MacStandardGlyphOrdering = t2.FontFlags = void 0;
        t2.normalizeFontName = function normalizeFontName(e3) {
          return e3.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
        };
        t2.recoverGlyphName = recoverGlyphName;
        t2.type1FontGlyphMapping = function type1FontGlyphMapping(e3, t3, a3) {
          const i2 = /* @__PURE__ */ Object.create(null);
          let s2, c, l;
          const h = !!(e3.flags & o.Symbolic);
          if (e3.isInternalFont) {
            l = t3;
            for (c = 0; c < l.length; c++) {
              s2 = a3.indexOf(l[c]);
              i2[c] = s2 >= 0 ? s2 : 0;
            }
          } else if (e3.baseEncodingName) {
            l = (0, r.getEncoding)(e3.baseEncodingName);
            for (c = 0; c < l.length; c++) {
              s2 = a3.indexOf(l[c]);
              i2[c] = s2 >= 0 ? s2 : 0;
            }
          } else if (h) for (c in t3) i2[c] = t3[c];
          else {
            l = r.StandardEncoding;
            for (c = 0; c < l.length; c++) {
              s2 = a3.indexOf(l[c]);
              i2[c] = s2 >= 0 ? s2 : 0;
            }
          }
          const u = e3.differences;
          let d;
          if (u) for (c in u) {
            const e4 = u[c];
            s2 = a3.indexOf(e4);
            if (-1 === s2) {
              d || (d = (0, n.getGlyphsUnicode)());
              const t4 = recoverGlyphName(e4, d);
              t4 !== e4 && (s2 = a3.indexOf(t4));
            }
            i2[c] = s2 >= 0 ? s2 : 0;
          }
          return i2;
        };
        var r = a2(37), n = a2(39), i = a2(40), s = a2(2);
        t2.SEAC_ANALYSIS_ENABLED = true;
        const o = { FixedPitch: 1, Serif: 2, Symbolic: 4, Script: 8, Nonsymbolic: 32, Italic: 64, AllCap: 65536, SmallCap: 131072, ForceBold: 262144 };
        t2.FontFlags = o;
        t2.MacStandardGlyphOrdering = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
        function recoverGlyphName(e3, t3) {
          if (void 0 !== t3[e3]) return e3;
          const a3 = (0, i.getUnicodeForGlyph)(e3, t3);
          if (-1 !== a3) {
            for (const e4 in t3) if (t3[e4] === a3) return e4;
          }
          (0, s.info)("Unable to recover a standard glyph name for: " + e3);
          return e3;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getGlyphsUnicode = t2.getDingbatsGlyphsUnicode = void 0;
        var r = a2(3);
        const n = (0, r.getLookupTableFactory)(function(e3) {
          e3.A = 65;
          e3.AE = 198;
          e3.AEacute = 508;
          e3.AEmacron = 482;
          e3.AEsmall = 63462;
          e3.Aacute = 193;
          e3.Aacutesmall = 63457;
          e3.Abreve = 258;
          e3.Abreveacute = 7854;
          e3.Abrevecyrillic = 1232;
          e3.Abrevedotbelow = 7862;
          e3.Abrevegrave = 7856;
          e3.Abrevehookabove = 7858;
          e3.Abrevetilde = 7860;
          e3.Acaron = 461;
          e3.Acircle = 9398;
          e3.Acircumflex = 194;
          e3.Acircumflexacute = 7844;
          e3.Acircumflexdotbelow = 7852;
          e3.Acircumflexgrave = 7846;
          e3.Acircumflexhookabove = 7848;
          e3.Acircumflexsmall = 63458;
          e3.Acircumflextilde = 7850;
          e3.Acute = 63177;
          e3.Acutesmall = 63412;
          e3.Acyrillic = 1040;
          e3.Adblgrave = 512;
          e3.Adieresis = 196;
          e3.Adieresiscyrillic = 1234;
          e3.Adieresismacron = 478;
          e3.Adieresissmall = 63460;
          e3.Adotbelow = 7840;
          e3.Adotmacron = 480;
          e3.Agrave = 192;
          e3.Agravesmall = 63456;
          e3.Ahookabove = 7842;
          e3.Aiecyrillic = 1236;
          e3.Ainvertedbreve = 514;
          e3.Alpha = 913;
          e3.Alphatonos = 902;
          e3.Amacron = 256;
          e3.Amonospace = 65313;
          e3.Aogonek = 260;
          e3.Aring = 197;
          e3.Aringacute = 506;
          e3.Aringbelow = 7680;
          e3.Aringsmall = 63461;
          e3.Asmall = 63329;
          e3.Atilde = 195;
          e3.Atildesmall = 63459;
          e3.Aybarmenian = 1329;
          e3.B = 66;
          e3.Bcircle = 9399;
          e3.Bdotaccent = 7682;
          e3.Bdotbelow = 7684;
          e3.Becyrillic = 1041;
          e3.Benarmenian = 1330;
          e3.Beta = 914;
          e3.Bhook = 385;
          e3.Blinebelow = 7686;
          e3.Bmonospace = 65314;
          e3.Brevesmall = 63220;
          e3.Bsmall = 63330;
          e3.Btopbar = 386;
          e3.C = 67;
          e3.Caarmenian = 1342;
          e3.Cacute = 262;
          e3.Caron = 63178;
          e3.Caronsmall = 63221;
          e3.Ccaron = 268;
          e3.Ccedilla = 199;
          e3.Ccedillaacute = 7688;
          e3.Ccedillasmall = 63463;
          e3.Ccircle = 9400;
          e3.Ccircumflex = 264;
          e3.Cdot = 266;
          e3.Cdotaccent = 266;
          e3.Cedillasmall = 63416;
          e3.Chaarmenian = 1353;
          e3.Cheabkhasiancyrillic = 1212;
          e3.Checyrillic = 1063;
          e3.Chedescenderabkhasiancyrillic = 1214;
          e3.Chedescendercyrillic = 1206;
          e3.Chedieresiscyrillic = 1268;
          e3.Cheharmenian = 1347;
          e3.Chekhakassiancyrillic = 1227;
          e3.Cheverticalstrokecyrillic = 1208;
          e3.Chi = 935;
          e3.Chook = 391;
          e3.Circumflexsmall = 63222;
          e3.Cmonospace = 65315;
          e3.Coarmenian = 1361;
          e3.Csmall = 63331;
          e3.D = 68;
          e3.DZ = 497;
          e3.DZcaron = 452;
          e3.Daarmenian = 1332;
          e3.Dafrican = 393;
          e3.Dcaron = 270;
          e3.Dcedilla = 7696;
          e3.Dcircle = 9401;
          e3.Dcircumflexbelow = 7698;
          e3.Dcroat = 272;
          e3.Ddotaccent = 7690;
          e3.Ddotbelow = 7692;
          e3.Decyrillic = 1044;
          e3.Deicoptic = 1006;
          e3.Delta = 8710;
          e3.Deltagreek = 916;
          e3.Dhook = 394;
          e3.Dieresis = 63179;
          e3.DieresisAcute = 63180;
          e3.DieresisGrave = 63181;
          e3.Dieresissmall = 63400;
          e3.Digammagreek = 988;
          e3.Djecyrillic = 1026;
          e3.Dlinebelow = 7694;
          e3.Dmonospace = 65316;
          e3.Dotaccentsmall = 63223;
          e3.Dslash = 272;
          e3.Dsmall = 63332;
          e3.Dtopbar = 395;
          e3.Dz = 498;
          e3.Dzcaron = 453;
          e3.Dzeabkhasiancyrillic = 1248;
          e3.Dzecyrillic = 1029;
          e3.Dzhecyrillic = 1039;
          e3.E = 69;
          e3.Eacute = 201;
          e3.Eacutesmall = 63465;
          e3.Ebreve = 276;
          e3.Ecaron = 282;
          e3.Ecedillabreve = 7708;
          e3.Echarmenian = 1333;
          e3.Ecircle = 9402;
          e3.Ecircumflex = 202;
          e3.Ecircumflexacute = 7870;
          e3.Ecircumflexbelow = 7704;
          e3.Ecircumflexdotbelow = 7878;
          e3.Ecircumflexgrave = 7872;
          e3.Ecircumflexhookabove = 7874;
          e3.Ecircumflexsmall = 63466;
          e3.Ecircumflextilde = 7876;
          e3.Ecyrillic = 1028;
          e3.Edblgrave = 516;
          e3.Edieresis = 203;
          e3.Edieresissmall = 63467;
          e3.Edot = 278;
          e3.Edotaccent = 278;
          e3.Edotbelow = 7864;
          e3.Efcyrillic = 1060;
          e3.Egrave = 200;
          e3.Egravesmall = 63464;
          e3.Eharmenian = 1335;
          e3.Ehookabove = 7866;
          e3.Eightroman = 8551;
          e3.Einvertedbreve = 518;
          e3.Eiotifiedcyrillic = 1124;
          e3.Elcyrillic = 1051;
          e3.Elevenroman = 8554;
          e3.Emacron = 274;
          e3.Emacronacute = 7702;
          e3.Emacrongrave = 7700;
          e3.Emcyrillic = 1052;
          e3.Emonospace = 65317;
          e3.Encyrillic = 1053;
          e3.Endescendercyrillic = 1186;
          e3.Eng = 330;
          e3.Enghecyrillic = 1188;
          e3.Enhookcyrillic = 1223;
          e3.Eogonek = 280;
          e3.Eopen = 400;
          e3.Epsilon = 917;
          e3.Epsilontonos = 904;
          e3.Ercyrillic = 1056;
          e3.Ereversed = 398;
          e3.Ereversedcyrillic = 1069;
          e3.Escyrillic = 1057;
          e3.Esdescendercyrillic = 1194;
          e3.Esh = 425;
          e3.Esmall = 63333;
          e3.Eta = 919;
          e3.Etarmenian = 1336;
          e3.Etatonos = 905;
          e3.Eth = 208;
          e3.Ethsmall = 63472;
          e3.Etilde = 7868;
          e3.Etildebelow = 7706;
          e3.Euro = 8364;
          e3.Ezh = 439;
          e3.Ezhcaron = 494;
          e3.Ezhreversed = 440;
          e3.F = 70;
          e3.Fcircle = 9403;
          e3.Fdotaccent = 7710;
          e3.Feharmenian = 1366;
          e3.Feicoptic = 996;
          e3.Fhook = 401;
          e3.Fitacyrillic = 1138;
          e3.Fiveroman = 8548;
          e3.Fmonospace = 65318;
          e3.Fourroman = 8547;
          e3.Fsmall = 63334;
          e3.G = 71;
          e3.GBsquare = 13191;
          e3.Gacute = 500;
          e3.Gamma = 915;
          e3.Gammaafrican = 404;
          e3.Gangiacoptic = 1002;
          e3.Gbreve = 286;
          e3.Gcaron = 486;
          e3.Gcedilla = 290;
          e3.Gcircle = 9404;
          e3.Gcircumflex = 284;
          e3.Gcommaaccent = 290;
          e3.Gdot = 288;
          e3.Gdotaccent = 288;
          e3.Gecyrillic = 1043;
          e3.Ghadarmenian = 1346;
          e3.Ghemiddlehookcyrillic = 1172;
          e3.Ghestrokecyrillic = 1170;
          e3.Gheupturncyrillic = 1168;
          e3.Ghook = 403;
          e3.Gimarmenian = 1331;
          e3.Gjecyrillic = 1027;
          e3.Gmacron = 7712;
          e3.Gmonospace = 65319;
          e3.Grave = 63182;
          e3.Gravesmall = 63328;
          e3.Gsmall = 63335;
          e3.Gsmallhook = 667;
          e3.Gstroke = 484;
          e3.H = 72;
          e3.H18533 = 9679;
          e3.H18543 = 9642;
          e3.H18551 = 9643;
          e3.H22073 = 9633;
          e3.HPsquare = 13259;
          e3.Haabkhasiancyrillic = 1192;
          e3.Hadescendercyrillic = 1202;
          e3.Hardsigncyrillic = 1066;
          e3.Hbar = 294;
          e3.Hbrevebelow = 7722;
          e3.Hcedilla = 7720;
          e3.Hcircle = 9405;
          e3.Hcircumflex = 292;
          e3.Hdieresis = 7718;
          e3.Hdotaccent = 7714;
          e3.Hdotbelow = 7716;
          e3.Hmonospace = 65320;
          e3.Hoarmenian = 1344;
          e3.Horicoptic = 1e3;
          e3.Hsmall = 63336;
          e3.Hungarumlaut = 63183;
          e3.Hungarumlautsmall = 63224;
          e3.Hzsquare = 13200;
          e3.I = 73;
          e3.IAcyrillic = 1071;
          e3.IJ = 306;
          e3.IUcyrillic = 1070;
          e3.Iacute = 205;
          e3.Iacutesmall = 63469;
          e3.Ibreve = 300;
          e3.Icaron = 463;
          e3.Icircle = 9406;
          e3.Icircumflex = 206;
          e3.Icircumflexsmall = 63470;
          e3.Icyrillic = 1030;
          e3.Idblgrave = 520;
          e3.Idieresis = 207;
          e3.Idieresisacute = 7726;
          e3.Idieresiscyrillic = 1252;
          e3.Idieresissmall = 63471;
          e3.Idot = 304;
          e3.Idotaccent = 304;
          e3.Idotbelow = 7882;
          e3.Iebrevecyrillic = 1238;
          e3.Iecyrillic = 1045;
          e3.Ifraktur = 8465;
          e3.Igrave = 204;
          e3.Igravesmall = 63468;
          e3.Ihookabove = 7880;
          e3.Iicyrillic = 1048;
          e3.Iinvertedbreve = 522;
          e3.Iishortcyrillic = 1049;
          e3.Imacron = 298;
          e3.Imacroncyrillic = 1250;
          e3.Imonospace = 65321;
          e3.Iniarmenian = 1339;
          e3.Iocyrillic = 1025;
          e3.Iogonek = 302;
          e3.Iota = 921;
          e3.Iotaafrican = 406;
          e3.Iotadieresis = 938;
          e3.Iotatonos = 906;
          e3.Ismall = 63337;
          e3.Istroke = 407;
          e3.Itilde = 296;
          e3.Itildebelow = 7724;
          e3.Izhitsacyrillic = 1140;
          e3.Izhitsadblgravecyrillic = 1142;
          e3.J = 74;
          e3.Jaarmenian = 1345;
          e3.Jcircle = 9407;
          e3.Jcircumflex = 308;
          e3.Jecyrillic = 1032;
          e3.Jheharmenian = 1355;
          e3.Jmonospace = 65322;
          e3.Jsmall = 63338;
          e3.K = 75;
          e3.KBsquare = 13189;
          e3.KKsquare = 13261;
          e3.Kabashkircyrillic = 1184;
          e3.Kacute = 7728;
          e3.Kacyrillic = 1050;
          e3.Kadescendercyrillic = 1178;
          e3.Kahookcyrillic = 1219;
          e3.Kappa = 922;
          e3.Kastrokecyrillic = 1182;
          e3.Kaverticalstrokecyrillic = 1180;
          e3.Kcaron = 488;
          e3.Kcedilla = 310;
          e3.Kcircle = 9408;
          e3.Kcommaaccent = 310;
          e3.Kdotbelow = 7730;
          e3.Keharmenian = 1364;
          e3.Kenarmenian = 1343;
          e3.Khacyrillic = 1061;
          e3.Kheicoptic = 998;
          e3.Khook = 408;
          e3.Kjecyrillic = 1036;
          e3.Klinebelow = 7732;
          e3.Kmonospace = 65323;
          e3.Koppacyrillic = 1152;
          e3.Koppagreek = 990;
          e3.Ksicyrillic = 1134;
          e3.Ksmall = 63339;
          e3.L = 76;
          e3.LJ = 455;
          e3.LL = 63167;
          e3.Lacute = 313;
          e3.Lambda = 923;
          e3.Lcaron = 317;
          e3.Lcedilla = 315;
          e3.Lcircle = 9409;
          e3.Lcircumflexbelow = 7740;
          e3.Lcommaaccent = 315;
          e3.Ldot = 319;
          e3.Ldotaccent = 319;
          e3.Ldotbelow = 7734;
          e3.Ldotbelowmacron = 7736;
          e3.Liwnarmenian = 1340;
          e3.Lj = 456;
          e3.Ljecyrillic = 1033;
          e3.Llinebelow = 7738;
          e3.Lmonospace = 65324;
          e3.Lslash = 321;
          e3.Lslashsmall = 63225;
          e3.Lsmall = 63340;
          e3.M = 77;
          e3.MBsquare = 13190;
          e3.Macron = 63184;
          e3.Macronsmall = 63407;
          e3.Macute = 7742;
          e3.Mcircle = 9410;
          e3.Mdotaccent = 7744;
          e3.Mdotbelow = 7746;
          e3.Menarmenian = 1348;
          e3.Mmonospace = 65325;
          e3.Msmall = 63341;
          e3.Mturned = 412;
          e3.Mu = 924;
          e3.N = 78;
          e3.NJ = 458;
          e3.Nacute = 323;
          e3.Ncaron = 327;
          e3.Ncedilla = 325;
          e3.Ncircle = 9411;
          e3.Ncircumflexbelow = 7754;
          e3.Ncommaaccent = 325;
          e3.Ndotaccent = 7748;
          e3.Ndotbelow = 7750;
          e3.Nhookleft = 413;
          e3.Nineroman = 8552;
          e3.Nj = 459;
          e3.Njecyrillic = 1034;
          e3.Nlinebelow = 7752;
          e3.Nmonospace = 65326;
          e3.Nowarmenian = 1350;
          e3.Nsmall = 63342;
          e3.Ntilde = 209;
          e3.Ntildesmall = 63473;
          e3.Nu = 925;
          e3.O = 79;
          e3.OE = 338;
          e3.OEsmall = 63226;
          e3.Oacute = 211;
          e3.Oacutesmall = 63475;
          e3.Obarredcyrillic = 1256;
          e3.Obarreddieresiscyrillic = 1258;
          e3.Obreve = 334;
          e3.Ocaron = 465;
          e3.Ocenteredtilde = 415;
          e3.Ocircle = 9412;
          e3.Ocircumflex = 212;
          e3.Ocircumflexacute = 7888;
          e3.Ocircumflexdotbelow = 7896;
          e3.Ocircumflexgrave = 7890;
          e3.Ocircumflexhookabove = 7892;
          e3.Ocircumflexsmall = 63476;
          e3.Ocircumflextilde = 7894;
          e3.Ocyrillic = 1054;
          e3.Odblacute = 336;
          e3.Odblgrave = 524;
          e3.Odieresis = 214;
          e3.Odieresiscyrillic = 1254;
          e3.Odieresissmall = 63478;
          e3.Odotbelow = 7884;
          e3.Ogoneksmall = 63227;
          e3.Ograve = 210;
          e3.Ogravesmall = 63474;
          e3.Oharmenian = 1365;
          e3.Ohm = 8486;
          e3.Ohookabove = 7886;
          e3.Ohorn = 416;
          e3.Ohornacute = 7898;
          e3.Ohorndotbelow = 7906;
          e3.Ohorngrave = 7900;
          e3.Ohornhookabove = 7902;
          e3.Ohorntilde = 7904;
          e3.Ohungarumlaut = 336;
          e3.Oi = 418;
          e3.Oinvertedbreve = 526;
          e3.Omacron = 332;
          e3.Omacronacute = 7762;
          e3.Omacrongrave = 7760;
          e3.Omega = 8486;
          e3.Omegacyrillic = 1120;
          e3.Omegagreek = 937;
          e3.Omegaroundcyrillic = 1146;
          e3.Omegatitlocyrillic = 1148;
          e3.Omegatonos = 911;
          e3.Omicron = 927;
          e3.Omicrontonos = 908;
          e3.Omonospace = 65327;
          e3.Oneroman = 8544;
          e3.Oogonek = 490;
          e3.Oogonekmacron = 492;
          e3.Oopen = 390;
          e3.Oslash = 216;
          e3.Oslashacute = 510;
          e3.Oslashsmall = 63480;
          e3.Osmall = 63343;
          e3.Ostrokeacute = 510;
          e3.Otcyrillic = 1150;
          e3.Otilde = 213;
          e3.Otildeacute = 7756;
          e3.Otildedieresis = 7758;
          e3.Otildesmall = 63477;
          e3.P = 80;
          e3.Pacute = 7764;
          e3.Pcircle = 9413;
          e3.Pdotaccent = 7766;
          e3.Pecyrillic = 1055;
          e3.Peharmenian = 1354;
          e3.Pemiddlehookcyrillic = 1190;
          e3.Phi = 934;
          e3.Phook = 420;
          e3.Pi = 928;
          e3.Piwrarmenian = 1363;
          e3.Pmonospace = 65328;
          e3.Psi = 936;
          e3.Psicyrillic = 1136;
          e3.Psmall = 63344;
          e3.Q = 81;
          e3.Qcircle = 9414;
          e3.Qmonospace = 65329;
          e3.Qsmall = 63345;
          e3.R = 82;
          e3.Raarmenian = 1356;
          e3.Racute = 340;
          e3.Rcaron = 344;
          e3.Rcedilla = 342;
          e3.Rcircle = 9415;
          e3.Rcommaaccent = 342;
          e3.Rdblgrave = 528;
          e3.Rdotaccent = 7768;
          e3.Rdotbelow = 7770;
          e3.Rdotbelowmacron = 7772;
          e3.Reharmenian = 1360;
          e3.Rfraktur = 8476;
          e3.Rho = 929;
          e3.Ringsmall = 63228;
          e3.Rinvertedbreve = 530;
          e3.Rlinebelow = 7774;
          e3.Rmonospace = 65330;
          e3.Rsmall = 63346;
          e3.Rsmallinverted = 641;
          e3.Rsmallinvertedsuperior = 694;
          e3.S = 83;
          e3.SF010000 = 9484;
          e3.SF020000 = 9492;
          e3.SF030000 = 9488;
          e3.SF040000 = 9496;
          e3.SF050000 = 9532;
          e3.SF060000 = 9516;
          e3.SF070000 = 9524;
          e3.SF080000 = 9500;
          e3.SF090000 = 9508;
          e3.SF100000 = 9472;
          e3.SF110000 = 9474;
          e3.SF190000 = 9569;
          e3.SF200000 = 9570;
          e3.SF210000 = 9558;
          e3.SF220000 = 9557;
          e3.SF230000 = 9571;
          e3.SF240000 = 9553;
          e3.SF250000 = 9559;
          e3.SF260000 = 9565;
          e3.SF270000 = 9564;
          e3.SF280000 = 9563;
          e3.SF360000 = 9566;
          e3.SF370000 = 9567;
          e3.SF380000 = 9562;
          e3.SF390000 = 9556;
          e3.SF400000 = 9577;
          e3.SF410000 = 9574;
          e3.SF420000 = 9568;
          e3.SF430000 = 9552;
          e3.SF440000 = 9580;
          e3.SF450000 = 9575;
          e3.SF460000 = 9576;
          e3.SF470000 = 9572;
          e3.SF480000 = 9573;
          e3.SF490000 = 9561;
          e3.SF500000 = 9560;
          e3.SF510000 = 9554;
          e3.SF520000 = 9555;
          e3.SF530000 = 9579;
          e3.SF540000 = 9578;
          e3.Sacute = 346;
          e3.Sacutedotaccent = 7780;
          e3.Sampigreek = 992;
          e3.Scaron = 352;
          e3.Scarondotaccent = 7782;
          e3.Scaronsmall = 63229;
          e3.Scedilla = 350;
          e3.Schwa = 399;
          e3.Schwacyrillic = 1240;
          e3.Schwadieresiscyrillic = 1242;
          e3.Scircle = 9416;
          e3.Scircumflex = 348;
          e3.Scommaaccent = 536;
          e3.Sdotaccent = 7776;
          e3.Sdotbelow = 7778;
          e3.Sdotbelowdotaccent = 7784;
          e3.Seharmenian = 1357;
          e3.Sevenroman = 8550;
          e3.Shaarmenian = 1351;
          e3.Shacyrillic = 1064;
          e3.Shchacyrillic = 1065;
          e3.Sheicoptic = 994;
          e3.Shhacyrillic = 1210;
          e3.Shimacoptic = 1004;
          e3.Sigma = 931;
          e3.Sixroman = 8549;
          e3.Smonospace = 65331;
          e3.Softsigncyrillic = 1068;
          e3.Ssmall = 63347;
          e3.Stigmagreek = 986;
          e3.T = 84;
          e3.Tau = 932;
          e3.Tbar = 358;
          e3.Tcaron = 356;
          e3.Tcedilla = 354;
          e3.Tcircle = 9417;
          e3.Tcircumflexbelow = 7792;
          e3.Tcommaaccent = 354;
          e3.Tdotaccent = 7786;
          e3.Tdotbelow = 7788;
          e3.Tecyrillic = 1058;
          e3.Tedescendercyrillic = 1196;
          e3.Tenroman = 8553;
          e3.Tetsecyrillic = 1204;
          e3.Theta = 920;
          e3.Thook = 428;
          e3.Thorn = 222;
          e3.Thornsmall = 63486;
          e3.Threeroman = 8546;
          e3.Tildesmall = 63230;
          e3.Tiwnarmenian = 1359;
          e3.Tlinebelow = 7790;
          e3.Tmonospace = 65332;
          e3.Toarmenian = 1337;
          e3.Tonefive = 444;
          e3.Tonesix = 388;
          e3.Tonetwo = 423;
          e3.Tretroflexhook = 430;
          e3.Tsecyrillic = 1062;
          e3.Tshecyrillic = 1035;
          e3.Tsmall = 63348;
          e3.Twelveroman = 8555;
          e3.Tworoman = 8545;
          e3.U = 85;
          e3.Uacute = 218;
          e3.Uacutesmall = 63482;
          e3.Ubreve = 364;
          e3.Ucaron = 467;
          e3.Ucircle = 9418;
          e3.Ucircumflex = 219;
          e3.Ucircumflexbelow = 7798;
          e3.Ucircumflexsmall = 63483;
          e3.Ucyrillic = 1059;
          e3.Udblacute = 368;
          e3.Udblgrave = 532;
          e3.Udieresis = 220;
          e3.Udieresisacute = 471;
          e3.Udieresisbelow = 7794;
          e3.Udieresiscaron = 473;
          e3.Udieresiscyrillic = 1264;
          e3.Udieresisgrave = 475;
          e3.Udieresismacron = 469;
          e3.Udieresissmall = 63484;
          e3.Udotbelow = 7908;
          e3.Ugrave = 217;
          e3.Ugravesmall = 63481;
          e3.Uhookabove = 7910;
          e3.Uhorn = 431;
          e3.Uhornacute = 7912;
          e3.Uhorndotbelow = 7920;
          e3.Uhorngrave = 7914;
          e3.Uhornhookabove = 7916;
          e3.Uhorntilde = 7918;
          e3.Uhungarumlaut = 368;
          e3.Uhungarumlautcyrillic = 1266;
          e3.Uinvertedbreve = 534;
          e3.Ukcyrillic = 1144;
          e3.Umacron = 362;
          e3.Umacroncyrillic = 1262;
          e3.Umacrondieresis = 7802;
          e3.Umonospace = 65333;
          e3.Uogonek = 370;
          e3.Upsilon = 933;
          e3.Upsilon1 = 978;
          e3.Upsilonacutehooksymbolgreek = 979;
          e3.Upsilonafrican = 433;
          e3.Upsilondieresis = 939;
          e3.Upsilondieresishooksymbolgreek = 980;
          e3.Upsilonhooksymbol = 978;
          e3.Upsilontonos = 910;
          e3.Uring = 366;
          e3.Ushortcyrillic = 1038;
          e3.Usmall = 63349;
          e3.Ustraightcyrillic = 1198;
          e3.Ustraightstrokecyrillic = 1200;
          e3.Utilde = 360;
          e3.Utildeacute = 7800;
          e3.Utildebelow = 7796;
          e3.V = 86;
          e3.Vcircle = 9419;
          e3.Vdotbelow = 7806;
          e3.Vecyrillic = 1042;
          e3.Vewarmenian = 1358;
          e3.Vhook = 434;
          e3.Vmonospace = 65334;
          e3.Voarmenian = 1352;
          e3.Vsmall = 63350;
          e3.Vtilde = 7804;
          e3.W = 87;
          e3.Wacute = 7810;
          e3.Wcircle = 9420;
          e3.Wcircumflex = 372;
          e3.Wdieresis = 7812;
          e3.Wdotaccent = 7814;
          e3.Wdotbelow = 7816;
          e3.Wgrave = 7808;
          e3.Wmonospace = 65335;
          e3.Wsmall = 63351;
          e3.X = 88;
          e3.Xcircle = 9421;
          e3.Xdieresis = 7820;
          e3.Xdotaccent = 7818;
          e3.Xeharmenian = 1341;
          e3.Xi = 926;
          e3.Xmonospace = 65336;
          e3.Xsmall = 63352;
          e3.Y = 89;
          e3.Yacute = 221;
          e3.Yacutesmall = 63485;
          e3.Yatcyrillic = 1122;
          e3.Ycircle = 9422;
          e3.Ycircumflex = 374;
          e3.Ydieresis = 376;
          e3.Ydieresissmall = 63487;
          e3.Ydotaccent = 7822;
          e3.Ydotbelow = 7924;
          e3.Yericyrillic = 1067;
          e3.Yerudieresiscyrillic = 1272;
          e3.Ygrave = 7922;
          e3.Yhook = 435;
          e3.Yhookabove = 7926;
          e3.Yiarmenian = 1349;
          e3.Yicyrillic = 1031;
          e3.Yiwnarmenian = 1362;
          e3.Ymonospace = 65337;
          e3.Ysmall = 63353;
          e3.Ytilde = 7928;
          e3.Yusbigcyrillic = 1130;
          e3.Yusbigiotifiedcyrillic = 1132;
          e3.Yuslittlecyrillic = 1126;
          e3.Yuslittleiotifiedcyrillic = 1128;
          e3.Z = 90;
          e3.Zaarmenian = 1334;
          e3.Zacute = 377;
          e3.Zcaron = 381;
          e3.Zcaronsmall = 63231;
          e3.Zcircle = 9423;
          e3.Zcircumflex = 7824;
          e3.Zdot = 379;
          e3.Zdotaccent = 379;
          e3.Zdotbelow = 7826;
          e3.Zecyrillic = 1047;
          e3.Zedescendercyrillic = 1176;
          e3.Zedieresiscyrillic = 1246;
          e3.Zeta = 918;
          e3.Zhearmenian = 1338;
          e3.Zhebrevecyrillic = 1217;
          e3.Zhecyrillic = 1046;
          e3.Zhedescendercyrillic = 1174;
          e3.Zhedieresiscyrillic = 1244;
          e3.Zlinebelow = 7828;
          e3.Zmonospace = 65338;
          e3.Zsmall = 63354;
          e3.Zstroke = 437;
          e3.a = 97;
          e3.aabengali = 2438;
          e3.aacute = 225;
          e3.aadeva = 2310;
          e3.aagujarati = 2694;
          e3.aagurmukhi = 2566;
          e3.aamatragurmukhi = 2622;
          e3.aarusquare = 13059;
          e3.aavowelsignbengali = 2494;
          e3.aavowelsigndeva = 2366;
          e3.aavowelsigngujarati = 2750;
          e3.abbreviationmarkarmenian = 1375;
          e3.abbreviationsigndeva = 2416;
          e3.abengali = 2437;
          e3.abopomofo = 12570;
          e3.abreve = 259;
          e3.abreveacute = 7855;
          e3.abrevecyrillic = 1233;
          e3.abrevedotbelow = 7863;
          e3.abrevegrave = 7857;
          e3.abrevehookabove = 7859;
          e3.abrevetilde = 7861;
          e3.acaron = 462;
          e3.acircle = 9424;
          e3.acircumflex = 226;
          e3.acircumflexacute = 7845;
          e3.acircumflexdotbelow = 7853;
          e3.acircumflexgrave = 7847;
          e3.acircumflexhookabove = 7849;
          e3.acircumflextilde = 7851;
          e3.acute = 180;
          e3.acutebelowcmb = 791;
          e3.acutecmb = 769;
          e3.acutecomb = 769;
          e3.acutedeva = 2388;
          e3.acutelowmod = 719;
          e3.acutetonecmb = 833;
          e3.acyrillic = 1072;
          e3.adblgrave = 513;
          e3.addakgurmukhi = 2673;
          e3.adeva = 2309;
          e3.adieresis = 228;
          e3.adieresiscyrillic = 1235;
          e3.adieresismacron = 479;
          e3.adotbelow = 7841;
          e3.adotmacron = 481;
          e3.ae = 230;
          e3.aeacute = 509;
          e3.aekorean = 12624;
          e3.aemacron = 483;
          e3.afii00208 = 8213;
          e3.afii08941 = 8356;
          e3.afii10017 = 1040;
          e3.afii10018 = 1041;
          e3.afii10019 = 1042;
          e3.afii10020 = 1043;
          e3.afii10021 = 1044;
          e3.afii10022 = 1045;
          e3.afii10023 = 1025;
          e3.afii10024 = 1046;
          e3.afii10025 = 1047;
          e3.afii10026 = 1048;
          e3.afii10027 = 1049;
          e3.afii10028 = 1050;
          e3.afii10029 = 1051;
          e3.afii10030 = 1052;
          e3.afii10031 = 1053;
          e3.afii10032 = 1054;
          e3.afii10033 = 1055;
          e3.afii10034 = 1056;
          e3.afii10035 = 1057;
          e3.afii10036 = 1058;
          e3.afii10037 = 1059;
          e3.afii10038 = 1060;
          e3.afii10039 = 1061;
          e3.afii10040 = 1062;
          e3.afii10041 = 1063;
          e3.afii10042 = 1064;
          e3.afii10043 = 1065;
          e3.afii10044 = 1066;
          e3.afii10045 = 1067;
          e3.afii10046 = 1068;
          e3.afii10047 = 1069;
          e3.afii10048 = 1070;
          e3.afii10049 = 1071;
          e3.afii10050 = 1168;
          e3.afii10051 = 1026;
          e3.afii10052 = 1027;
          e3.afii10053 = 1028;
          e3.afii10054 = 1029;
          e3.afii10055 = 1030;
          e3.afii10056 = 1031;
          e3.afii10057 = 1032;
          e3.afii10058 = 1033;
          e3.afii10059 = 1034;
          e3.afii10060 = 1035;
          e3.afii10061 = 1036;
          e3.afii10062 = 1038;
          e3.afii10063 = 63172;
          e3.afii10064 = 63173;
          e3.afii10065 = 1072;
          e3.afii10066 = 1073;
          e3.afii10067 = 1074;
          e3.afii10068 = 1075;
          e3.afii10069 = 1076;
          e3.afii10070 = 1077;
          e3.afii10071 = 1105;
          e3.afii10072 = 1078;
          e3.afii10073 = 1079;
          e3.afii10074 = 1080;
          e3.afii10075 = 1081;
          e3.afii10076 = 1082;
          e3.afii10077 = 1083;
          e3.afii10078 = 1084;
          e3.afii10079 = 1085;
          e3.afii10080 = 1086;
          e3.afii10081 = 1087;
          e3.afii10082 = 1088;
          e3.afii10083 = 1089;
          e3.afii10084 = 1090;
          e3.afii10085 = 1091;
          e3.afii10086 = 1092;
          e3.afii10087 = 1093;
          e3.afii10088 = 1094;
          e3.afii10089 = 1095;
          e3.afii10090 = 1096;
          e3.afii10091 = 1097;
          e3.afii10092 = 1098;
          e3.afii10093 = 1099;
          e3.afii10094 = 1100;
          e3.afii10095 = 1101;
          e3.afii10096 = 1102;
          e3.afii10097 = 1103;
          e3.afii10098 = 1169;
          e3.afii10099 = 1106;
          e3.afii10100 = 1107;
          e3.afii10101 = 1108;
          e3.afii10102 = 1109;
          e3.afii10103 = 1110;
          e3.afii10104 = 1111;
          e3.afii10105 = 1112;
          e3.afii10106 = 1113;
          e3.afii10107 = 1114;
          e3.afii10108 = 1115;
          e3.afii10109 = 1116;
          e3.afii10110 = 1118;
          e3.afii10145 = 1039;
          e3.afii10146 = 1122;
          e3.afii10147 = 1138;
          e3.afii10148 = 1140;
          e3.afii10192 = 63174;
          e3.afii10193 = 1119;
          e3.afii10194 = 1123;
          e3.afii10195 = 1139;
          e3.afii10196 = 1141;
          e3.afii10831 = 63175;
          e3.afii10832 = 63176;
          e3.afii10846 = 1241;
          e3.afii299 = 8206;
          e3.afii300 = 8207;
          e3.afii301 = 8205;
          e3.afii57381 = 1642;
          e3.afii57388 = 1548;
          e3.afii57392 = 1632;
          e3.afii57393 = 1633;
          e3.afii57394 = 1634;
          e3.afii57395 = 1635;
          e3.afii57396 = 1636;
          e3.afii57397 = 1637;
          e3.afii57398 = 1638;
          e3.afii57399 = 1639;
          e3.afii57400 = 1640;
          e3.afii57401 = 1641;
          e3.afii57403 = 1563;
          e3.afii57407 = 1567;
          e3.afii57409 = 1569;
          e3.afii57410 = 1570;
          e3.afii57411 = 1571;
          e3.afii57412 = 1572;
          e3.afii57413 = 1573;
          e3.afii57414 = 1574;
          e3.afii57415 = 1575;
          e3.afii57416 = 1576;
          e3.afii57417 = 1577;
          e3.afii57418 = 1578;
          e3.afii57419 = 1579;
          e3.afii57420 = 1580;
          e3.afii57421 = 1581;
          e3.afii57422 = 1582;
          e3.afii57423 = 1583;
          e3.afii57424 = 1584;
          e3.afii57425 = 1585;
          e3.afii57426 = 1586;
          e3.afii57427 = 1587;
          e3.afii57428 = 1588;
          e3.afii57429 = 1589;
          e3.afii57430 = 1590;
          e3.afii57431 = 1591;
          e3.afii57432 = 1592;
          e3.afii57433 = 1593;
          e3.afii57434 = 1594;
          e3.afii57440 = 1600;
          e3.afii57441 = 1601;
          e3.afii57442 = 1602;
          e3.afii57443 = 1603;
          e3.afii57444 = 1604;
          e3.afii57445 = 1605;
          e3.afii57446 = 1606;
          e3.afii57448 = 1608;
          e3.afii57449 = 1609;
          e3.afii57450 = 1610;
          e3.afii57451 = 1611;
          e3.afii57452 = 1612;
          e3.afii57453 = 1613;
          e3.afii57454 = 1614;
          e3.afii57455 = 1615;
          e3.afii57456 = 1616;
          e3.afii57457 = 1617;
          e3.afii57458 = 1618;
          e3.afii57470 = 1607;
          e3.afii57505 = 1700;
          e3.afii57506 = 1662;
          e3.afii57507 = 1670;
          e3.afii57508 = 1688;
          e3.afii57509 = 1711;
          e3.afii57511 = 1657;
          e3.afii57512 = 1672;
          e3.afii57513 = 1681;
          e3.afii57514 = 1722;
          e3.afii57519 = 1746;
          e3.afii57534 = 1749;
          e3.afii57636 = 8362;
          e3.afii57645 = 1470;
          e3.afii57658 = 1475;
          e3.afii57664 = 1488;
          e3.afii57665 = 1489;
          e3.afii57666 = 1490;
          e3.afii57667 = 1491;
          e3.afii57668 = 1492;
          e3.afii57669 = 1493;
          e3.afii57670 = 1494;
          e3.afii57671 = 1495;
          e3.afii57672 = 1496;
          e3.afii57673 = 1497;
          e3.afii57674 = 1498;
          e3.afii57675 = 1499;
          e3.afii57676 = 1500;
          e3.afii57677 = 1501;
          e3.afii57678 = 1502;
          e3.afii57679 = 1503;
          e3.afii57680 = 1504;
          e3.afii57681 = 1505;
          e3.afii57682 = 1506;
          e3.afii57683 = 1507;
          e3.afii57684 = 1508;
          e3.afii57685 = 1509;
          e3.afii57686 = 1510;
          e3.afii57687 = 1511;
          e3.afii57688 = 1512;
          e3.afii57689 = 1513;
          e3.afii57690 = 1514;
          e3.afii57694 = 64298;
          e3.afii57695 = 64299;
          e3.afii57700 = 64331;
          e3.afii57705 = 64287;
          e3.afii57716 = 1520;
          e3.afii57717 = 1521;
          e3.afii57718 = 1522;
          e3.afii57723 = 64309;
          e3.afii57793 = 1460;
          e3.afii57794 = 1461;
          e3.afii57795 = 1462;
          e3.afii57796 = 1467;
          e3.afii57797 = 1464;
          e3.afii57798 = 1463;
          e3.afii57799 = 1456;
          e3.afii57800 = 1458;
          e3.afii57801 = 1457;
          e3.afii57802 = 1459;
          e3.afii57803 = 1474;
          e3.afii57804 = 1473;
          e3.afii57806 = 1465;
          e3.afii57807 = 1468;
          e3.afii57839 = 1469;
          e3.afii57841 = 1471;
          e3.afii57842 = 1472;
          e3.afii57929 = 700;
          e3.afii61248 = 8453;
          e3.afii61289 = 8467;
          e3.afii61352 = 8470;
          e3.afii61573 = 8236;
          e3.afii61574 = 8237;
          e3.afii61575 = 8238;
          e3.afii61664 = 8204;
          e3.afii63167 = 1645;
          e3.afii64937 = 701;
          e3.agrave = 224;
          e3.agujarati = 2693;
          e3.agurmukhi = 2565;
          e3.ahiragana = 12354;
          e3.ahookabove = 7843;
          e3.aibengali = 2448;
          e3.aibopomofo = 12574;
          e3.aideva = 2320;
          e3.aiecyrillic = 1237;
          e3.aigujarati = 2704;
          e3.aigurmukhi = 2576;
          e3.aimatragurmukhi = 2632;
          e3.ainarabic = 1593;
          e3.ainfinalarabic = 65226;
          e3.aininitialarabic = 65227;
          e3.ainmedialarabic = 65228;
          e3.ainvertedbreve = 515;
          e3.aivowelsignbengali = 2504;
          e3.aivowelsigndeva = 2376;
          e3.aivowelsigngujarati = 2760;
          e3.akatakana = 12450;
          e3.akatakanahalfwidth = 65393;
          e3.akorean = 12623;
          e3.alef = 1488;
          e3.alefarabic = 1575;
          e3.alefdageshhebrew = 64304;
          e3.aleffinalarabic = 65166;
          e3.alefhamzaabovearabic = 1571;
          e3.alefhamzaabovefinalarabic = 65156;
          e3.alefhamzabelowarabic = 1573;
          e3.alefhamzabelowfinalarabic = 65160;
          e3.alefhebrew = 1488;
          e3.aleflamedhebrew = 64335;
          e3.alefmaddaabovearabic = 1570;
          e3.alefmaddaabovefinalarabic = 65154;
          e3.alefmaksuraarabic = 1609;
          e3.alefmaksurafinalarabic = 65264;
          e3.alefmaksurainitialarabic = 65267;
          e3.alefmaksuramedialarabic = 65268;
          e3.alefpatahhebrew = 64302;
          e3.alefqamatshebrew = 64303;
          e3.aleph = 8501;
          e3.allequal = 8780;
          e3.alpha = 945;
          e3.alphatonos = 940;
          e3.amacron = 257;
          e3.amonospace = 65345;
          e3.ampersand = 38;
          e3.ampersandmonospace = 65286;
          e3.ampersandsmall = 63270;
          e3.amsquare = 13250;
          e3.anbopomofo = 12578;
          e3.angbopomofo = 12580;
          e3.angbracketleft = 12296;
          e3.angbracketright = 12297;
          e3.angkhankhuthai = 3674;
          e3.angle = 8736;
          e3.anglebracketleft = 12296;
          e3.anglebracketleftvertical = 65087;
          e3.anglebracketright = 12297;
          e3.anglebracketrightvertical = 65088;
          e3.angleleft = 9001;
          e3.angleright = 9002;
          e3.angstrom = 8491;
          e3.anoteleia = 903;
          e3.anudattadeva = 2386;
          e3.anusvarabengali = 2434;
          e3.anusvaradeva = 2306;
          e3.anusvaragujarati = 2690;
          e3.aogonek = 261;
          e3.apaatosquare = 13056;
          e3.aparen = 9372;
          e3.apostrophearmenian = 1370;
          e3.apostrophemod = 700;
          e3.apple = 63743;
          e3.approaches = 8784;
          e3.approxequal = 8776;
          e3.approxequalorimage = 8786;
          e3.approximatelyequal = 8773;
          e3.araeaekorean = 12686;
          e3.araeakorean = 12685;
          e3.arc = 8978;
          e3.arighthalfring = 7834;
          e3.aring = 229;
          e3.aringacute = 507;
          e3.aringbelow = 7681;
          e3.arrowboth = 8596;
          e3.arrowdashdown = 8675;
          e3.arrowdashleft = 8672;
          e3.arrowdashright = 8674;
          e3.arrowdashup = 8673;
          e3.arrowdblboth = 8660;
          e3.arrowdbldown = 8659;
          e3.arrowdblleft = 8656;
          e3.arrowdblright = 8658;
          e3.arrowdblup = 8657;
          e3.arrowdown = 8595;
          e3.arrowdownleft = 8601;
          e3.arrowdownright = 8600;
          e3.arrowdownwhite = 8681;
          e3.arrowheaddownmod = 709;
          e3.arrowheadleftmod = 706;
          e3.arrowheadrightmod = 707;
          e3.arrowheadupmod = 708;
          e3.arrowhorizex = 63719;
          e3.arrowleft = 8592;
          e3.arrowleftdbl = 8656;
          e3.arrowleftdblstroke = 8653;
          e3.arrowleftoverright = 8646;
          e3.arrowleftwhite = 8678;
          e3.arrowright = 8594;
          e3.arrowrightdblstroke = 8655;
          e3.arrowrightheavy = 10142;
          e3.arrowrightoverleft = 8644;
          e3.arrowrightwhite = 8680;
          e3.arrowtableft = 8676;
          e3.arrowtabright = 8677;
          e3.arrowup = 8593;
          e3.arrowupdn = 8597;
          e3.arrowupdnbse = 8616;
          e3.arrowupdownbase = 8616;
          e3.arrowupleft = 8598;
          e3.arrowupleftofdown = 8645;
          e3.arrowupright = 8599;
          e3.arrowupwhite = 8679;
          e3.arrowvertex = 63718;
          e3.asciicircum = 94;
          e3.asciicircummonospace = 65342;
          e3.asciitilde = 126;
          e3.asciitildemonospace = 65374;
          e3.ascript = 593;
          e3.ascriptturned = 594;
          e3.asmallhiragana = 12353;
          e3.asmallkatakana = 12449;
          e3.asmallkatakanahalfwidth = 65383;
          e3.asterisk = 42;
          e3.asteriskaltonearabic = 1645;
          e3.asteriskarabic = 1645;
          e3.asteriskmath = 8727;
          e3.asteriskmonospace = 65290;
          e3.asterisksmall = 65121;
          e3.asterism = 8258;
          e3.asuperior = 63209;
          e3.asymptoticallyequal = 8771;
          e3.at = 64;
          e3.atilde = 227;
          e3.atmonospace = 65312;
          e3.atsmall = 65131;
          e3.aturned = 592;
          e3.aubengali = 2452;
          e3.aubopomofo = 12576;
          e3.audeva = 2324;
          e3.augujarati = 2708;
          e3.augurmukhi = 2580;
          e3.aulengthmarkbengali = 2519;
          e3.aumatragurmukhi = 2636;
          e3.auvowelsignbengali = 2508;
          e3.auvowelsigndeva = 2380;
          e3.auvowelsigngujarati = 2764;
          e3.avagrahadeva = 2365;
          e3.aybarmenian = 1377;
          e3.ayin = 1506;
          e3.ayinaltonehebrew = 64288;
          e3.ayinhebrew = 1506;
          e3.b = 98;
          e3.babengali = 2476;
          e3.backslash = 92;
          e3.backslashmonospace = 65340;
          e3.badeva = 2348;
          e3.bagujarati = 2732;
          e3.bagurmukhi = 2604;
          e3.bahiragana = 12400;
          e3.bahtthai = 3647;
          e3.bakatakana = 12496;
          e3.bar = 124;
          e3.barmonospace = 65372;
          e3.bbopomofo = 12549;
          e3.bcircle = 9425;
          e3.bdotaccent = 7683;
          e3.bdotbelow = 7685;
          e3.beamedsixteenthnotes = 9836;
          e3.because = 8757;
          e3.becyrillic = 1073;
          e3.beharabic = 1576;
          e3.behfinalarabic = 65168;
          e3.behinitialarabic = 65169;
          e3.behiragana = 12409;
          e3.behmedialarabic = 65170;
          e3.behmeeminitialarabic = 64671;
          e3.behmeemisolatedarabic = 64520;
          e3.behnoonfinalarabic = 64621;
          e3.bekatakana = 12505;
          e3.benarmenian = 1378;
          e3.bet = 1489;
          e3.beta = 946;
          e3.betasymbolgreek = 976;
          e3.betdagesh = 64305;
          e3.betdageshhebrew = 64305;
          e3.bethebrew = 1489;
          e3.betrafehebrew = 64332;
          e3.bhabengali = 2477;
          e3.bhadeva = 2349;
          e3.bhagujarati = 2733;
          e3.bhagurmukhi = 2605;
          e3.bhook = 595;
          e3.bihiragana = 12403;
          e3.bikatakana = 12499;
          e3.bilabialclick = 664;
          e3.bindigurmukhi = 2562;
          e3.birusquare = 13105;
          e3.blackcircle = 9679;
          e3.blackdiamond = 9670;
          e3.blackdownpointingtriangle = 9660;
          e3.blackleftpointingpointer = 9668;
          e3.blackleftpointingtriangle = 9664;
          e3.blacklenticularbracketleft = 12304;
          e3.blacklenticularbracketleftvertical = 65083;
          e3.blacklenticularbracketright = 12305;
          e3.blacklenticularbracketrightvertical = 65084;
          e3.blacklowerlefttriangle = 9699;
          e3.blacklowerrighttriangle = 9698;
          e3.blackrectangle = 9644;
          e3.blackrightpointingpointer = 9658;
          e3.blackrightpointingtriangle = 9654;
          e3.blacksmallsquare = 9642;
          e3.blacksmilingface = 9787;
          e3.blacksquare = 9632;
          e3.blackstar = 9733;
          e3.blackupperlefttriangle = 9700;
          e3.blackupperrighttriangle = 9701;
          e3.blackuppointingsmalltriangle = 9652;
          e3.blackuppointingtriangle = 9650;
          e3.blank = 9251;
          e3.blinebelow = 7687;
          e3.block = 9608;
          e3.bmonospace = 65346;
          e3.bobaimaithai = 3610;
          e3.bohiragana = 12412;
          e3.bokatakana = 12508;
          e3.bparen = 9373;
          e3.bqsquare = 13251;
          e3.braceex = 63732;
          e3.braceleft = 123;
          e3.braceleftbt = 63731;
          e3.braceleftmid = 63730;
          e3.braceleftmonospace = 65371;
          e3.braceleftsmall = 65115;
          e3.bracelefttp = 63729;
          e3.braceleftvertical = 65079;
          e3.braceright = 125;
          e3.bracerightbt = 63742;
          e3.bracerightmid = 63741;
          e3.bracerightmonospace = 65373;
          e3.bracerightsmall = 65116;
          e3.bracerighttp = 63740;
          e3.bracerightvertical = 65080;
          e3.bracketleft = 91;
          e3.bracketleftbt = 63728;
          e3.bracketleftex = 63727;
          e3.bracketleftmonospace = 65339;
          e3.bracketlefttp = 63726;
          e3.bracketright = 93;
          e3.bracketrightbt = 63739;
          e3.bracketrightex = 63738;
          e3.bracketrightmonospace = 65341;
          e3.bracketrighttp = 63737;
          e3.breve = 728;
          e3.brevebelowcmb = 814;
          e3.brevecmb = 774;
          e3.breveinvertedbelowcmb = 815;
          e3.breveinvertedcmb = 785;
          e3.breveinverteddoublecmb = 865;
          e3.bridgebelowcmb = 810;
          e3.bridgeinvertedbelowcmb = 826;
          e3.brokenbar = 166;
          e3.bstroke = 384;
          e3.bsuperior = 63210;
          e3.btopbar = 387;
          e3.buhiragana = 12406;
          e3.bukatakana = 12502;
          e3.bullet = 8226;
          e3.bulletinverse = 9688;
          e3.bulletoperator = 8729;
          e3.bullseye = 9678;
          e3.c = 99;
          e3.caarmenian = 1390;
          e3.cabengali = 2458;
          e3.cacute = 263;
          e3.cadeva = 2330;
          e3.cagujarati = 2714;
          e3.cagurmukhi = 2586;
          e3.calsquare = 13192;
          e3.candrabindubengali = 2433;
          e3.candrabinducmb = 784;
          e3.candrabindudeva = 2305;
          e3.candrabindugujarati = 2689;
          e3.capslock = 8682;
          e3.careof = 8453;
          e3.caron = 711;
          e3.caronbelowcmb = 812;
          e3.caroncmb = 780;
          e3.carriagereturn = 8629;
          e3.cbopomofo = 12568;
          e3.ccaron = 269;
          e3.ccedilla = 231;
          e3.ccedillaacute = 7689;
          e3.ccircle = 9426;
          e3.ccircumflex = 265;
          e3.ccurl = 597;
          e3.cdot = 267;
          e3.cdotaccent = 267;
          e3.cdsquare = 13253;
          e3.cedilla = 184;
          e3.cedillacmb = 807;
          e3.cent = 162;
          e3.centigrade = 8451;
          e3.centinferior = 63199;
          e3.centmonospace = 65504;
          e3.centoldstyle = 63394;
          e3.centsuperior = 63200;
          e3.chaarmenian = 1401;
          e3.chabengali = 2459;
          e3.chadeva = 2331;
          e3.chagujarati = 2715;
          e3.chagurmukhi = 2587;
          e3.chbopomofo = 12564;
          e3.cheabkhasiancyrillic = 1213;
          e3.checkmark = 10003;
          e3.checyrillic = 1095;
          e3.chedescenderabkhasiancyrillic = 1215;
          e3.chedescendercyrillic = 1207;
          e3.chedieresiscyrillic = 1269;
          e3.cheharmenian = 1395;
          e3.chekhakassiancyrillic = 1228;
          e3.cheverticalstrokecyrillic = 1209;
          e3.chi = 967;
          e3.chieuchacirclekorean = 12919;
          e3.chieuchaparenkorean = 12823;
          e3.chieuchcirclekorean = 12905;
          e3.chieuchkorean = 12618;
          e3.chieuchparenkorean = 12809;
          e3.chochangthai = 3594;
          e3.chochanthai = 3592;
          e3.chochingthai = 3593;
          e3.chochoethai = 3596;
          e3.chook = 392;
          e3.cieucacirclekorean = 12918;
          e3.cieucaparenkorean = 12822;
          e3.cieuccirclekorean = 12904;
          e3.cieuckorean = 12616;
          e3.cieucparenkorean = 12808;
          e3.cieucuparenkorean = 12828;
          e3.circle = 9675;
          e3.circlecopyrt = 169;
          e3.circlemultiply = 8855;
          e3.circleot = 8857;
          e3.circleplus = 8853;
          e3.circlepostalmark = 12342;
          e3.circlewithlefthalfblack = 9680;
          e3.circlewithrighthalfblack = 9681;
          e3.circumflex = 710;
          e3.circumflexbelowcmb = 813;
          e3.circumflexcmb = 770;
          e3.clear = 8999;
          e3.clickalveolar = 450;
          e3.clickdental = 448;
          e3.clicklateral = 449;
          e3.clickretroflex = 451;
          e3.club = 9827;
          e3.clubsuitblack = 9827;
          e3.clubsuitwhite = 9831;
          e3.cmcubedsquare = 13220;
          e3.cmonospace = 65347;
          e3.cmsquaredsquare = 13216;
          e3.coarmenian = 1409;
          e3.colon = 58;
          e3.colonmonetary = 8353;
          e3.colonmonospace = 65306;
          e3.colonsign = 8353;
          e3.colonsmall = 65109;
          e3.colontriangularhalfmod = 721;
          e3.colontriangularmod = 720;
          e3.comma = 44;
          e3.commaabovecmb = 787;
          e3.commaaboverightcmb = 789;
          e3.commaaccent = 63171;
          e3.commaarabic = 1548;
          e3.commaarmenian = 1373;
          e3.commainferior = 63201;
          e3.commamonospace = 65292;
          e3.commareversedabovecmb = 788;
          e3.commareversedmod = 701;
          e3.commasmall = 65104;
          e3.commasuperior = 63202;
          e3.commaturnedabovecmb = 786;
          e3.commaturnedmod = 699;
          e3.compass = 9788;
          e3.congruent = 8773;
          e3.contourintegral = 8750;
          e3.control = 8963;
          e3.controlACK = 6;
          e3.controlBEL = 7;
          e3.controlBS = 8;
          e3.controlCAN = 24;
          e3.controlCR = 13;
          e3.controlDC1 = 17;
          e3.controlDC2 = 18;
          e3.controlDC3 = 19;
          e3.controlDC4 = 20;
          e3.controlDEL = 127;
          e3.controlDLE = 16;
          e3.controlEM = 25;
          e3.controlENQ = 5;
          e3.controlEOT = 4;
          e3.controlESC = 27;
          e3.controlETB = 23;
          e3.controlETX = 3;
          e3.controlFF = 12;
          e3.controlFS = 28;
          e3.controlGS = 29;
          e3.controlHT = 9;
          e3.controlLF = 10;
          e3.controlNAK = 21;
          e3.controlNULL = 0;
          e3.controlRS = 30;
          e3.controlSI = 15;
          e3.controlSO = 14;
          e3.controlSOT = 2;
          e3.controlSTX = 1;
          e3.controlSUB = 26;
          e3.controlSYN = 22;
          e3.controlUS = 31;
          e3.controlVT = 11;
          e3.copyright = 169;
          e3.copyrightsans = 63721;
          e3.copyrightserif = 63193;
          e3.cornerbracketleft = 12300;
          e3.cornerbracketlefthalfwidth = 65378;
          e3.cornerbracketleftvertical = 65089;
          e3.cornerbracketright = 12301;
          e3.cornerbracketrighthalfwidth = 65379;
          e3.cornerbracketrightvertical = 65090;
          e3.corporationsquare = 13183;
          e3.cosquare = 13255;
          e3.coverkgsquare = 13254;
          e3.cparen = 9374;
          e3.cruzeiro = 8354;
          e3.cstretched = 663;
          e3.curlyand = 8911;
          e3.curlyor = 8910;
          e3.currency = 164;
          e3.cyrBreve = 63185;
          e3.cyrFlex = 63186;
          e3.cyrbreve = 63188;
          e3.cyrflex = 63189;
          e3.d = 100;
          e3.daarmenian = 1380;
          e3.dabengali = 2470;
          e3.dadarabic = 1590;
          e3.dadeva = 2342;
          e3.dadfinalarabic = 65214;
          e3.dadinitialarabic = 65215;
          e3.dadmedialarabic = 65216;
          e3.dagesh = 1468;
          e3.dageshhebrew = 1468;
          e3.dagger = 8224;
          e3.daggerdbl = 8225;
          e3.dagujarati = 2726;
          e3.dagurmukhi = 2598;
          e3.dahiragana = 12384;
          e3.dakatakana = 12480;
          e3.dalarabic = 1583;
          e3.dalet = 1491;
          e3.daletdagesh = 64307;
          e3.daletdageshhebrew = 64307;
          e3.dalethebrew = 1491;
          e3.dalfinalarabic = 65194;
          e3.dammaarabic = 1615;
          e3.dammalowarabic = 1615;
          e3.dammatanaltonearabic = 1612;
          e3.dammatanarabic = 1612;
          e3.danda = 2404;
          e3.dargahebrew = 1447;
          e3.dargalefthebrew = 1447;
          e3.dasiapneumatacyrilliccmb = 1157;
          e3.dblGrave = 63187;
          e3.dblanglebracketleft = 12298;
          e3.dblanglebracketleftvertical = 65085;
          e3.dblanglebracketright = 12299;
          e3.dblanglebracketrightvertical = 65086;
          e3.dblarchinvertedbelowcmb = 811;
          e3.dblarrowleft = 8660;
          e3.dblarrowright = 8658;
          e3.dbldanda = 2405;
          e3.dblgrave = 63190;
          e3.dblgravecmb = 783;
          e3.dblintegral = 8748;
          e3.dbllowline = 8215;
          e3.dbllowlinecmb = 819;
          e3.dbloverlinecmb = 831;
          e3.dblprimemod = 698;
          e3.dblverticalbar = 8214;
          e3.dblverticallineabovecmb = 782;
          e3.dbopomofo = 12553;
          e3.dbsquare = 13256;
          e3.dcaron = 271;
          e3.dcedilla = 7697;
          e3.dcircle = 9427;
          e3.dcircumflexbelow = 7699;
          e3.dcroat = 273;
          e3.ddabengali = 2465;
          e3.ddadeva = 2337;
          e3.ddagujarati = 2721;
          e3.ddagurmukhi = 2593;
          e3.ddalarabic = 1672;
          e3.ddalfinalarabic = 64393;
          e3.dddhadeva = 2396;
          e3.ddhabengali = 2466;
          e3.ddhadeva = 2338;
          e3.ddhagujarati = 2722;
          e3.ddhagurmukhi = 2594;
          e3.ddotaccent = 7691;
          e3.ddotbelow = 7693;
          e3.decimalseparatorarabic = 1643;
          e3.decimalseparatorpersian = 1643;
          e3.decyrillic = 1076;
          e3.degree = 176;
          e3.dehihebrew = 1453;
          e3.dehiragana = 12391;
          e3.deicoptic = 1007;
          e3.dekatakana = 12487;
          e3.deleteleft = 9003;
          e3.deleteright = 8998;
          e3.delta = 948;
          e3.deltaturned = 397;
          e3.denominatorminusonenumeratorbengali = 2552;
          e3.dezh = 676;
          e3.dhabengali = 2471;
          e3.dhadeva = 2343;
          e3.dhagujarati = 2727;
          e3.dhagurmukhi = 2599;
          e3.dhook = 599;
          e3.dialytikatonos = 901;
          e3.dialytikatonoscmb = 836;
          e3.diamond = 9830;
          e3.diamondsuitwhite = 9826;
          e3.dieresis = 168;
          e3.dieresisacute = 63191;
          e3.dieresisbelowcmb = 804;
          e3.dieresiscmb = 776;
          e3.dieresisgrave = 63192;
          e3.dieresistonos = 901;
          e3.dihiragana = 12386;
          e3.dikatakana = 12482;
          e3.dittomark = 12291;
          e3.divide = 247;
          e3.divides = 8739;
          e3.divisionslash = 8725;
          e3.djecyrillic = 1106;
          e3.dkshade = 9619;
          e3.dlinebelow = 7695;
          e3.dlsquare = 13207;
          e3.dmacron = 273;
          e3.dmonospace = 65348;
          e3.dnblock = 9604;
          e3.dochadathai = 3598;
          e3.dodekthai = 3604;
          e3.dohiragana = 12393;
          e3.dokatakana = 12489;
          e3.dollar = 36;
          e3.dollarinferior = 63203;
          e3.dollarmonospace = 65284;
          e3.dollaroldstyle = 63268;
          e3.dollarsmall = 65129;
          e3.dollarsuperior = 63204;
          e3.dong = 8363;
          e3.dorusquare = 13094;
          e3.dotaccent = 729;
          e3.dotaccentcmb = 775;
          e3.dotbelowcmb = 803;
          e3.dotbelowcomb = 803;
          e3.dotkatakana = 12539;
          e3.dotlessi = 305;
          e3.dotlessj = 63166;
          e3.dotlessjstrokehook = 644;
          e3.dotmath = 8901;
          e3.dottedcircle = 9676;
          e3.doubleyodpatah = 64287;
          e3.doubleyodpatahhebrew = 64287;
          e3.downtackbelowcmb = 798;
          e3.downtackmod = 725;
          e3.dparen = 9375;
          e3.dsuperior = 63211;
          e3.dtail = 598;
          e3.dtopbar = 396;
          e3.duhiragana = 12389;
          e3.dukatakana = 12485;
          e3.dz = 499;
          e3.dzaltone = 675;
          e3.dzcaron = 454;
          e3.dzcurl = 677;
          e3.dzeabkhasiancyrillic = 1249;
          e3.dzecyrillic = 1109;
          e3.dzhecyrillic = 1119;
          e3.e = 101;
          e3.eacute = 233;
          e3.earth = 9793;
          e3.ebengali = 2447;
          e3.ebopomofo = 12572;
          e3.ebreve = 277;
          e3.ecandradeva = 2317;
          e3.ecandragujarati = 2701;
          e3.ecandravowelsigndeva = 2373;
          e3.ecandravowelsigngujarati = 2757;
          e3.ecaron = 283;
          e3.ecedillabreve = 7709;
          e3.echarmenian = 1381;
          e3.echyiwnarmenian = 1415;
          e3.ecircle = 9428;
          e3.ecircumflex = 234;
          e3.ecircumflexacute = 7871;
          e3.ecircumflexbelow = 7705;
          e3.ecircumflexdotbelow = 7879;
          e3.ecircumflexgrave = 7873;
          e3.ecircumflexhookabove = 7875;
          e3.ecircumflextilde = 7877;
          e3.ecyrillic = 1108;
          e3.edblgrave = 517;
          e3.edeva = 2319;
          e3.edieresis = 235;
          e3.edot = 279;
          e3.edotaccent = 279;
          e3.edotbelow = 7865;
          e3.eegurmukhi = 2575;
          e3.eematragurmukhi = 2631;
          e3.efcyrillic = 1092;
          e3.egrave = 232;
          e3.egujarati = 2703;
          e3.eharmenian = 1383;
          e3.ehbopomofo = 12573;
          e3.ehiragana = 12360;
          e3.ehookabove = 7867;
          e3.eibopomofo = 12575;
          e3.eight = 56;
          e3.eightarabic = 1640;
          e3.eightbengali = 2542;
          e3.eightcircle = 9319;
          e3.eightcircleinversesansserif = 10129;
          e3.eightdeva = 2414;
          e3.eighteencircle = 9329;
          e3.eighteenparen = 9349;
          e3.eighteenperiod = 9369;
          e3.eightgujarati = 2798;
          e3.eightgurmukhi = 2670;
          e3.eighthackarabic = 1640;
          e3.eighthangzhou = 12328;
          e3.eighthnotebeamed = 9835;
          e3.eightideographicparen = 12839;
          e3.eightinferior = 8328;
          e3.eightmonospace = 65304;
          e3.eightoldstyle = 63288;
          e3.eightparen = 9339;
          e3.eightperiod = 9359;
          e3.eightpersian = 1784;
          e3.eightroman = 8567;
          e3.eightsuperior = 8312;
          e3.eightthai = 3672;
          e3.einvertedbreve = 519;
          e3.eiotifiedcyrillic = 1125;
          e3.ekatakana = 12456;
          e3.ekatakanahalfwidth = 65396;
          e3.ekonkargurmukhi = 2676;
          e3.ekorean = 12628;
          e3.elcyrillic = 1083;
          e3.element = 8712;
          e3.elevencircle = 9322;
          e3.elevenparen = 9342;
          e3.elevenperiod = 9362;
          e3.elevenroman = 8570;
          e3.ellipsis = 8230;
          e3.ellipsisvertical = 8942;
          e3.emacron = 275;
          e3.emacronacute = 7703;
          e3.emacrongrave = 7701;
          e3.emcyrillic = 1084;
          e3.emdash = 8212;
          e3.emdashvertical = 65073;
          e3.emonospace = 65349;
          e3.emphasismarkarmenian = 1371;
          e3.emptyset = 8709;
          e3.enbopomofo = 12579;
          e3.encyrillic = 1085;
          e3.endash = 8211;
          e3.endashvertical = 65074;
          e3.endescendercyrillic = 1187;
          e3.eng = 331;
          e3.engbopomofo = 12581;
          e3.enghecyrillic = 1189;
          e3.enhookcyrillic = 1224;
          e3.enspace = 8194;
          e3.eogonek = 281;
          e3.eokorean = 12627;
          e3.eopen = 603;
          e3.eopenclosed = 666;
          e3.eopenreversed = 604;
          e3.eopenreversedclosed = 606;
          e3.eopenreversedhook = 605;
          e3.eparen = 9376;
          e3.epsilon = 949;
          e3.epsilontonos = 941;
          e3.equal = 61;
          e3.equalmonospace = 65309;
          e3.equalsmall = 65126;
          e3.equalsuperior = 8316;
          e3.equivalence = 8801;
          e3.erbopomofo = 12582;
          e3.ercyrillic = 1088;
          e3.ereversed = 600;
          e3.ereversedcyrillic = 1101;
          e3.escyrillic = 1089;
          e3.esdescendercyrillic = 1195;
          e3.esh = 643;
          e3.eshcurl = 646;
          e3.eshortdeva = 2318;
          e3.eshortvowelsigndeva = 2374;
          e3.eshreversedloop = 426;
          e3.eshsquatreversed = 645;
          e3.esmallhiragana = 12359;
          e3.esmallkatakana = 12455;
          e3.esmallkatakanahalfwidth = 65386;
          e3.estimated = 8494;
          e3.esuperior = 63212;
          e3.eta = 951;
          e3.etarmenian = 1384;
          e3.etatonos = 942;
          e3.eth = 240;
          e3.etilde = 7869;
          e3.etildebelow = 7707;
          e3.etnahtafoukhhebrew = 1425;
          e3.etnahtafoukhlefthebrew = 1425;
          e3.etnahtahebrew = 1425;
          e3.etnahtalefthebrew = 1425;
          e3.eturned = 477;
          e3.eukorean = 12641;
          e3.euro = 8364;
          e3.evowelsignbengali = 2503;
          e3.evowelsigndeva = 2375;
          e3.evowelsigngujarati = 2759;
          e3.exclam = 33;
          e3.exclamarmenian = 1372;
          e3.exclamdbl = 8252;
          e3.exclamdown = 161;
          e3.exclamdownsmall = 63393;
          e3.exclammonospace = 65281;
          e3.exclamsmall = 63265;
          e3.existential = 8707;
          e3.ezh = 658;
          e3.ezhcaron = 495;
          e3.ezhcurl = 659;
          e3.ezhreversed = 441;
          e3.ezhtail = 442;
          e3.f = 102;
          e3.fadeva = 2398;
          e3.fagurmukhi = 2654;
          e3.fahrenheit = 8457;
          e3.fathaarabic = 1614;
          e3.fathalowarabic = 1614;
          e3.fathatanarabic = 1611;
          e3.fbopomofo = 12552;
          e3.fcircle = 9429;
          e3.fdotaccent = 7711;
          e3.feharabic = 1601;
          e3.feharmenian = 1414;
          e3.fehfinalarabic = 65234;
          e3.fehinitialarabic = 65235;
          e3.fehmedialarabic = 65236;
          e3.feicoptic = 997;
          e3.female = 9792;
          e3.ff = 64256;
          e3.f_f = 64256;
          e3.ffi = 64259;
          e3.f_f_i = 64259;
          e3.ffl = 64260;
          e3.f_f_l = 64260;
          e3.fi = 64257;
          e3.f_i = 64257;
          e3.fifteencircle = 9326;
          e3.fifteenparen = 9346;
          e3.fifteenperiod = 9366;
          e3.figuredash = 8210;
          e3.filledbox = 9632;
          e3.filledrect = 9644;
          e3.finalkaf = 1498;
          e3.finalkafdagesh = 64314;
          e3.finalkafdageshhebrew = 64314;
          e3.finalkafhebrew = 1498;
          e3.finalmem = 1501;
          e3.finalmemhebrew = 1501;
          e3.finalnun = 1503;
          e3.finalnunhebrew = 1503;
          e3.finalpe = 1507;
          e3.finalpehebrew = 1507;
          e3.finaltsadi = 1509;
          e3.finaltsadihebrew = 1509;
          e3.firsttonechinese = 713;
          e3.fisheye = 9673;
          e3.fitacyrillic = 1139;
          e3.five = 53;
          e3.fivearabic = 1637;
          e3.fivebengali = 2539;
          e3.fivecircle = 9316;
          e3.fivecircleinversesansserif = 10126;
          e3.fivedeva = 2411;
          e3.fiveeighths = 8541;
          e3.fivegujarati = 2795;
          e3.fivegurmukhi = 2667;
          e3.fivehackarabic = 1637;
          e3.fivehangzhou = 12325;
          e3.fiveideographicparen = 12836;
          e3.fiveinferior = 8325;
          e3.fivemonospace = 65301;
          e3.fiveoldstyle = 63285;
          e3.fiveparen = 9336;
          e3.fiveperiod = 9356;
          e3.fivepersian = 1781;
          e3.fiveroman = 8564;
          e3.fivesuperior = 8309;
          e3.fivethai = 3669;
          e3.fl = 64258;
          e3.f_l = 64258;
          e3.florin = 402;
          e3.fmonospace = 65350;
          e3.fmsquare = 13209;
          e3.fofanthai = 3615;
          e3.fofathai = 3613;
          e3.fongmanthai = 3663;
          e3.forall = 8704;
          e3.four = 52;
          e3.fourarabic = 1636;
          e3.fourbengali = 2538;
          e3.fourcircle = 9315;
          e3.fourcircleinversesansserif = 10125;
          e3.fourdeva = 2410;
          e3.fourgujarati = 2794;
          e3.fourgurmukhi = 2666;
          e3.fourhackarabic = 1636;
          e3.fourhangzhou = 12324;
          e3.fourideographicparen = 12835;
          e3.fourinferior = 8324;
          e3.fourmonospace = 65300;
          e3.fournumeratorbengali = 2551;
          e3.fouroldstyle = 63284;
          e3.fourparen = 9335;
          e3.fourperiod = 9355;
          e3.fourpersian = 1780;
          e3.fourroman = 8563;
          e3.foursuperior = 8308;
          e3.fourteencircle = 9325;
          e3.fourteenparen = 9345;
          e3.fourteenperiod = 9365;
          e3.fourthai = 3668;
          e3.fourthtonechinese = 715;
          e3.fparen = 9377;
          e3.fraction = 8260;
          e3.franc = 8355;
          e3.g = 103;
          e3.gabengali = 2455;
          e3.gacute = 501;
          e3.gadeva = 2327;
          e3.gafarabic = 1711;
          e3.gaffinalarabic = 64403;
          e3.gafinitialarabic = 64404;
          e3.gafmedialarabic = 64405;
          e3.gagujarati = 2711;
          e3.gagurmukhi = 2583;
          e3.gahiragana = 12364;
          e3.gakatakana = 12460;
          e3.gamma = 947;
          e3.gammalatinsmall = 611;
          e3.gammasuperior = 736;
          e3.gangiacoptic = 1003;
          e3.gbopomofo = 12557;
          e3.gbreve = 287;
          e3.gcaron = 487;
          e3.gcedilla = 291;
          e3.gcircle = 9430;
          e3.gcircumflex = 285;
          e3.gcommaaccent = 291;
          e3.gdot = 289;
          e3.gdotaccent = 289;
          e3.gecyrillic = 1075;
          e3.gehiragana = 12370;
          e3.gekatakana = 12466;
          e3.geometricallyequal = 8785;
          e3.gereshaccenthebrew = 1436;
          e3.gereshhebrew = 1523;
          e3.gereshmuqdamhebrew = 1437;
          e3.germandbls = 223;
          e3.gershayimaccenthebrew = 1438;
          e3.gershayimhebrew = 1524;
          e3.getamark = 12307;
          e3.ghabengali = 2456;
          e3.ghadarmenian = 1394;
          e3.ghadeva = 2328;
          e3.ghagujarati = 2712;
          e3.ghagurmukhi = 2584;
          e3.ghainarabic = 1594;
          e3.ghainfinalarabic = 65230;
          e3.ghaininitialarabic = 65231;
          e3.ghainmedialarabic = 65232;
          e3.ghemiddlehookcyrillic = 1173;
          e3.ghestrokecyrillic = 1171;
          e3.gheupturncyrillic = 1169;
          e3.ghhadeva = 2394;
          e3.ghhagurmukhi = 2650;
          e3.ghook = 608;
          e3.ghzsquare = 13203;
          e3.gihiragana = 12366;
          e3.gikatakana = 12462;
          e3.gimarmenian = 1379;
          e3.gimel = 1490;
          e3.gimeldagesh = 64306;
          e3.gimeldageshhebrew = 64306;
          e3.gimelhebrew = 1490;
          e3.gjecyrillic = 1107;
          e3.glottalinvertedstroke = 446;
          e3.glottalstop = 660;
          e3.glottalstopinverted = 662;
          e3.glottalstopmod = 704;
          e3.glottalstopreversed = 661;
          e3.glottalstopreversedmod = 705;
          e3.glottalstopreversedsuperior = 740;
          e3.glottalstopstroke = 673;
          e3.glottalstopstrokereversed = 674;
          e3.gmacron = 7713;
          e3.gmonospace = 65351;
          e3.gohiragana = 12372;
          e3.gokatakana = 12468;
          e3.gparen = 9378;
          e3.gpasquare = 13228;
          e3.gradient = 8711;
          e3.grave = 96;
          e3.gravebelowcmb = 790;
          e3.gravecmb = 768;
          e3.gravecomb = 768;
          e3.gravedeva = 2387;
          e3.gravelowmod = 718;
          e3.gravemonospace = 65344;
          e3.gravetonecmb = 832;
          e3.greater = 62;
          e3.greaterequal = 8805;
          e3.greaterequalorless = 8923;
          e3.greatermonospace = 65310;
          e3.greaterorequivalent = 8819;
          e3.greaterorless = 8823;
          e3.greateroverequal = 8807;
          e3.greatersmall = 65125;
          e3.gscript = 609;
          e3.gstroke = 485;
          e3.guhiragana = 12368;
          e3.guillemotleft = 171;
          e3.guillemotright = 187;
          e3.guilsinglleft = 8249;
          e3.guilsinglright = 8250;
          e3.gukatakana = 12464;
          e3.guramusquare = 13080;
          e3.gysquare = 13257;
          e3.h = 104;
          e3.haabkhasiancyrillic = 1193;
          e3.haaltonearabic = 1729;
          e3.habengali = 2489;
          e3.hadescendercyrillic = 1203;
          e3.hadeva = 2361;
          e3.hagujarati = 2745;
          e3.hagurmukhi = 2617;
          e3.haharabic = 1581;
          e3.hahfinalarabic = 65186;
          e3.hahinitialarabic = 65187;
          e3.hahiragana = 12399;
          e3.hahmedialarabic = 65188;
          e3.haitusquare = 13098;
          e3.hakatakana = 12495;
          e3.hakatakanahalfwidth = 65418;
          e3.halantgurmukhi = 2637;
          e3.hamzaarabic = 1569;
          e3.hamzalowarabic = 1569;
          e3.hangulfiller = 12644;
          e3.hardsigncyrillic = 1098;
          e3.harpoonleftbarbup = 8636;
          e3.harpoonrightbarbup = 8640;
          e3.hasquare = 13258;
          e3.hatafpatah = 1458;
          e3.hatafpatah16 = 1458;
          e3.hatafpatah23 = 1458;
          e3.hatafpatah2f = 1458;
          e3.hatafpatahhebrew = 1458;
          e3.hatafpatahnarrowhebrew = 1458;
          e3.hatafpatahquarterhebrew = 1458;
          e3.hatafpatahwidehebrew = 1458;
          e3.hatafqamats = 1459;
          e3.hatafqamats1b = 1459;
          e3.hatafqamats28 = 1459;
          e3.hatafqamats34 = 1459;
          e3.hatafqamatshebrew = 1459;
          e3.hatafqamatsnarrowhebrew = 1459;
          e3.hatafqamatsquarterhebrew = 1459;
          e3.hatafqamatswidehebrew = 1459;
          e3.hatafsegol = 1457;
          e3.hatafsegol17 = 1457;
          e3.hatafsegol24 = 1457;
          e3.hatafsegol30 = 1457;
          e3.hatafsegolhebrew = 1457;
          e3.hatafsegolnarrowhebrew = 1457;
          e3.hatafsegolquarterhebrew = 1457;
          e3.hatafsegolwidehebrew = 1457;
          e3.hbar = 295;
          e3.hbopomofo = 12559;
          e3.hbrevebelow = 7723;
          e3.hcedilla = 7721;
          e3.hcircle = 9431;
          e3.hcircumflex = 293;
          e3.hdieresis = 7719;
          e3.hdotaccent = 7715;
          e3.hdotbelow = 7717;
          e3.he = 1492;
          e3.heart = 9829;
          e3.heartsuitblack = 9829;
          e3.heartsuitwhite = 9825;
          e3.hedagesh = 64308;
          e3.hedageshhebrew = 64308;
          e3.hehaltonearabic = 1729;
          e3.heharabic = 1607;
          e3.hehebrew = 1492;
          e3.hehfinalaltonearabic = 64423;
          e3.hehfinalalttwoarabic = 65258;
          e3.hehfinalarabic = 65258;
          e3.hehhamzaabovefinalarabic = 64421;
          e3.hehhamzaaboveisolatedarabic = 64420;
          e3.hehinitialaltonearabic = 64424;
          e3.hehinitialarabic = 65259;
          e3.hehiragana = 12408;
          e3.hehmedialaltonearabic = 64425;
          e3.hehmedialarabic = 65260;
          e3.heiseierasquare = 13179;
          e3.hekatakana = 12504;
          e3.hekatakanahalfwidth = 65421;
          e3.hekutaarusquare = 13110;
          e3.henghook = 615;
          e3.herutusquare = 13113;
          e3.het = 1495;
          e3.hethebrew = 1495;
          e3.hhook = 614;
          e3.hhooksuperior = 689;
          e3.hieuhacirclekorean = 12923;
          e3.hieuhaparenkorean = 12827;
          e3.hieuhcirclekorean = 12909;
          e3.hieuhkorean = 12622;
          e3.hieuhparenkorean = 12813;
          e3.hihiragana = 12402;
          e3.hikatakana = 12498;
          e3.hikatakanahalfwidth = 65419;
          e3.hiriq = 1460;
          e3.hiriq14 = 1460;
          e3.hiriq21 = 1460;
          e3.hiriq2d = 1460;
          e3.hiriqhebrew = 1460;
          e3.hiriqnarrowhebrew = 1460;
          e3.hiriqquarterhebrew = 1460;
          e3.hiriqwidehebrew = 1460;
          e3.hlinebelow = 7830;
          e3.hmonospace = 65352;
          e3.hoarmenian = 1392;
          e3.hohipthai = 3627;
          e3.hohiragana = 12411;
          e3.hokatakana = 12507;
          e3.hokatakanahalfwidth = 65422;
          e3.holam = 1465;
          e3.holam19 = 1465;
          e3.holam26 = 1465;
          e3.holam32 = 1465;
          e3.holamhebrew = 1465;
          e3.holamnarrowhebrew = 1465;
          e3.holamquarterhebrew = 1465;
          e3.holamwidehebrew = 1465;
          e3.honokhukthai = 3630;
          e3.hookabovecomb = 777;
          e3.hookcmb = 777;
          e3.hookpalatalizedbelowcmb = 801;
          e3.hookretroflexbelowcmb = 802;
          e3.hoonsquare = 13122;
          e3.horicoptic = 1001;
          e3.horizontalbar = 8213;
          e3.horncmb = 795;
          e3.hotsprings = 9832;
          e3.house = 8962;
          e3.hparen = 9379;
          e3.hsuperior = 688;
          e3.hturned = 613;
          e3.huhiragana = 12405;
          e3.huiitosquare = 13107;
          e3.hukatakana = 12501;
          e3.hukatakanahalfwidth = 65420;
          e3.hungarumlaut = 733;
          e3.hungarumlautcmb = 779;
          e3.hv = 405;
          e3.hyphen = 45;
          e3.hypheninferior = 63205;
          e3.hyphenmonospace = 65293;
          e3.hyphensmall = 65123;
          e3.hyphensuperior = 63206;
          e3.hyphentwo = 8208;
          e3.i = 105;
          e3.iacute = 237;
          e3.iacyrillic = 1103;
          e3.ibengali = 2439;
          e3.ibopomofo = 12583;
          e3.ibreve = 301;
          e3.icaron = 464;
          e3.icircle = 9432;
          e3.icircumflex = 238;
          e3.icyrillic = 1110;
          e3.idblgrave = 521;
          e3.ideographearthcircle = 12943;
          e3.ideographfirecircle = 12939;
          e3.ideographicallianceparen = 12863;
          e3.ideographiccallparen = 12858;
          e3.ideographiccentrecircle = 12965;
          e3.ideographicclose = 12294;
          e3.ideographiccomma = 12289;
          e3.ideographiccommaleft = 65380;
          e3.ideographiccongratulationparen = 12855;
          e3.ideographiccorrectcircle = 12963;
          e3.ideographicearthparen = 12847;
          e3.ideographicenterpriseparen = 12861;
          e3.ideographicexcellentcircle = 12957;
          e3.ideographicfestivalparen = 12864;
          e3.ideographicfinancialcircle = 12950;
          e3.ideographicfinancialparen = 12854;
          e3.ideographicfireparen = 12843;
          e3.ideographichaveparen = 12850;
          e3.ideographichighcircle = 12964;
          e3.ideographiciterationmark = 12293;
          e3.ideographiclaborcircle = 12952;
          e3.ideographiclaborparen = 12856;
          e3.ideographicleftcircle = 12967;
          e3.ideographiclowcircle = 12966;
          e3.ideographicmedicinecircle = 12969;
          e3.ideographicmetalparen = 12846;
          e3.ideographicmoonparen = 12842;
          e3.ideographicnameparen = 12852;
          e3.ideographicperiod = 12290;
          e3.ideographicprintcircle = 12958;
          e3.ideographicreachparen = 12867;
          e3.ideographicrepresentparen = 12857;
          e3.ideographicresourceparen = 12862;
          e3.ideographicrightcircle = 12968;
          e3.ideographicsecretcircle = 12953;
          e3.ideographicselfparen = 12866;
          e3.ideographicsocietyparen = 12851;
          e3.ideographicspace = 12288;
          e3.ideographicspecialparen = 12853;
          e3.ideographicstockparen = 12849;
          e3.ideographicstudyparen = 12859;
          e3.ideographicsunparen = 12848;
          e3.ideographicsuperviseparen = 12860;
          e3.ideographicwaterparen = 12844;
          e3.ideographicwoodparen = 12845;
          e3.ideographiczero = 12295;
          e3.ideographmetalcircle = 12942;
          e3.ideographmooncircle = 12938;
          e3.ideographnamecircle = 12948;
          e3.ideographsuncircle = 12944;
          e3.ideographwatercircle = 12940;
          e3.ideographwoodcircle = 12941;
          e3.ideva = 2311;
          e3.idieresis = 239;
          e3.idieresisacute = 7727;
          e3.idieresiscyrillic = 1253;
          e3.idotbelow = 7883;
          e3.iebrevecyrillic = 1239;
          e3.iecyrillic = 1077;
          e3.ieungacirclekorean = 12917;
          e3.ieungaparenkorean = 12821;
          e3.ieungcirclekorean = 12903;
          e3.ieungkorean = 12615;
          e3.ieungparenkorean = 12807;
          e3.igrave = 236;
          e3.igujarati = 2695;
          e3.igurmukhi = 2567;
          e3.ihiragana = 12356;
          e3.ihookabove = 7881;
          e3.iibengali = 2440;
          e3.iicyrillic = 1080;
          e3.iideva = 2312;
          e3.iigujarati = 2696;
          e3.iigurmukhi = 2568;
          e3.iimatragurmukhi = 2624;
          e3.iinvertedbreve = 523;
          e3.iishortcyrillic = 1081;
          e3.iivowelsignbengali = 2496;
          e3.iivowelsigndeva = 2368;
          e3.iivowelsigngujarati = 2752;
          e3.ij = 307;
          e3.ikatakana = 12452;
          e3.ikatakanahalfwidth = 65394;
          e3.ikorean = 12643;
          e3.ilde = 732;
          e3.iluyhebrew = 1452;
          e3.imacron = 299;
          e3.imacroncyrillic = 1251;
          e3.imageorapproximatelyequal = 8787;
          e3.imatragurmukhi = 2623;
          e3.imonospace = 65353;
          e3.increment = 8710;
          e3.infinity = 8734;
          e3.iniarmenian = 1387;
          e3.integral = 8747;
          e3.integralbottom = 8993;
          e3.integralbt = 8993;
          e3.integralex = 63733;
          e3.integraltop = 8992;
          e3.integraltp = 8992;
          e3.intersection = 8745;
          e3.intisquare = 13061;
          e3.invbullet = 9688;
          e3.invcircle = 9689;
          e3.invsmileface = 9787;
          e3.iocyrillic = 1105;
          e3.iogonek = 303;
          e3.iota = 953;
          e3.iotadieresis = 970;
          e3.iotadieresistonos = 912;
          e3.iotalatin = 617;
          e3.iotatonos = 943;
          e3.iparen = 9380;
          e3.irigurmukhi = 2674;
          e3.ismallhiragana = 12355;
          e3.ismallkatakana = 12451;
          e3.ismallkatakanahalfwidth = 65384;
          e3.issharbengali = 2554;
          e3.istroke = 616;
          e3.isuperior = 63213;
          e3.iterationhiragana = 12445;
          e3.iterationkatakana = 12541;
          e3.itilde = 297;
          e3.itildebelow = 7725;
          e3.iubopomofo = 12585;
          e3.iucyrillic = 1102;
          e3.ivowelsignbengali = 2495;
          e3.ivowelsigndeva = 2367;
          e3.ivowelsigngujarati = 2751;
          e3.izhitsacyrillic = 1141;
          e3.izhitsadblgravecyrillic = 1143;
          e3.j = 106;
          e3.jaarmenian = 1393;
          e3.jabengali = 2460;
          e3.jadeva = 2332;
          e3.jagujarati = 2716;
          e3.jagurmukhi = 2588;
          e3.jbopomofo = 12560;
          e3.jcaron = 496;
          e3.jcircle = 9433;
          e3.jcircumflex = 309;
          e3.jcrossedtail = 669;
          e3.jdotlessstroke = 607;
          e3.jecyrillic = 1112;
          e3.jeemarabic = 1580;
          e3.jeemfinalarabic = 65182;
          e3.jeeminitialarabic = 65183;
          e3.jeemmedialarabic = 65184;
          e3.jeharabic = 1688;
          e3.jehfinalarabic = 64395;
          e3.jhabengali = 2461;
          e3.jhadeva = 2333;
          e3.jhagujarati = 2717;
          e3.jhagurmukhi = 2589;
          e3.jheharmenian = 1403;
          e3.jis = 12292;
          e3.jmonospace = 65354;
          e3.jparen = 9381;
          e3.jsuperior = 690;
          e3.k = 107;
          e3.kabashkircyrillic = 1185;
          e3.kabengali = 2453;
          e3.kacute = 7729;
          e3.kacyrillic = 1082;
          e3.kadescendercyrillic = 1179;
          e3.kadeva = 2325;
          e3.kaf = 1499;
          e3.kafarabic = 1603;
          e3.kafdagesh = 64315;
          e3.kafdageshhebrew = 64315;
          e3.kaffinalarabic = 65242;
          e3.kafhebrew = 1499;
          e3.kafinitialarabic = 65243;
          e3.kafmedialarabic = 65244;
          e3.kafrafehebrew = 64333;
          e3.kagujarati = 2709;
          e3.kagurmukhi = 2581;
          e3.kahiragana = 12363;
          e3.kahookcyrillic = 1220;
          e3.kakatakana = 12459;
          e3.kakatakanahalfwidth = 65398;
          e3.kappa = 954;
          e3.kappasymbolgreek = 1008;
          e3.kapyeounmieumkorean = 12657;
          e3.kapyeounphieuphkorean = 12676;
          e3.kapyeounpieupkorean = 12664;
          e3.kapyeounssangpieupkorean = 12665;
          e3.karoriisquare = 13069;
          e3.kashidaautoarabic = 1600;
          e3.kashidaautonosidebearingarabic = 1600;
          e3.kasmallkatakana = 12533;
          e3.kasquare = 13188;
          e3.kasraarabic = 1616;
          e3.kasratanarabic = 1613;
          e3.kastrokecyrillic = 1183;
          e3.katahiraprolongmarkhalfwidth = 65392;
          e3.kaverticalstrokecyrillic = 1181;
          e3.kbopomofo = 12558;
          e3.kcalsquare = 13193;
          e3.kcaron = 489;
          e3.kcedilla = 311;
          e3.kcircle = 9434;
          e3.kcommaaccent = 311;
          e3.kdotbelow = 7731;
          e3.keharmenian = 1412;
          e3.kehiragana = 12369;
          e3.kekatakana = 12465;
          e3.kekatakanahalfwidth = 65401;
          e3.kenarmenian = 1391;
          e3.kesmallkatakana = 12534;
          e3.kgreenlandic = 312;
          e3.khabengali = 2454;
          e3.khacyrillic = 1093;
          e3.khadeva = 2326;
          e3.khagujarati = 2710;
          e3.khagurmukhi = 2582;
          e3.khaharabic = 1582;
          e3.khahfinalarabic = 65190;
          e3.khahinitialarabic = 65191;
          e3.khahmedialarabic = 65192;
          e3.kheicoptic = 999;
          e3.khhadeva = 2393;
          e3.khhagurmukhi = 2649;
          e3.khieukhacirclekorean = 12920;
          e3.khieukhaparenkorean = 12824;
          e3.khieukhcirclekorean = 12906;
          e3.khieukhkorean = 12619;
          e3.khieukhparenkorean = 12810;
          e3.khokhaithai = 3586;
          e3.khokhonthai = 3589;
          e3.khokhuatthai = 3587;
          e3.khokhwaithai = 3588;
          e3.khomutthai = 3675;
          e3.khook = 409;
          e3.khorakhangthai = 3590;
          e3.khzsquare = 13201;
          e3.kihiragana = 12365;
          e3.kikatakana = 12461;
          e3.kikatakanahalfwidth = 65399;
          e3.kiroguramusquare = 13077;
          e3.kiromeetorusquare = 13078;
          e3.kirosquare = 13076;
          e3.kiyeokacirclekorean = 12910;
          e3.kiyeokaparenkorean = 12814;
          e3.kiyeokcirclekorean = 12896;
          e3.kiyeokkorean = 12593;
          e3.kiyeokparenkorean = 12800;
          e3.kiyeoksioskorean = 12595;
          e3.kjecyrillic = 1116;
          e3.klinebelow = 7733;
          e3.klsquare = 13208;
          e3.kmcubedsquare = 13222;
          e3.kmonospace = 65355;
          e3.kmsquaredsquare = 13218;
          e3.kohiragana = 12371;
          e3.kohmsquare = 13248;
          e3.kokaithai = 3585;
          e3.kokatakana = 12467;
          e3.kokatakanahalfwidth = 65402;
          e3.kooposquare = 13086;
          e3.koppacyrillic = 1153;
          e3.koreanstandardsymbol = 12927;
          e3.koroniscmb = 835;
          e3.kparen = 9382;
          e3.kpasquare = 13226;
          e3.ksicyrillic = 1135;
          e3.ktsquare = 13263;
          e3.kturned = 670;
          e3.kuhiragana = 12367;
          e3.kukatakana = 12463;
          e3.kukatakanahalfwidth = 65400;
          e3.kvsquare = 13240;
          e3.kwsquare = 13246;
          e3.l = 108;
          e3.labengali = 2482;
          e3.lacute = 314;
          e3.ladeva = 2354;
          e3.lagujarati = 2738;
          e3.lagurmukhi = 2610;
          e3.lakkhangyaothai = 3653;
          e3.lamaleffinalarabic = 65276;
          e3.lamalefhamzaabovefinalarabic = 65272;
          e3.lamalefhamzaaboveisolatedarabic = 65271;
          e3.lamalefhamzabelowfinalarabic = 65274;
          e3.lamalefhamzabelowisolatedarabic = 65273;
          e3.lamalefisolatedarabic = 65275;
          e3.lamalefmaddaabovefinalarabic = 65270;
          e3.lamalefmaddaaboveisolatedarabic = 65269;
          e3.lamarabic = 1604;
          e3.lambda = 955;
          e3.lambdastroke = 411;
          e3.lamed = 1500;
          e3.lameddagesh = 64316;
          e3.lameddageshhebrew = 64316;
          e3.lamedhebrew = 1500;
          e3.lamfinalarabic = 65246;
          e3.lamhahinitialarabic = 64714;
          e3.laminitialarabic = 65247;
          e3.lamjeeminitialarabic = 64713;
          e3.lamkhahinitialarabic = 64715;
          e3.lamlamhehisolatedarabic = 65010;
          e3.lammedialarabic = 65248;
          e3.lammeemhahinitialarabic = 64904;
          e3.lammeeminitialarabic = 64716;
          e3.largecircle = 9711;
          e3.lbar = 410;
          e3.lbelt = 620;
          e3.lbopomofo = 12556;
          e3.lcaron = 318;
          e3.lcedilla = 316;
          e3.lcircle = 9435;
          e3.lcircumflexbelow = 7741;
          e3.lcommaaccent = 316;
          e3.ldot = 320;
          e3.ldotaccent = 320;
          e3.ldotbelow = 7735;
          e3.ldotbelowmacron = 7737;
          e3.leftangleabovecmb = 794;
          e3.lefttackbelowcmb = 792;
          e3.less = 60;
          e3.lessequal = 8804;
          e3.lessequalorgreater = 8922;
          e3.lessmonospace = 65308;
          e3.lessorequivalent = 8818;
          e3.lessorgreater = 8822;
          e3.lessoverequal = 8806;
          e3.lesssmall = 65124;
          e3.lezh = 622;
          e3.lfblock = 9612;
          e3.lhookretroflex = 621;
          e3.lira = 8356;
          e3.liwnarmenian = 1388;
          e3.lj = 457;
          e3.ljecyrillic = 1113;
          e3.ll = 63168;
          e3.lladeva = 2355;
          e3.llagujarati = 2739;
          e3.llinebelow = 7739;
          e3.llladeva = 2356;
          e3.llvocalicbengali = 2529;
          e3.llvocalicdeva = 2401;
          e3.llvocalicvowelsignbengali = 2531;
          e3.llvocalicvowelsigndeva = 2403;
          e3.lmiddletilde = 619;
          e3.lmonospace = 65356;
          e3.lmsquare = 13264;
          e3.lochulathai = 3628;
          e3.logicaland = 8743;
          e3.logicalnot = 172;
          e3.logicalnotreversed = 8976;
          e3.logicalor = 8744;
          e3.lolingthai = 3621;
          e3.longs = 383;
          e3.lowlinecenterline = 65102;
          e3.lowlinecmb = 818;
          e3.lowlinedashed = 65101;
          e3.lozenge = 9674;
          e3.lparen = 9383;
          e3.lslash = 322;
          e3.lsquare = 8467;
          e3.lsuperior = 63214;
          e3.ltshade = 9617;
          e3.luthai = 3622;
          e3.lvocalicbengali = 2444;
          e3.lvocalicdeva = 2316;
          e3.lvocalicvowelsignbengali = 2530;
          e3.lvocalicvowelsigndeva = 2402;
          e3.lxsquare = 13267;
          e3.m = 109;
          e3.mabengali = 2478;
          e3.macron = 175;
          e3.macronbelowcmb = 817;
          e3.macroncmb = 772;
          e3.macronlowmod = 717;
          e3.macronmonospace = 65507;
          e3.macute = 7743;
          e3.madeva = 2350;
          e3.magujarati = 2734;
          e3.magurmukhi = 2606;
          e3.mahapakhhebrew = 1444;
          e3.mahapakhlefthebrew = 1444;
          e3.mahiragana = 12414;
          e3.maichattawalowleftthai = 63637;
          e3.maichattawalowrightthai = 63636;
          e3.maichattawathai = 3659;
          e3.maichattawaupperleftthai = 63635;
          e3.maieklowleftthai = 63628;
          e3.maieklowrightthai = 63627;
          e3.maiekthai = 3656;
          e3.maiekupperleftthai = 63626;
          e3.maihanakatleftthai = 63620;
          e3.maihanakatthai = 3633;
          e3.maitaikhuleftthai = 63625;
          e3.maitaikhuthai = 3655;
          e3.maitholowleftthai = 63631;
          e3.maitholowrightthai = 63630;
          e3.maithothai = 3657;
          e3.maithoupperleftthai = 63629;
          e3.maitrilowleftthai = 63634;
          e3.maitrilowrightthai = 63633;
          e3.maitrithai = 3658;
          e3.maitriupperleftthai = 63632;
          e3.maiyamokthai = 3654;
          e3.makatakana = 12510;
          e3.makatakanahalfwidth = 65423;
          e3.male = 9794;
          e3.mansyonsquare = 13127;
          e3.maqafhebrew = 1470;
          e3.mars = 9794;
          e3.masoracirclehebrew = 1455;
          e3.masquare = 13187;
          e3.mbopomofo = 12551;
          e3.mbsquare = 13268;
          e3.mcircle = 9436;
          e3.mcubedsquare = 13221;
          e3.mdotaccent = 7745;
          e3.mdotbelow = 7747;
          e3.meemarabic = 1605;
          e3.meemfinalarabic = 65250;
          e3.meeminitialarabic = 65251;
          e3.meemmedialarabic = 65252;
          e3.meemmeeminitialarabic = 64721;
          e3.meemmeemisolatedarabic = 64584;
          e3.meetorusquare = 13133;
          e3.mehiragana = 12417;
          e3.meizierasquare = 13182;
          e3.mekatakana = 12513;
          e3.mekatakanahalfwidth = 65426;
          e3.mem = 1502;
          e3.memdagesh = 64318;
          e3.memdageshhebrew = 64318;
          e3.memhebrew = 1502;
          e3.menarmenian = 1396;
          e3.merkhahebrew = 1445;
          e3.merkhakefulahebrew = 1446;
          e3.merkhakefulalefthebrew = 1446;
          e3.merkhalefthebrew = 1445;
          e3.mhook = 625;
          e3.mhzsquare = 13202;
          e3.middledotkatakanahalfwidth = 65381;
          e3.middot = 183;
          e3.mieumacirclekorean = 12914;
          e3.mieumaparenkorean = 12818;
          e3.mieumcirclekorean = 12900;
          e3.mieumkorean = 12609;
          e3.mieumpansioskorean = 12656;
          e3.mieumparenkorean = 12804;
          e3.mieumpieupkorean = 12654;
          e3.mieumsioskorean = 12655;
          e3.mihiragana = 12415;
          e3.mikatakana = 12511;
          e3.mikatakanahalfwidth = 65424;
          e3.minus = 8722;
          e3.minusbelowcmb = 800;
          e3.minuscircle = 8854;
          e3.minusmod = 727;
          e3.minusplus = 8723;
          e3.minute = 8242;
          e3.miribaarusquare = 13130;
          e3.mirisquare = 13129;
          e3.mlonglegturned = 624;
          e3.mlsquare = 13206;
          e3.mmcubedsquare = 13219;
          e3.mmonospace = 65357;
          e3.mmsquaredsquare = 13215;
          e3.mohiragana = 12418;
          e3.mohmsquare = 13249;
          e3.mokatakana = 12514;
          e3.mokatakanahalfwidth = 65427;
          e3.molsquare = 13270;
          e3.momathai = 3617;
          e3.moverssquare = 13223;
          e3.moverssquaredsquare = 13224;
          e3.mparen = 9384;
          e3.mpasquare = 13227;
          e3.mssquare = 13235;
          e3.msuperior = 63215;
          e3.mturned = 623;
          e3.mu = 181;
          e3.mu1 = 181;
          e3.muasquare = 13186;
          e3.muchgreater = 8811;
          e3.muchless = 8810;
          e3.mufsquare = 13196;
          e3.mugreek = 956;
          e3.mugsquare = 13197;
          e3.muhiragana = 12416;
          e3.mukatakana = 12512;
          e3.mukatakanahalfwidth = 65425;
          e3.mulsquare = 13205;
          e3.multiply = 215;
          e3.mumsquare = 13211;
          e3.munahhebrew = 1443;
          e3.munahlefthebrew = 1443;
          e3.musicalnote = 9834;
          e3.musicalnotedbl = 9835;
          e3.musicflatsign = 9837;
          e3.musicsharpsign = 9839;
          e3.mussquare = 13234;
          e3.muvsquare = 13238;
          e3.muwsquare = 13244;
          e3.mvmegasquare = 13241;
          e3.mvsquare = 13239;
          e3.mwmegasquare = 13247;
          e3.mwsquare = 13245;
          e3.n = 110;
          e3.nabengali = 2472;
          e3.nabla = 8711;
          e3.nacute = 324;
          e3.nadeva = 2344;
          e3.nagujarati = 2728;
          e3.nagurmukhi = 2600;
          e3.nahiragana = 12394;
          e3.nakatakana = 12490;
          e3.nakatakanahalfwidth = 65413;
          e3.napostrophe = 329;
          e3.nasquare = 13185;
          e3.nbopomofo = 12555;
          e3.nbspace = 160;
          e3.ncaron = 328;
          e3.ncedilla = 326;
          e3.ncircle = 9437;
          e3.ncircumflexbelow = 7755;
          e3.ncommaaccent = 326;
          e3.ndotaccent = 7749;
          e3.ndotbelow = 7751;
          e3.nehiragana = 12397;
          e3.nekatakana = 12493;
          e3.nekatakanahalfwidth = 65416;
          e3.newsheqelsign = 8362;
          e3.nfsquare = 13195;
          e3.ngabengali = 2457;
          e3.ngadeva = 2329;
          e3.ngagujarati = 2713;
          e3.ngagurmukhi = 2585;
          e3.ngonguthai = 3591;
          e3.nhiragana = 12435;
          e3.nhookleft = 626;
          e3.nhookretroflex = 627;
          e3.nieunacirclekorean = 12911;
          e3.nieunaparenkorean = 12815;
          e3.nieuncieuckorean = 12597;
          e3.nieuncirclekorean = 12897;
          e3.nieunhieuhkorean = 12598;
          e3.nieunkorean = 12596;
          e3.nieunpansioskorean = 12648;
          e3.nieunparenkorean = 12801;
          e3.nieunsioskorean = 12647;
          e3.nieuntikeutkorean = 12646;
          e3.nihiragana = 12395;
          e3.nikatakana = 12491;
          e3.nikatakanahalfwidth = 65414;
          e3.nikhahitleftthai = 63641;
          e3.nikhahitthai = 3661;
          e3.nine = 57;
          e3.ninearabic = 1641;
          e3.ninebengali = 2543;
          e3.ninecircle = 9320;
          e3.ninecircleinversesansserif = 10130;
          e3.ninedeva = 2415;
          e3.ninegujarati = 2799;
          e3.ninegurmukhi = 2671;
          e3.ninehackarabic = 1641;
          e3.ninehangzhou = 12329;
          e3.nineideographicparen = 12840;
          e3.nineinferior = 8329;
          e3.ninemonospace = 65305;
          e3.nineoldstyle = 63289;
          e3.nineparen = 9340;
          e3.nineperiod = 9360;
          e3.ninepersian = 1785;
          e3.nineroman = 8568;
          e3.ninesuperior = 8313;
          e3.nineteencircle = 9330;
          e3.nineteenparen = 9350;
          e3.nineteenperiod = 9370;
          e3.ninethai = 3673;
          e3.nj = 460;
          e3.njecyrillic = 1114;
          e3.nkatakana = 12531;
          e3.nkatakanahalfwidth = 65437;
          e3.nlegrightlong = 414;
          e3.nlinebelow = 7753;
          e3.nmonospace = 65358;
          e3.nmsquare = 13210;
          e3.nnabengali = 2467;
          e3.nnadeva = 2339;
          e3.nnagujarati = 2723;
          e3.nnagurmukhi = 2595;
          e3.nnnadeva = 2345;
          e3.nohiragana = 12398;
          e3.nokatakana = 12494;
          e3.nokatakanahalfwidth = 65417;
          e3.nonbreakingspace = 160;
          e3.nonenthai = 3603;
          e3.nonuthai = 3609;
          e3.noonarabic = 1606;
          e3.noonfinalarabic = 65254;
          e3.noonghunnaarabic = 1722;
          e3.noonghunnafinalarabic = 64415;
          e3.nooninitialarabic = 65255;
          e3.noonjeeminitialarabic = 64722;
          e3.noonjeemisolatedarabic = 64587;
          e3.noonmedialarabic = 65256;
          e3.noonmeeminitialarabic = 64725;
          e3.noonmeemisolatedarabic = 64590;
          e3.noonnoonfinalarabic = 64653;
          e3.notcontains = 8716;
          e3.notelement = 8713;
          e3.notelementof = 8713;
          e3.notequal = 8800;
          e3.notgreater = 8815;
          e3.notgreaternorequal = 8817;
          e3.notgreaternorless = 8825;
          e3.notidentical = 8802;
          e3.notless = 8814;
          e3.notlessnorequal = 8816;
          e3.notparallel = 8742;
          e3.notprecedes = 8832;
          e3.notsubset = 8836;
          e3.notsucceeds = 8833;
          e3.notsuperset = 8837;
          e3.nowarmenian = 1398;
          e3.nparen = 9385;
          e3.nssquare = 13233;
          e3.nsuperior = 8319;
          e3.ntilde = 241;
          e3.nu = 957;
          e3.nuhiragana = 12396;
          e3.nukatakana = 12492;
          e3.nukatakanahalfwidth = 65415;
          e3.nuktabengali = 2492;
          e3.nuktadeva = 2364;
          e3.nuktagujarati = 2748;
          e3.nuktagurmukhi = 2620;
          e3.numbersign = 35;
          e3.numbersignmonospace = 65283;
          e3.numbersignsmall = 65119;
          e3.numeralsigngreek = 884;
          e3.numeralsignlowergreek = 885;
          e3.numero = 8470;
          e3.nun = 1504;
          e3.nundagesh = 64320;
          e3.nundageshhebrew = 64320;
          e3.nunhebrew = 1504;
          e3.nvsquare = 13237;
          e3.nwsquare = 13243;
          e3.nyabengali = 2462;
          e3.nyadeva = 2334;
          e3.nyagujarati = 2718;
          e3.nyagurmukhi = 2590;
          e3.o = 111;
          e3.oacute = 243;
          e3.oangthai = 3629;
          e3.obarred = 629;
          e3.obarredcyrillic = 1257;
          e3.obarreddieresiscyrillic = 1259;
          e3.obengali = 2451;
          e3.obopomofo = 12571;
          e3.obreve = 335;
          e3.ocandradeva = 2321;
          e3.ocandragujarati = 2705;
          e3.ocandravowelsigndeva = 2377;
          e3.ocandravowelsigngujarati = 2761;
          e3.ocaron = 466;
          e3.ocircle = 9438;
          e3.ocircumflex = 244;
          e3.ocircumflexacute = 7889;
          e3.ocircumflexdotbelow = 7897;
          e3.ocircumflexgrave = 7891;
          e3.ocircumflexhookabove = 7893;
          e3.ocircumflextilde = 7895;
          e3.ocyrillic = 1086;
          e3.odblacute = 337;
          e3.odblgrave = 525;
          e3.odeva = 2323;
          e3.odieresis = 246;
          e3.odieresiscyrillic = 1255;
          e3.odotbelow = 7885;
          e3.oe = 339;
          e3.oekorean = 12634;
          e3.ogonek = 731;
          e3.ogonekcmb = 808;
          e3.ograve = 242;
          e3.ogujarati = 2707;
          e3.oharmenian = 1413;
          e3.ohiragana = 12362;
          e3.ohookabove = 7887;
          e3.ohorn = 417;
          e3.ohornacute = 7899;
          e3.ohorndotbelow = 7907;
          e3.ohorngrave = 7901;
          e3.ohornhookabove = 7903;
          e3.ohorntilde = 7905;
          e3.ohungarumlaut = 337;
          e3.oi = 419;
          e3.oinvertedbreve = 527;
          e3.okatakana = 12458;
          e3.okatakanahalfwidth = 65397;
          e3.okorean = 12631;
          e3.olehebrew = 1451;
          e3.omacron = 333;
          e3.omacronacute = 7763;
          e3.omacrongrave = 7761;
          e3.omdeva = 2384;
          e3.omega = 969;
          e3.omega1 = 982;
          e3.omegacyrillic = 1121;
          e3.omegalatinclosed = 631;
          e3.omegaroundcyrillic = 1147;
          e3.omegatitlocyrillic = 1149;
          e3.omegatonos = 974;
          e3.omgujarati = 2768;
          e3.omicron = 959;
          e3.omicrontonos = 972;
          e3.omonospace = 65359;
          e3.one = 49;
          e3.onearabic = 1633;
          e3.onebengali = 2535;
          e3.onecircle = 9312;
          e3.onecircleinversesansserif = 10122;
          e3.onedeva = 2407;
          e3.onedotenleader = 8228;
          e3.oneeighth = 8539;
          e3.onefitted = 63196;
          e3.onegujarati = 2791;
          e3.onegurmukhi = 2663;
          e3.onehackarabic = 1633;
          e3.onehalf = 189;
          e3.onehangzhou = 12321;
          e3.oneideographicparen = 12832;
          e3.oneinferior = 8321;
          e3.onemonospace = 65297;
          e3.onenumeratorbengali = 2548;
          e3.oneoldstyle = 63281;
          e3.oneparen = 9332;
          e3.oneperiod = 9352;
          e3.onepersian = 1777;
          e3.onequarter = 188;
          e3.oneroman = 8560;
          e3.onesuperior = 185;
          e3.onethai = 3665;
          e3.onethird = 8531;
          e3.oogonek = 491;
          e3.oogonekmacron = 493;
          e3.oogurmukhi = 2579;
          e3.oomatragurmukhi = 2635;
          e3.oopen = 596;
          e3.oparen = 9386;
          e3.openbullet = 9702;
          e3.option = 8997;
          e3.ordfeminine = 170;
          e3.ordmasculine = 186;
          e3.orthogonal = 8735;
          e3.oshortdeva = 2322;
          e3.oshortvowelsigndeva = 2378;
          e3.oslash = 248;
          e3.oslashacute = 511;
          e3.osmallhiragana = 12361;
          e3.osmallkatakana = 12457;
          e3.osmallkatakanahalfwidth = 65387;
          e3.ostrokeacute = 511;
          e3.osuperior = 63216;
          e3.otcyrillic = 1151;
          e3.otilde = 245;
          e3.otildeacute = 7757;
          e3.otildedieresis = 7759;
          e3.oubopomofo = 12577;
          e3.overline = 8254;
          e3.overlinecenterline = 65098;
          e3.overlinecmb = 773;
          e3.overlinedashed = 65097;
          e3.overlinedblwavy = 65100;
          e3.overlinewavy = 65099;
          e3.overscore = 175;
          e3.ovowelsignbengali = 2507;
          e3.ovowelsigndeva = 2379;
          e3.ovowelsigngujarati = 2763;
          e3.p = 112;
          e3.paampssquare = 13184;
          e3.paasentosquare = 13099;
          e3.pabengali = 2474;
          e3.pacute = 7765;
          e3.padeva = 2346;
          e3.pagedown = 8671;
          e3.pageup = 8670;
          e3.pagujarati = 2730;
          e3.pagurmukhi = 2602;
          e3.pahiragana = 12401;
          e3.paiyannoithai = 3631;
          e3.pakatakana = 12497;
          e3.palatalizationcyrilliccmb = 1156;
          e3.palochkacyrillic = 1216;
          e3.pansioskorean = 12671;
          e3.paragraph = 182;
          e3.parallel = 8741;
          e3.parenleft = 40;
          e3.parenleftaltonearabic = 64830;
          e3.parenleftbt = 63725;
          e3.parenleftex = 63724;
          e3.parenleftinferior = 8333;
          e3.parenleftmonospace = 65288;
          e3.parenleftsmall = 65113;
          e3.parenleftsuperior = 8317;
          e3.parenlefttp = 63723;
          e3.parenleftvertical = 65077;
          e3.parenright = 41;
          e3.parenrightaltonearabic = 64831;
          e3.parenrightbt = 63736;
          e3.parenrightex = 63735;
          e3.parenrightinferior = 8334;
          e3.parenrightmonospace = 65289;
          e3.parenrightsmall = 65114;
          e3.parenrightsuperior = 8318;
          e3.parenrighttp = 63734;
          e3.parenrightvertical = 65078;
          e3.partialdiff = 8706;
          e3.paseqhebrew = 1472;
          e3.pashtahebrew = 1433;
          e3.pasquare = 13225;
          e3.patah = 1463;
          e3.patah11 = 1463;
          e3.patah1d = 1463;
          e3.patah2a = 1463;
          e3.patahhebrew = 1463;
          e3.patahnarrowhebrew = 1463;
          e3.patahquarterhebrew = 1463;
          e3.patahwidehebrew = 1463;
          e3.pazerhebrew = 1441;
          e3.pbopomofo = 12550;
          e3.pcircle = 9439;
          e3.pdotaccent = 7767;
          e3.pe = 1508;
          e3.pecyrillic = 1087;
          e3.pedagesh = 64324;
          e3.pedageshhebrew = 64324;
          e3.peezisquare = 13115;
          e3.pefinaldageshhebrew = 64323;
          e3.peharabic = 1662;
          e3.peharmenian = 1402;
          e3.pehebrew = 1508;
          e3.pehfinalarabic = 64343;
          e3.pehinitialarabic = 64344;
          e3.pehiragana = 12410;
          e3.pehmedialarabic = 64345;
          e3.pekatakana = 12506;
          e3.pemiddlehookcyrillic = 1191;
          e3.perafehebrew = 64334;
          e3.percent = 37;
          e3.percentarabic = 1642;
          e3.percentmonospace = 65285;
          e3.percentsmall = 65130;
          e3.period = 46;
          e3.periodarmenian = 1417;
          e3.periodcentered = 183;
          e3.periodhalfwidth = 65377;
          e3.periodinferior = 63207;
          e3.periodmonospace = 65294;
          e3.periodsmall = 65106;
          e3.periodsuperior = 63208;
          e3.perispomenigreekcmb = 834;
          e3.perpendicular = 8869;
          e3.perthousand = 8240;
          e3.peseta = 8359;
          e3.pfsquare = 13194;
          e3.phabengali = 2475;
          e3.phadeva = 2347;
          e3.phagujarati = 2731;
          e3.phagurmukhi = 2603;
          e3.phi = 966;
          e3.phi1 = 981;
          e3.phieuphacirclekorean = 12922;
          e3.phieuphaparenkorean = 12826;
          e3.phieuphcirclekorean = 12908;
          e3.phieuphkorean = 12621;
          e3.phieuphparenkorean = 12812;
          e3.philatin = 632;
          e3.phinthuthai = 3642;
          e3.phisymbolgreek = 981;
          e3.phook = 421;
          e3.phophanthai = 3614;
          e3.phophungthai = 3612;
          e3.phosamphaothai = 3616;
          e3.pi = 960;
          e3.pieupacirclekorean = 12915;
          e3.pieupaparenkorean = 12819;
          e3.pieupcieuckorean = 12662;
          e3.pieupcirclekorean = 12901;
          e3.pieupkiyeokkorean = 12658;
          e3.pieupkorean = 12610;
          e3.pieupparenkorean = 12805;
          e3.pieupsioskiyeokkorean = 12660;
          e3.pieupsioskorean = 12612;
          e3.pieupsiostikeutkorean = 12661;
          e3.pieupthieuthkorean = 12663;
          e3.pieuptikeutkorean = 12659;
          e3.pihiragana = 12404;
          e3.pikatakana = 12500;
          e3.pisymbolgreek = 982;
          e3.piwrarmenian = 1411;
          e3.planckover2pi = 8463;
          e3.planckover2pi1 = 8463;
          e3.plus = 43;
          e3.plusbelowcmb = 799;
          e3.pluscircle = 8853;
          e3.plusminus = 177;
          e3.plusmod = 726;
          e3.plusmonospace = 65291;
          e3.plussmall = 65122;
          e3.plussuperior = 8314;
          e3.pmonospace = 65360;
          e3.pmsquare = 13272;
          e3.pohiragana = 12413;
          e3.pointingindexdownwhite = 9759;
          e3.pointingindexleftwhite = 9756;
          e3.pointingindexrightwhite = 9758;
          e3.pointingindexupwhite = 9757;
          e3.pokatakana = 12509;
          e3.poplathai = 3611;
          e3.postalmark = 12306;
          e3.postalmarkface = 12320;
          e3.pparen = 9387;
          e3.precedes = 8826;
          e3.prescription = 8478;
          e3.primemod = 697;
          e3.primereversed = 8245;
          e3.product = 8719;
          e3.projective = 8965;
          e3.prolongedkana = 12540;
          e3.propellor = 8984;
          e3.propersubset = 8834;
          e3.propersuperset = 8835;
          e3.proportion = 8759;
          e3.proportional = 8733;
          e3.psi = 968;
          e3.psicyrillic = 1137;
          e3.psilipneumatacyrilliccmb = 1158;
          e3.pssquare = 13232;
          e3.puhiragana = 12407;
          e3.pukatakana = 12503;
          e3.pvsquare = 13236;
          e3.pwsquare = 13242;
          e3.q = 113;
          e3.qadeva = 2392;
          e3.qadmahebrew = 1448;
          e3.qafarabic = 1602;
          e3.qaffinalarabic = 65238;
          e3.qafinitialarabic = 65239;
          e3.qafmedialarabic = 65240;
          e3.qamats = 1464;
          e3.qamats10 = 1464;
          e3.qamats1a = 1464;
          e3.qamats1c = 1464;
          e3.qamats27 = 1464;
          e3.qamats29 = 1464;
          e3.qamats33 = 1464;
          e3.qamatsde = 1464;
          e3.qamatshebrew = 1464;
          e3.qamatsnarrowhebrew = 1464;
          e3.qamatsqatanhebrew = 1464;
          e3.qamatsqatannarrowhebrew = 1464;
          e3.qamatsqatanquarterhebrew = 1464;
          e3.qamatsqatanwidehebrew = 1464;
          e3.qamatsquarterhebrew = 1464;
          e3.qamatswidehebrew = 1464;
          e3.qarneyparahebrew = 1439;
          e3.qbopomofo = 12561;
          e3.qcircle = 9440;
          e3.qhook = 672;
          e3.qmonospace = 65361;
          e3.qof = 1511;
          e3.qofdagesh = 64327;
          e3.qofdageshhebrew = 64327;
          e3.qofhebrew = 1511;
          e3.qparen = 9388;
          e3.quarternote = 9833;
          e3.qubuts = 1467;
          e3.qubuts18 = 1467;
          e3.qubuts25 = 1467;
          e3.qubuts31 = 1467;
          e3.qubutshebrew = 1467;
          e3.qubutsnarrowhebrew = 1467;
          e3.qubutsquarterhebrew = 1467;
          e3.qubutswidehebrew = 1467;
          e3.question = 63;
          e3.questionarabic = 1567;
          e3.questionarmenian = 1374;
          e3.questiondown = 191;
          e3.questiondownsmall = 63423;
          e3.questiongreek = 894;
          e3.questionmonospace = 65311;
          e3.questionsmall = 63295;
          e3.quotedbl = 34;
          e3.quotedblbase = 8222;
          e3.quotedblleft = 8220;
          e3.quotedblmonospace = 65282;
          e3.quotedblprime = 12318;
          e3.quotedblprimereversed = 12317;
          e3.quotedblright = 8221;
          e3.quoteleft = 8216;
          e3.quoteleftreversed = 8219;
          e3.quotereversed = 8219;
          e3.quoteright = 8217;
          e3.quoterightn = 329;
          e3.quotesinglbase = 8218;
          e3.quotesingle = 39;
          e3.quotesinglemonospace = 65287;
          e3.r = 114;
          e3.raarmenian = 1404;
          e3.rabengali = 2480;
          e3.racute = 341;
          e3.radeva = 2352;
          e3.radical = 8730;
          e3.radicalex = 63717;
          e3.radoverssquare = 13230;
          e3.radoverssquaredsquare = 13231;
          e3.radsquare = 13229;
          e3.rafe = 1471;
          e3.rafehebrew = 1471;
          e3.ragujarati = 2736;
          e3.ragurmukhi = 2608;
          e3.rahiragana = 12425;
          e3.rakatakana = 12521;
          e3.rakatakanahalfwidth = 65431;
          e3.ralowerdiagonalbengali = 2545;
          e3.ramiddlediagonalbengali = 2544;
          e3.ramshorn = 612;
          e3.ratio = 8758;
          e3.rbopomofo = 12566;
          e3.rcaron = 345;
          e3.rcedilla = 343;
          e3.rcircle = 9441;
          e3.rcommaaccent = 343;
          e3.rdblgrave = 529;
          e3.rdotaccent = 7769;
          e3.rdotbelow = 7771;
          e3.rdotbelowmacron = 7773;
          e3.referencemark = 8251;
          e3.reflexsubset = 8838;
          e3.reflexsuperset = 8839;
          e3.registered = 174;
          e3.registersans = 63720;
          e3.registerserif = 63194;
          e3.reharabic = 1585;
          e3.reharmenian = 1408;
          e3.rehfinalarabic = 65198;
          e3.rehiragana = 12428;
          e3.rekatakana = 12524;
          e3.rekatakanahalfwidth = 65434;
          e3.resh = 1512;
          e3.reshdageshhebrew = 64328;
          e3.reshhebrew = 1512;
          e3.reversedtilde = 8765;
          e3.reviahebrew = 1431;
          e3.reviamugrashhebrew = 1431;
          e3.revlogicalnot = 8976;
          e3.rfishhook = 638;
          e3.rfishhookreversed = 639;
          e3.rhabengali = 2525;
          e3.rhadeva = 2397;
          e3.rho = 961;
          e3.rhook = 637;
          e3.rhookturned = 635;
          e3.rhookturnedsuperior = 693;
          e3.rhosymbolgreek = 1009;
          e3.rhotichookmod = 734;
          e3.rieulacirclekorean = 12913;
          e3.rieulaparenkorean = 12817;
          e3.rieulcirclekorean = 12899;
          e3.rieulhieuhkorean = 12608;
          e3.rieulkiyeokkorean = 12602;
          e3.rieulkiyeoksioskorean = 12649;
          e3.rieulkorean = 12601;
          e3.rieulmieumkorean = 12603;
          e3.rieulpansioskorean = 12652;
          e3.rieulparenkorean = 12803;
          e3.rieulphieuphkorean = 12607;
          e3.rieulpieupkorean = 12604;
          e3.rieulpieupsioskorean = 12651;
          e3.rieulsioskorean = 12605;
          e3.rieulthieuthkorean = 12606;
          e3.rieultikeutkorean = 12650;
          e3.rieulyeorinhieuhkorean = 12653;
          e3.rightangle = 8735;
          e3.righttackbelowcmb = 793;
          e3.righttriangle = 8895;
          e3.rihiragana = 12426;
          e3.rikatakana = 12522;
          e3.rikatakanahalfwidth = 65432;
          e3.ring = 730;
          e3.ringbelowcmb = 805;
          e3.ringcmb = 778;
          e3.ringhalfleft = 703;
          e3.ringhalfleftarmenian = 1369;
          e3.ringhalfleftbelowcmb = 796;
          e3.ringhalfleftcentered = 723;
          e3.ringhalfright = 702;
          e3.ringhalfrightbelowcmb = 825;
          e3.ringhalfrightcentered = 722;
          e3.rinvertedbreve = 531;
          e3.rittorusquare = 13137;
          e3.rlinebelow = 7775;
          e3.rlongleg = 636;
          e3.rlonglegturned = 634;
          e3.rmonospace = 65362;
          e3.rohiragana = 12429;
          e3.rokatakana = 12525;
          e3.rokatakanahalfwidth = 65435;
          e3.roruathai = 3619;
          e3.rparen = 9389;
          e3.rrabengali = 2524;
          e3.rradeva = 2353;
          e3.rragurmukhi = 2652;
          e3.rreharabic = 1681;
          e3.rrehfinalarabic = 64397;
          e3.rrvocalicbengali = 2528;
          e3.rrvocalicdeva = 2400;
          e3.rrvocalicgujarati = 2784;
          e3.rrvocalicvowelsignbengali = 2500;
          e3.rrvocalicvowelsigndeva = 2372;
          e3.rrvocalicvowelsigngujarati = 2756;
          e3.rsuperior = 63217;
          e3.rtblock = 9616;
          e3.rturned = 633;
          e3.rturnedsuperior = 692;
          e3.ruhiragana = 12427;
          e3.rukatakana = 12523;
          e3.rukatakanahalfwidth = 65433;
          e3.rupeemarkbengali = 2546;
          e3.rupeesignbengali = 2547;
          e3.rupiah = 63197;
          e3.ruthai = 3620;
          e3.rvocalicbengali = 2443;
          e3.rvocalicdeva = 2315;
          e3.rvocalicgujarati = 2699;
          e3.rvocalicvowelsignbengali = 2499;
          e3.rvocalicvowelsigndeva = 2371;
          e3.rvocalicvowelsigngujarati = 2755;
          e3.s = 115;
          e3.sabengali = 2488;
          e3.sacute = 347;
          e3.sacutedotaccent = 7781;
          e3.sadarabic = 1589;
          e3.sadeva = 2360;
          e3.sadfinalarabic = 65210;
          e3.sadinitialarabic = 65211;
          e3.sadmedialarabic = 65212;
          e3.sagujarati = 2744;
          e3.sagurmukhi = 2616;
          e3.sahiragana = 12373;
          e3.sakatakana = 12469;
          e3.sakatakanahalfwidth = 65403;
          e3.sallallahoualayhewasallamarabic = 65018;
          e3.samekh = 1505;
          e3.samekhdagesh = 64321;
          e3.samekhdageshhebrew = 64321;
          e3.samekhhebrew = 1505;
          e3.saraaathai = 3634;
          e3.saraaethai = 3649;
          e3.saraaimaimalaithai = 3652;
          e3.saraaimaimuanthai = 3651;
          e3.saraamthai = 3635;
          e3.saraathai = 3632;
          e3.saraethai = 3648;
          e3.saraiileftthai = 63622;
          e3.saraiithai = 3637;
          e3.saraileftthai = 63621;
          e3.saraithai = 3636;
          e3.saraothai = 3650;
          e3.saraueeleftthai = 63624;
          e3.saraueethai = 3639;
          e3.saraueleftthai = 63623;
          e3.sarauethai = 3638;
          e3.sarauthai = 3640;
          e3.sarauuthai = 3641;
          e3.sbopomofo = 12569;
          e3.scaron = 353;
          e3.scarondotaccent = 7783;
          e3.scedilla = 351;
          e3.schwa = 601;
          e3.schwacyrillic = 1241;
          e3.schwadieresiscyrillic = 1243;
          e3.schwahook = 602;
          e3.scircle = 9442;
          e3.scircumflex = 349;
          e3.scommaaccent = 537;
          e3.sdotaccent = 7777;
          e3.sdotbelow = 7779;
          e3.sdotbelowdotaccent = 7785;
          e3.seagullbelowcmb = 828;
          e3.second = 8243;
          e3.secondtonechinese = 714;
          e3.section = 167;
          e3.seenarabic = 1587;
          e3.seenfinalarabic = 65202;
          e3.seeninitialarabic = 65203;
          e3.seenmedialarabic = 65204;
          e3.segol = 1462;
          e3.segol13 = 1462;
          e3.segol1f = 1462;
          e3.segol2c = 1462;
          e3.segolhebrew = 1462;
          e3.segolnarrowhebrew = 1462;
          e3.segolquarterhebrew = 1462;
          e3.segoltahebrew = 1426;
          e3.segolwidehebrew = 1462;
          e3.seharmenian = 1405;
          e3.sehiragana = 12379;
          e3.sekatakana = 12475;
          e3.sekatakanahalfwidth = 65406;
          e3.semicolon = 59;
          e3.semicolonarabic = 1563;
          e3.semicolonmonospace = 65307;
          e3.semicolonsmall = 65108;
          e3.semivoicedmarkkana = 12444;
          e3.semivoicedmarkkanahalfwidth = 65439;
          e3.sentisquare = 13090;
          e3.sentosquare = 13091;
          e3.seven = 55;
          e3.sevenarabic = 1639;
          e3.sevenbengali = 2541;
          e3.sevencircle = 9318;
          e3.sevencircleinversesansserif = 10128;
          e3.sevendeva = 2413;
          e3.seveneighths = 8542;
          e3.sevengujarati = 2797;
          e3.sevengurmukhi = 2669;
          e3.sevenhackarabic = 1639;
          e3.sevenhangzhou = 12327;
          e3.sevenideographicparen = 12838;
          e3.seveninferior = 8327;
          e3.sevenmonospace = 65303;
          e3.sevenoldstyle = 63287;
          e3.sevenparen = 9338;
          e3.sevenperiod = 9358;
          e3.sevenpersian = 1783;
          e3.sevenroman = 8566;
          e3.sevensuperior = 8311;
          e3.seventeencircle = 9328;
          e3.seventeenparen = 9348;
          e3.seventeenperiod = 9368;
          e3.seventhai = 3671;
          e3.sfthyphen = 173;
          e3.shaarmenian = 1399;
          e3.shabengali = 2486;
          e3.shacyrillic = 1096;
          e3.shaddaarabic = 1617;
          e3.shaddadammaarabic = 64609;
          e3.shaddadammatanarabic = 64606;
          e3.shaddafathaarabic = 64608;
          e3.shaddakasraarabic = 64610;
          e3.shaddakasratanarabic = 64607;
          e3.shade = 9618;
          e3.shadedark = 9619;
          e3.shadelight = 9617;
          e3.shademedium = 9618;
          e3.shadeva = 2358;
          e3.shagujarati = 2742;
          e3.shagurmukhi = 2614;
          e3.shalshelethebrew = 1427;
          e3.shbopomofo = 12565;
          e3.shchacyrillic = 1097;
          e3.sheenarabic = 1588;
          e3.sheenfinalarabic = 65206;
          e3.sheeninitialarabic = 65207;
          e3.sheenmedialarabic = 65208;
          e3.sheicoptic = 995;
          e3.sheqel = 8362;
          e3.sheqelhebrew = 8362;
          e3.sheva = 1456;
          e3.sheva115 = 1456;
          e3.sheva15 = 1456;
          e3.sheva22 = 1456;
          e3.sheva2e = 1456;
          e3.shevahebrew = 1456;
          e3.shevanarrowhebrew = 1456;
          e3.shevaquarterhebrew = 1456;
          e3.shevawidehebrew = 1456;
          e3.shhacyrillic = 1211;
          e3.shimacoptic = 1005;
          e3.shin = 1513;
          e3.shindagesh = 64329;
          e3.shindageshhebrew = 64329;
          e3.shindageshshindot = 64300;
          e3.shindageshshindothebrew = 64300;
          e3.shindageshsindot = 64301;
          e3.shindageshsindothebrew = 64301;
          e3.shindothebrew = 1473;
          e3.shinhebrew = 1513;
          e3.shinshindot = 64298;
          e3.shinshindothebrew = 64298;
          e3.shinsindot = 64299;
          e3.shinsindothebrew = 64299;
          e3.shook = 642;
          e3.sigma = 963;
          e3.sigma1 = 962;
          e3.sigmafinal = 962;
          e3.sigmalunatesymbolgreek = 1010;
          e3.sihiragana = 12375;
          e3.sikatakana = 12471;
          e3.sikatakanahalfwidth = 65404;
          e3.siluqhebrew = 1469;
          e3.siluqlefthebrew = 1469;
          e3.similar = 8764;
          e3.sindothebrew = 1474;
          e3.siosacirclekorean = 12916;
          e3.siosaparenkorean = 12820;
          e3.sioscieuckorean = 12670;
          e3.sioscirclekorean = 12902;
          e3.sioskiyeokkorean = 12666;
          e3.sioskorean = 12613;
          e3.siosnieunkorean = 12667;
          e3.siosparenkorean = 12806;
          e3.siospieupkorean = 12669;
          e3.siostikeutkorean = 12668;
          e3.six = 54;
          e3.sixarabic = 1638;
          e3.sixbengali = 2540;
          e3.sixcircle = 9317;
          e3.sixcircleinversesansserif = 10127;
          e3.sixdeva = 2412;
          e3.sixgujarati = 2796;
          e3.sixgurmukhi = 2668;
          e3.sixhackarabic = 1638;
          e3.sixhangzhou = 12326;
          e3.sixideographicparen = 12837;
          e3.sixinferior = 8326;
          e3.sixmonospace = 65302;
          e3.sixoldstyle = 63286;
          e3.sixparen = 9337;
          e3.sixperiod = 9357;
          e3.sixpersian = 1782;
          e3.sixroman = 8565;
          e3.sixsuperior = 8310;
          e3.sixteencircle = 9327;
          e3.sixteencurrencydenominatorbengali = 2553;
          e3.sixteenparen = 9347;
          e3.sixteenperiod = 9367;
          e3.sixthai = 3670;
          e3.slash = 47;
          e3.slashmonospace = 65295;
          e3.slong = 383;
          e3.slongdotaccent = 7835;
          e3.smileface = 9786;
          e3.smonospace = 65363;
          e3.sofpasuqhebrew = 1475;
          e3.softhyphen = 173;
          e3.softsigncyrillic = 1100;
          e3.sohiragana = 12381;
          e3.sokatakana = 12477;
          e3.sokatakanahalfwidth = 65407;
          e3.soliduslongoverlaycmb = 824;
          e3.solidusshortoverlaycmb = 823;
          e3.sorusithai = 3625;
          e3.sosalathai = 3624;
          e3.sosothai = 3595;
          e3.sosuathai = 3626;
          e3.space = 32;
          e3.spacehackarabic = 32;
          e3.spade = 9824;
          e3.spadesuitblack = 9824;
          e3.spadesuitwhite = 9828;
          e3.sparen = 9390;
          e3.squarebelowcmb = 827;
          e3.squarecc = 13252;
          e3.squarecm = 13213;
          e3.squarediagonalcrosshatchfill = 9641;
          e3.squarehorizontalfill = 9636;
          e3.squarekg = 13199;
          e3.squarekm = 13214;
          e3.squarekmcapital = 13262;
          e3.squareln = 13265;
          e3.squarelog = 13266;
          e3.squaremg = 13198;
          e3.squaremil = 13269;
          e3.squaremm = 13212;
          e3.squaremsquared = 13217;
          e3.squareorthogonalcrosshatchfill = 9638;
          e3.squareupperlefttolowerrightfill = 9639;
          e3.squareupperrighttolowerleftfill = 9640;
          e3.squareverticalfill = 9637;
          e3.squarewhitewithsmallblack = 9635;
          e3.srsquare = 13275;
          e3.ssabengali = 2487;
          e3.ssadeva = 2359;
          e3.ssagujarati = 2743;
          e3.ssangcieuckorean = 12617;
          e3.ssanghieuhkorean = 12677;
          e3.ssangieungkorean = 12672;
          e3.ssangkiyeokkorean = 12594;
          e3.ssangnieunkorean = 12645;
          e3.ssangpieupkorean = 12611;
          e3.ssangsioskorean = 12614;
          e3.ssangtikeutkorean = 12600;
          e3.ssuperior = 63218;
          e3.sterling = 163;
          e3.sterlingmonospace = 65505;
          e3.strokelongoverlaycmb = 822;
          e3.strokeshortoverlaycmb = 821;
          e3.subset = 8834;
          e3.subsetnotequal = 8842;
          e3.subsetorequal = 8838;
          e3.succeeds = 8827;
          e3.suchthat = 8715;
          e3.suhiragana = 12377;
          e3.sukatakana = 12473;
          e3.sukatakanahalfwidth = 65405;
          e3.sukunarabic = 1618;
          e3.summation = 8721;
          e3.sun = 9788;
          e3.superset = 8835;
          e3.supersetnotequal = 8843;
          e3.supersetorequal = 8839;
          e3.svsquare = 13276;
          e3.syouwaerasquare = 13180;
          e3.t = 116;
          e3.tabengali = 2468;
          e3.tackdown = 8868;
          e3.tackleft = 8867;
          e3.tadeva = 2340;
          e3.tagujarati = 2724;
          e3.tagurmukhi = 2596;
          e3.taharabic = 1591;
          e3.tahfinalarabic = 65218;
          e3.tahinitialarabic = 65219;
          e3.tahiragana = 12383;
          e3.tahmedialarabic = 65220;
          e3.taisyouerasquare = 13181;
          e3.takatakana = 12479;
          e3.takatakanahalfwidth = 65408;
          e3.tatweelarabic = 1600;
          e3.tau = 964;
          e3.tav = 1514;
          e3.tavdages = 64330;
          e3.tavdagesh = 64330;
          e3.tavdageshhebrew = 64330;
          e3.tavhebrew = 1514;
          e3.tbar = 359;
          e3.tbopomofo = 12554;
          e3.tcaron = 357;
          e3.tccurl = 680;
          e3.tcedilla = 355;
          e3.tcheharabic = 1670;
          e3.tchehfinalarabic = 64379;
          e3.tchehinitialarabic = 64380;
          e3.tchehmedialarabic = 64381;
          e3.tcircle = 9443;
          e3.tcircumflexbelow = 7793;
          e3.tcommaaccent = 355;
          e3.tdieresis = 7831;
          e3.tdotaccent = 7787;
          e3.tdotbelow = 7789;
          e3.tecyrillic = 1090;
          e3.tedescendercyrillic = 1197;
          e3.teharabic = 1578;
          e3.tehfinalarabic = 65174;
          e3.tehhahinitialarabic = 64674;
          e3.tehhahisolatedarabic = 64524;
          e3.tehinitialarabic = 65175;
          e3.tehiragana = 12390;
          e3.tehjeeminitialarabic = 64673;
          e3.tehjeemisolatedarabic = 64523;
          e3.tehmarbutaarabic = 1577;
          e3.tehmarbutafinalarabic = 65172;
          e3.tehmedialarabic = 65176;
          e3.tehmeeminitialarabic = 64676;
          e3.tehmeemisolatedarabic = 64526;
          e3.tehnoonfinalarabic = 64627;
          e3.tekatakana = 12486;
          e3.tekatakanahalfwidth = 65411;
          e3.telephone = 8481;
          e3.telephoneblack = 9742;
          e3.telishagedolahebrew = 1440;
          e3.telishaqetanahebrew = 1449;
          e3.tencircle = 9321;
          e3.tenideographicparen = 12841;
          e3.tenparen = 9341;
          e3.tenperiod = 9361;
          e3.tenroman = 8569;
          e3.tesh = 679;
          e3.tet = 1496;
          e3.tetdagesh = 64312;
          e3.tetdageshhebrew = 64312;
          e3.tethebrew = 1496;
          e3.tetsecyrillic = 1205;
          e3.tevirhebrew = 1435;
          e3.tevirlefthebrew = 1435;
          e3.thabengali = 2469;
          e3.thadeva = 2341;
          e3.thagujarati = 2725;
          e3.thagurmukhi = 2597;
          e3.thalarabic = 1584;
          e3.thalfinalarabic = 65196;
          e3.thanthakhatlowleftthai = 63640;
          e3.thanthakhatlowrightthai = 63639;
          e3.thanthakhatthai = 3660;
          e3.thanthakhatupperleftthai = 63638;
          e3.theharabic = 1579;
          e3.thehfinalarabic = 65178;
          e3.thehinitialarabic = 65179;
          e3.thehmedialarabic = 65180;
          e3.thereexists = 8707;
          e3.therefore = 8756;
          e3.theta = 952;
          e3.theta1 = 977;
          e3.thetasymbolgreek = 977;
          e3.thieuthacirclekorean = 12921;
          e3.thieuthaparenkorean = 12825;
          e3.thieuthcirclekorean = 12907;
          e3.thieuthkorean = 12620;
          e3.thieuthparenkorean = 12811;
          e3.thirteencircle = 9324;
          e3.thirteenparen = 9344;
          e3.thirteenperiod = 9364;
          e3.thonangmonthothai = 3601;
          e3.thook = 429;
          e3.thophuthaothai = 3602;
          e3.thorn = 254;
          e3.thothahanthai = 3607;
          e3.thothanthai = 3600;
          e3.thothongthai = 3608;
          e3.thothungthai = 3606;
          e3.thousandcyrillic = 1154;
          e3.thousandsseparatorarabic = 1644;
          e3.thousandsseparatorpersian = 1644;
          e3.three = 51;
          e3.threearabic = 1635;
          e3.threebengali = 2537;
          e3.threecircle = 9314;
          e3.threecircleinversesansserif = 10124;
          e3.threedeva = 2409;
          e3.threeeighths = 8540;
          e3.threegujarati = 2793;
          e3.threegurmukhi = 2665;
          e3.threehackarabic = 1635;
          e3.threehangzhou = 12323;
          e3.threeideographicparen = 12834;
          e3.threeinferior = 8323;
          e3.threemonospace = 65299;
          e3.threenumeratorbengali = 2550;
          e3.threeoldstyle = 63283;
          e3.threeparen = 9334;
          e3.threeperiod = 9354;
          e3.threepersian = 1779;
          e3.threequarters = 190;
          e3.threequartersemdash = 63198;
          e3.threeroman = 8562;
          e3.threesuperior = 179;
          e3.threethai = 3667;
          e3.thzsquare = 13204;
          e3.tihiragana = 12385;
          e3.tikatakana = 12481;
          e3.tikatakanahalfwidth = 65409;
          e3.tikeutacirclekorean = 12912;
          e3.tikeutaparenkorean = 12816;
          e3.tikeutcirclekorean = 12898;
          e3.tikeutkorean = 12599;
          e3.tikeutparenkorean = 12802;
          e3.tilde = 732;
          e3.tildebelowcmb = 816;
          e3.tildecmb = 771;
          e3.tildecomb = 771;
          e3.tildedoublecmb = 864;
          e3.tildeoperator = 8764;
          e3.tildeoverlaycmb = 820;
          e3.tildeverticalcmb = 830;
          e3.timescircle = 8855;
          e3.tipehahebrew = 1430;
          e3.tipehalefthebrew = 1430;
          e3.tippigurmukhi = 2672;
          e3.titlocyrilliccmb = 1155;
          e3.tiwnarmenian = 1407;
          e3.tlinebelow = 7791;
          e3.tmonospace = 65364;
          e3.toarmenian = 1385;
          e3.tohiragana = 12392;
          e3.tokatakana = 12488;
          e3.tokatakanahalfwidth = 65412;
          e3.tonebarextrahighmod = 741;
          e3.tonebarextralowmod = 745;
          e3.tonebarhighmod = 742;
          e3.tonebarlowmod = 744;
          e3.tonebarmidmod = 743;
          e3.tonefive = 445;
          e3.tonesix = 389;
          e3.tonetwo = 424;
          e3.tonos = 900;
          e3.tonsquare = 13095;
          e3.topatakthai = 3599;
          e3.tortoiseshellbracketleft = 12308;
          e3.tortoiseshellbracketleftsmall = 65117;
          e3.tortoiseshellbracketleftvertical = 65081;
          e3.tortoiseshellbracketright = 12309;
          e3.tortoiseshellbracketrightsmall = 65118;
          e3.tortoiseshellbracketrightvertical = 65082;
          e3.totaothai = 3605;
          e3.tpalatalhook = 427;
          e3.tparen = 9391;
          e3.trademark = 8482;
          e3.trademarksans = 63722;
          e3.trademarkserif = 63195;
          e3.tretroflexhook = 648;
          e3.triagdn = 9660;
          e3.triaglf = 9668;
          e3.triagrt = 9658;
          e3.triagup = 9650;
          e3.ts = 678;
          e3.tsadi = 1510;
          e3.tsadidagesh = 64326;
          e3.tsadidageshhebrew = 64326;
          e3.tsadihebrew = 1510;
          e3.tsecyrillic = 1094;
          e3.tsere = 1461;
          e3.tsere12 = 1461;
          e3.tsere1e = 1461;
          e3.tsere2b = 1461;
          e3.tserehebrew = 1461;
          e3.tserenarrowhebrew = 1461;
          e3.tserequarterhebrew = 1461;
          e3.tserewidehebrew = 1461;
          e3.tshecyrillic = 1115;
          e3.tsuperior = 63219;
          e3.ttabengali = 2463;
          e3.ttadeva = 2335;
          e3.ttagujarati = 2719;
          e3.ttagurmukhi = 2591;
          e3.tteharabic = 1657;
          e3.ttehfinalarabic = 64359;
          e3.ttehinitialarabic = 64360;
          e3.ttehmedialarabic = 64361;
          e3.tthabengali = 2464;
          e3.tthadeva = 2336;
          e3.tthagujarati = 2720;
          e3.tthagurmukhi = 2592;
          e3.tturned = 647;
          e3.tuhiragana = 12388;
          e3.tukatakana = 12484;
          e3.tukatakanahalfwidth = 65410;
          e3.tusmallhiragana = 12387;
          e3.tusmallkatakana = 12483;
          e3.tusmallkatakanahalfwidth = 65391;
          e3.twelvecircle = 9323;
          e3.twelveparen = 9343;
          e3.twelveperiod = 9363;
          e3.twelveroman = 8571;
          e3.twentycircle = 9331;
          e3.twentyhangzhou = 21316;
          e3.twentyparen = 9351;
          e3.twentyperiod = 9371;
          e3.two = 50;
          e3.twoarabic = 1634;
          e3.twobengali = 2536;
          e3.twocircle = 9313;
          e3.twocircleinversesansserif = 10123;
          e3.twodeva = 2408;
          e3.twodotenleader = 8229;
          e3.twodotleader = 8229;
          e3.twodotleadervertical = 65072;
          e3.twogujarati = 2792;
          e3.twogurmukhi = 2664;
          e3.twohackarabic = 1634;
          e3.twohangzhou = 12322;
          e3.twoideographicparen = 12833;
          e3.twoinferior = 8322;
          e3.twomonospace = 65298;
          e3.twonumeratorbengali = 2549;
          e3.twooldstyle = 63282;
          e3.twoparen = 9333;
          e3.twoperiod = 9353;
          e3.twopersian = 1778;
          e3.tworoman = 8561;
          e3.twostroke = 443;
          e3.twosuperior = 178;
          e3.twothai = 3666;
          e3.twothirds = 8532;
          e3.u = 117;
          e3.uacute = 250;
          e3.ubar = 649;
          e3.ubengali = 2441;
          e3.ubopomofo = 12584;
          e3.ubreve = 365;
          e3.ucaron = 468;
          e3.ucircle = 9444;
          e3.ucircumflex = 251;
          e3.ucircumflexbelow = 7799;
          e3.ucyrillic = 1091;
          e3.udattadeva = 2385;
          e3.udblacute = 369;
          e3.udblgrave = 533;
          e3.udeva = 2313;
          e3.udieresis = 252;
          e3.udieresisacute = 472;
          e3.udieresisbelow = 7795;
          e3.udieresiscaron = 474;
          e3.udieresiscyrillic = 1265;
          e3.udieresisgrave = 476;
          e3.udieresismacron = 470;
          e3.udotbelow = 7909;
          e3.ugrave = 249;
          e3.ugujarati = 2697;
          e3.ugurmukhi = 2569;
          e3.uhiragana = 12358;
          e3.uhookabove = 7911;
          e3.uhorn = 432;
          e3.uhornacute = 7913;
          e3.uhorndotbelow = 7921;
          e3.uhorngrave = 7915;
          e3.uhornhookabove = 7917;
          e3.uhorntilde = 7919;
          e3.uhungarumlaut = 369;
          e3.uhungarumlautcyrillic = 1267;
          e3.uinvertedbreve = 535;
          e3.ukatakana = 12454;
          e3.ukatakanahalfwidth = 65395;
          e3.ukcyrillic = 1145;
          e3.ukorean = 12636;
          e3.umacron = 363;
          e3.umacroncyrillic = 1263;
          e3.umacrondieresis = 7803;
          e3.umatragurmukhi = 2625;
          e3.umonospace = 65365;
          e3.underscore = 95;
          e3.underscoredbl = 8215;
          e3.underscoremonospace = 65343;
          e3.underscorevertical = 65075;
          e3.underscorewavy = 65103;
          e3.union = 8746;
          e3.universal = 8704;
          e3.uogonek = 371;
          e3.uparen = 9392;
          e3.upblock = 9600;
          e3.upperdothebrew = 1476;
          e3.upsilon = 965;
          e3.upsilondieresis = 971;
          e3.upsilondieresistonos = 944;
          e3.upsilonlatin = 650;
          e3.upsilontonos = 973;
          e3.uptackbelowcmb = 797;
          e3.uptackmod = 724;
          e3.uragurmukhi = 2675;
          e3.uring = 367;
          e3.ushortcyrillic = 1118;
          e3.usmallhiragana = 12357;
          e3.usmallkatakana = 12453;
          e3.usmallkatakanahalfwidth = 65385;
          e3.ustraightcyrillic = 1199;
          e3.ustraightstrokecyrillic = 1201;
          e3.utilde = 361;
          e3.utildeacute = 7801;
          e3.utildebelow = 7797;
          e3.uubengali = 2442;
          e3.uudeva = 2314;
          e3.uugujarati = 2698;
          e3.uugurmukhi = 2570;
          e3.uumatragurmukhi = 2626;
          e3.uuvowelsignbengali = 2498;
          e3.uuvowelsigndeva = 2370;
          e3.uuvowelsigngujarati = 2754;
          e3.uvowelsignbengali = 2497;
          e3.uvowelsigndeva = 2369;
          e3.uvowelsigngujarati = 2753;
          e3.v = 118;
          e3.vadeva = 2357;
          e3.vagujarati = 2741;
          e3.vagurmukhi = 2613;
          e3.vakatakana = 12535;
          e3.vav = 1493;
          e3.vavdagesh = 64309;
          e3.vavdagesh65 = 64309;
          e3.vavdageshhebrew = 64309;
          e3.vavhebrew = 1493;
          e3.vavholam = 64331;
          e3.vavholamhebrew = 64331;
          e3.vavvavhebrew = 1520;
          e3.vavyodhebrew = 1521;
          e3.vcircle = 9445;
          e3.vdotbelow = 7807;
          e3.vecyrillic = 1074;
          e3.veharabic = 1700;
          e3.vehfinalarabic = 64363;
          e3.vehinitialarabic = 64364;
          e3.vehmedialarabic = 64365;
          e3.vekatakana = 12537;
          e3.venus = 9792;
          e3.verticalbar = 124;
          e3.verticallineabovecmb = 781;
          e3.verticallinebelowcmb = 809;
          e3.verticallinelowmod = 716;
          e3.verticallinemod = 712;
          e3.vewarmenian = 1406;
          e3.vhook = 651;
          e3.vikatakana = 12536;
          e3.viramabengali = 2509;
          e3.viramadeva = 2381;
          e3.viramagujarati = 2765;
          e3.visargabengali = 2435;
          e3.visargadeva = 2307;
          e3.visargagujarati = 2691;
          e3.vmonospace = 65366;
          e3.voarmenian = 1400;
          e3.voicediterationhiragana = 12446;
          e3.voicediterationkatakana = 12542;
          e3.voicedmarkkana = 12443;
          e3.voicedmarkkanahalfwidth = 65438;
          e3.vokatakana = 12538;
          e3.vparen = 9393;
          e3.vtilde = 7805;
          e3.vturned = 652;
          e3.vuhiragana = 12436;
          e3.vukatakana = 12532;
          e3.w = 119;
          e3.wacute = 7811;
          e3.waekorean = 12633;
          e3.wahiragana = 12431;
          e3.wakatakana = 12527;
          e3.wakatakanahalfwidth = 65436;
          e3.wakorean = 12632;
          e3.wasmallhiragana = 12430;
          e3.wasmallkatakana = 12526;
          e3.wattosquare = 13143;
          e3.wavedash = 12316;
          e3.wavyunderscorevertical = 65076;
          e3.wawarabic = 1608;
          e3.wawfinalarabic = 65262;
          e3.wawhamzaabovearabic = 1572;
          e3.wawhamzaabovefinalarabic = 65158;
          e3.wbsquare = 13277;
          e3.wcircle = 9446;
          e3.wcircumflex = 373;
          e3.wdieresis = 7813;
          e3.wdotaccent = 7815;
          e3.wdotbelow = 7817;
          e3.wehiragana = 12433;
          e3.weierstrass = 8472;
          e3.wekatakana = 12529;
          e3.wekorean = 12638;
          e3.weokorean = 12637;
          e3.wgrave = 7809;
          e3.whitebullet = 9702;
          e3.whitecircle = 9675;
          e3.whitecircleinverse = 9689;
          e3.whitecornerbracketleft = 12302;
          e3.whitecornerbracketleftvertical = 65091;
          e3.whitecornerbracketright = 12303;
          e3.whitecornerbracketrightvertical = 65092;
          e3.whitediamond = 9671;
          e3.whitediamondcontainingblacksmalldiamond = 9672;
          e3.whitedownpointingsmalltriangle = 9663;
          e3.whitedownpointingtriangle = 9661;
          e3.whiteleftpointingsmalltriangle = 9667;
          e3.whiteleftpointingtriangle = 9665;
          e3.whitelenticularbracketleft = 12310;
          e3.whitelenticularbracketright = 12311;
          e3.whiterightpointingsmalltriangle = 9657;
          e3.whiterightpointingtriangle = 9655;
          e3.whitesmallsquare = 9643;
          e3.whitesmilingface = 9786;
          e3.whitesquare = 9633;
          e3.whitestar = 9734;
          e3.whitetelephone = 9743;
          e3.whitetortoiseshellbracketleft = 12312;
          e3.whitetortoiseshellbracketright = 12313;
          e3.whiteuppointingsmalltriangle = 9653;
          e3.whiteuppointingtriangle = 9651;
          e3.wihiragana = 12432;
          e3.wikatakana = 12528;
          e3.wikorean = 12639;
          e3.wmonospace = 65367;
          e3.wohiragana = 12434;
          e3.wokatakana = 12530;
          e3.wokatakanahalfwidth = 65382;
          e3.won = 8361;
          e3.wonmonospace = 65510;
          e3.wowaenthai = 3623;
          e3.wparen = 9394;
          e3.wring = 7832;
          e3.wsuperior = 695;
          e3.wturned = 653;
          e3.wynn = 447;
          e3.x = 120;
          e3.xabovecmb = 829;
          e3.xbopomofo = 12562;
          e3.xcircle = 9447;
          e3.xdieresis = 7821;
          e3.xdotaccent = 7819;
          e3.xeharmenian = 1389;
          e3.xi = 958;
          e3.xmonospace = 65368;
          e3.xparen = 9395;
          e3.xsuperior = 739;
          e3.y = 121;
          e3.yaadosquare = 13134;
          e3.yabengali = 2479;
          e3.yacute = 253;
          e3.yadeva = 2351;
          e3.yaekorean = 12626;
          e3.yagujarati = 2735;
          e3.yagurmukhi = 2607;
          e3.yahiragana = 12420;
          e3.yakatakana = 12516;
          e3.yakatakanahalfwidth = 65428;
          e3.yakorean = 12625;
          e3.yamakkanthai = 3662;
          e3.yasmallhiragana = 12419;
          e3.yasmallkatakana = 12515;
          e3.yasmallkatakanahalfwidth = 65388;
          e3.yatcyrillic = 1123;
          e3.ycircle = 9448;
          e3.ycircumflex = 375;
          e3.ydieresis = 255;
          e3.ydotaccent = 7823;
          e3.ydotbelow = 7925;
          e3.yeharabic = 1610;
          e3.yehbarreearabic = 1746;
          e3.yehbarreefinalarabic = 64431;
          e3.yehfinalarabic = 65266;
          e3.yehhamzaabovearabic = 1574;
          e3.yehhamzaabovefinalarabic = 65162;
          e3.yehhamzaaboveinitialarabic = 65163;
          e3.yehhamzaabovemedialarabic = 65164;
          e3.yehinitialarabic = 65267;
          e3.yehmedialarabic = 65268;
          e3.yehmeeminitialarabic = 64733;
          e3.yehmeemisolatedarabic = 64600;
          e3.yehnoonfinalarabic = 64660;
          e3.yehthreedotsbelowarabic = 1745;
          e3.yekorean = 12630;
          e3.yen = 165;
          e3.yenmonospace = 65509;
          e3.yeokorean = 12629;
          e3.yeorinhieuhkorean = 12678;
          e3.yerahbenyomohebrew = 1450;
          e3.yerahbenyomolefthebrew = 1450;
          e3.yericyrillic = 1099;
          e3.yerudieresiscyrillic = 1273;
          e3.yesieungkorean = 12673;
          e3.yesieungpansioskorean = 12675;
          e3.yesieungsioskorean = 12674;
          e3.yetivhebrew = 1434;
          e3.ygrave = 7923;
          e3.yhook = 436;
          e3.yhookabove = 7927;
          e3.yiarmenian = 1397;
          e3.yicyrillic = 1111;
          e3.yikorean = 12642;
          e3.yinyang = 9775;
          e3.yiwnarmenian = 1410;
          e3.ymonospace = 65369;
          e3.yod = 1497;
          e3.yoddagesh = 64313;
          e3.yoddageshhebrew = 64313;
          e3.yodhebrew = 1497;
          e3.yodyodhebrew = 1522;
          e3.yodyodpatahhebrew = 64287;
          e3.yohiragana = 12424;
          e3.yoikorean = 12681;
          e3.yokatakana = 12520;
          e3.yokatakanahalfwidth = 65430;
          e3.yokorean = 12635;
          e3.yosmallhiragana = 12423;
          e3.yosmallkatakana = 12519;
          e3.yosmallkatakanahalfwidth = 65390;
          e3.yotgreek = 1011;
          e3.yoyaekorean = 12680;
          e3.yoyakorean = 12679;
          e3.yoyakthai = 3618;
          e3.yoyingthai = 3597;
          e3.yparen = 9396;
          e3.ypogegrammeni = 890;
          e3.ypogegrammenigreekcmb = 837;
          e3.yr = 422;
          e3.yring = 7833;
          e3.ysuperior = 696;
          e3.ytilde = 7929;
          e3.yturned = 654;
          e3.yuhiragana = 12422;
          e3.yuikorean = 12684;
          e3.yukatakana = 12518;
          e3.yukatakanahalfwidth = 65429;
          e3.yukorean = 12640;
          e3.yusbigcyrillic = 1131;
          e3.yusbigiotifiedcyrillic = 1133;
          e3.yuslittlecyrillic = 1127;
          e3.yuslittleiotifiedcyrillic = 1129;
          e3.yusmallhiragana = 12421;
          e3.yusmallkatakana = 12517;
          e3.yusmallkatakanahalfwidth = 65389;
          e3.yuyekorean = 12683;
          e3.yuyeokorean = 12682;
          e3.yyabengali = 2527;
          e3.yyadeva = 2399;
          e3.z = 122;
          e3.zaarmenian = 1382;
          e3.zacute = 378;
          e3.zadeva = 2395;
          e3.zagurmukhi = 2651;
          e3.zaharabic = 1592;
          e3.zahfinalarabic = 65222;
          e3.zahinitialarabic = 65223;
          e3.zahiragana = 12374;
          e3.zahmedialarabic = 65224;
          e3.zainarabic = 1586;
          e3.zainfinalarabic = 65200;
          e3.zakatakana = 12470;
          e3.zaqefgadolhebrew = 1429;
          e3.zaqefqatanhebrew = 1428;
          e3.zarqahebrew = 1432;
          e3.zayin = 1494;
          e3.zayindagesh = 64310;
          e3.zayindageshhebrew = 64310;
          e3.zayinhebrew = 1494;
          e3.zbopomofo = 12567;
          e3.zcaron = 382;
          e3.zcircle = 9449;
          e3.zcircumflex = 7825;
          e3.zcurl = 657;
          e3.zdot = 380;
          e3.zdotaccent = 380;
          e3.zdotbelow = 7827;
          e3.zecyrillic = 1079;
          e3.zedescendercyrillic = 1177;
          e3.zedieresiscyrillic = 1247;
          e3.zehiragana = 12380;
          e3.zekatakana = 12476;
          e3.zero = 48;
          e3.zeroarabic = 1632;
          e3.zerobengali = 2534;
          e3.zerodeva = 2406;
          e3.zerogujarati = 2790;
          e3.zerogurmukhi = 2662;
          e3.zerohackarabic = 1632;
          e3.zeroinferior = 8320;
          e3.zeromonospace = 65296;
          e3.zerooldstyle = 63280;
          e3.zeropersian = 1776;
          e3.zerosuperior = 8304;
          e3.zerothai = 3664;
          e3.zerowidthjoiner = 65279;
          e3.zerowidthnonjoiner = 8204;
          e3.zerowidthspace = 8203;
          e3.zeta = 950;
          e3.zhbopomofo = 12563;
          e3.zhearmenian = 1386;
          e3.zhebrevecyrillic = 1218;
          e3.zhecyrillic = 1078;
          e3.zhedescendercyrillic = 1175;
          e3.zhedieresiscyrillic = 1245;
          e3.zihiragana = 12376;
          e3.zikatakana = 12472;
          e3.zinorhebrew = 1454;
          e3.zlinebelow = 7829;
          e3.zmonospace = 65370;
          e3.zohiragana = 12382;
          e3.zokatakana = 12478;
          e3.zparen = 9397;
          e3.zretroflexhook = 656;
          e3.zstroke = 438;
          e3.zuhiragana = 12378;
          e3.zukatakana = 12474;
          e3[".notdef"] = 0;
          e3.angbracketleftbig = 9001;
          e3.angbracketleftBig = 9001;
          e3.angbracketleftbigg = 9001;
          e3.angbracketleftBigg = 9001;
          e3.angbracketrightBig = 9002;
          e3.angbracketrightbig = 9002;
          e3.angbracketrightBigg = 9002;
          e3.angbracketrightbigg = 9002;
          e3.arrowhookleft = 8618;
          e3.arrowhookright = 8617;
          e3.arrowlefttophalf = 8636;
          e3.arrowleftbothalf = 8637;
          e3.arrownortheast = 8599;
          e3.arrownorthwest = 8598;
          e3.arrowrighttophalf = 8640;
          e3.arrowrightbothalf = 8641;
          e3.arrowsoutheast = 8600;
          e3.arrowsouthwest = 8601;
          e3.backslashbig = 8726;
          e3.backslashBig = 8726;
          e3.backslashBigg = 8726;
          e3.backslashbigg = 8726;
          e3.bardbl = 8214;
          e3.bracehtipdownleft = 65079;
          e3.bracehtipdownright = 65079;
          e3.bracehtipupleft = 65080;
          e3.bracehtipupright = 65080;
          e3.braceleftBig = 123;
          e3.braceleftbig = 123;
          e3.braceleftbigg = 123;
          e3.braceleftBigg = 123;
          e3.bracerightBig = 125;
          e3.bracerightbig = 125;
          e3.bracerightbigg = 125;
          e3.bracerightBigg = 125;
          e3.bracketleftbig = 91;
          e3.bracketleftBig = 91;
          e3.bracketleftbigg = 91;
          e3.bracketleftBigg = 91;
          e3.bracketrightBig = 93;
          e3.bracketrightbig = 93;
          e3.bracketrightbigg = 93;
          e3.bracketrightBigg = 93;
          e3.ceilingleftbig = 8968;
          e3.ceilingleftBig = 8968;
          e3.ceilingleftBigg = 8968;
          e3.ceilingleftbigg = 8968;
          e3.ceilingrightbig = 8969;
          e3.ceilingrightBig = 8969;
          e3.ceilingrightbigg = 8969;
          e3.ceilingrightBigg = 8969;
          e3.circledotdisplay = 8857;
          e3.circledottext = 8857;
          e3.circlemultiplydisplay = 8855;
          e3.circlemultiplytext = 8855;
          e3.circleplusdisplay = 8853;
          e3.circleplustext = 8853;
          e3.contintegraldisplay = 8750;
          e3.contintegraltext = 8750;
          e3.coproductdisplay = 8720;
          e3.coproducttext = 8720;
          e3.floorleftBig = 8970;
          e3.floorleftbig = 8970;
          e3.floorleftbigg = 8970;
          e3.floorleftBigg = 8970;
          e3.floorrightbig = 8971;
          e3.floorrightBig = 8971;
          e3.floorrightBigg = 8971;
          e3.floorrightbigg = 8971;
          e3.hatwide = 770;
          e3.hatwider = 770;
          e3.hatwidest = 770;
          e3.intercal = 7488;
          e3.integraldisplay = 8747;
          e3.integraltext = 8747;
          e3.intersectiondisplay = 8898;
          e3.intersectiontext = 8898;
          e3.logicalanddisplay = 8743;
          e3.logicalandtext = 8743;
          e3.logicalordisplay = 8744;
          e3.logicalortext = 8744;
          e3.parenleftBig = 40;
          e3.parenleftbig = 40;
          e3.parenleftBigg = 40;
          e3.parenleftbigg = 40;
          e3.parenrightBig = 41;
          e3.parenrightbig = 41;
          e3.parenrightBigg = 41;
          e3.parenrightbigg = 41;
          e3.prime = 8242;
          e3.productdisplay = 8719;
          e3.producttext = 8719;
          e3.radicalbig = 8730;
          e3.radicalBig = 8730;
          e3.radicalBigg = 8730;
          e3.radicalbigg = 8730;
          e3.radicalbt = 8730;
          e3.radicaltp = 8730;
          e3.radicalvertex = 8730;
          e3.slashbig = 47;
          e3.slashBig = 47;
          e3.slashBigg = 47;
          e3.slashbigg = 47;
          e3.summationdisplay = 8721;
          e3.summationtext = 8721;
          e3.tildewide = 732;
          e3.tildewider = 732;
          e3.tildewidest = 732;
          e3.uniondisplay = 8899;
          e3.unionmultidisplay = 8846;
          e3.unionmultitext = 8846;
          e3.unionsqdisplay = 8852;
          e3.unionsqtext = 8852;
          e3.uniontext = 8899;
          e3.vextenddouble = 8741;
          e3.vextendsingle = 8739;
        });
        t2.getGlyphsUnicode = n;
        const i = (0, r.getLookupTableFactory)(function(e3) {
          e3.space = 32;
          e3.a1 = 9985;
          e3.a2 = 9986;
          e3.a202 = 9987;
          e3.a3 = 9988;
          e3.a4 = 9742;
          e3.a5 = 9990;
          e3.a119 = 9991;
          e3.a118 = 9992;
          e3.a117 = 9993;
          e3.a11 = 9755;
          e3.a12 = 9758;
          e3.a13 = 9996;
          e3.a14 = 9997;
          e3.a15 = 9998;
          e3.a16 = 9999;
          e3.a105 = 1e4;
          e3.a17 = 10001;
          e3.a18 = 10002;
          e3.a19 = 10003;
          e3.a20 = 10004;
          e3.a21 = 10005;
          e3.a22 = 10006;
          e3.a23 = 10007;
          e3.a24 = 10008;
          e3.a25 = 10009;
          e3.a26 = 10010;
          e3.a27 = 10011;
          e3.a28 = 10012;
          e3.a6 = 10013;
          e3.a7 = 10014;
          e3.a8 = 10015;
          e3.a9 = 10016;
          e3.a10 = 10017;
          e3.a29 = 10018;
          e3.a30 = 10019;
          e3.a31 = 10020;
          e3.a32 = 10021;
          e3.a33 = 10022;
          e3.a34 = 10023;
          e3.a35 = 9733;
          e3.a36 = 10025;
          e3.a37 = 10026;
          e3.a38 = 10027;
          e3.a39 = 10028;
          e3.a40 = 10029;
          e3.a41 = 10030;
          e3.a42 = 10031;
          e3.a43 = 10032;
          e3.a44 = 10033;
          e3.a45 = 10034;
          e3.a46 = 10035;
          e3.a47 = 10036;
          e3.a48 = 10037;
          e3.a49 = 10038;
          e3.a50 = 10039;
          e3.a51 = 10040;
          e3.a52 = 10041;
          e3.a53 = 10042;
          e3.a54 = 10043;
          e3.a55 = 10044;
          e3.a56 = 10045;
          e3.a57 = 10046;
          e3.a58 = 10047;
          e3.a59 = 10048;
          e3.a60 = 10049;
          e3.a61 = 10050;
          e3.a62 = 10051;
          e3.a63 = 10052;
          e3.a64 = 10053;
          e3.a65 = 10054;
          e3.a66 = 10055;
          e3.a67 = 10056;
          e3.a68 = 10057;
          e3.a69 = 10058;
          e3.a70 = 10059;
          e3.a71 = 9679;
          e3.a72 = 10061;
          e3.a73 = 9632;
          e3.a74 = 10063;
          e3.a203 = 10064;
          e3.a75 = 10065;
          e3.a204 = 10066;
          e3.a76 = 9650;
          e3.a77 = 9660;
          e3.a78 = 9670;
          e3.a79 = 10070;
          e3.a81 = 9687;
          e3.a82 = 10072;
          e3.a83 = 10073;
          e3.a84 = 10074;
          e3.a97 = 10075;
          e3.a98 = 10076;
          e3.a99 = 10077;
          e3.a100 = 10078;
          e3.a101 = 10081;
          e3.a102 = 10082;
          e3.a103 = 10083;
          e3.a104 = 10084;
          e3.a106 = 10085;
          e3.a107 = 10086;
          e3.a108 = 10087;
          e3.a112 = 9827;
          e3.a111 = 9830;
          e3.a110 = 9829;
          e3.a109 = 9824;
          e3.a120 = 9312;
          e3.a121 = 9313;
          e3.a122 = 9314;
          e3.a123 = 9315;
          e3.a124 = 9316;
          e3.a125 = 9317;
          e3.a126 = 9318;
          e3.a127 = 9319;
          e3.a128 = 9320;
          e3.a129 = 9321;
          e3.a130 = 10102;
          e3.a131 = 10103;
          e3.a132 = 10104;
          e3.a133 = 10105;
          e3.a134 = 10106;
          e3.a135 = 10107;
          e3.a136 = 10108;
          e3.a137 = 10109;
          e3.a138 = 10110;
          e3.a139 = 10111;
          e3.a140 = 10112;
          e3.a141 = 10113;
          e3.a142 = 10114;
          e3.a143 = 10115;
          e3.a144 = 10116;
          e3.a145 = 10117;
          e3.a146 = 10118;
          e3.a147 = 10119;
          e3.a148 = 10120;
          e3.a149 = 10121;
          e3.a150 = 10122;
          e3.a151 = 10123;
          e3.a152 = 10124;
          e3.a153 = 10125;
          e3.a154 = 10126;
          e3.a155 = 10127;
          e3.a156 = 10128;
          e3.a157 = 10129;
          e3.a158 = 10130;
          e3.a159 = 10131;
          e3.a160 = 10132;
          e3.a161 = 8594;
          e3.a163 = 8596;
          e3.a164 = 8597;
          e3.a196 = 10136;
          e3.a165 = 10137;
          e3.a192 = 10138;
          e3.a166 = 10139;
          e3.a167 = 10140;
          e3.a168 = 10141;
          e3.a169 = 10142;
          e3.a170 = 10143;
          e3.a171 = 10144;
          e3.a172 = 10145;
          e3.a173 = 10146;
          e3.a162 = 10147;
          e3.a174 = 10148;
          e3.a175 = 10149;
          e3.a176 = 10150;
          e3.a177 = 10151;
          e3.a178 = 10152;
          e3.a179 = 10153;
          e3.a193 = 10154;
          e3.a180 = 10155;
          e3.a199 = 10156;
          e3.a181 = 10157;
          e3.a200 = 10158;
          e3.a182 = 10159;
          e3.a201 = 10161;
          e3.a183 = 10162;
          e3.a184 = 10163;
          e3.a197 = 10164;
          e3.a185 = 10165;
          e3.a194 = 10166;
          e3.a198 = 10167;
          e3.a186 = 10168;
          e3.a195 = 10169;
          e3.a187 = 10170;
          e3.a188 = 10171;
          e3.a189 = 10172;
          e3.a190 = 10173;
          e3.a191 = 10174;
          e3.a89 = 10088;
          e3.a90 = 10089;
          e3.a93 = 10090;
          e3.a94 = 10091;
          e3.a91 = 10092;
          e3.a92 = 10093;
          e3.a205 = 10094;
          e3.a85 = 10095;
          e3.a206 = 10096;
          e3.a86 = 10097;
          e3.a87 = 10098;
          e3.a88 = 10099;
          e3.a95 = 10100;
          e3.a96 = 10101;
          e3[".notdef"] = 0;
        });
        t2.getDingbatsGlyphsUnicode = i;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.clearUnicodeCaches = function clearUnicodeCaches() {
          s.clear();
        };
        t2.getCharUnicodeCategory = function getCharUnicodeCategory(e3) {
          const t3 = s.get(e3);
          if (t3) return t3;
          const a3 = e3.match(i), r2 = { isWhitespace: !!(a3 == null ? void 0 : a3[1]), isZeroWidthDiacritic: !!(a3 == null ? void 0 : a3[2]), isInvisibleFormatMark: !!(a3 == null ? void 0 : a3[3]) };
          s.set(e3, r2);
          return r2;
        };
        t2.getUnicodeForGlyph = function getUnicodeForGlyph(e3, t3) {
          let a3 = t3[e3];
          if (void 0 !== a3) return a3;
          if (!e3) return -1;
          if ("u" === e3[0]) {
            const t4 = e3.length;
            let r2;
            if (7 === t4 && "n" === e3[1] && "i" === e3[2]) r2 = e3.substring(3);
            else {
              if (!(t4 >= 5 && t4 <= 7)) return -1;
              r2 = e3.substring(1);
            }
            if (r2 === r2.toUpperCase()) {
              a3 = parseInt(r2, 16);
              if (a3 >= 0) return a3;
            }
          }
          return -1;
        };
        t2.getUnicodeRangeFor = function getUnicodeRangeFor(e3, t3 = -1) {
          if (-1 !== t3) {
            const a3 = n[t3];
            for (let r2 = 0, n2 = a3.length; r2 < n2; r2 += 2) if (e3 >= a3[r2] && e3 <= a3[r2 + 1]) return t3;
          }
          for (let t4 = 0, a3 = n.length; t4 < a3; t4++) {
            const a4 = n[t4];
            for (let r2 = 0, n2 = a4.length; r2 < n2; r2 += 2) if (e3 >= a4[r2] && e3 <= a4[r2 + 1]) return t4;
          }
          return -1;
        };
        t2.mapSpecialUnicodeValues = function mapSpecialUnicodeValues(e3) {
          if (e3 >= 65520 && e3 <= 65535) return 0;
          if (e3 >= 62976 && e3 <= 63743) return r()[e3] || e3;
          if (173 === e3) return 45;
          return e3;
        };
        const r = (0, a2(3).getLookupTableFactory)(function(e3) {
          e3[63721] = 169;
          e3[63193] = 169;
          e3[63720] = 174;
          e3[63194] = 174;
          e3[63722] = 8482;
          e3[63195] = 8482;
          e3[63729] = 9127;
          e3[63730] = 9128;
          e3[63731] = 9129;
          e3[63740] = 9131;
          e3[63741] = 9132;
          e3[63742] = 9133;
          e3[63726] = 9121;
          e3[63727] = 9122;
          e3[63728] = 9123;
          e3[63737] = 9124;
          e3[63738] = 9125;
          e3[63739] = 9126;
          e3[63723] = 9115;
          e3[63724] = 9116;
          e3[63725] = 9117;
          e3[63734] = 9118;
          e3[63735] = 9119;
          e3[63736] = 9120;
        });
        const n = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
        const i = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), s = /* @__PURE__ */ new Map();
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getSerifFonts = t2.getNonStdFontMap = t2.getGlyphMapForStandardFonts = t2.getFontNameToFileMap = void 0;
        t2.getStandardFontName = function getStandardFontName(e3) {
          const t3 = (0, n.normalizeFontName)(e3);
          return i()[t3];
        };
        t2.getSymbolsFonts = t2.getSupplementalGlyphMapForCalibri = t2.getSupplementalGlyphMapForArialBlack = t2.getStdFontMap = void 0;
        t2.isKnownFontName = function isKnownFontName(e3) {
          const t3 = (0, n.normalizeFontName)(e3);
          return !!(i()[t3] || o()[t3] || c()[t3] || l()[t3]);
        };
        var r = a2(3), n = a2(38);
        const i = (0, r.getLookupTableFactory)(function(e3) {
          e3["Times-Roman"] = "Times-Roman";
          e3.Helvetica = "Helvetica";
          e3.Courier = "Courier";
          e3.Symbol = "Symbol";
          e3["Times-Bold"] = "Times-Bold";
          e3["Helvetica-Bold"] = "Helvetica-Bold";
          e3["Courier-Bold"] = "Courier-Bold";
          e3.ZapfDingbats = "ZapfDingbats";
          e3["Times-Italic"] = "Times-Italic";
          e3["Helvetica-Oblique"] = "Helvetica-Oblique";
          e3["Courier-Oblique"] = "Courier-Oblique";
          e3["Times-BoldItalic"] = "Times-BoldItalic";
          e3["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
          e3["Courier-BoldOblique"] = "Courier-BoldOblique";
          e3.ArialNarrow = "Helvetica";
          e3["ArialNarrow-Bold"] = "Helvetica-Bold";
          e3["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
          e3["ArialNarrow-Italic"] = "Helvetica-Oblique";
          e3.ArialBlack = "Helvetica";
          e3["ArialBlack-Bold"] = "Helvetica-Bold";
          e3["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
          e3["ArialBlack-Italic"] = "Helvetica-Oblique";
          e3["Arial-Black"] = "Helvetica";
          e3["Arial-Black-Bold"] = "Helvetica-Bold";
          e3["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
          e3["Arial-Black-Italic"] = "Helvetica-Oblique";
          e3.Arial = "Helvetica";
          e3["Arial-Bold"] = "Helvetica-Bold";
          e3["Arial-BoldItalic"] = "Helvetica-BoldOblique";
          e3["Arial-Italic"] = "Helvetica-Oblique";
          e3.ArialMT = "Helvetica";
          e3["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
          e3["Arial-BoldMT"] = "Helvetica-Bold";
          e3["Arial-ItalicMT"] = "Helvetica-Oblique";
          e3["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
          e3["Arial-BoldMT-Bold"] = "Helvetica-Bold";
          e3["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
          e3.ArialUnicodeMS = "Helvetica";
          e3["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
          e3["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
          e3["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
          e3["Courier-BoldItalic"] = "Courier-BoldOblique";
          e3["Courier-Italic"] = "Courier-Oblique";
          e3.CourierNew = "Courier";
          e3["CourierNew-Bold"] = "Courier-Bold";
          e3["CourierNew-BoldItalic"] = "Courier-BoldOblique";
          e3["CourierNew-Italic"] = "Courier-Oblique";
          e3["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
          e3["CourierNewPS-BoldMT"] = "Courier-Bold";
          e3["CourierNewPS-ItalicMT"] = "Courier-Oblique";
          e3.CourierNewPSMT = "Courier";
          e3["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
          e3["Helvetica-Italic"] = "Helvetica-Oblique";
          e3["Symbol-Bold"] = "Symbol";
          e3["Symbol-BoldItalic"] = "Symbol";
          e3["Symbol-Italic"] = "Symbol";
          e3.TimesNewRoman = "Times-Roman";
          e3["TimesNewRoman-Bold"] = "Times-Bold";
          e3["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
          e3["TimesNewRoman-Italic"] = "Times-Italic";
          e3.TimesNewRomanPS = "Times-Roman";
          e3["TimesNewRomanPS-Bold"] = "Times-Bold";
          e3["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
          e3["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
          e3["TimesNewRomanPS-BoldMT"] = "Times-Bold";
          e3["TimesNewRomanPS-Italic"] = "Times-Italic";
          e3["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
          e3.TimesNewRomanPSMT = "Times-Roman";
          e3["TimesNewRomanPSMT-Bold"] = "Times-Bold";
          e3["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
          e3["TimesNewRomanPSMT-Italic"] = "Times-Italic";
        });
        t2.getStdFontMap = i;
        const s = (0, r.getLookupTableFactory)(function(e3) {
          e3.Courier = "FoxitFixed.pfb";
          e3["Courier-Bold"] = "FoxitFixedBold.pfb";
          e3["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
          e3["Courier-Oblique"] = "FoxitFixedItalic.pfb";
          e3.Helvetica = "LiberationSans-Regular.ttf";
          e3["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
          e3["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
          e3["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
          e3["Times-Roman"] = "FoxitSerif.pfb";
          e3["Times-Bold"] = "FoxitSerifBold.pfb";
          e3["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
          e3["Times-Italic"] = "FoxitSerifItalic.pfb";
          e3.Symbol = "FoxitSymbol.pfb";
          e3.ZapfDingbats = "FoxitDingbats.pfb";
          e3["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
          e3["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
          e3["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
          e3["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
        });
        t2.getFontNameToFileMap = s;
        const o = (0, r.getLookupTableFactory)(function(e3) {
          e3.Calibri = "Helvetica";
          e3["Calibri-Bold"] = "Helvetica-Bold";
          e3["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
          e3["Calibri-Italic"] = "Helvetica-Oblique";
          e3.CenturyGothic = "Helvetica";
          e3["CenturyGothic-Bold"] = "Helvetica-Bold";
          e3["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
          e3["CenturyGothic-Italic"] = "Helvetica-Oblique";
          e3.ComicSansMS = "Comic Sans MS";
          e3["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
          e3["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
          e3["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
          e3.Impact = "Helvetica";
          e3["ItcSymbol-Bold"] = "Helvetica-Bold";
          e3["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
          e3["ItcSymbol-Book"] = "Helvetica";
          e3["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
          e3["ItcSymbol-Medium"] = "Helvetica";
          e3["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
          e3.LucidaConsole = "Courier";
          e3["LucidaConsole-Bold"] = "Courier-Bold";
          e3["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
          e3["LucidaConsole-Italic"] = "Courier-Oblique";
          e3["LucidaSans-Demi"] = "Helvetica-Bold";
          e3["MS-Gothic"] = "MS Gothic";
          e3["MS-Gothic-Bold"] = "MS Gothic-Bold";
          e3["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
          e3["MS-Gothic-Italic"] = "MS Gothic-Italic";
          e3["MS-Mincho"] = "MS Mincho";
          e3["MS-Mincho-Bold"] = "MS Mincho-Bold";
          e3["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
          e3["MS-Mincho-Italic"] = "MS Mincho-Italic";
          e3["MS-PGothic"] = "MS PGothic";
          e3["MS-PGothic-Bold"] = "MS PGothic-Bold";
          e3["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
          e3["MS-PGothic-Italic"] = "MS PGothic-Italic";
          e3["MS-PMincho"] = "MS PMincho";
          e3["MS-PMincho-Bold"] = "MS PMincho-Bold";
          e3["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
          e3["MS-PMincho-Italic"] = "MS PMincho-Italic";
          e3.NuptialScript = "Times-Italic";
          e3.SegoeUISymbol = "Helvetica";
        });
        t2.getNonStdFontMap = o;
        const c = (0, r.getLookupTableFactory)(function(e3) {
          e3["Adobe Jenson"] = true;
          e3["Adobe Text"] = true;
          e3.Albertus = true;
          e3.Aldus = true;
          e3.Alexandria = true;
          e3.Algerian = true;
          e3["American Typewriter"] = true;
          e3.Antiqua = true;
          e3.Apex = true;
          e3.Arno = true;
          e3.Aster = true;
          e3.Aurora = true;
          e3.Baskerville = true;
          e3.Bell = true;
          e3.Bembo = true;
          e3["Bembo Schoolbook"] = true;
          e3.Benguiat = true;
          e3["Berkeley Old Style"] = true;
          e3["Bernhard Modern"] = true;
          e3["Berthold City"] = true;
          e3.Bodoni = true;
          e3["Bauer Bodoni"] = true;
          e3["Book Antiqua"] = true;
          e3.Bookman = true;
          e3["Bordeaux Roman"] = true;
          e3["Californian FB"] = true;
          e3.Calisto = true;
          e3.Calvert = true;
          e3.Capitals = true;
          e3.Cambria = true;
          e3.Cartier = true;
          e3.Caslon = true;
          e3.Catull = true;
          e3.Centaur = true;
          e3["Century Old Style"] = true;
          e3["Century Schoolbook"] = true;
          e3.Chaparral = true;
          e3["Charis SIL"] = true;
          e3.Cheltenham = true;
          e3["Cholla Slab"] = true;
          e3.Clarendon = true;
          e3.Clearface = true;
          e3.Cochin = true;
          e3.Colonna = true;
          e3["Computer Modern"] = true;
          e3["Concrete Roman"] = true;
          e3.Constantia = true;
          e3["Cooper Black"] = true;
          e3.Corona = true;
          e3.Ecotype = true;
          e3.Egyptienne = true;
          e3.Elephant = true;
          e3.Excelsior = true;
          e3.Fairfield = true;
          e3["FF Scala"] = true;
          e3.Folkard = true;
          e3.Footlight = true;
          e3.FreeSerif = true;
          e3["Friz Quadrata"] = true;
          e3.Garamond = true;
          e3.Gentium = true;
          e3.Georgia = true;
          e3.Gloucester = true;
          e3["Goudy Old Style"] = true;
          e3["Goudy Schoolbook"] = true;
          e3["Goudy Pro Font"] = true;
          e3.Granjon = true;
          e3["Guardian Egyptian"] = true;
          e3.Heather = true;
          e3.Hercules = true;
          e3["High Tower Text"] = true;
          e3.Hiroshige = true;
          e3["Hoefler Text"] = true;
          e3["Humana Serif"] = true;
          e3.Imprint = true;
          e3["Ionic No. 5"] = true;
          e3.Janson = true;
          e3.Joanna = true;
          e3.Korinna = true;
          e3.Lexicon = true;
          e3.LiberationSerif = true;
          e3["Liberation Serif"] = true;
          e3["Linux Libertine"] = true;
          e3.Literaturnaya = true;
          e3.Lucida = true;
          e3["Lucida Bright"] = true;
          e3.Melior = true;
          e3.Memphis = true;
          e3.Miller = true;
          e3.Minion = true;
          e3.Modern = true;
          e3["Mona Lisa"] = true;
          e3["Mrs Eaves"] = true;
          e3["MS Serif"] = true;
          e3["Museo Slab"] = true;
          e3["New York"] = true;
          e3["Nimbus Roman"] = true;
          e3["NPS Rawlinson Roadway"] = true;
          e3.NuptialScript = true;
          e3.Palatino = true;
          e3.Perpetua = true;
          e3.Plantin = true;
          e3["Plantin Schoolbook"] = true;
          e3.Playbill = true;
          e3["Poor Richard"] = true;
          e3["Rawlinson Roadway"] = true;
          e3.Renault = true;
          e3.Requiem = true;
          e3.Rockwell = true;
          e3.Roman = true;
          e3["Rotis Serif"] = true;
          e3.Sabon = true;
          e3.Scala = true;
          e3.Seagull = true;
          e3.Sistina = true;
          e3.Souvenir = true;
          e3.STIX = true;
          e3["Stone Informal"] = true;
          e3["Stone Serif"] = true;
          e3.Sylfaen = true;
          e3.Times = true;
          e3.Trajan = true;
          e3["Trinité"] = true;
          e3["Trump Mediaeval"] = true;
          e3.Utopia = true;
          e3["Vale Type"] = true;
          e3["Bitstream Vera"] = true;
          e3["Vera Serif"] = true;
          e3.Versailles = true;
          e3.Wanted = true;
          e3.Weiss = true;
          e3["Wide Latin"] = true;
          e3.Windsor = true;
          e3.XITS = true;
        });
        t2.getSerifFonts = c;
        const l = (0, r.getLookupTableFactory)(function(e3) {
          e3.Dingbats = true;
          e3.Symbol = true;
          e3.ZapfDingbats = true;
          e3.Wingdings = true;
          e3["Wingdings-Bold"] = true;
          e3["Wingdings-Regular"] = true;
        });
        t2.getSymbolsFonts = l;
        const h = (0, r.getLookupTableFactory)(function(e3) {
          e3[2] = 10;
          e3[3] = 32;
          e3[4] = 33;
          e3[5] = 34;
          e3[6] = 35;
          e3[7] = 36;
          e3[8] = 37;
          e3[9] = 38;
          e3[10] = 39;
          e3[11] = 40;
          e3[12] = 41;
          e3[13] = 42;
          e3[14] = 43;
          e3[15] = 44;
          e3[16] = 45;
          e3[17] = 46;
          e3[18] = 47;
          e3[19] = 48;
          e3[20] = 49;
          e3[21] = 50;
          e3[22] = 51;
          e3[23] = 52;
          e3[24] = 53;
          e3[25] = 54;
          e3[26] = 55;
          e3[27] = 56;
          e3[28] = 57;
          e3[29] = 58;
          e3[30] = 894;
          e3[31] = 60;
          e3[32] = 61;
          e3[33] = 62;
          e3[34] = 63;
          e3[35] = 64;
          e3[36] = 65;
          e3[37] = 66;
          e3[38] = 67;
          e3[39] = 68;
          e3[40] = 69;
          e3[41] = 70;
          e3[42] = 71;
          e3[43] = 72;
          e3[44] = 73;
          e3[45] = 74;
          e3[46] = 75;
          e3[47] = 76;
          e3[48] = 77;
          e3[49] = 78;
          e3[50] = 79;
          e3[51] = 80;
          e3[52] = 81;
          e3[53] = 82;
          e3[54] = 83;
          e3[55] = 84;
          e3[56] = 85;
          e3[57] = 86;
          e3[58] = 87;
          e3[59] = 88;
          e3[60] = 89;
          e3[61] = 90;
          e3[62] = 91;
          e3[63] = 92;
          e3[64] = 93;
          e3[65] = 94;
          e3[66] = 95;
          e3[67] = 96;
          e3[68] = 97;
          e3[69] = 98;
          e3[70] = 99;
          e3[71] = 100;
          e3[72] = 101;
          e3[73] = 102;
          e3[74] = 103;
          e3[75] = 104;
          e3[76] = 105;
          e3[77] = 106;
          e3[78] = 107;
          e3[79] = 108;
          e3[80] = 109;
          e3[81] = 110;
          e3[82] = 111;
          e3[83] = 112;
          e3[84] = 113;
          e3[85] = 114;
          e3[86] = 115;
          e3[87] = 116;
          e3[88] = 117;
          e3[89] = 118;
          e3[90] = 119;
          e3[91] = 120;
          e3[92] = 121;
          e3[93] = 122;
          e3[94] = 123;
          e3[95] = 124;
          e3[96] = 125;
          e3[97] = 126;
          e3[98] = 196;
          e3[99] = 197;
          e3[100] = 199;
          e3[101] = 201;
          e3[102] = 209;
          e3[103] = 214;
          e3[104] = 220;
          e3[105] = 225;
          e3[106] = 224;
          e3[107] = 226;
          e3[108] = 228;
          e3[109] = 227;
          e3[110] = 229;
          e3[111] = 231;
          e3[112] = 233;
          e3[113] = 232;
          e3[114] = 234;
          e3[115] = 235;
          e3[116] = 237;
          e3[117] = 236;
          e3[118] = 238;
          e3[119] = 239;
          e3[120] = 241;
          e3[121] = 243;
          e3[122] = 242;
          e3[123] = 244;
          e3[124] = 246;
          e3[125] = 245;
          e3[126] = 250;
          e3[127] = 249;
          e3[128] = 251;
          e3[129] = 252;
          e3[130] = 8224;
          e3[131] = 176;
          e3[132] = 162;
          e3[133] = 163;
          e3[134] = 167;
          e3[135] = 8226;
          e3[136] = 182;
          e3[137] = 223;
          e3[138] = 174;
          e3[139] = 169;
          e3[140] = 8482;
          e3[141] = 180;
          e3[142] = 168;
          e3[143] = 8800;
          e3[144] = 198;
          e3[145] = 216;
          e3[146] = 8734;
          e3[147] = 177;
          e3[148] = 8804;
          e3[149] = 8805;
          e3[150] = 165;
          e3[151] = 181;
          e3[152] = 8706;
          e3[153] = 8721;
          e3[154] = 8719;
          e3[156] = 8747;
          e3[157] = 170;
          e3[158] = 186;
          e3[159] = 8486;
          e3[160] = 230;
          e3[161] = 248;
          e3[162] = 191;
          e3[163] = 161;
          e3[164] = 172;
          e3[165] = 8730;
          e3[166] = 402;
          e3[167] = 8776;
          e3[168] = 8710;
          e3[169] = 171;
          e3[170] = 187;
          e3[171] = 8230;
          e3[179] = 8220;
          e3[180] = 8221;
          e3[181] = 8216;
          e3[182] = 8217;
          e3[200] = 193;
          e3[203] = 205;
          e3[207] = 211;
          e3[210] = 218;
          e3[223] = 711;
          e3[224] = 321;
          e3[225] = 322;
          e3[226] = 352;
          e3[227] = 353;
          e3[228] = 381;
          e3[229] = 382;
          e3[233] = 221;
          e3[234] = 253;
          e3[252] = 263;
          e3[253] = 268;
          e3[254] = 269;
          e3[258] = 258;
          e3[260] = 260;
          e3[261] = 261;
          e3[265] = 280;
          e3[266] = 281;
          e3[267] = 282;
          e3[268] = 283;
          e3[269] = 313;
          e3[275] = 323;
          e3[276] = 324;
          e3[278] = 328;
          e3[283] = 344;
          e3[284] = 345;
          e3[285] = 346;
          e3[286] = 347;
          e3[292] = 367;
          e3[295] = 377;
          e3[296] = 378;
          e3[298] = 380;
          e3[305] = 963;
          e3[306] = 964;
          e3[307] = 966;
          e3[308] = 8215;
          e3[309] = 8252;
          e3[310] = 8319;
          e3[311] = 8359;
          e3[312] = 8592;
          e3[313] = 8593;
          e3[337] = 9552;
          e3[493] = 1039;
          e3[494] = 1040;
          e3[672] = 1488;
          e3[673] = 1489;
          e3[674] = 1490;
          e3[675] = 1491;
          e3[676] = 1492;
          e3[677] = 1493;
          e3[678] = 1494;
          e3[679] = 1495;
          e3[680] = 1496;
          e3[681] = 1497;
          e3[682] = 1498;
          e3[683] = 1499;
          e3[684] = 1500;
          e3[685] = 1501;
          e3[686] = 1502;
          e3[687] = 1503;
          e3[688] = 1504;
          e3[689] = 1505;
          e3[690] = 1506;
          e3[691] = 1507;
          e3[692] = 1508;
          e3[693] = 1509;
          e3[694] = 1510;
          e3[695] = 1511;
          e3[696] = 1512;
          e3[697] = 1513;
          e3[698] = 1514;
          e3[705] = 1524;
          e3[706] = 8362;
          e3[710] = 64288;
          e3[711] = 64298;
          e3[759] = 1617;
          e3[761] = 1776;
          e3[763] = 1778;
          e3[775] = 1652;
          e3[777] = 1764;
          e3[778] = 1780;
          e3[779] = 1781;
          e3[780] = 1782;
          e3[782] = 771;
          e3[783] = 64726;
          e3[786] = 8363;
          e3[788] = 8532;
          e3[790] = 768;
          e3[791] = 769;
          e3[792] = 768;
          e3[795] = 803;
          e3[797] = 64336;
          e3[798] = 64337;
          e3[799] = 64342;
          e3[800] = 64343;
          e3[801] = 64344;
          e3[802] = 64345;
          e3[803] = 64362;
          e3[804] = 64363;
          e3[805] = 64364;
          e3[2424] = 7821;
          e3[2425] = 7822;
          e3[2426] = 7823;
          e3[2427] = 7824;
          e3[2428] = 7825;
          e3[2429] = 7826;
          e3[2430] = 7827;
          e3[2433] = 7682;
          e3[2678] = 8045;
          e3[2679] = 8046;
          e3[2830] = 1552;
          e3[2838] = 686;
          e3[2840] = 751;
          e3[2842] = 753;
          e3[2843] = 754;
          e3[2844] = 755;
          e3[2846] = 757;
          e3[2856] = 767;
          e3[2857] = 848;
          e3[2858] = 849;
          e3[2862] = 853;
          e3[2863] = 854;
          e3[2864] = 855;
          e3[2865] = 861;
          e3[2866] = 862;
          e3[2906] = 7460;
          e3[2908] = 7462;
          e3[2909] = 7463;
          e3[2910] = 7464;
          e3[2912] = 7466;
          e3[2913] = 7467;
          e3[2914] = 7468;
          e3[2916] = 7470;
          e3[2917] = 7471;
          e3[2918] = 7472;
          e3[2920] = 7474;
          e3[2921] = 7475;
          e3[2922] = 7476;
          e3[2924] = 7478;
          e3[2925] = 7479;
          e3[2926] = 7480;
          e3[2928] = 7482;
          e3[2929] = 7483;
          e3[2930] = 7484;
          e3[2932] = 7486;
          e3[2933] = 7487;
          e3[2934] = 7488;
          e3[2936] = 7490;
          e3[2937] = 7491;
          e3[2938] = 7492;
          e3[2940] = 7494;
          e3[2941] = 7495;
          e3[2942] = 7496;
          e3[2944] = 7498;
          e3[2946] = 7500;
          e3[2948] = 7502;
          e3[2950] = 7504;
          e3[2951] = 7505;
          e3[2952] = 7506;
          e3[2954] = 7508;
          e3[2955] = 7509;
          e3[2956] = 7510;
          e3[2958] = 7512;
          e3[2959] = 7513;
          e3[2960] = 7514;
          e3[2962] = 7516;
          e3[2963] = 7517;
          e3[2964] = 7518;
          e3[2966] = 7520;
          e3[2967] = 7521;
          e3[2968] = 7522;
          e3[2970] = 7524;
          e3[2971] = 7525;
          e3[2972] = 7526;
          e3[2974] = 7528;
          e3[2975] = 7529;
          e3[2976] = 7530;
          e3[2978] = 1537;
          e3[2979] = 1538;
          e3[2980] = 1539;
          e3[2982] = 1549;
          e3[2983] = 1551;
          e3[2984] = 1552;
          e3[2986] = 1554;
          e3[2987] = 1555;
          e3[2988] = 1556;
          e3[2990] = 1623;
          e3[2991] = 1624;
          e3[2995] = 1775;
          e3[2999] = 1791;
          e3[3002] = 64290;
          e3[3003] = 64291;
          e3[3004] = 64292;
          e3[3006] = 64294;
          e3[3007] = 64295;
          e3[3008] = 64296;
          e3[3011] = 1900;
          e3[3014] = 8223;
          e3[3015] = 8244;
          e3[3017] = 7532;
          e3[3018] = 7533;
          e3[3019] = 7534;
          e3[3075] = 7590;
          e3[3076] = 7591;
          e3[3079] = 7594;
          e3[3080] = 7595;
          e3[3083] = 7598;
          e3[3084] = 7599;
          e3[3087] = 7602;
          e3[3088] = 7603;
          e3[3091] = 7606;
          e3[3092] = 7607;
          e3[3095] = 7610;
          e3[3096] = 7611;
          e3[3099] = 7614;
          e3[3100] = 7615;
          e3[3103] = 7618;
          e3[3104] = 7619;
          e3[3107] = 8337;
          e3[3108] = 8338;
          e3[3116] = 1884;
          e3[3119] = 1885;
          e3[3120] = 1885;
          e3[3123] = 1886;
          e3[3124] = 1886;
          e3[3127] = 1887;
          e3[3128] = 1887;
          e3[3131] = 1888;
          e3[3132] = 1888;
          e3[3135] = 1889;
          e3[3136] = 1889;
          e3[3139] = 1890;
          e3[3140] = 1890;
          e3[3143] = 1891;
          e3[3144] = 1891;
          e3[3147] = 1892;
          e3[3148] = 1892;
          e3[3153] = 580;
          e3[3154] = 581;
          e3[3157] = 584;
          e3[3158] = 585;
          e3[3161] = 588;
          e3[3162] = 589;
          e3[3165] = 891;
          e3[3166] = 892;
          e3[3169] = 1274;
          e3[3170] = 1275;
          e3[3173] = 1278;
          e3[3174] = 1279;
          e3[3181] = 7622;
          e3[3182] = 7623;
          e3[3282] = 11799;
          e3[3316] = 578;
          e3[3379] = 42785;
          e3[3393] = 1159;
          e3[3416] = 8377;
        });
        t2.getGlyphMapForStandardFonts = h;
        const u = (0, r.getLookupTableFactory)(function(e3) {
          e3[227] = 322;
          e3[264] = 261;
          e3[291] = 346;
        });
        t2.getSupplementalGlyphMapForArialBlack = u;
        const d = (0, r.getLookupTableFactory)(function(e3) {
          e3[1] = 32;
          e3[4] = 65;
          e3[5] = 192;
          e3[6] = 193;
          e3[9] = 196;
          e3[17] = 66;
          e3[18] = 67;
          e3[21] = 268;
          e3[24] = 68;
          e3[28] = 69;
          e3[29] = 200;
          e3[30] = 201;
          e3[32] = 282;
          e3[38] = 70;
          e3[39] = 71;
          e3[44] = 72;
          e3[47] = 73;
          e3[48] = 204;
          e3[49] = 205;
          e3[58] = 74;
          e3[60] = 75;
          e3[62] = 76;
          e3[68] = 77;
          e3[69] = 78;
          e3[75] = 79;
          e3[76] = 210;
          e3[80] = 214;
          e3[87] = 80;
          e3[89] = 81;
          e3[90] = 82;
          e3[92] = 344;
          e3[94] = 83;
          e3[97] = 352;
          e3[100] = 84;
          e3[104] = 85;
          e3[109] = 220;
          e3[115] = 86;
          e3[116] = 87;
          e3[121] = 88;
          e3[122] = 89;
          e3[124] = 221;
          e3[127] = 90;
          e3[129] = 381;
          e3[258] = 97;
          e3[259] = 224;
          e3[260] = 225;
          e3[263] = 228;
          e3[268] = 261;
          e3[271] = 98;
          e3[272] = 99;
          e3[273] = 263;
          e3[275] = 269;
          e3[282] = 100;
          e3[286] = 101;
          e3[287] = 232;
          e3[288] = 233;
          e3[290] = 283;
          e3[295] = 281;
          e3[296] = 102;
          e3[336] = 103;
          e3[346] = 104;
          e3[349] = 105;
          e3[350] = 236;
          e3[351] = 237;
          e3[361] = 106;
          e3[364] = 107;
          e3[367] = 108;
          e3[371] = 322;
          e3[373] = 109;
          e3[374] = 110;
          e3[381] = 111;
          e3[382] = 242;
          e3[383] = 243;
          e3[386] = 246;
          e3[393] = 112;
          e3[395] = 113;
          e3[396] = 114;
          e3[398] = 345;
          e3[400] = 115;
          e3[401] = 347;
          e3[403] = 353;
          e3[410] = 116;
          e3[437] = 117;
          e3[442] = 252;
          e3[448] = 118;
          e3[449] = 119;
          e3[454] = 120;
          e3[455] = 121;
          e3[457] = 253;
          e3[460] = 122;
          e3[462] = 382;
          e3[463] = 380;
          e3[853] = 44;
          e3[855] = 58;
          e3[856] = 46;
          e3[876] = 47;
          e3[878] = 45;
          e3[882] = 45;
          e3[894] = 40;
          e3[895] = 41;
          e3[896] = 91;
          e3[897] = 93;
          e3[923] = 64;
          e3[1004] = 48;
          e3[1005] = 49;
          e3[1006] = 50;
          e3[1007] = 51;
          e3[1008] = 52;
          e3[1009] = 53;
          e3[1010] = 54;
          e3[1011] = 55;
          e3[1012] = 56;
          e3[1013] = 57;
          e3[1081] = 37;
          e3[1085] = 43;
          e3[1086] = 45;
        });
        t2.getSupplementalGlyphMapForCalibri = d;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ToUnicodeMap = t2.IdentityToUnicodeMap = void 0;
        var r = a2(2);
        t2.ToUnicodeMap = class ToUnicodeMap {
          constructor(e3 = []) {
            this._map = e3;
          }
          get length() {
            return this._map.length;
          }
          forEach(e3) {
            for (const t3 in this._map) e3(t3, this._map[t3].charCodeAt(0));
          }
          has(e3) {
            return void 0 !== this._map[e3];
          }
          get(e3) {
            return this._map[e3];
          }
          charCodeOf(e3) {
            const t3 = this._map;
            if (t3.length <= 65536) return t3.indexOf(e3);
            for (const a3 in t3) if (t3[a3] === e3) return 0 | a3;
            return -1;
          }
          amend(e3) {
            for (const t3 in e3) this._map[t3] = e3[t3];
          }
        };
        t2.IdentityToUnicodeMap = class IdentityToUnicodeMap {
          constructor(e3, t3) {
            this.firstChar = e3;
            this.lastChar = t3;
          }
          get length() {
            return this.lastChar + 1 - this.firstChar;
          }
          forEach(e3) {
            for (let t3 = this.firstChar, a3 = this.lastChar; t3 <= a3; t3++) e3(t3, t3);
          }
          has(e3) {
            return this.firstChar <= e3 && e3 <= this.lastChar;
          }
          get(e3) {
            if (this.firstChar <= e3 && e3 <= this.lastChar) return String.fromCharCode(e3);
          }
          charCodeOf(e3) {
            return Number.isInteger(e3) && e3 >= this.firstChar && e3 <= this.lastChar ? e3 : -1;
          }
          amend(e3) {
            (0, r.unreachable)("Should not call amend()");
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.CFFFont = void 0;
        var r = a2(35), n = a2(38), i = a2(2);
        t2.CFFFont = class CFFFont {
          constructor(e3, t3) {
            this.properties = t3;
            const a3 = new r.CFFParser(e3, t3, n.SEAC_ANALYSIS_ENABLED);
            this.cff = a3.parse();
            this.cff.duplicateFirstGlyph();
            const s = new r.CFFCompiler(this.cff);
            this.seacs = this.cff.seacs;
            try {
              this.data = s.compile();
            } catch {
              (0, i.warn)("Failed to compile font " + t3.loadedName);
              this.data = e3;
            }
            this._createBuiltInEncoding();
          }
          get numGlyphs() {
            return this.cff.charStrings.count;
          }
          getCharset() {
            return this.cff.charset.charset;
          }
          getGlyphMapping() {
            const e3 = this.cff, t3 = this.properties, { cidToGidMap: a3, cMap: r2 } = t3, i2 = e3.charset.charset;
            let s, o;
            if (t3.composite) {
              let t4, n2;
              if ((a3 == null ? void 0 : a3.length) > 0) {
                t4 = /* @__PURE__ */ Object.create(null);
                for (let e4 = 0, r3 = a3.length; e4 < r3; e4++) {
                  const r4 = a3[e4];
                  void 0 !== r4 && (t4[r4] = e4);
                }
              }
              s = /* @__PURE__ */ Object.create(null);
              if (e3.isCIDFont) for (o = 0; o < i2.length; o++) {
                const e4 = i2[o];
                n2 = r2.charCodeOf(e4);
                void 0 !== (t4 == null ? void 0 : t4[n2]) && (n2 = t4[n2]);
                s[n2] = o;
              }
              else for (o = 0; o < e3.charStrings.count; o++) {
                n2 = r2.charCodeOf(o);
                s[n2] = o;
              }
              return s;
            }
            let c = e3.encoding ? e3.encoding.encoding : null;
            t3.isInternalFont && (c = t3.defaultEncoding);
            s = (0, n.type1FontGlyphMapping)(t3, c, i2);
            return s;
          }
          hasGlyphId(e3) {
            return this.cff.hasGlyphId(e3);
          }
          _createBuiltInEncoding() {
            const { charset: e3, encoding: t3 } = this.cff;
            if (!e3 || !t3) return;
            const a3 = e3.charset, r2 = t3.encoding, n2 = [];
            for (const e4 in r2) {
              const t4 = r2[e4];
              if (t4 >= 0) {
                const r3 = a3[t4];
                r3 && (n2[e4] = r3);
              }
            }
            n2.length > 0 && (this.properties.builtInEncoding = n2);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.FontRendererFactory = void 0;
        var r = a2(2), n = a2(35), i = a2(39), s = a2(37), o = a2(8);
        function getUint32(e3, t3) {
          return (e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | e3[t3 + 3]) >>> 0;
        }
        function getUint16(e3, t3) {
          return e3[t3] << 8 | e3[t3 + 1];
        }
        function getInt16(e3, t3) {
          return (e3[t3] << 24 | e3[t3 + 1] << 16) >> 16;
        }
        function getInt8(e3, t3) {
          return e3[t3] << 24 >> 24;
        }
        function getFloat214(e3, t3) {
          return getInt16(e3, t3) / 16384;
        }
        function getSubroutineBias(e3) {
          const t3 = e3.length;
          let a3 = 32768;
          t3 < 1240 ? a3 = 107 : t3 < 33900 && (a3 = 1131);
          return a3;
        }
        function parseCmap(e3, t3, a3) {
          const n2 = 1 === getUint16(e3, t3 + 2) ? getUint32(e3, t3 + 8) : getUint32(e3, t3 + 16), i2 = getUint16(e3, t3 + n2);
          let s2, o2, c2;
          if (4 === i2) {
            getUint16(e3, t3 + n2 + 2);
            const a4 = getUint16(e3, t3 + n2 + 6) >> 1;
            o2 = t3 + n2 + 14;
            s2 = [];
            for (c2 = 0; c2 < a4; c2++, o2 += 2) s2[c2] = { end: getUint16(e3, o2) };
            o2 += 2;
            for (c2 = 0; c2 < a4; c2++, o2 += 2) s2[c2].start = getUint16(e3, o2);
            for (c2 = 0; c2 < a4; c2++, o2 += 2) s2[c2].idDelta = getUint16(e3, o2);
            for (c2 = 0; c2 < a4; c2++, o2 += 2) {
              let t4 = getUint16(e3, o2);
              if (0 !== t4) {
                s2[c2].ids = [];
                for (let a5 = 0, r2 = s2[c2].end - s2[c2].start + 1; a5 < r2; a5++) {
                  s2[c2].ids[a5] = getUint16(e3, o2 + t4);
                  t4 += 2;
                }
              }
            }
            return s2;
          }
          if (12 === i2) {
            const a4 = getUint32(e3, t3 + n2 + 12);
            o2 = t3 + n2 + 16;
            s2 = [];
            for (c2 = 0; c2 < a4; c2++) {
              t3 = getUint32(e3, o2);
              s2.push({ start: t3, end: getUint32(e3, o2 + 4), idDelta: getUint32(e3, o2 + 8) - t3 });
              o2 += 12;
            }
            return s2;
          }
          throw new r.FormatError(`unsupported cmap: ${i2}`);
        }
        function parseCff(e3, t3, a3, r2) {
          var _a, _b, _c;
          const i2 = new n.CFFParser(new o.Stream(e3, t3, a3 - t3), {}, r2).parse();
          return { glyphs: i2.charStrings.objects, subrs: (_b = (_a = i2.topDict.privateDict) == null ? void 0 : _a.subrsIndex) == null ? void 0 : _b.objects, gsubrs: (_c = i2.globalSubrIndex) == null ? void 0 : _c.objects, isCFFCIDFont: i2.isCIDFont, fdSelect: i2.fdSelect, fdArray: i2.fdArray };
        }
        function lookupCmap(e3, t3) {
          const a3 = t3.codePointAt(0);
          let r2 = 0, n2 = 0, i2 = e3.length - 1;
          for (; n2 < i2; ) {
            const t4 = n2 + i2 + 1 >> 1;
            a3 < e3[t4].start ? i2 = t4 - 1 : n2 = t4;
          }
          e3[n2].start <= a3 && a3 <= e3[n2].end && (r2 = e3[n2].idDelta + (e3[n2].ids ? e3[n2].ids[a3 - e3[n2].start] : a3) & 65535);
          return { charCode: a3, glyphId: r2 };
        }
        function compileGlyf(e3, t3, a3) {
          function moveTo(e4, a4) {
            t3.push({ cmd: "moveTo", args: [e4, a4] });
          }
          function lineTo(e4, a4) {
            t3.push({ cmd: "lineTo", args: [e4, a4] });
          }
          function quadraticCurveTo(e4, a4, r3, n3) {
            t3.push({ cmd: "quadraticCurveTo", args: [e4, a4, r3, n3] });
          }
          let r2 = 0;
          const n2 = getInt16(e3, r2);
          let i2, s2 = 0, o2 = 0;
          r2 += 10;
          if (n2 < 0) do {
            i2 = getUint16(e3, r2);
            const n3 = getUint16(e3, r2 + 2);
            r2 += 4;
            let c2, l;
            if (1 & i2) {
              if (2 & i2) {
                c2 = getInt16(e3, r2);
                l = getInt16(e3, r2 + 2);
              } else {
                c2 = getUint16(e3, r2);
                l = getUint16(e3, r2 + 2);
              }
              r2 += 4;
            } else if (2 & i2) {
              c2 = getInt8(e3, r2++);
              l = getInt8(e3, r2++);
            } else {
              c2 = e3[r2++];
              l = e3[r2++];
            }
            if (2 & i2) {
              s2 = c2;
              o2 = l;
            } else {
              s2 = 0;
              o2 = 0;
            }
            let h = 1, u = 1, d = 0, f = 0;
            if (8 & i2) {
              h = u = getFloat214(e3, r2);
              r2 += 2;
            } else if (64 & i2) {
              h = getFloat214(e3, r2);
              u = getFloat214(e3, r2 + 2);
              r2 += 4;
            } else if (128 & i2) {
              h = getFloat214(e3, r2);
              d = getFloat214(e3, r2 + 2);
              f = getFloat214(e3, r2 + 4);
              u = getFloat214(e3, r2 + 6);
              r2 += 8;
            }
            const g = a3.glyphs[n3];
            if (g) {
              t3.push({ cmd: "save" }, { cmd: "transform", args: [h, d, f, u, s2, o2] });
              compileGlyf(g, t3, a3);
              t3.push({ cmd: "restore" });
            }
          } while (32 & i2);
          else {
            const t4 = [];
            let a4, c2;
            for (a4 = 0; a4 < n2; a4++) {
              t4.push(getUint16(e3, r2));
              r2 += 2;
            }
            r2 += 2 + getUint16(e3, r2);
            const l = t4.at(-1) + 1, h = [];
            for (; h.length < l; ) {
              i2 = e3[r2++];
              let t5 = 1;
              8 & i2 && (t5 += e3[r2++]);
              for (; t5-- > 0; ) h.push({ flags: i2 });
            }
            for (a4 = 0; a4 < l; a4++) {
              switch (18 & h[a4].flags) {
                case 0:
                  s2 += getInt16(e3, r2);
                  r2 += 2;
                  break;
                case 2:
                  s2 -= e3[r2++];
                  break;
                case 18:
                  s2 += e3[r2++];
              }
              h[a4].x = s2;
            }
            for (a4 = 0; a4 < l; a4++) {
              switch (36 & h[a4].flags) {
                case 0:
                  o2 += getInt16(e3, r2);
                  r2 += 2;
                  break;
                case 4:
                  o2 -= e3[r2++];
                  break;
                case 36:
                  o2 += e3[r2++];
              }
              h[a4].y = o2;
            }
            let u = 0;
            for (r2 = 0; r2 < n2; r2++) {
              const e4 = t4[r2], n3 = h.slice(u, e4 + 1);
              if (1 & n3[0].flags) n3.push(n3[0]);
              else if (1 & n3.at(-1).flags) n3.unshift(n3.at(-1));
              else {
                const e5 = { flags: 1, x: (n3[0].x + n3.at(-1).x) / 2, y: (n3[0].y + n3.at(-1).y) / 2 };
                n3.unshift(e5);
                n3.push(e5);
              }
              moveTo(n3[0].x, n3[0].y);
              for (a4 = 1, c2 = n3.length; a4 < c2; a4++) if (1 & n3[a4].flags) lineTo(n3[a4].x, n3[a4].y);
              else if (1 & n3[a4 + 1].flags) {
                quadraticCurveTo(n3[a4].x, n3[a4].y, n3[a4 + 1].x, n3[a4 + 1].y);
                a4++;
              } else quadraticCurveTo(n3[a4].x, n3[a4].y, (n3[a4].x + n3[a4 + 1].x) / 2, (n3[a4].y + n3[a4 + 1].y) / 2);
              u = e4 + 1;
            }
          }
        }
        function compileCharString(e3, t3, a3, n2) {
          function moveTo(e4, a4) {
            t3.push({ cmd: "moveTo", args: [e4, a4] });
          }
          function lineTo(e4, a4) {
            t3.push({ cmd: "lineTo", args: [e4, a4] });
          }
          function bezierCurveTo(e4, a4, r2, n3, i3, s2) {
            t3.push({ cmd: "bezierCurveTo", args: [e4, a4, r2, n3, i3, s2] });
          }
          const i2 = [];
          let o2 = 0, c2 = 0, l = 0;
          !function parse(e4) {
            var _a;
            let h = 0;
            for (; h < e4.length; ) {
              let u, d, f, g, p, m, b, y, w, S = false, x = e4[h++];
              switch (x) {
                case 1:
                case 3:
                case 18:
                case 23:
                  l += i2.length >> 1;
                  S = true;
                  break;
                case 4:
                  c2 += i2.pop();
                  moveTo(o2, c2);
                  S = true;
                  break;
                case 5:
                  for (; i2.length > 0; ) {
                    o2 += i2.shift();
                    c2 += i2.shift();
                    lineTo(o2, c2);
                  }
                  break;
                case 6:
                  for (; i2.length > 0; ) {
                    o2 += i2.shift();
                    lineTo(o2, c2);
                    if (0 === i2.length) break;
                    c2 += i2.shift();
                    lineTo(o2, c2);
                  }
                  break;
                case 7:
                  for (; i2.length > 0; ) {
                    c2 += i2.shift();
                    lineTo(o2, c2);
                    if (0 === i2.length) break;
                    o2 += i2.shift();
                    lineTo(o2, c2);
                  }
                  break;
                case 8:
                  for (; i2.length > 0; ) {
                    u = o2 + i2.shift();
                    f = c2 + i2.shift();
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d + i2.shift();
                    c2 = g + i2.shift();
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  break;
                case 10:
                  y = i2.pop();
                  w = null;
                  if (a3.isCFFCIDFont) {
                    const e5 = a3.fdSelect.getFDIndex(n2);
                    if (e5 >= 0 && e5 < a3.fdArray.length) {
                      const t4 = a3.fdArray[e5];
                      let r2;
                      ((_a = t4.privateDict) == null ? void 0 : _a.subrsIndex) && (r2 = t4.privateDict.subrsIndex.objects);
                      if (r2) {
                        y += getSubroutineBias(r2);
                        w = r2[y];
                      }
                    } else (0, r.warn)("Invalid fd index for glyph index.");
                  } else w = a3.subrs[y + a3.subrsBias];
                  w && parse(w);
                  break;
                case 11:
                  return;
                case 12:
                  x = e4[h++];
                  switch (x) {
                    case 34:
                      u = o2 + i2.shift();
                      d = u + i2.shift();
                      p = c2 + i2.shift();
                      o2 = d + i2.shift();
                      bezierCurveTo(u, c2, d, p, o2, p);
                      u = o2 + i2.shift();
                      d = u + i2.shift();
                      o2 = d + i2.shift();
                      bezierCurveTo(u, p, d, c2, o2, c2);
                      break;
                    case 35:
                      u = o2 + i2.shift();
                      f = c2 + i2.shift();
                      d = u + i2.shift();
                      g = f + i2.shift();
                      o2 = d + i2.shift();
                      c2 = g + i2.shift();
                      bezierCurveTo(u, f, d, g, o2, c2);
                      u = o2 + i2.shift();
                      f = c2 + i2.shift();
                      d = u + i2.shift();
                      g = f + i2.shift();
                      o2 = d + i2.shift();
                      c2 = g + i2.shift();
                      bezierCurveTo(u, f, d, g, o2, c2);
                      i2.pop();
                      break;
                    case 36:
                      u = o2 + i2.shift();
                      p = c2 + i2.shift();
                      d = u + i2.shift();
                      m = p + i2.shift();
                      o2 = d + i2.shift();
                      bezierCurveTo(u, p, d, m, o2, m);
                      u = o2 + i2.shift();
                      d = u + i2.shift();
                      b = m + i2.shift();
                      o2 = d + i2.shift();
                      bezierCurveTo(u, m, d, b, o2, c2);
                      break;
                    case 37:
                      const e5 = o2, t4 = c2;
                      u = o2 + i2.shift();
                      f = c2 + i2.shift();
                      d = u + i2.shift();
                      g = f + i2.shift();
                      o2 = d + i2.shift();
                      c2 = g + i2.shift();
                      bezierCurveTo(u, f, d, g, o2, c2);
                      u = o2 + i2.shift();
                      f = c2 + i2.shift();
                      d = u + i2.shift();
                      g = f + i2.shift();
                      o2 = d;
                      c2 = g;
                      Math.abs(o2 - e5) > Math.abs(c2 - t4) ? o2 += i2.shift() : c2 += i2.shift();
                      bezierCurveTo(u, f, d, g, o2, c2);
                      break;
                    default:
                      throw new r.FormatError(`unknown operator: 12 ${x}`);
                  }
                  break;
                case 14:
                  if (i2.length >= 4) {
                    const e5 = i2.pop(), r2 = i2.pop();
                    c2 = i2.pop();
                    o2 = i2.pop();
                    t3.push({ cmd: "save" }, { cmd: "translate", args: [o2, c2] });
                    let n3 = lookupCmap(a3.cmap, String.fromCharCode(a3.glyphNameMap[s.StandardEncoding[e5]]));
                    compileCharString(a3.glyphs[n3.glyphId], t3, a3, n3.glyphId);
                    t3.push({ cmd: "restore" });
                    n3 = lookupCmap(a3.cmap, String.fromCharCode(a3.glyphNameMap[s.StandardEncoding[r2]]));
                    compileCharString(a3.glyphs[n3.glyphId], t3, a3, n3.glyphId);
                  }
                  return;
                case 19:
                case 20:
                  l += i2.length >> 1;
                  h += l + 7 >> 3;
                  S = true;
                  break;
                case 21:
                  c2 += i2.pop();
                  o2 += i2.pop();
                  moveTo(o2, c2);
                  S = true;
                  break;
                case 22:
                  o2 += i2.pop();
                  moveTo(o2, c2);
                  S = true;
                  break;
                case 24:
                  for (; i2.length > 2; ) {
                    u = o2 + i2.shift();
                    f = c2 + i2.shift();
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d + i2.shift();
                    c2 = g + i2.shift();
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  o2 += i2.shift();
                  c2 += i2.shift();
                  lineTo(o2, c2);
                  break;
                case 25:
                  for (; i2.length > 6; ) {
                    o2 += i2.shift();
                    c2 += i2.shift();
                    lineTo(o2, c2);
                  }
                  u = o2 + i2.shift();
                  f = c2 + i2.shift();
                  d = u + i2.shift();
                  g = f + i2.shift();
                  o2 = d + i2.shift();
                  c2 = g + i2.shift();
                  bezierCurveTo(u, f, d, g, o2, c2);
                  break;
                case 26:
                  i2.length % 2 && (o2 += i2.shift());
                  for (; i2.length > 0; ) {
                    u = o2;
                    f = c2 + i2.shift();
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d;
                    c2 = g + i2.shift();
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  break;
                case 27:
                  i2.length % 2 && (c2 += i2.shift());
                  for (; i2.length > 0; ) {
                    u = o2 + i2.shift();
                    f = c2;
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d + i2.shift();
                    c2 = g;
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  break;
                case 28:
                  i2.push((e4[h] << 24 | e4[h + 1] << 16) >> 16);
                  h += 2;
                  break;
                case 29:
                  y = i2.pop() + a3.gsubrsBias;
                  w = a3.gsubrs[y];
                  w && parse(w);
                  break;
                case 30:
                  for (; i2.length > 0; ) {
                    u = o2;
                    f = c2 + i2.shift();
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d + i2.shift();
                    c2 = g + (1 === i2.length ? i2.shift() : 0);
                    bezierCurveTo(u, f, d, g, o2, c2);
                    if (0 === i2.length) break;
                    u = o2 + i2.shift();
                    f = c2;
                    d = u + i2.shift();
                    g = f + i2.shift();
                    c2 = g + i2.shift();
                    o2 = d + (1 === i2.length ? i2.shift() : 0);
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  break;
                case 31:
                  for (; i2.length > 0; ) {
                    u = o2 + i2.shift();
                    f = c2;
                    d = u + i2.shift();
                    g = f + i2.shift();
                    c2 = g + i2.shift();
                    o2 = d + (1 === i2.length ? i2.shift() : 0);
                    bezierCurveTo(u, f, d, g, o2, c2);
                    if (0 === i2.length) break;
                    u = o2;
                    f = c2 + i2.shift();
                    d = u + i2.shift();
                    g = f + i2.shift();
                    o2 = d + i2.shift();
                    c2 = g + (1 === i2.length ? i2.shift() : 0);
                    bezierCurveTo(u, f, d, g, o2, c2);
                  }
                  break;
                default:
                  if (x < 32) throw new r.FormatError(`unknown operator: ${x}`);
                  if (x < 247) i2.push(x - 139);
                  else if (x < 251) i2.push(256 * (x - 247) + e4[h++] + 108);
                  else if (x < 255) i2.push(256 * -(x - 251) - e4[h++] - 108);
                  else {
                    i2.push((e4[h] << 24 | e4[h + 1] << 16 | e4[h + 2] << 8 | e4[h + 3]) / 65536);
                    h += 4;
                  }
              }
              S && (i2.length = 0);
            }
          }(e3);
        }
        const c = [];
        class CompiledFont {
          constructor(e3) {
            this.constructor === CompiledFont && (0, r.unreachable)("Cannot initialize CompiledFont.");
            this.fontMatrix = e3;
            this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
            this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
          }
          getPathJs(e3) {
            const { charCode: t3, glyphId: a3 } = lookupCmap(this.cmap, e3);
            let r2 = this.compiledGlyphs[a3];
            if (!r2) try {
              r2 = this.compileGlyph(this.glyphs[a3], a3);
              this.compiledGlyphs[a3] = r2;
            } catch (e4) {
              this.compiledGlyphs[a3] = c;
              void 0 === this.compiledCharCodeToGlyphId[t3] && (this.compiledCharCodeToGlyphId[t3] = a3);
              throw e4;
            }
            void 0 === this.compiledCharCodeToGlyphId[t3] && (this.compiledCharCodeToGlyphId[t3] = a3);
            return r2;
          }
          compileGlyph(e3, t3) {
            if (!e3 || 0 === e3.length || 14 === e3[0]) return c;
            let a3 = this.fontMatrix;
            if (this.isCFFCIDFont) {
              const e4 = this.fdSelect.getFDIndex(t3);
              if (e4 >= 0 && e4 < this.fdArray.length) {
                a3 = this.fdArray[e4].getByName("FontMatrix") || r.FONT_IDENTITY_MATRIX;
              } else (0, r.warn)("Invalid fd index for glyph index.");
            }
            const n2 = [{ cmd: "save" }, { cmd: "transform", args: a3.slice() }, { cmd: "scale", args: ["size", "-size"] }];
            this.compileGlyphImpl(e3, n2, t3);
            n2.push({ cmd: "restore" });
            return n2;
          }
          compileGlyphImpl() {
            (0, r.unreachable)("Children classes should implement this.");
          }
          hasBuiltPath(e3) {
            const { charCode: t3, glyphId: a3 } = lookupCmap(this.cmap, e3);
            return void 0 !== this.compiledGlyphs[a3] && void 0 !== this.compiledCharCodeToGlyphId[t3];
          }
        }
        class TrueTypeCompiled extends CompiledFont {
          constructor(e3, t3, a3) {
            super(a3 || [488e-6, 0, 0, 488e-6, 0, 0]);
            this.glyphs = e3;
            this.cmap = t3;
          }
          compileGlyphImpl(e3, t3) {
            compileGlyf(e3, t3, this);
          }
        }
        class Type2Compiled extends CompiledFont {
          constructor(e3, t3, a3, r2) {
            super(a3 || [1e-3, 0, 0, 1e-3, 0, 0]);
            this.glyphs = e3.glyphs;
            this.gsubrs = e3.gsubrs || [];
            this.subrs = e3.subrs || [];
            this.cmap = t3;
            this.glyphNameMap = r2 || (0, i.getGlyphsUnicode)();
            this.gsubrsBias = getSubroutineBias(this.gsubrs);
            this.subrsBias = getSubroutineBias(this.subrs);
            this.isCFFCIDFont = e3.isCFFCIDFont;
            this.fdSelect = e3.fdSelect;
            this.fdArray = e3.fdArray;
          }
          compileGlyphImpl(e3, t3, a3) {
            compileCharString(e3, t3, this, a3);
          }
        }
        t2.FontRendererFactory = class FontRendererFactory {
          static create(e3, t3) {
            const a3 = new Uint8Array(e3.data);
            let n2, i2, s2, o2, c2, l;
            const h = getUint16(a3, 4);
            for (let e4 = 0, u = 12; e4 < h; e4++, u += 16) {
              const e5 = (0, r.bytesToString)(a3.subarray(u, u + 4)), h2 = getUint32(a3, u + 8), d = getUint32(a3, u + 12);
              switch (e5) {
                case "cmap":
                  n2 = parseCmap(a3, h2);
                  break;
                case "glyf":
                  i2 = a3.subarray(h2, h2 + d);
                  break;
                case "loca":
                  s2 = a3.subarray(h2, h2 + d);
                  break;
                case "head":
                  l = getUint16(a3, h2 + 18);
                  c2 = getUint16(a3, h2 + 50);
                  break;
                case "CFF ":
                  o2 = parseCff(a3, h2, h2 + d, t3);
              }
            }
            if (i2) {
              const t4 = l ? [1 / l, 0, 0, 1 / l, 0, 0] : e3.fontMatrix;
              return new TrueTypeCompiled(function parseGlyfTable(e4, t5, a4) {
                let r2, n3;
                if (a4) {
                  r2 = 4;
                  n3 = getUint32;
                } else {
                  r2 = 2;
                  n3 = (e5, t6) => 2 * getUint16(e5, t6);
                }
                const i3 = [];
                let s3 = n3(t5, 0);
                for (let a5 = r2; a5 < t5.length; a5 += r2) {
                  const r3 = n3(t5, a5);
                  i3.push(e4.subarray(s3, r3));
                  s3 = r3;
                }
                return i3;
              }(i2, s2, c2), n2, t4);
            }
            return new Type2Compiled(o2, n2, e3.fontMatrix, e3.glyphNameMap);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getMetrics = t2.getFontBasicMetrics = void 0;
        var r = a2(3);
        const n = (0, r.getLookupTableFactory)(function(e3) {
          e3.Courier = 600;
          e3["Courier-Bold"] = 600;
          e3["Courier-BoldOblique"] = 600;
          e3["Courier-Oblique"] = 600;
          e3.Helvetica = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 278;
            e4.exclam = 278;
            e4.quotedbl = 355;
            e4.numbersign = 556;
            e4.dollar = 556;
            e4.percent = 889;
            e4.ampersand = 667;
            e4.quoteright = 222;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 389;
            e4.plus = 584;
            e4.comma = 278;
            e4.hyphen = 333;
            e4.period = 278;
            e4.slash = 278;
            e4.zero = 556;
            e4.one = 556;
            e4.two = 556;
            e4.three = 556;
            e4.four = 556;
            e4.five = 556;
            e4.six = 556;
            e4.seven = 556;
            e4.eight = 556;
            e4.nine = 556;
            e4.colon = 278;
            e4.semicolon = 278;
            e4.less = 584;
            e4.equal = 584;
            e4.greater = 584;
            e4.question = 556;
            e4.at = 1015;
            e4.A = 667;
            e4.B = 667;
            e4.C = 722;
            e4.D = 722;
            e4.E = 667;
            e4.F = 611;
            e4.G = 778;
            e4.H = 722;
            e4.I = 278;
            e4.J = 500;
            e4.K = 667;
            e4.L = 556;
            e4.M = 833;
            e4.N = 722;
            e4.O = 778;
            e4.P = 667;
            e4.Q = 778;
            e4.R = 722;
            e4.S = 667;
            e4.T = 611;
            e4.U = 722;
            e4.V = 667;
            e4.W = 944;
            e4.X = 667;
            e4.Y = 667;
            e4.Z = 611;
            e4.bracketleft = 278;
            e4.backslash = 278;
            e4.bracketright = 278;
            e4.asciicircum = 469;
            e4.underscore = 556;
            e4.quoteleft = 222;
            e4.a = 556;
            e4.b = 556;
            e4.c = 500;
            e4.d = 556;
            e4.e = 556;
            e4.f = 278;
            e4.g = 556;
            e4.h = 556;
            e4.i = 222;
            e4.j = 222;
            e4.k = 500;
            e4.l = 222;
            e4.m = 833;
            e4.n = 556;
            e4.o = 556;
            e4.p = 556;
            e4.q = 556;
            e4.r = 333;
            e4.s = 500;
            e4.t = 278;
            e4.u = 556;
            e4.v = 500;
            e4.w = 722;
            e4.x = 500;
            e4.y = 500;
            e4.z = 500;
            e4.braceleft = 334;
            e4.bar = 260;
            e4.braceright = 334;
            e4.asciitilde = 584;
            e4.exclamdown = 333;
            e4.cent = 556;
            e4.sterling = 556;
            e4.fraction = 167;
            e4.yen = 556;
            e4.florin = 556;
            e4.section = 556;
            e4.currency = 556;
            e4.quotesingle = 191;
            e4.quotedblleft = 333;
            e4.guillemotleft = 556;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 500;
            e4.fl = 500;
            e4.endash = 556;
            e4.dagger = 556;
            e4.daggerdbl = 556;
            e4.periodcentered = 278;
            e4.paragraph = 537;
            e4.bullet = 350;
            e4.quotesinglbase = 222;
            e4.quotedblbase = 333;
            e4.quotedblright = 333;
            e4.guillemotright = 556;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 611;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 1e3;
            e4.ordfeminine = 370;
            e4.Lslash = 556;
            e4.Oslash = 778;
            e4.OE = 1e3;
            e4.ordmasculine = 365;
            e4.ae = 889;
            e4.dotlessi = 278;
            e4.lslash = 222;
            e4.oslash = 611;
            e4.oe = 944;
            e4.germandbls = 611;
            e4.Idieresis = 278;
            e4.eacute = 556;
            e4.abreve = 556;
            e4.uhungarumlaut = 556;
            e4.ecaron = 556;
            e4.Ydieresis = 667;
            e4.divide = 584;
            e4.Yacute = 667;
            e4.Acircumflex = 667;
            e4.aacute = 556;
            e4.Ucircumflex = 722;
            e4.yacute = 500;
            e4.scommaaccent = 500;
            e4.ecircumflex = 556;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 556;
            e4.Uacute = 722;
            e4.uogonek = 556;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 737;
            e4.Emacron = 667;
            e4.ccaron = 500;
            e4.aring = 556;
            e4.Ncommaaccent = 722;
            e4.lacute = 222;
            e4.agrave = 556;
            e4.Tcommaaccent = 611;
            e4.Cacute = 722;
            e4.atilde = 556;
            e4.Edotaccent = 667;
            e4.scaron = 500;
            e4.scedilla = 500;
            e4.iacute = 278;
            e4.lozenge = 471;
            e4.Rcaron = 722;
            e4.Gcommaaccent = 778;
            e4.ucircumflex = 556;
            e4.acircumflex = 556;
            e4.Amacron = 667;
            e4.rcaron = 333;
            e4.ccedilla = 500;
            e4.Zdotaccent = 611;
            e4.Thorn = 667;
            e4.Omacron = 778;
            e4.Racute = 722;
            e4.Sacute = 667;
            e4.dcaron = 643;
            e4.Umacron = 722;
            e4.uring = 556;
            e4.threesuperior = 333;
            e4.Ograve = 778;
            e4.Agrave = 667;
            e4.Abreve = 667;
            e4.multiply = 584;
            e4.uacute = 556;
            e4.Tcaron = 611;
            e4.partialdiff = 476;
            e4.ydieresis = 500;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 556;
            e4.edieresis = 556;
            e4.cacute = 500;
            e4.nacute = 556;
            e4.umacron = 556;
            e4.Ncaron = 722;
            e4.Iacute = 278;
            e4.plusminus = 584;
            e4.brokenbar = 260;
            e4.registered = 737;
            e4.Gbreve = 778;
            e4.Idotaccent = 278;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 333;
            e4.omacron = 556;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 722;
            e4.lcommaaccent = 222;
            e4.tcaron = 317;
            e4.eogonek = 556;
            e4.Uogonek = 722;
            e4.Aacute = 667;
            e4.Adieresis = 667;
            e4.egrave = 556;
            e4.zacute = 500;
            e4.iogonek = 222;
            e4.Oacute = 778;
            e4.oacute = 556;
            e4.amacron = 556;
            e4.sacute = 500;
            e4.idieresis = 278;
            e4.Ocircumflex = 778;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 556;
            e4.twosuperior = 333;
            e4.Odieresis = 778;
            e4.mu = 556;
            e4.igrave = 278;
            e4.ohungarumlaut = 556;
            e4.Eogonek = 667;
            e4.dcroat = 556;
            e4.threequarters = 834;
            e4.Scedilla = 667;
            e4.lcaron = 299;
            e4.Kcommaaccent = 667;
            e4.Lacute = 556;
            e4.trademark = 1e3;
            e4.edotaccent = 556;
            e4.Igrave = 278;
            e4.Imacron = 278;
            e4.Lcaron = 556;
            e4.onehalf = 834;
            e4.lessequal = 549;
            e4.ocircumflex = 556;
            e4.ntilde = 556;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 556;
            e4.gbreve = 556;
            e4.onequarter = 834;
            e4.Scaron = 667;
            e4.Scommaaccent = 667;
            e4.Ohungarumlaut = 778;
            e4.degree = 400;
            e4.ograve = 556;
            e4.Ccaron = 722;
            e4.ugrave = 556;
            e4.radical = 453;
            e4.Dcaron = 722;
            e4.rcommaaccent = 333;
            e4.Ntilde = 722;
            e4.otilde = 556;
            e4.Rcommaaccent = 722;
            e4.Lcommaaccent = 556;
            e4.Atilde = 667;
            e4.Aogonek = 667;
            e4.Aring = 667;
            e4.Otilde = 778;
            e4.zdotaccent = 500;
            e4.Ecaron = 667;
            e4.Iogonek = 278;
            e4.kcommaaccent = 500;
            e4.minus = 584;
            e4.Icircumflex = 278;
            e4.ncaron = 556;
            e4.tcommaaccent = 278;
            e4.logicalnot = 584;
            e4.odieresis = 556;
            e4.udieresis = 556;
            e4.notequal = 549;
            e4.gcommaaccent = 556;
            e4.eth = 556;
            e4.zcaron = 500;
            e4.ncommaaccent = 556;
            e4.onesuperior = 333;
            e4.imacron = 278;
            e4.Euro = 556;
          });
          e3["Helvetica-Bold"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 278;
            e4.exclam = 333;
            e4.quotedbl = 474;
            e4.numbersign = 556;
            e4.dollar = 556;
            e4.percent = 889;
            e4.ampersand = 722;
            e4.quoteright = 278;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 389;
            e4.plus = 584;
            e4.comma = 278;
            e4.hyphen = 333;
            e4.period = 278;
            e4.slash = 278;
            e4.zero = 556;
            e4.one = 556;
            e4.two = 556;
            e4.three = 556;
            e4.four = 556;
            e4.five = 556;
            e4.six = 556;
            e4.seven = 556;
            e4.eight = 556;
            e4.nine = 556;
            e4.colon = 333;
            e4.semicolon = 333;
            e4.less = 584;
            e4.equal = 584;
            e4.greater = 584;
            e4.question = 611;
            e4.at = 975;
            e4.A = 722;
            e4.B = 722;
            e4.C = 722;
            e4.D = 722;
            e4.E = 667;
            e4.F = 611;
            e4.G = 778;
            e4.H = 722;
            e4.I = 278;
            e4.J = 556;
            e4.K = 722;
            e4.L = 611;
            e4.M = 833;
            e4.N = 722;
            e4.O = 778;
            e4.P = 667;
            e4.Q = 778;
            e4.R = 722;
            e4.S = 667;
            e4.T = 611;
            e4.U = 722;
            e4.V = 667;
            e4.W = 944;
            e4.X = 667;
            e4.Y = 667;
            e4.Z = 611;
            e4.bracketleft = 333;
            e4.backslash = 278;
            e4.bracketright = 333;
            e4.asciicircum = 584;
            e4.underscore = 556;
            e4.quoteleft = 278;
            e4.a = 556;
            e4.b = 611;
            e4.c = 556;
            e4.d = 611;
            e4.e = 556;
            e4.f = 333;
            e4.g = 611;
            e4.h = 611;
            e4.i = 278;
            e4.j = 278;
            e4.k = 556;
            e4.l = 278;
            e4.m = 889;
            e4.n = 611;
            e4.o = 611;
            e4.p = 611;
            e4.q = 611;
            e4.r = 389;
            e4.s = 556;
            e4.t = 333;
            e4.u = 611;
            e4.v = 556;
            e4.w = 778;
            e4.x = 556;
            e4.y = 556;
            e4.z = 500;
            e4.braceleft = 389;
            e4.bar = 280;
            e4.braceright = 389;
            e4.asciitilde = 584;
            e4.exclamdown = 333;
            e4.cent = 556;
            e4.sterling = 556;
            e4.fraction = 167;
            e4.yen = 556;
            e4.florin = 556;
            e4.section = 556;
            e4.currency = 556;
            e4.quotesingle = 238;
            e4.quotedblleft = 500;
            e4.guillemotleft = 556;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 611;
            e4.fl = 611;
            e4.endash = 556;
            e4.dagger = 556;
            e4.daggerdbl = 556;
            e4.periodcentered = 278;
            e4.paragraph = 556;
            e4.bullet = 350;
            e4.quotesinglbase = 278;
            e4.quotedblbase = 500;
            e4.quotedblright = 500;
            e4.guillemotright = 556;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 611;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 1e3;
            e4.ordfeminine = 370;
            e4.Lslash = 611;
            e4.Oslash = 778;
            e4.OE = 1e3;
            e4.ordmasculine = 365;
            e4.ae = 889;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 611;
            e4.oe = 944;
            e4.germandbls = 611;
            e4.Idieresis = 278;
            e4.eacute = 556;
            e4.abreve = 556;
            e4.uhungarumlaut = 611;
            e4.ecaron = 556;
            e4.Ydieresis = 667;
            e4.divide = 584;
            e4.Yacute = 667;
            e4.Acircumflex = 722;
            e4.aacute = 556;
            e4.Ucircumflex = 722;
            e4.yacute = 556;
            e4.scommaaccent = 556;
            e4.ecircumflex = 556;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 556;
            e4.Uacute = 722;
            e4.uogonek = 611;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 737;
            e4.Emacron = 667;
            e4.ccaron = 556;
            e4.aring = 556;
            e4.Ncommaaccent = 722;
            e4.lacute = 278;
            e4.agrave = 556;
            e4.Tcommaaccent = 611;
            e4.Cacute = 722;
            e4.atilde = 556;
            e4.Edotaccent = 667;
            e4.scaron = 556;
            e4.scedilla = 556;
            e4.iacute = 278;
            e4.lozenge = 494;
            e4.Rcaron = 722;
            e4.Gcommaaccent = 778;
            e4.ucircumflex = 611;
            e4.acircumflex = 556;
            e4.Amacron = 722;
            e4.rcaron = 389;
            e4.ccedilla = 556;
            e4.Zdotaccent = 611;
            e4.Thorn = 667;
            e4.Omacron = 778;
            e4.Racute = 722;
            e4.Sacute = 667;
            e4.dcaron = 743;
            e4.Umacron = 722;
            e4.uring = 611;
            e4.threesuperior = 333;
            e4.Ograve = 778;
            e4.Agrave = 722;
            e4.Abreve = 722;
            e4.multiply = 584;
            e4.uacute = 611;
            e4.Tcaron = 611;
            e4.partialdiff = 494;
            e4.ydieresis = 556;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 556;
            e4.edieresis = 556;
            e4.cacute = 556;
            e4.nacute = 611;
            e4.umacron = 611;
            e4.Ncaron = 722;
            e4.Iacute = 278;
            e4.plusminus = 584;
            e4.brokenbar = 280;
            e4.registered = 737;
            e4.Gbreve = 778;
            e4.Idotaccent = 278;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 389;
            e4.omacron = 611;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 722;
            e4.lcommaaccent = 278;
            e4.tcaron = 389;
            e4.eogonek = 556;
            e4.Uogonek = 722;
            e4.Aacute = 722;
            e4.Adieresis = 722;
            e4.egrave = 556;
            e4.zacute = 500;
            e4.iogonek = 278;
            e4.Oacute = 778;
            e4.oacute = 611;
            e4.amacron = 556;
            e4.sacute = 556;
            e4.idieresis = 278;
            e4.Ocircumflex = 778;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 611;
            e4.twosuperior = 333;
            e4.Odieresis = 778;
            e4.mu = 611;
            e4.igrave = 278;
            e4.ohungarumlaut = 611;
            e4.Eogonek = 667;
            e4.dcroat = 611;
            e4.threequarters = 834;
            e4.Scedilla = 667;
            e4.lcaron = 400;
            e4.Kcommaaccent = 722;
            e4.Lacute = 611;
            e4.trademark = 1e3;
            e4.edotaccent = 556;
            e4.Igrave = 278;
            e4.Imacron = 278;
            e4.Lcaron = 611;
            e4.onehalf = 834;
            e4.lessequal = 549;
            e4.ocircumflex = 611;
            e4.ntilde = 611;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 556;
            e4.gbreve = 611;
            e4.onequarter = 834;
            e4.Scaron = 667;
            e4.Scommaaccent = 667;
            e4.Ohungarumlaut = 778;
            e4.degree = 400;
            e4.ograve = 611;
            e4.Ccaron = 722;
            e4.ugrave = 611;
            e4.radical = 549;
            e4.Dcaron = 722;
            e4.rcommaaccent = 389;
            e4.Ntilde = 722;
            e4.otilde = 611;
            e4.Rcommaaccent = 722;
            e4.Lcommaaccent = 611;
            e4.Atilde = 722;
            e4.Aogonek = 722;
            e4.Aring = 722;
            e4.Otilde = 778;
            e4.zdotaccent = 500;
            e4.Ecaron = 667;
            e4.Iogonek = 278;
            e4.kcommaaccent = 556;
            e4.minus = 584;
            e4.Icircumflex = 278;
            e4.ncaron = 611;
            e4.tcommaaccent = 333;
            e4.logicalnot = 584;
            e4.odieresis = 611;
            e4.udieresis = 611;
            e4.notequal = 549;
            e4.gcommaaccent = 611;
            e4.eth = 611;
            e4.zcaron = 500;
            e4.ncommaaccent = 611;
            e4.onesuperior = 333;
            e4.imacron = 278;
            e4.Euro = 556;
          });
          e3["Helvetica-BoldOblique"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 278;
            e4.exclam = 333;
            e4.quotedbl = 474;
            e4.numbersign = 556;
            e4.dollar = 556;
            e4.percent = 889;
            e4.ampersand = 722;
            e4.quoteright = 278;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 389;
            e4.plus = 584;
            e4.comma = 278;
            e4.hyphen = 333;
            e4.period = 278;
            e4.slash = 278;
            e4.zero = 556;
            e4.one = 556;
            e4.two = 556;
            e4.three = 556;
            e4.four = 556;
            e4.five = 556;
            e4.six = 556;
            e4.seven = 556;
            e4.eight = 556;
            e4.nine = 556;
            e4.colon = 333;
            e4.semicolon = 333;
            e4.less = 584;
            e4.equal = 584;
            e4.greater = 584;
            e4.question = 611;
            e4.at = 975;
            e4.A = 722;
            e4.B = 722;
            e4.C = 722;
            e4.D = 722;
            e4.E = 667;
            e4.F = 611;
            e4.G = 778;
            e4.H = 722;
            e4.I = 278;
            e4.J = 556;
            e4.K = 722;
            e4.L = 611;
            e4.M = 833;
            e4.N = 722;
            e4.O = 778;
            e4.P = 667;
            e4.Q = 778;
            e4.R = 722;
            e4.S = 667;
            e4.T = 611;
            e4.U = 722;
            e4.V = 667;
            e4.W = 944;
            e4.X = 667;
            e4.Y = 667;
            e4.Z = 611;
            e4.bracketleft = 333;
            e4.backslash = 278;
            e4.bracketright = 333;
            e4.asciicircum = 584;
            e4.underscore = 556;
            e4.quoteleft = 278;
            e4.a = 556;
            e4.b = 611;
            e4.c = 556;
            e4.d = 611;
            e4.e = 556;
            e4.f = 333;
            e4.g = 611;
            e4.h = 611;
            e4.i = 278;
            e4.j = 278;
            e4.k = 556;
            e4.l = 278;
            e4.m = 889;
            e4.n = 611;
            e4.o = 611;
            e4.p = 611;
            e4.q = 611;
            e4.r = 389;
            e4.s = 556;
            e4.t = 333;
            e4.u = 611;
            e4.v = 556;
            e4.w = 778;
            e4.x = 556;
            e4.y = 556;
            e4.z = 500;
            e4.braceleft = 389;
            e4.bar = 280;
            e4.braceright = 389;
            e4.asciitilde = 584;
            e4.exclamdown = 333;
            e4.cent = 556;
            e4.sterling = 556;
            e4.fraction = 167;
            e4.yen = 556;
            e4.florin = 556;
            e4.section = 556;
            e4.currency = 556;
            e4.quotesingle = 238;
            e4.quotedblleft = 500;
            e4.guillemotleft = 556;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 611;
            e4.fl = 611;
            e4.endash = 556;
            e4.dagger = 556;
            e4.daggerdbl = 556;
            e4.periodcentered = 278;
            e4.paragraph = 556;
            e4.bullet = 350;
            e4.quotesinglbase = 278;
            e4.quotedblbase = 500;
            e4.quotedblright = 500;
            e4.guillemotright = 556;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 611;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 1e3;
            e4.ordfeminine = 370;
            e4.Lslash = 611;
            e4.Oslash = 778;
            e4.OE = 1e3;
            e4.ordmasculine = 365;
            e4.ae = 889;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 611;
            e4.oe = 944;
            e4.germandbls = 611;
            e4.Idieresis = 278;
            e4.eacute = 556;
            e4.abreve = 556;
            e4.uhungarumlaut = 611;
            e4.ecaron = 556;
            e4.Ydieresis = 667;
            e4.divide = 584;
            e4.Yacute = 667;
            e4.Acircumflex = 722;
            e4.aacute = 556;
            e4.Ucircumflex = 722;
            e4.yacute = 556;
            e4.scommaaccent = 556;
            e4.ecircumflex = 556;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 556;
            e4.Uacute = 722;
            e4.uogonek = 611;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 737;
            e4.Emacron = 667;
            e4.ccaron = 556;
            e4.aring = 556;
            e4.Ncommaaccent = 722;
            e4.lacute = 278;
            e4.agrave = 556;
            e4.Tcommaaccent = 611;
            e4.Cacute = 722;
            e4.atilde = 556;
            e4.Edotaccent = 667;
            e4.scaron = 556;
            e4.scedilla = 556;
            e4.iacute = 278;
            e4.lozenge = 494;
            e4.Rcaron = 722;
            e4.Gcommaaccent = 778;
            e4.ucircumflex = 611;
            e4.acircumflex = 556;
            e4.Amacron = 722;
            e4.rcaron = 389;
            e4.ccedilla = 556;
            e4.Zdotaccent = 611;
            e4.Thorn = 667;
            e4.Omacron = 778;
            e4.Racute = 722;
            e4.Sacute = 667;
            e4.dcaron = 743;
            e4.Umacron = 722;
            e4.uring = 611;
            e4.threesuperior = 333;
            e4.Ograve = 778;
            e4.Agrave = 722;
            e4.Abreve = 722;
            e4.multiply = 584;
            e4.uacute = 611;
            e4.Tcaron = 611;
            e4.partialdiff = 494;
            e4.ydieresis = 556;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 556;
            e4.edieresis = 556;
            e4.cacute = 556;
            e4.nacute = 611;
            e4.umacron = 611;
            e4.Ncaron = 722;
            e4.Iacute = 278;
            e4.plusminus = 584;
            e4.brokenbar = 280;
            e4.registered = 737;
            e4.Gbreve = 778;
            e4.Idotaccent = 278;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 389;
            e4.omacron = 611;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 722;
            e4.lcommaaccent = 278;
            e4.tcaron = 389;
            e4.eogonek = 556;
            e4.Uogonek = 722;
            e4.Aacute = 722;
            e4.Adieresis = 722;
            e4.egrave = 556;
            e4.zacute = 500;
            e4.iogonek = 278;
            e4.Oacute = 778;
            e4.oacute = 611;
            e4.amacron = 556;
            e4.sacute = 556;
            e4.idieresis = 278;
            e4.Ocircumflex = 778;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 611;
            e4.twosuperior = 333;
            e4.Odieresis = 778;
            e4.mu = 611;
            e4.igrave = 278;
            e4.ohungarumlaut = 611;
            e4.Eogonek = 667;
            e4.dcroat = 611;
            e4.threequarters = 834;
            e4.Scedilla = 667;
            e4.lcaron = 400;
            e4.Kcommaaccent = 722;
            e4.Lacute = 611;
            e4.trademark = 1e3;
            e4.edotaccent = 556;
            e4.Igrave = 278;
            e4.Imacron = 278;
            e4.Lcaron = 611;
            e4.onehalf = 834;
            e4.lessequal = 549;
            e4.ocircumflex = 611;
            e4.ntilde = 611;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 556;
            e4.gbreve = 611;
            e4.onequarter = 834;
            e4.Scaron = 667;
            e4.Scommaaccent = 667;
            e4.Ohungarumlaut = 778;
            e4.degree = 400;
            e4.ograve = 611;
            e4.Ccaron = 722;
            e4.ugrave = 611;
            e4.radical = 549;
            e4.Dcaron = 722;
            e4.rcommaaccent = 389;
            e4.Ntilde = 722;
            e4.otilde = 611;
            e4.Rcommaaccent = 722;
            e4.Lcommaaccent = 611;
            e4.Atilde = 722;
            e4.Aogonek = 722;
            e4.Aring = 722;
            e4.Otilde = 778;
            e4.zdotaccent = 500;
            e4.Ecaron = 667;
            e4.Iogonek = 278;
            e4.kcommaaccent = 556;
            e4.minus = 584;
            e4.Icircumflex = 278;
            e4.ncaron = 611;
            e4.tcommaaccent = 333;
            e4.logicalnot = 584;
            e4.odieresis = 611;
            e4.udieresis = 611;
            e4.notequal = 549;
            e4.gcommaaccent = 611;
            e4.eth = 611;
            e4.zcaron = 500;
            e4.ncommaaccent = 611;
            e4.onesuperior = 333;
            e4.imacron = 278;
            e4.Euro = 556;
          });
          e3["Helvetica-Oblique"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 278;
            e4.exclam = 278;
            e4.quotedbl = 355;
            e4.numbersign = 556;
            e4.dollar = 556;
            e4.percent = 889;
            e4.ampersand = 667;
            e4.quoteright = 222;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 389;
            e4.plus = 584;
            e4.comma = 278;
            e4.hyphen = 333;
            e4.period = 278;
            e4.slash = 278;
            e4.zero = 556;
            e4.one = 556;
            e4.two = 556;
            e4.three = 556;
            e4.four = 556;
            e4.five = 556;
            e4.six = 556;
            e4.seven = 556;
            e4.eight = 556;
            e4.nine = 556;
            e4.colon = 278;
            e4.semicolon = 278;
            e4.less = 584;
            e4.equal = 584;
            e4.greater = 584;
            e4.question = 556;
            e4.at = 1015;
            e4.A = 667;
            e4.B = 667;
            e4.C = 722;
            e4.D = 722;
            e4.E = 667;
            e4.F = 611;
            e4.G = 778;
            e4.H = 722;
            e4.I = 278;
            e4.J = 500;
            e4.K = 667;
            e4.L = 556;
            e4.M = 833;
            e4.N = 722;
            e4.O = 778;
            e4.P = 667;
            e4.Q = 778;
            e4.R = 722;
            e4.S = 667;
            e4.T = 611;
            e4.U = 722;
            e4.V = 667;
            e4.W = 944;
            e4.X = 667;
            e4.Y = 667;
            e4.Z = 611;
            e4.bracketleft = 278;
            e4.backslash = 278;
            e4.bracketright = 278;
            e4.asciicircum = 469;
            e4.underscore = 556;
            e4.quoteleft = 222;
            e4.a = 556;
            e4.b = 556;
            e4.c = 500;
            e4.d = 556;
            e4.e = 556;
            e4.f = 278;
            e4.g = 556;
            e4.h = 556;
            e4.i = 222;
            e4.j = 222;
            e4.k = 500;
            e4.l = 222;
            e4.m = 833;
            e4.n = 556;
            e4.o = 556;
            e4.p = 556;
            e4.q = 556;
            e4.r = 333;
            e4.s = 500;
            e4.t = 278;
            e4.u = 556;
            e4.v = 500;
            e4.w = 722;
            e4.x = 500;
            e4.y = 500;
            e4.z = 500;
            e4.braceleft = 334;
            e4.bar = 260;
            e4.braceright = 334;
            e4.asciitilde = 584;
            e4.exclamdown = 333;
            e4.cent = 556;
            e4.sterling = 556;
            e4.fraction = 167;
            e4.yen = 556;
            e4.florin = 556;
            e4.section = 556;
            e4.currency = 556;
            e4.quotesingle = 191;
            e4.quotedblleft = 333;
            e4.guillemotleft = 556;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 500;
            e4.fl = 500;
            e4.endash = 556;
            e4.dagger = 556;
            e4.daggerdbl = 556;
            e4.periodcentered = 278;
            e4.paragraph = 537;
            e4.bullet = 350;
            e4.quotesinglbase = 222;
            e4.quotedblbase = 333;
            e4.quotedblright = 333;
            e4.guillemotright = 556;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 611;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 1e3;
            e4.ordfeminine = 370;
            e4.Lslash = 556;
            e4.Oslash = 778;
            e4.OE = 1e3;
            e4.ordmasculine = 365;
            e4.ae = 889;
            e4.dotlessi = 278;
            e4.lslash = 222;
            e4.oslash = 611;
            e4.oe = 944;
            e4.germandbls = 611;
            e4.Idieresis = 278;
            e4.eacute = 556;
            e4.abreve = 556;
            e4.uhungarumlaut = 556;
            e4.ecaron = 556;
            e4.Ydieresis = 667;
            e4.divide = 584;
            e4.Yacute = 667;
            e4.Acircumflex = 667;
            e4.aacute = 556;
            e4.Ucircumflex = 722;
            e4.yacute = 500;
            e4.scommaaccent = 500;
            e4.ecircumflex = 556;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 556;
            e4.Uacute = 722;
            e4.uogonek = 556;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 737;
            e4.Emacron = 667;
            e4.ccaron = 500;
            e4.aring = 556;
            e4.Ncommaaccent = 722;
            e4.lacute = 222;
            e4.agrave = 556;
            e4.Tcommaaccent = 611;
            e4.Cacute = 722;
            e4.atilde = 556;
            e4.Edotaccent = 667;
            e4.scaron = 500;
            e4.scedilla = 500;
            e4.iacute = 278;
            e4.lozenge = 471;
            e4.Rcaron = 722;
            e4.Gcommaaccent = 778;
            e4.ucircumflex = 556;
            e4.acircumflex = 556;
            e4.Amacron = 667;
            e4.rcaron = 333;
            e4.ccedilla = 500;
            e4.Zdotaccent = 611;
            e4.Thorn = 667;
            e4.Omacron = 778;
            e4.Racute = 722;
            e4.Sacute = 667;
            e4.dcaron = 643;
            e4.Umacron = 722;
            e4.uring = 556;
            e4.threesuperior = 333;
            e4.Ograve = 778;
            e4.Agrave = 667;
            e4.Abreve = 667;
            e4.multiply = 584;
            e4.uacute = 556;
            e4.Tcaron = 611;
            e4.partialdiff = 476;
            e4.ydieresis = 500;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 556;
            e4.edieresis = 556;
            e4.cacute = 500;
            e4.nacute = 556;
            e4.umacron = 556;
            e4.Ncaron = 722;
            e4.Iacute = 278;
            e4.plusminus = 584;
            e4.brokenbar = 260;
            e4.registered = 737;
            e4.Gbreve = 778;
            e4.Idotaccent = 278;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 333;
            e4.omacron = 556;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 722;
            e4.lcommaaccent = 222;
            e4.tcaron = 317;
            e4.eogonek = 556;
            e4.Uogonek = 722;
            e4.Aacute = 667;
            e4.Adieresis = 667;
            e4.egrave = 556;
            e4.zacute = 500;
            e4.iogonek = 222;
            e4.Oacute = 778;
            e4.oacute = 556;
            e4.amacron = 556;
            e4.sacute = 500;
            e4.idieresis = 278;
            e4.Ocircumflex = 778;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 556;
            e4.twosuperior = 333;
            e4.Odieresis = 778;
            e4.mu = 556;
            e4.igrave = 278;
            e4.ohungarumlaut = 556;
            e4.Eogonek = 667;
            e4.dcroat = 556;
            e4.threequarters = 834;
            e4.Scedilla = 667;
            e4.lcaron = 299;
            e4.Kcommaaccent = 667;
            e4.Lacute = 556;
            e4.trademark = 1e3;
            e4.edotaccent = 556;
            e4.Igrave = 278;
            e4.Imacron = 278;
            e4.Lcaron = 556;
            e4.onehalf = 834;
            e4.lessequal = 549;
            e4.ocircumflex = 556;
            e4.ntilde = 556;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 556;
            e4.gbreve = 556;
            e4.onequarter = 834;
            e4.Scaron = 667;
            e4.Scommaaccent = 667;
            e4.Ohungarumlaut = 778;
            e4.degree = 400;
            e4.ograve = 556;
            e4.Ccaron = 722;
            e4.ugrave = 556;
            e4.radical = 453;
            e4.Dcaron = 722;
            e4.rcommaaccent = 333;
            e4.Ntilde = 722;
            e4.otilde = 556;
            e4.Rcommaaccent = 722;
            e4.Lcommaaccent = 556;
            e4.Atilde = 667;
            e4.Aogonek = 667;
            e4.Aring = 667;
            e4.Otilde = 778;
            e4.zdotaccent = 500;
            e4.Ecaron = 667;
            e4.Iogonek = 278;
            e4.kcommaaccent = 500;
            e4.minus = 584;
            e4.Icircumflex = 278;
            e4.ncaron = 556;
            e4.tcommaaccent = 278;
            e4.logicalnot = 584;
            e4.odieresis = 556;
            e4.udieresis = 556;
            e4.notequal = 549;
            e4.gcommaaccent = 556;
            e4.eth = 556;
            e4.zcaron = 500;
            e4.ncommaaccent = 556;
            e4.onesuperior = 333;
            e4.imacron = 278;
            e4.Euro = 556;
          });
          e3.Symbol = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 250;
            e4.exclam = 333;
            e4.universal = 713;
            e4.numbersign = 500;
            e4.existential = 549;
            e4.percent = 833;
            e4.ampersand = 778;
            e4.suchthat = 439;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asteriskmath = 500;
            e4.plus = 549;
            e4.comma = 250;
            e4.minus = 549;
            e4.period = 250;
            e4.slash = 278;
            e4.zero = 500;
            e4.one = 500;
            e4.two = 500;
            e4.three = 500;
            e4.four = 500;
            e4.five = 500;
            e4.six = 500;
            e4.seven = 500;
            e4.eight = 500;
            e4.nine = 500;
            e4.colon = 278;
            e4.semicolon = 278;
            e4.less = 549;
            e4.equal = 549;
            e4.greater = 549;
            e4.question = 444;
            e4.congruent = 549;
            e4.Alpha = 722;
            e4.Beta = 667;
            e4.Chi = 722;
            e4.Delta = 612;
            e4.Epsilon = 611;
            e4.Phi = 763;
            e4.Gamma = 603;
            e4.Eta = 722;
            e4.Iota = 333;
            e4.theta1 = 631;
            e4.Kappa = 722;
            e4.Lambda = 686;
            e4.Mu = 889;
            e4.Nu = 722;
            e4.Omicron = 722;
            e4.Pi = 768;
            e4.Theta = 741;
            e4.Rho = 556;
            e4.Sigma = 592;
            e4.Tau = 611;
            e4.Upsilon = 690;
            e4.sigma1 = 439;
            e4.Omega = 768;
            e4.Xi = 645;
            e4.Psi = 795;
            e4.Zeta = 611;
            e4.bracketleft = 333;
            e4.therefore = 863;
            e4.bracketright = 333;
            e4.perpendicular = 658;
            e4.underscore = 500;
            e4.radicalex = 500;
            e4.alpha = 631;
            e4.beta = 549;
            e4.chi = 549;
            e4.delta = 494;
            e4.epsilon = 439;
            e4.phi = 521;
            e4.gamma = 411;
            e4.eta = 603;
            e4.iota = 329;
            e4.phi1 = 603;
            e4.kappa = 549;
            e4.lambda = 549;
            e4.mu = 576;
            e4.nu = 521;
            e4.omicron = 549;
            e4.pi = 549;
            e4.theta = 521;
            e4.rho = 549;
            e4.sigma = 603;
            e4.tau = 439;
            e4.upsilon = 576;
            e4.omega1 = 713;
            e4.omega = 686;
            e4.xi = 493;
            e4.psi = 686;
            e4.zeta = 494;
            e4.braceleft = 480;
            e4.bar = 200;
            e4.braceright = 480;
            e4.similar = 549;
            e4.Euro = 750;
            e4.Upsilon1 = 620;
            e4.minute = 247;
            e4.lessequal = 549;
            e4.fraction = 167;
            e4.infinity = 713;
            e4.florin = 500;
            e4.club = 753;
            e4.diamond = 753;
            e4.heart = 753;
            e4.spade = 753;
            e4.arrowboth = 1042;
            e4.arrowleft = 987;
            e4.arrowup = 603;
            e4.arrowright = 987;
            e4.arrowdown = 603;
            e4.degree = 400;
            e4.plusminus = 549;
            e4.second = 411;
            e4.greaterequal = 549;
            e4.multiply = 549;
            e4.proportional = 713;
            e4.partialdiff = 494;
            e4.bullet = 460;
            e4.divide = 549;
            e4.notequal = 549;
            e4.equivalence = 549;
            e4.approxequal = 549;
            e4.ellipsis = 1e3;
            e4.arrowvertex = 603;
            e4.arrowhorizex = 1e3;
            e4.carriagereturn = 658;
            e4.aleph = 823;
            e4.Ifraktur = 686;
            e4.Rfraktur = 795;
            e4.weierstrass = 987;
            e4.circlemultiply = 768;
            e4.circleplus = 768;
            e4.emptyset = 823;
            e4.intersection = 768;
            e4.union = 768;
            e4.propersuperset = 713;
            e4.reflexsuperset = 713;
            e4.notsubset = 713;
            e4.propersubset = 713;
            e4.reflexsubset = 713;
            e4.element = 713;
            e4.notelement = 713;
            e4.angle = 768;
            e4.gradient = 713;
            e4.registerserif = 790;
            e4.copyrightserif = 790;
            e4.trademarkserif = 890;
            e4.product = 823;
            e4.radical = 549;
            e4.dotmath = 250;
            e4.logicalnot = 713;
            e4.logicaland = 603;
            e4.logicalor = 603;
            e4.arrowdblboth = 1042;
            e4.arrowdblleft = 987;
            e4.arrowdblup = 603;
            e4.arrowdblright = 987;
            e4.arrowdbldown = 603;
            e4.lozenge = 494;
            e4.angleleft = 329;
            e4.registersans = 790;
            e4.copyrightsans = 790;
            e4.trademarksans = 786;
            e4.summation = 713;
            e4.parenlefttp = 384;
            e4.parenleftex = 384;
            e4.parenleftbt = 384;
            e4.bracketlefttp = 384;
            e4.bracketleftex = 384;
            e4.bracketleftbt = 384;
            e4.bracelefttp = 494;
            e4.braceleftmid = 494;
            e4.braceleftbt = 494;
            e4.braceex = 494;
            e4.angleright = 329;
            e4.integral = 274;
            e4.integraltp = 686;
            e4.integralex = 686;
            e4.integralbt = 686;
            e4.parenrighttp = 384;
            e4.parenrightex = 384;
            e4.parenrightbt = 384;
            e4.bracketrighttp = 384;
            e4.bracketrightex = 384;
            e4.bracketrightbt = 384;
            e4.bracerighttp = 494;
            e4.bracerightmid = 494;
            e4.bracerightbt = 494;
            e4.apple = 790;
          });
          e3["Times-Roman"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 250;
            e4.exclam = 333;
            e4.quotedbl = 408;
            e4.numbersign = 500;
            e4.dollar = 500;
            e4.percent = 833;
            e4.ampersand = 778;
            e4.quoteright = 333;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 500;
            e4.plus = 564;
            e4.comma = 250;
            e4.hyphen = 333;
            e4.period = 250;
            e4.slash = 278;
            e4.zero = 500;
            e4.one = 500;
            e4.two = 500;
            e4.three = 500;
            e4.four = 500;
            e4.five = 500;
            e4.six = 500;
            e4.seven = 500;
            e4.eight = 500;
            e4.nine = 500;
            e4.colon = 278;
            e4.semicolon = 278;
            e4.less = 564;
            e4.equal = 564;
            e4.greater = 564;
            e4.question = 444;
            e4.at = 921;
            e4.A = 722;
            e4.B = 667;
            e4.C = 667;
            e4.D = 722;
            e4.E = 611;
            e4.F = 556;
            e4.G = 722;
            e4.H = 722;
            e4.I = 333;
            e4.J = 389;
            e4.K = 722;
            e4.L = 611;
            e4.M = 889;
            e4.N = 722;
            e4.O = 722;
            e4.P = 556;
            e4.Q = 722;
            e4.R = 667;
            e4.S = 556;
            e4.T = 611;
            e4.U = 722;
            e4.V = 722;
            e4.W = 944;
            e4.X = 722;
            e4.Y = 722;
            e4.Z = 611;
            e4.bracketleft = 333;
            e4.backslash = 278;
            e4.bracketright = 333;
            e4.asciicircum = 469;
            e4.underscore = 500;
            e4.quoteleft = 333;
            e4.a = 444;
            e4.b = 500;
            e4.c = 444;
            e4.d = 500;
            e4.e = 444;
            e4.f = 333;
            e4.g = 500;
            e4.h = 500;
            e4.i = 278;
            e4.j = 278;
            e4.k = 500;
            e4.l = 278;
            e4.m = 778;
            e4.n = 500;
            e4.o = 500;
            e4.p = 500;
            e4.q = 500;
            e4.r = 333;
            e4.s = 389;
            e4.t = 278;
            e4.u = 500;
            e4.v = 500;
            e4.w = 722;
            e4.x = 500;
            e4.y = 500;
            e4.z = 444;
            e4.braceleft = 480;
            e4.bar = 200;
            e4.braceright = 480;
            e4.asciitilde = 541;
            e4.exclamdown = 333;
            e4.cent = 500;
            e4.sterling = 500;
            e4.fraction = 167;
            e4.yen = 500;
            e4.florin = 500;
            e4.section = 500;
            e4.currency = 500;
            e4.quotesingle = 180;
            e4.quotedblleft = 444;
            e4.guillemotleft = 500;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 556;
            e4.fl = 556;
            e4.endash = 500;
            e4.dagger = 500;
            e4.daggerdbl = 500;
            e4.periodcentered = 250;
            e4.paragraph = 453;
            e4.bullet = 350;
            e4.quotesinglbase = 333;
            e4.quotedblbase = 444;
            e4.quotedblright = 444;
            e4.guillemotright = 500;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 444;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 889;
            e4.ordfeminine = 276;
            e4.Lslash = 611;
            e4.Oslash = 722;
            e4.OE = 889;
            e4.ordmasculine = 310;
            e4.ae = 667;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 500;
            e4.oe = 722;
            e4.germandbls = 500;
            e4.Idieresis = 333;
            e4.eacute = 444;
            e4.abreve = 444;
            e4.uhungarumlaut = 500;
            e4.ecaron = 444;
            e4.Ydieresis = 722;
            e4.divide = 564;
            e4.Yacute = 722;
            e4.Acircumflex = 722;
            e4.aacute = 444;
            e4.Ucircumflex = 722;
            e4.yacute = 500;
            e4.scommaaccent = 389;
            e4.ecircumflex = 444;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 444;
            e4.Uacute = 722;
            e4.uogonek = 500;
            e4.Edieresis = 611;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 760;
            e4.Emacron = 611;
            e4.ccaron = 444;
            e4.aring = 444;
            e4.Ncommaaccent = 722;
            e4.lacute = 278;
            e4.agrave = 444;
            e4.Tcommaaccent = 611;
            e4.Cacute = 667;
            e4.atilde = 444;
            e4.Edotaccent = 611;
            e4.scaron = 389;
            e4.scedilla = 389;
            e4.iacute = 278;
            e4.lozenge = 471;
            e4.Rcaron = 667;
            e4.Gcommaaccent = 722;
            e4.ucircumflex = 500;
            e4.acircumflex = 444;
            e4.Amacron = 722;
            e4.rcaron = 333;
            e4.ccedilla = 444;
            e4.Zdotaccent = 611;
            e4.Thorn = 556;
            e4.Omacron = 722;
            e4.Racute = 667;
            e4.Sacute = 556;
            e4.dcaron = 588;
            e4.Umacron = 722;
            e4.uring = 500;
            e4.threesuperior = 300;
            e4.Ograve = 722;
            e4.Agrave = 722;
            e4.Abreve = 722;
            e4.multiply = 564;
            e4.uacute = 500;
            e4.Tcaron = 611;
            e4.partialdiff = 476;
            e4.ydieresis = 500;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 611;
            e4.adieresis = 444;
            e4.edieresis = 444;
            e4.cacute = 444;
            e4.nacute = 500;
            e4.umacron = 500;
            e4.Ncaron = 722;
            e4.Iacute = 333;
            e4.plusminus = 564;
            e4.brokenbar = 200;
            e4.registered = 760;
            e4.Gbreve = 722;
            e4.Idotaccent = 333;
            e4.summation = 600;
            e4.Egrave = 611;
            e4.racute = 333;
            e4.omacron = 500;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 667;
            e4.lcommaaccent = 278;
            e4.tcaron = 326;
            e4.eogonek = 444;
            e4.Uogonek = 722;
            e4.Aacute = 722;
            e4.Adieresis = 722;
            e4.egrave = 444;
            e4.zacute = 444;
            e4.iogonek = 278;
            e4.Oacute = 722;
            e4.oacute = 500;
            e4.amacron = 444;
            e4.sacute = 389;
            e4.idieresis = 278;
            e4.Ocircumflex = 722;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 500;
            e4.twosuperior = 300;
            e4.Odieresis = 722;
            e4.mu = 500;
            e4.igrave = 278;
            e4.ohungarumlaut = 500;
            e4.Eogonek = 611;
            e4.dcroat = 500;
            e4.threequarters = 750;
            e4.Scedilla = 556;
            e4.lcaron = 344;
            e4.Kcommaaccent = 722;
            e4.Lacute = 611;
            e4.trademark = 980;
            e4.edotaccent = 444;
            e4.Igrave = 333;
            e4.Imacron = 333;
            e4.Lcaron = 611;
            e4.onehalf = 750;
            e4.lessequal = 549;
            e4.ocircumflex = 500;
            e4.ntilde = 500;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 611;
            e4.emacron = 444;
            e4.gbreve = 500;
            e4.onequarter = 750;
            e4.Scaron = 556;
            e4.Scommaaccent = 556;
            e4.Ohungarumlaut = 722;
            e4.degree = 400;
            e4.ograve = 500;
            e4.Ccaron = 667;
            e4.ugrave = 500;
            e4.radical = 453;
            e4.Dcaron = 722;
            e4.rcommaaccent = 333;
            e4.Ntilde = 722;
            e4.otilde = 500;
            e4.Rcommaaccent = 667;
            e4.Lcommaaccent = 611;
            e4.Atilde = 722;
            e4.Aogonek = 722;
            e4.Aring = 722;
            e4.Otilde = 722;
            e4.zdotaccent = 444;
            e4.Ecaron = 611;
            e4.Iogonek = 333;
            e4.kcommaaccent = 500;
            e4.minus = 564;
            e4.Icircumflex = 333;
            e4.ncaron = 500;
            e4.tcommaaccent = 278;
            e4.logicalnot = 564;
            e4.odieresis = 500;
            e4.udieresis = 500;
            e4.notequal = 549;
            e4.gcommaaccent = 500;
            e4.eth = 500;
            e4.zcaron = 444;
            e4.ncommaaccent = 500;
            e4.onesuperior = 300;
            e4.imacron = 278;
            e4.Euro = 500;
          });
          e3["Times-Bold"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 250;
            e4.exclam = 333;
            e4.quotedbl = 555;
            e4.numbersign = 500;
            e4.dollar = 500;
            e4.percent = 1e3;
            e4.ampersand = 833;
            e4.quoteright = 333;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 500;
            e4.plus = 570;
            e4.comma = 250;
            e4.hyphen = 333;
            e4.period = 250;
            e4.slash = 278;
            e4.zero = 500;
            e4.one = 500;
            e4.two = 500;
            e4.three = 500;
            e4.four = 500;
            e4.five = 500;
            e4.six = 500;
            e4.seven = 500;
            e4.eight = 500;
            e4.nine = 500;
            e4.colon = 333;
            e4.semicolon = 333;
            e4.less = 570;
            e4.equal = 570;
            e4.greater = 570;
            e4.question = 500;
            e4.at = 930;
            e4.A = 722;
            e4.B = 667;
            e4.C = 722;
            e4.D = 722;
            e4.E = 667;
            e4.F = 611;
            e4.G = 778;
            e4.H = 778;
            e4.I = 389;
            e4.J = 500;
            e4.K = 778;
            e4.L = 667;
            e4.M = 944;
            e4.N = 722;
            e4.O = 778;
            e4.P = 611;
            e4.Q = 778;
            e4.R = 722;
            e4.S = 556;
            e4.T = 667;
            e4.U = 722;
            e4.V = 722;
            e4.W = 1e3;
            e4.X = 722;
            e4.Y = 722;
            e4.Z = 667;
            e4.bracketleft = 333;
            e4.backslash = 278;
            e4.bracketright = 333;
            e4.asciicircum = 581;
            e4.underscore = 500;
            e4.quoteleft = 333;
            e4.a = 500;
            e4.b = 556;
            e4.c = 444;
            e4.d = 556;
            e4.e = 444;
            e4.f = 333;
            e4.g = 500;
            e4.h = 556;
            e4.i = 278;
            e4.j = 333;
            e4.k = 556;
            e4.l = 278;
            e4.m = 833;
            e4.n = 556;
            e4.o = 500;
            e4.p = 556;
            e4.q = 556;
            e4.r = 444;
            e4.s = 389;
            e4.t = 333;
            e4.u = 556;
            e4.v = 500;
            e4.w = 722;
            e4.x = 500;
            e4.y = 500;
            e4.z = 444;
            e4.braceleft = 394;
            e4.bar = 220;
            e4.braceright = 394;
            e4.asciitilde = 520;
            e4.exclamdown = 333;
            e4.cent = 500;
            e4.sterling = 500;
            e4.fraction = 167;
            e4.yen = 500;
            e4.florin = 500;
            e4.section = 500;
            e4.currency = 500;
            e4.quotesingle = 278;
            e4.quotedblleft = 500;
            e4.guillemotleft = 500;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 556;
            e4.fl = 556;
            e4.endash = 500;
            e4.dagger = 500;
            e4.daggerdbl = 500;
            e4.periodcentered = 250;
            e4.paragraph = 540;
            e4.bullet = 350;
            e4.quotesinglbase = 333;
            e4.quotedblbase = 500;
            e4.quotedblright = 500;
            e4.guillemotright = 500;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 500;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 1e3;
            e4.ordfeminine = 300;
            e4.Lslash = 667;
            e4.Oslash = 778;
            e4.OE = 1e3;
            e4.ordmasculine = 330;
            e4.ae = 722;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 500;
            e4.oe = 722;
            e4.germandbls = 556;
            e4.Idieresis = 389;
            e4.eacute = 444;
            e4.abreve = 500;
            e4.uhungarumlaut = 556;
            e4.ecaron = 444;
            e4.Ydieresis = 722;
            e4.divide = 570;
            e4.Yacute = 722;
            e4.Acircumflex = 722;
            e4.aacute = 500;
            e4.Ucircumflex = 722;
            e4.yacute = 500;
            e4.scommaaccent = 389;
            e4.ecircumflex = 444;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 500;
            e4.Uacute = 722;
            e4.uogonek = 556;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 747;
            e4.Emacron = 667;
            e4.ccaron = 444;
            e4.aring = 500;
            e4.Ncommaaccent = 722;
            e4.lacute = 278;
            e4.agrave = 500;
            e4.Tcommaaccent = 667;
            e4.Cacute = 722;
            e4.atilde = 500;
            e4.Edotaccent = 667;
            e4.scaron = 389;
            e4.scedilla = 389;
            e4.iacute = 278;
            e4.lozenge = 494;
            e4.Rcaron = 722;
            e4.Gcommaaccent = 778;
            e4.ucircumflex = 556;
            e4.acircumflex = 500;
            e4.Amacron = 722;
            e4.rcaron = 444;
            e4.ccedilla = 444;
            e4.Zdotaccent = 667;
            e4.Thorn = 611;
            e4.Omacron = 778;
            e4.Racute = 722;
            e4.Sacute = 556;
            e4.dcaron = 672;
            e4.Umacron = 722;
            e4.uring = 556;
            e4.threesuperior = 300;
            e4.Ograve = 778;
            e4.Agrave = 722;
            e4.Abreve = 722;
            e4.multiply = 570;
            e4.uacute = 556;
            e4.Tcaron = 667;
            e4.partialdiff = 494;
            e4.ydieresis = 500;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 500;
            e4.edieresis = 444;
            e4.cacute = 444;
            e4.nacute = 556;
            e4.umacron = 556;
            e4.Ncaron = 722;
            e4.Iacute = 389;
            e4.plusminus = 570;
            e4.brokenbar = 220;
            e4.registered = 747;
            e4.Gbreve = 778;
            e4.Idotaccent = 389;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 444;
            e4.omacron = 500;
            e4.Zacute = 667;
            e4.Zcaron = 667;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 722;
            e4.lcommaaccent = 278;
            e4.tcaron = 416;
            e4.eogonek = 444;
            e4.Uogonek = 722;
            e4.Aacute = 722;
            e4.Adieresis = 722;
            e4.egrave = 444;
            e4.zacute = 444;
            e4.iogonek = 278;
            e4.Oacute = 778;
            e4.oacute = 500;
            e4.amacron = 500;
            e4.sacute = 389;
            e4.idieresis = 278;
            e4.Ocircumflex = 778;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 556;
            e4.twosuperior = 300;
            e4.Odieresis = 778;
            e4.mu = 556;
            e4.igrave = 278;
            e4.ohungarumlaut = 500;
            e4.Eogonek = 667;
            e4.dcroat = 556;
            e4.threequarters = 750;
            e4.Scedilla = 556;
            e4.lcaron = 394;
            e4.Kcommaaccent = 778;
            e4.Lacute = 667;
            e4.trademark = 1e3;
            e4.edotaccent = 444;
            e4.Igrave = 389;
            e4.Imacron = 389;
            e4.Lcaron = 667;
            e4.onehalf = 750;
            e4.lessequal = 549;
            e4.ocircumflex = 500;
            e4.ntilde = 556;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 444;
            e4.gbreve = 500;
            e4.onequarter = 750;
            e4.Scaron = 556;
            e4.Scommaaccent = 556;
            e4.Ohungarumlaut = 778;
            e4.degree = 400;
            e4.ograve = 500;
            e4.Ccaron = 722;
            e4.ugrave = 556;
            e4.radical = 549;
            e4.Dcaron = 722;
            e4.rcommaaccent = 444;
            e4.Ntilde = 722;
            e4.otilde = 500;
            e4.Rcommaaccent = 722;
            e4.Lcommaaccent = 667;
            e4.Atilde = 722;
            e4.Aogonek = 722;
            e4.Aring = 722;
            e4.Otilde = 778;
            e4.zdotaccent = 444;
            e4.Ecaron = 667;
            e4.Iogonek = 389;
            e4.kcommaaccent = 556;
            e4.minus = 570;
            e4.Icircumflex = 389;
            e4.ncaron = 556;
            e4.tcommaaccent = 333;
            e4.logicalnot = 570;
            e4.odieresis = 500;
            e4.udieresis = 556;
            e4.notequal = 549;
            e4.gcommaaccent = 500;
            e4.eth = 500;
            e4.zcaron = 444;
            e4.ncommaaccent = 556;
            e4.onesuperior = 300;
            e4.imacron = 278;
            e4.Euro = 500;
          });
          e3["Times-BoldItalic"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 250;
            e4.exclam = 389;
            e4.quotedbl = 555;
            e4.numbersign = 500;
            e4.dollar = 500;
            e4.percent = 833;
            e4.ampersand = 778;
            e4.quoteright = 333;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 500;
            e4.plus = 570;
            e4.comma = 250;
            e4.hyphen = 333;
            e4.period = 250;
            e4.slash = 278;
            e4.zero = 500;
            e4.one = 500;
            e4.two = 500;
            e4.three = 500;
            e4.four = 500;
            e4.five = 500;
            e4.six = 500;
            e4.seven = 500;
            e4.eight = 500;
            e4.nine = 500;
            e4.colon = 333;
            e4.semicolon = 333;
            e4.less = 570;
            e4.equal = 570;
            e4.greater = 570;
            e4.question = 500;
            e4.at = 832;
            e4.A = 667;
            e4.B = 667;
            e4.C = 667;
            e4.D = 722;
            e4.E = 667;
            e4.F = 667;
            e4.G = 722;
            e4.H = 778;
            e4.I = 389;
            e4.J = 500;
            e4.K = 667;
            e4.L = 611;
            e4.M = 889;
            e4.N = 722;
            e4.O = 722;
            e4.P = 611;
            e4.Q = 722;
            e4.R = 667;
            e4.S = 556;
            e4.T = 611;
            e4.U = 722;
            e4.V = 667;
            e4.W = 889;
            e4.X = 667;
            e4.Y = 611;
            e4.Z = 611;
            e4.bracketleft = 333;
            e4.backslash = 278;
            e4.bracketright = 333;
            e4.asciicircum = 570;
            e4.underscore = 500;
            e4.quoteleft = 333;
            e4.a = 500;
            e4.b = 500;
            e4.c = 444;
            e4.d = 500;
            e4.e = 444;
            e4.f = 333;
            e4.g = 500;
            e4.h = 556;
            e4.i = 278;
            e4.j = 278;
            e4.k = 500;
            e4.l = 278;
            e4.m = 778;
            e4.n = 556;
            e4.o = 500;
            e4.p = 500;
            e4.q = 500;
            e4.r = 389;
            e4.s = 389;
            e4.t = 278;
            e4.u = 556;
            e4.v = 444;
            e4.w = 667;
            e4.x = 500;
            e4.y = 444;
            e4.z = 389;
            e4.braceleft = 348;
            e4.bar = 220;
            e4.braceright = 348;
            e4.asciitilde = 570;
            e4.exclamdown = 389;
            e4.cent = 500;
            e4.sterling = 500;
            e4.fraction = 167;
            e4.yen = 500;
            e4.florin = 500;
            e4.section = 500;
            e4.currency = 500;
            e4.quotesingle = 278;
            e4.quotedblleft = 500;
            e4.guillemotleft = 500;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 556;
            e4.fl = 556;
            e4.endash = 500;
            e4.dagger = 500;
            e4.daggerdbl = 500;
            e4.periodcentered = 250;
            e4.paragraph = 500;
            e4.bullet = 350;
            e4.quotesinglbase = 333;
            e4.quotedblbase = 500;
            e4.quotedblright = 500;
            e4.guillemotright = 500;
            e4.ellipsis = 1e3;
            e4.perthousand = 1e3;
            e4.questiondown = 500;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 1e3;
            e4.AE = 944;
            e4.ordfeminine = 266;
            e4.Lslash = 611;
            e4.Oslash = 722;
            e4.OE = 944;
            e4.ordmasculine = 300;
            e4.ae = 722;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 500;
            e4.oe = 722;
            e4.germandbls = 500;
            e4.Idieresis = 389;
            e4.eacute = 444;
            e4.abreve = 500;
            e4.uhungarumlaut = 556;
            e4.ecaron = 444;
            e4.Ydieresis = 611;
            e4.divide = 570;
            e4.Yacute = 611;
            e4.Acircumflex = 667;
            e4.aacute = 500;
            e4.Ucircumflex = 722;
            e4.yacute = 444;
            e4.scommaaccent = 389;
            e4.ecircumflex = 444;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 500;
            e4.Uacute = 722;
            e4.uogonek = 556;
            e4.Edieresis = 667;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 747;
            e4.Emacron = 667;
            e4.ccaron = 444;
            e4.aring = 500;
            e4.Ncommaaccent = 722;
            e4.lacute = 278;
            e4.agrave = 500;
            e4.Tcommaaccent = 611;
            e4.Cacute = 667;
            e4.atilde = 500;
            e4.Edotaccent = 667;
            e4.scaron = 389;
            e4.scedilla = 389;
            e4.iacute = 278;
            e4.lozenge = 494;
            e4.Rcaron = 667;
            e4.Gcommaaccent = 722;
            e4.ucircumflex = 556;
            e4.acircumflex = 500;
            e4.Amacron = 667;
            e4.rcaron = 389;
            e4.ccedilla = 444;
            e4.Zdotaccent = 611;
            e4.Thorn = 611;
            e4.Omacron = 722;
            e4.Racute = 667;
            e4.Sacute = 556;
            e4.dcaron = 608;
            e4.Umacron = 722;
            e4.uring = 556;
            e4.threesuperior = 300;
            e4.Ograve = 722;
            e4.Agrave = 667;
            e4.Abreve = 667;
            e4.multiply = 570;
            e4.uacute = 556;
            e4.Tcaron = 611;
            e4.partialdiff = 494;
            e4.ydieresis = 444;
            e4.Nacute = 722;
            e4.icircumflex = 278;
            e4.Ecircumflex = 667;
            e4.adieresis = 500;
            e4.edieresis = 444;
            e4.cacute = 444;
            e4.nacute = 556;
            e4.umacron = 556;
            e4.Ncaron = 722;
            e4.Iacute = 389;
            e4.plusminus = 570;
            e4.brokenbar = 220;
            e4.registered = 747;
            e4.Gbreve = 722;
            e4.Idotaccent = 389;
            e4.summation = 600;
            e4.Egrave = 667;
            e4.racute = 389;
            e4.omacron = 500;
            e4.Zacute = 611;
            e4.Zcaron = 611;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 667;
            e4.lcommaaccent = 278;
            e4.tcaron = 366;
            e4.eogonek = 444;
            e4.Uogonek = 722;
            e4.Aacute = 667;
            e4.Adieresis = 667;
            e4.egrave = 444;
            e4.zacute = 389;
            e4.iogonek = 278;
            e4.Oacute = 722;
            e4.oacute = 500;
            e4.amacron = 500;
            e4.sacute = 389;
            e4.idieresis = 278;
            e4.Ocircumflex = 722;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 500;
            e4.twosuperior = 300;
            e4.Odieresis = 722;
            e4.mu = 576;
            e4.igrave = 278;
            e4.ohungarumlaut = 500;
            e4.Eogonek = 667;
            e4.dcroat = 500;
            e4.threequarters = 750;
            e4.Scedilla = 556;
            e4.lcaron = 382;
            e4.Kcommaaccent = 667;
            e4.Lacute = 611;
            e4.trademark = 1e3;
            e4.edotaccent = 444;
            e4.Igrave = 389;
            e4.Imacron = 389;
            e4.Lcaron = 611;
            e4.onehalf = 750;
            e4.lessequal = 549;
            e4.ocircumflex = 500;
            e4.ntilde = 556;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 667;
            e4.emacron = 444;
            e4.gbreve = 500;
            e4.onequarter = 750;
            e4.Scaron = 556;
            e4.Scommaaccent = 556;
            e4.Ohungarumlaut = 722;
            e4.degree = 400;
            e4.ograve = 500;
            e4.Ccaron = 667;
            e4.ugrave = 556;
            e4.radical = 549;
            e4.Dcaron = 722;
            e4.rcommaaccent = 389;
            e4.Ntilde = 722;
            e4.otilde = 500;
            e4.Rcommaaccent = 667;
            e4.Lcommaaccent = 611;
            e4.Atilde = 667;
            e4.Aogonek = 667;
            e4.Aring = 667;
            e4.Otilde = 722;
            e4.zdotaccent = 389;
            e4.Ecaron = 667;
            e4.Iogonek = 389;
            e4.kcommaaccent = 500;
            e4.minus = 606;
            e4.Icircumflex = 389;
            e4.ncaron = 556;
            e4.tcommaaccent = 278;
            e4.logicalnot = 606;
            e4.odieresis = 500;
            e4.udieresis = 556;
            e4.notequal = 549;
            e4.gcommaaccent = 500;
            e4.eth = 500;
            e4.zcaron = 389;
            e4.ncommaaccent = 556;
            e4.onesuperior = 300;
            e4.imacron = 278;
            e4.Euro = 500;
          });
          e3["Times-Italic"] = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 250;
            e4.exclam = 333;
            e4.quotedbl = 420;
            e4.numbersign = 500;
            e4.dollar = 500;
            e4.percent = 833;
            e4.ampersand = 778;
            e4.quoteright = 333;
            e4.parenleft = 333;
            e4.parenright = 333;
            e4.asterisk = 500;
            e4.plus = 675;
            e4.comma = 250;
            e4.hyphen = 333;
            e4.period = 250;
            e4.slash = 278;
            e4.zero = 500;
            e4.one = 500;
            e4.two = 500;
            e4.three = 500;
            e4.four = 500;
            e4.five = 500;
            e4.six = 500;
            e4.seven = 500;
            e4.eight = 500;
            e4.nine = 500;
            e4.colon = 333;
            e4.semicolon = 333;
            e4.less = 675;
            e4.equal = 675;
            e4.greater = 675;
            e4.question = 500;
            e4.at = 920;
            e4.A = 611;
            e4.B = 611;
            e4.C = 667;
            e4.D = 722;
            e4.E = 611;
            e4.F = 611;
            e4.G = 722;
            e4.H = 722;
            e4.I = 333;
            e4.J = 444;
            e4.K = 667;
            e4.L = 556;
            e4.M = 833;
            e4.N = 667;
            e4.O = 722;
            e4.P = 611;
            e4.Q = 722;
            e4.R = 611;
            e4.S = 500;
            e4.T = 556;
            e4.U = 722;
            e4.V = 611;
            e4.W = 833;
            e4.X = 611;
            e4.Y = 556;
            e4.Z = 556;
            e4.bracketleft = 389;
            e4.backslash = 278;
            e4.bracketright = 389;
            e4.asciicircum = 422;
            e4.underscore = 500;
            e4.quoteleft = 333;
            e4.a = 500;
            e4.b = 500;
            e4.c = 444;
            e4.d = 500;
            e4.e = 444;
            e4.f = 278;
            e4.g = 500;
            e4.h = 500;
            e4.i = 278;
            e4.j = 278;
            e4.k = 444;
            e4.l = 278;
            e4.m = 722;
            e4.n = 500;
            e4.o = 500;
            e4.p = 500;
            e4.q = 500;
            e4.r = 389;
            e4.s = 389;
            e4.t = 278;
            e4.u = 500;
            e4.v = 444;
            e4.w = 667;
            e4.x = 444;
            e4.y = 444;
            e4.z = 389;
            e4.braceleft = 400;
            e4.bar = 275;
            e4.braceright = 400;
            e4.asciitilde = 541;
            e4.exclamdown = 389;
            e4.cent = 500;
            e4.sterling = 500;
            e4.fraction = 167;
            e4.yen = 500;
            e4.florin = 500;
            e4.section = 500;
            e4.currency = 500;
            e4.quotesingle = 214;
            e4.quotedblleft = 556;
            e4.guillemotleft = 500;
            e4.guilsinglleft = 333;
            e4.guilsinglright = 333;
            e4.fi = 500;
            e4.fl = 500;
            e4.endash = 500;
            e4.dagger = 500;
            e4.daggerdbl = 500;
            e4.periodcentered = 250;
            e4.paragraph = 523;
            e4.bullet = 350;
            e4.quotesinglbase = 333;
            e4.quotedblbase = 556;
            e4.quotedblright = 556;
            e4.guillemotright = 500;
            e4.ellipsis = 889;
            e4.perthousand = 1e3;
            e4.questiondown = 500;
            e4.grave = 333;
            e4.acute = 333;
            e4.circumflex = 333;
            e4.tilde = 333;
            e4.macron = 333;
            e4.breve = 333;
            e4.dotaccent = 333;
            e4.dieresis = 333;
            e4.ring = 333;
            e4.cedilla = 333;
            e4.hungarumlaut = 333;
            e4.ogonek = 333;
            e4.caron = 333;
            e4.emdash = 889;
            e4.AE = 889;
            e4.ordfeminine = 276;
            e4.Lslash = 556;
            e4.Oslash = 722;
            e4.OE = 944;
            e4.ordmasculine = 310;
            e4.ae = 667;
            e4.dotlessi = 278;
            e4.lslash = 278;
            e4.oslash = 500;
            e4.oe = 667;
            e4.germandbls = 500;
            e4.Idieresis = 333;
            e4.eacute = 444;
            e4.abreve = 500;
            e4.uhungarumlaut = 500;
            e4.ecaron = 444;
            e4.Ydieresis = 556;
            e4.divide = 675;
            e4.Yacute = 556;
            e4.Acircumflex = 611;
            e4.aacute = 500;
            e4.Ucircumflex = 722;
            e4.yacute = 444;
            e4.scommaaccent = 389;
            e4.ecircumflex = 444;
            e4.Uring = 722;
            e4.Udieresis = 722;
            e4.aogonek = 500;
            e4.Uacute = 722;
            e4.uogonek = 500;
            e4.Edieresis = 611;
            e4.Dcroat = 722;
            e4.commaaccent = 250;
            e4.copyright = 760;
            e4.Emacron = 611;
            e4.ccaron = 444;
            e4.aring = 500;
            e4.Ncommaaccent = 667;
            e4.lacute = 278;
            e4.agrave = 500;
            e4.Tcommaaccent = 556;
            e4.Cacute = 667;
            e4.atilde = 500;
            e4.Edotaccent = 611;
            e4.scaron = 389;
            e4.scedilla = 389;
            e4.iacute = 278;
            e4.lozenge = 471;
            e4.Rcaron = 611;
            e4.Gcommaaccent = 722;
            e4.ucircumflex = 500;
            e4.acircumflex = 500;
            e4.Amacron = 611;
            e4.rcaron = 389;
            e4.ccedilla = 444;
            e4.Zdotaccent = 556;
            e4.Thorn = 611;
            e4.Omacron = 722;
            e4.Racute = 611;
            e4.Sacute = 500;
            e4.dcaron = 544;
            e4.Umacron = 722;
            e4.uring = 500;
            e4.threesuperior = 300;
            e4.Ograve = 722;
            e4.Agrave = 611;
            e4.Abreve = 611;
            e4.multiply = 675;
            e4.uacute = 500;
            e4.Tcaron = 556;
            e4.partialdiff = 476;
            e4.ydieresis = 444;
            e4.Nacute = 667;
            e4.icircumflex = 278;
            e4.Ecircumflex = 611;
            e4.adieresis = 500;
            e4.edieresis = 444;
            e4.cacute = 444;
            e4.nacute = 500;
            e4.umacron = 500;
            e4.Ncaron = 667;
            e4.Iacute = 333;
            e4.plusminus = 675;
            e4.brokenbar = 275;
            e4.registered = 760;
            e4.Gbreve = 722;
            e4.Idotaccent = 333;
            e4.summation = 600;
            e4.Egrave = 611;
            e4.racute = 389;
            e4.omacron = 500;
            e4.Zacute = 556;
            e4.Zcaron = 556;
            e4.greaterequal = 549;
            e4.Eth = 722;
            e4.Ccedilla = 667;
            e4.lcommaaccent = 278;
            e4.tcaron = 300;
            e4.eogonek = 444;
            e4.Uogonek = 722;
            e4.Aacute = 611;
            e4.Adieresis = 611;
            e4.egrave = 444;
            e4.zacute = 389;
            e4.iogonek = 278;
            e4.Oacute = 722;
            e4.oacute = 500;
            e4.amacron = 500;
            e4.sacute = 389;
            e4.idieresis = 278;
            e4.Ocircumflex = 722;
            e4.Ugrave = 722;
            e4.Delta = 612;
            e4.thorn = 500;
            e4.twosuperior = 300;
            e4.Odieresis = 722;
            e4.mu = 500;
            e4.igrave = 278;
            e4.ohungarumlaut = 500;
            e4.Eogonek = 611;
            e4.dcroat = 500;
            e4.threequarters = 750;
            e4.Scedilla = 500;
            e4.lcaron = 300;
            e4.Kcommaaccent = 667;
            e4.Lacute = 556;
            e4.trademark = 980;
            e4.edotaccent = 444;
            e4.Igrave = 333;
            e4.Imacron = 333;
            e4.Lcaron = 611;
            e4.onehalf = 750;
            e4.lessequal = 549;
            e4.ocircumflex = 500;
            e4.ntilde = 500;
            e4.Uhungarumlaut = 722;
            e4.Eacute = 611;
            e4.emacron = 444;
            e4.gbreve = 500;
            e4.onequarter = 750;
            e4.Scaron = 500;
            e4.Scommaaccent = 500;
            e4.Ohungarumlaut = 722;
            e4.degree = 400;
            e4.ograve = 500;
            e4.Ccaron = 667;
            e4.ugrave = 500;
            e4.radical = 453;
            e4.Dcaron = 722;
            e4.rcommaaccent = 389;
            e4.Ntilde = 667;
            e4.otilde = 500;
            e4.Rcommaaccent = 611;
            e4.Lcommaaccent = 556;
            e4.Atilde = 611;
            e4.Aogonek = 611;
            e4.Aring = 611;
            e4.Otilde = 722;
            e4.zdotaccent = 389;
            e4.Ecaron = 611;
            e4.Iogonek = 333;
            e4.kcommaaccent = 444;
            e4.minus = 675;
            e4.Icircumflex = 333;
            e4.ncaron = 500;
            e4.tcommaaccent = 278;
            e4.logicalnot = 675;
            e4.odieresis = 500;
            e4.udieresis = 500;
            e4.notequal = 549;
            e4.gcommaaccent = 500;
            e4.eth = 500;
            e4.zcaron = 389;
            e4.ncommaaccent = 500;
            e4.onesuperior = 300;
            e4.imacron = 278;
            e4.Euro = 500;
          });
          e3.ZapfDingbats = (0, r.getLookupTableFactory)(function(e4) {
            e4.space = 278;
            e4.a1 = 974;
            e4.a2 = 961;
            e4.a202 = 974;
            e4.a3 = 980;
            e4.a4 = 719;
            e4.a5 = 789;
            e4.a119 = 790;
            e4.a118 = 791;
            e4.a117 = 690;
            e4.a11 = 960;
            e4.a12 = 939;
            e4.a13 = 549;
            e4.a14 = 855;
            e4.a15 = 911;
            e4.a16 = 933;
            e4.a105 = 911;
            e4.a17 = 945;
            e4.a18 = 974;
            e4.a19 = 755;
            e4.a20 = 846;
            e4.a21 = 762;
            e4.a22 = 761;
            e4.a23 = 571;
            e4.a24 = 677;
            e4.a25 = 763;
            e4.a26 = 760;
            e4.a27 = 759;
            e4.a28 = 754;
            e4.a6 = 494;
            e4.a7 = 552;
            e4.a8 = 537;
            e4.a9 = 577;
            e4.a10 = 692;
            e4.a29 = 786;
            e4.a30 = 788;
            e4.a31 = 788;
            e4.a32 = 790;
            e4.a33 = 793;
            e4.a34 = 794;
            e4.a35 = 816;
            e4.a36 = 823;
            e4.a37 = 789;
            e4.a38 = 841;
            e4.a39 = 823;
            e4.a40 = 833;
            e4.a41 = 816;
            e4.a42 = 831;
            e4.a43 = 923;
            e4.a44 = 744;
            e4.a45 = 723;
            e4.a46 = 749;
            e4.a47 = 790;
            e4.a48 = 792;
            e4.a49 = 695;
            e4.a50 = 776;
            e4.a51 = 768;
            e4.a52 = 792;
            e4.a53 = 759;
            e4.a54 = 707;
            e4.a55 = 708;
            e4.a56 = 682;
            e4.a57 = 701;
            e4.a58 = 826;
            e4.a59 = 815;
            e4.a60 = 789;
            e4.a61 = 789;
            e4.a62 = 707;
            e4.a63 = 687;
            e4.a64 = 696;
            e4.a65 = 689;
            e4.a66 = 786;
            e4.a67 = 787;
            e4.a68 = 713;
            e4.a69 = 791;
            e4.a70 = 785;
            e4.a71 = 791;
            e4.a72 = 873;
            e4.a73 = 761;
            e4.a74 = 762;
            e4.a203 = 762;
            e4.a75 = 759;
            e4.a204 = 759;
            e4.a76 = 892;
            e4.a77 = 892;
            e4.a78 = 788;
            e4.a79 = 784;
            e4.a81 = 438;
            e4.a82 = 138;
            e4.a83 = 277;
            e4.a84 = 415;
            e4.a97 = 392;
            e4.a98 = 392;
            e4.a99 = 668;
            e4.a100 = 668;
            e4.a89 = 390;
            e4.a90 = 390;
            e4.a93 = 317;
            e4.a94 = 317;
            e4.a91 = 276;
            e4.a92 = 276;
            e4.a205 = 509;
            e4.a85 = 509;
            e4.a206 = 410;
            e4.a86 = 410;
            e4.a87 = 234;
            e4.a88 = 234;
            e4.a95 = 334;
            e4.a96 = 334;
            e4.a101 = 732;
            e4.a102 = 544;
            e4.a103 = 544;
            e4.a104 = 910;
            e4.a106 = 667;
            e4.a107 = 760;
            e4.a108 = 760;
            e4.a112 = 776;
            e4.a111 = 595;
            e4.a110 = 694;
            e4.a109 = 626;
            e4.a120 = 788;
            e4.a121 = 788;
            e4.a122 = 788;
            e4.a123 = 788;
            e4.a124 = 788;
            e4.a125 = 788;
            e4.a126 = 788;
            e4.a127 = 788;
            e4.a128 = 788;
            e4.a129 = 788;
            e4.a130 = 788;
            e4.a131 = 788;
            e4.a132 = 788;
            e4.a133 = 788;
            e4.a134 = 788;
            e4.a135 = 788;
            e4.a136 = 788;
            e4.a137 = 788;
            e4.a138 = 788;
            e4.a139 = 788;
            e4.a140 = 788;
            e4.a141 = 788;
            e4.a142 = 788;
            e4.a143 = 788;
            e4.a144 = 788;
            e4.a145 = 788;
            e4.a146 = 788;
            e4.a147 = 788;
            e4.a148 = 788;
            e4.a149 = 788;
            e4.a150 = 788;
            e4.a151 = 788;
            e4.a152 = 788;
            e4.a153 = 788;
            e4.a154 = 788;
            e4.a155 = 788;
            e4.a156 = 788;
            e4.a157 = 788;
            e4.a158 = 788;
            e4.a159 = 788;
            e4.a160 = 894;
            e4.a161 = 838;
            e4.a163 = 1016;
            e4.a164 = 458;
            e4.a196 = 748;
            e4.a165 = 924;
            e4.a192 = 748;
            e4.a166 = 918;
            e4.a167 = 927;
            e4.a168 = 928;
            e4.a169 = 928;
            e4.a170 = 834;
            e4.a171 = 873;
            e4.a172 = 828;
            e4.a173 = 924;
            e4.a162 = 924;
            e4.a174 = 917;
            e4.a175 = 930;
            e4.a176 = 931;
            e4.a177 = 463;
            e4.a178 = 883;
            e4.a179 = 836;
            e4.a193 = 836;
            e4.a180 = 867;
            e4.a199 = 867;
            e4.a181 = 696;
            e4.a200 = 696;
            e4.a182 = 874;
            e4.a201 = 874;
            e4.a183 = 760;
            e4.a184 = 946;
            e4.a197 = 771;
            e4.a185 = 865;
            e4.a194 = 771;
            e4.a198 = 888;
            e4.a186 = 967;
            e4.a195 = 888;
            e4.a187 = 831;
            e4.a188 = 873;
            e4.a189 = 927;
            e4.a190 = 970;
            e4.a191 = 918;
          });
        });
        t2.getMetrics = n;
        const i = (0, r.getLookupTableFactory)(function(e3) {
          e3.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 };
          e3["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 };
          e3["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
          e3["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
          e3.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
          e3["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
          e3["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
          e3["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
          e3["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 };
          e3["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 };
          e3["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 };
          e3["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 };
          e3.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
          e3.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
        });
        t2.getFontBasicMetrics = i;
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.GlyfTable = void 0;
        t2.GlyfTable = class GlyfTable {
          constructor({ glyfTable: e3, isGlyphLocationsLong: t3, locaTable: a2, numGlyphs: r }) {
            this.glyphs = [];
            const n = new DataView(a2.buffer, a2.byteOffset, a2.byteLength), i = new DataView(e3.buffer, e3.byteOffset, e3.byteLength), s = t3 ? 4 : 2;
            let o = t3 ? n.getUint32(0) : 2 * n.getUint16(0), c = 0;
            for (let e4 = 0; e4 < r; e4++) {
              c += s;
              const e5 = t3 ? n.getUint32(c) : 2 * n.getUint16(c);
              if (e5 === o) {
                this.glyphs.push(new Glyph({}));
                continue;
              }
              const a3 = Glyph.parse(o, i);
              this.glyphs.push(a3);
              o = e5;
            }
          }
          getSize() {
            return this.glyphs.reduce((e3, t3) => e3 + (t3.getSize() + 3 & -4), 0);
          }
          write() {
            const e3 = this.getSize(), t3 = new DataView(new ArrayBuffer(e3)), a2 = e3 > 131070, r = a2 ? 4 : 2, n = new DataView(new ArrayBuffer((this.glyphs.length + 1) * r));
            a2 ? n.setUint32(0, 0) : n.setUint16(0, 0);
            let i = 0, s = 0;
            for (const e4 of this.glyphs) {
              i += e4.write(i, t3);
              i = i + 3 & -4;
              s += r;
              a2 ? n.setUint32(s, i) : n.setUint16(s, i >> 1);
            }
            return { isLocationLong: a2, loca: new Uint8Array(n.buffer), glyf: new Uint8Array(t3.buffer) };
          }
          scale(e3) {
            for (let t3 = 0, a2 = this.glyphs.length; t3 < a2; t3++) this.glyphs[t3].scale(e3[t3]);
          }
        };
        class Glyph {
          constructor({ header: e3 = null, simple: t3 = null, composites: a2 = null }) {
            this.header = e3;
            this.simple = t3;
            this.composites = a2;
          }
          static parse(e3, t3) {
            const [a2, r] = GlyphHeader.parse(e3, t3);
            e3 += a2;
            if (r.numberOfContours < 0) {
              const a3 = [];
              for (; ; ) {
                const [r2, n2] = CompositeGlyph.parse(e3, t3);
                e3 += r2;
                a3.push(n2);
                if (!(32 & n2.flags)) break;
              }
              return new Glyph({ header: r, composites: a3 });
            }
            const n = SimpleGlyph.parse(e3, t3, r.numberOfContours);
            return new Glyph({ header: r, simple: n });
          }
          getSize() {
            if (!this.header) return 0;
            const e3 = this.simple ? this.simple.getSize() : this.composites.reduce((e4, t3) => e4 + t3.getSize(), 0);
            return this.header.getSize() + e3;
          }
          write(e3, t3) {
            if (!this.header) return 0;
            const a2 = e3;
            e3 += this.header.write(e3, t3);
            if (this.simple) e3 += this.simple.write(e3, t3);
            else for (const a3 of this.composites) e3 += a3.write(e3, t3);
            return e3 - a2;
          }
          scale(e3) {
            if (!this.header) return;
            const t3 = (this.header.xMin + this.header.xMax) / 2;
            this.header.scale(t3, e3);
            if (this.simple) this.simple.scale(t3, e3);
            else for (const a2 of this.composites) a2.scale(t3, e3);
          }
        }
        class GlyphHeader {
          constructor({ numberOfContours: e3, xMin: t3, yMin: a2, xMax: r, yMax: n }) {
            this.numberOfContours = e3;
            this.xMin = t3;
            this.yMin = a2;
            this.xMax = r;
            this.yMax = n;
          }
          static parse(e3, t3) {
            return [10, new GlyphHeader({ numberOfContours: t3.getInt16(e3), xMin: t3.getInt16(e3 + 2), yMin: t3.getInt16(e3 + 4), xMax: t3.getInt16(e3 + 6), yMax: t3.getInt16(e3 + 8) })];
          }
          getSize() {
            return 10;
          }
          write(e3, t3) {
            t3.setInt16(e3, this.numberOfContours);
            t3.setInt16(e3 + 2, this.xMin);
            t3.setInt16(e3 + 4, this.yMin);
            t3.setInt16(e3 + 6, this.xMax);
            t3.setInt16(e3 + 8, this.yMax);
            return 10;
          }
          scale(e3, t3) {
            this.xMin = Math.round(e3 + (this.xMin - e3) * t3);
            this.xMax = Math.round(e3 + (this.xMax - e3) * t3);
          }
        }
        class Contour {
          constructor({ flags: e3, xCoordinates: t3, yCoordinates: a2 }) {
            this.xCoordinates = t3;
            this.yCoordinates = a2;
            this.flags = e3;
          }
        }
        class SimpleGlyph {
          constructor({ contours: e3, instructions: t3 }) {
            this.contours = e3;
            this.instructions = t3;
          }
          static parse(e3, t3, a2) {
            const r = [];
            for (let n2 = 0; n2 < a2; n2++) {
              const a3 = t3.getUint16(e3);
              e3 += 2;
              r.push(a3);
            }
            const n = r[a2 - 1] + 1, i = t3.getUint16(e3);
            e3 += 2;
            const s = new Uint8Array(t3).slice(e3, e3 + i);
            e3 += i;
            const o = [];
            for (let a3 = 0; a3 < n; e3++, a3++) {
              let r2 = t3.getUint8(e3);
              o.push(r2);
              if (8 & r2) {
                const n2 = t3.getUint8(++e3);
                r2 ^= 8;
                for (let e4 = 0; e4 < n2; e4++) o.push(r2);
                a3 += n2;
              }
            }
            const c = [];
            let l = [], h = [], u = [];
            const d = [];
            let f = 0, g = 0;
            for (let a3 = 0; a3 < n; a3++) {
              const n2 = o[a3];
              if (2 & n2) {
                const a4 = t3.getUint8(e3++);
                g += 16 & n2 ? a4 : -a4;
                l.push(g);
              } else if (16 & n2) l.push(g);
              else {
                g += t3.getInt16(e3);
                e3 += 2;
                l.push(g);
              }
              if (r[f] === a3) {
                f++;
                c.push(l);
                l = [];
              }
            }
            g = 0;
            f = 0;
            for (let a3 = 0; a3 < n; a3++) {
              const n2 = o[a3];
              if (4 & n2) {
                const a4 = t3.getUint8(e3++);
                g += 32 & n2 ? a4 : -a4;
                h.push(g);
              } else if (32 & n2) h.push(g);
              else {
                g += t3.getInt16(e3);
                e3 += 2;
                h.push(g);
              }
              u.push(1 & n2 | 64 & n2);
              if (r[f] === a3) {
                l = c[f];
                f++;
                d.push(new Contour({ flags: u, xCoordinates: l, yCoordinates: h }));
                h = [];
                u = [];
              }
            }
            return new SimpleGlyph({ contours: d, instructions: s });
          }
          getSize() {
            let e3 = 2 * this.contours.length + 2 + this.instructions.length, t3 = 0, a2 = 0;
            for (const r of this.contours) {
              e3 += r.flags.length;
              for (let n = 0, i = r.xCoordinates.length; n < i; n++) {
                const i2 = r.xCoordinates[n], s = r.yCoordinates[n];
                let o = Math.abs(i2 - t3);
                o > 255 ? e3 += 2 : o > 0 && (e3 += 1);
                t3 = i2;
                o = Math.abs(s - a2);
                o > 255 ? e3 += 2 : o > 0 && (e3 += 1);
                a2 = s;
              }
            }
            return e3;
          }
          write(e3, t3) {
            const a2 = e3, r = [], n = [], i = [];
            let s = 0, o = 0;
            for (const a3 of this.contours) {
              for (let e4 = 0, t4 = a3.xCoordinates.length; e4 < t4; e4++) {
                let t5 = a3.flags[e4];
                const c = a3.xCoordinates[e4];
                let l = c - s;
                if (0 === l) {
                  t5 |= 16;
                  r.push(0);
                } else {
                  const e5 = Math.abs(l);
                  if (e5 <= 255) {
                    t5 |= l >= 0 ? 18 : 2;
                    r.push(e5);
                  } else r.push(l);
                }
                s = c;
                const h = a3.yCoordinates[e4];
                l = h - o;
                if (0 === l) {
                  t5 |= 32;
                  n.push(0);
                } else {
                  const e5 = Math.abs(l);
                  if (e5 <= 255) {
                    t5 |= l >= 0 ? 36 : 4;
                    n.push(e5);
                  } else n.push(l);
                }
                o = h;
                i.push(t5);
              }
              t3.setUint16(e3, r.length - 1);
              e3 += 2;
            }
            t3.setUint16(e3, this.instructions.length);
            e3 += 2;
            if (this.instructions.length) {
              new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3);
              e3 += this.instructions.length;
            }
            for (const a3 of i) t3.setUint8(e3++, a3);
            for (let a3 = 0, n2 = r.length; a3 < n2; a3++) {
              const n3 = r[a3], s2 = i[a3];
              if (2 & s2) t3.setUint8(e3++, n3);
              else if (!(16 & s2)) {
                t3.setInt16(e3, n3);
                e3 += 2;
              }
            }
            for (let a3 = 0, r2 = n.length; a3 < r2; a3++) {
              const r3 = n[a3], s2 = i[a3];
              if (4 & s2) t3.setUint8(e3++, r3);
              else if (!(32 & s2)) {
                t3.setInt16(e3, r3);
                e3 += 2;
              }
            }
            return e3 - a2;
          }
          scale(e3, t3) {
            for (const a2 of this.contours) if (0 !== a2.xCoordinates.length) for (let r = 0, n = a2.xCoordinates.length; r < n; r++) a2.xCoordinates[r] = Math.round(e3 + (a2.xCoordinates[r] - e3) * t3);
          }
        }
        class CompositeGlyph {
          constructor({ flags: e3, glyphIndex: t3, argument1: a2, argument2: r, transf: n, instructions: i }) {
            this.flags = e3;
            this.glyphIndex = t3;
            this.argument1 = a2;
            this.argument2 = r;
            this.transf = n;
            this.instructions = i;
          }
          static parse(e3, t3) {
            const a2 = e3, r = [];
            let n = t3.getUint16(e3);
            const i = t3.getUint16(e3 + 2);
            e3 += 4;
            let s, o;
            if (1 & n) {
              if (2 & n) {
                s = t3.getInt16(e3);
                o = t3.getInt16(e3 + 2);
              } else {
                s = t3.getUint16(e3);
                o = t3.getUint16(e3 + 2);
              }
              e3 += 4;
              n ^= 1;
            } else {
              if (2 & n) {
                s = t3.getInt8(e3);
                o = t3.getInt8(e3 + 1);
              } else {
                s = t3.getUint8(e3);
                o = t3.getUint8(e3 + 1);
              }
              e3 += 2;
            }
            if (8 & n) {
              r.push(t3.getUint16(e3));
              e3 += 2;
            } else if (64 & n) {
              r.push(t3.getUint16(e3), t3.getUint16(e3 + 2));
              e3 += 4;
            } else if (128 & n) {
              r.push(t3.getUint16(e3), t3.getUint16(e3 + 2), t3.getUint16(e3 + 4), t3.getUint16(e3 + 6));
              e3 += 8;
            }
            let c = null;
            if (256 & n) {
              const a3 = t3.getUint16(e3);
              e3 += 2;
              c = new Uint8Array(t3).slice(e3, e3 + a3);
              e3 += a3;
            }
            return [e3 - a2, new CompositeGlyph({ flags: n, glyphIndex: i, argument1: s, argument2: o, transf: r, instructions: c })];
          }
          getSize() {
            let e3 = 4 + 2 * this.transf.length;
            256 & this.flags && (e3 += 2 + this.instructions.length);
            e3 += 2;
            2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e3 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e3 += 2);
            return e3;
          }
          write(e3, t3) {
            const a2 = e3;
            2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
            t3.setUint16(e3, this.flags);
            t3.setUint16(e3 + 2, this.glyphIndex);
            e3 += 4;
            if (1 & this.flags) {
              if (2 & this.flags) {
                t3.setInt16(e3, this.argument1);
                t3.setInt16(e3 + 2, this.argument2);
              } else {
                t3.setUint16(e3, this.argument1);
                t3.setUint16(e3 + 2, this.argument2);
              }
              e3 += 4;
            } else {
              t3.setUint8(e3, this.argument1);
              t3.setUint8(e3 + 1, this.argument2);
              e3 += 2;
            }
            if (256 & this.flags) {
              t3.setUint16(e3, this.instructions.length);
              e3 += 2;
              if (this.instructions.length) {
                new Uint8Array(t3.buffer, 0, t3.buffer.byteLength).set(this.instructions, e3);
                e3 += this.instructions.length;
              }
            }
            return e3 - a2;
          }
          scale(e3, t3) {
          }
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.OpenTypeFileBuilder = void 0;
        var r = a2(3), n = a2(2);
        function writeInt16(e3, t3, a3) {
          e3[t3] = a3 >> 8 & 255;
          e3[t3 + 1] = 255 & a3;
        }
        function writeInt32(e3, t3, a3) {
          e3[t3] = a3 >> 24 & 255;
          e3[t3 + 1] = a3 >> 16 & 255;
          e3[t3 + 2] = a3 >> 8 & 255;
          e3[t3 + 3] = 255 & a3;
        }
        function writeData(e3, t3, a3) {
          if (a3 instanceof Uint8Array) e3.set(a3, t3);
          else if ("string" == typeof a3) for (let r2 = 0, n2 = a3.length; r2 < n2; r2++) e3[t3++] = 255 & a3.charCodeAt(r2);
          else for (const r2 of a3) e3[t3++] = 255 & r2;
        }
        class OpenTypeFileBuilder {
          constructor(e3) {
            this.sfnt = e3;
            this.tables = /* @__PURE__ */ Object.create(null);
          }
          static getSearchParams(e3, t3) {
            let a3 = 1, r2 = 0;
            for (; (a3 ^ e3) > a3; ) {
              a3 <<= 1;
              r2++;
            }
            const n2 = a3 * t3;
            return { range: n2, entry: r2, rangeShift: t3 * e3 - n2 };
          }
          toArray() {
            let e3 = this.sfnt;
            const t3 = this.tables, a3 = Object.keys(t3);
            a3.sort();
            const i = a3.length;
            let s, o, c, l, h, u = 12 + 16 * i;
            const d = [u];
            for (s = 0; s < i; s++) {
              l = t3[a3[s]];
              u += (l.length + 3 & -4) >>> 0;
              d.push(u);
            }
            const f = new Uint8Array(u);
            for (s = 0; s < i; s++) {
              l = t3[a3[s]];
              writeData(f, d[s], l);
            }
            "true" === e3 && (e3 = (0, n.string32)(65536));
            f[0] = 255 & e3.charCodeAt(0);
            f[1] = 255 & e3.charCodeAt(1);
            f[2] = 255 & e3.charCodeAt(2);
            f[3] = 255 & e3.charCodeAt(3);
            writeInt16(f, 4, i);
            const g = OpenTypeFileBuilder.getSearchParams(i, 16);
            writeInt16(f, 6, g.range);
            writeInt16(f, 8, g.entry);
            writeInt16(f, 10, g.rangeShift);
            u = 12;
            for (s = 0; s < i; s++) {
              h = a3[s];
              f[u] = 255 & h.charCodeAt(0);
              f[u + 1] = 255 & h.charCodeAt(1);
              f[u + 2] = 255 & h.charCodeAt(2);
              f[u + 3] = 255 & h.charCodeAt(3);
              let e4 = 0;
              for (o = d[s], c = d[s + 1]; o < c; o += 4) {
                e4 = e4 + (0, r.readUint32)(f, o) >>> 0;
              }
              writeInt32(f, u + 4, e4);
              writeInt32(f, u + 8, d[s]);
              writeInt32(f, u + 12, t3[h].length);
              u += 16;
            }
            return f;
          }
          addTable(e3, t3) {
            if (e3 in this.tables) throw new Error("Table " + e3 + " already exists");
            this.tables[e3] = t3;
          }
        }
        t2.OpenTypeFileBuilder = OpenTypeFileBuilder;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Type1Font = void 0;
        var r = a2(35), n = a2(2), i = a2(38), s = a2(3), o = a2(8), c = a2(49);
        function findBlock(e3, t3, a3) {
          const r2 = e3.length, n2 = t3.length, i2 = r2 - n2;
          let o2 = a3, c2 = false;
          for (; o2 < i2; ) {
            let a4 = 0;
            for (; a4 < n2 && e3[o2 + a4] === t3[a4]; ) a4++;
            if (a4 >= n2) {
              o2 += a4;
              for (; o2 < r2 && (0, s.isWhiteSpace)(e3[o2]); ) o2++;
              c2 = true;
              break;
            }
            o2++;
          }
          return { found: c2, length: o2 };
        }
        t2.Type1Font = class Type1Font {
          constructor(e3, t3, a3) {
            let r2 = a3.length1, s2 = a3.length2, l = t3.peekBytes(6);
            const h = 128 === l[0] && 1 === l[1];
            if (h) {
              t3.skip(6);
              r2 = l[5] << 24 | l[4] << 16 | l[3] << 8 | l[2];
            }
            const u = function getHeaderBlock(e4, t4) {
              const a4 = [101, 101, 120, 101, 99], r3 = e4.pos;
              let i2, s3, c2, l2;
              try {
                i2 = e4.getBytes(t4);
                s3 = i2.length;
              } catch {
              }
              if (s3 === t4) {
                c2 = findBlock(i2, a4, t4 - 2 * a4.length);
                if (c2.found && c2.length === t4) return { stream: new o.Stream(i2), length: t4 };
              }
              (0, n.warn)('Invalid "Length1" property in Type1 font -- trying to recover.');
              e4.pos = r3;
              for (; ; ) {
                c2 = findBlock(e4.peekBytes(2048), a4, 0);
                if (0 === c2.length) break;
                e4.pos += c2.length;
                if (c2.found) {
                  l2 = e4.pos - r3;
                  break;
                }
              }
              e4.pos = r3;
              if (l2) return { stream: new o.Stream(e4.getBytes(l2)), length: l2 };
              (0, n.warn)('Unable to recover "Length1" property in Type1 font -- using as is.');
              return { stream: new o.Stream(e4.getBytes(t4)), length: t4 };
            }(t3, r2);
            new c.Type1Parser(u.stream, false, i.SEAC_ANALYSIS_ENABLED).extractFontHeader(a3);
            if (h) {
              l = t3.getBytes(6);
              s2 = l[5] << 24 | l[4] << 16 | l[3] << 8 | l[2];
            }
            const d = function getEexecBlock(e4, t4) {
              const a4 = e4.getBytes();
              if (0 === a4.length) throw new n.FormatError("getEexecBlock - no font program found.");
              return { stream: new o.Stream(a4), length: a4.length };
            }(t3), f = new c.Type1Parser(d.stream, true, i.SEAC_ANALYSIS_ENABLED).extractFontProgram(a3);
            for (const e4 in f.properties) a3[e4] = f.properties[e4];
            const g = f.charstrings, p = this.getType2Charstrings(g), m = this.getType2Subrs(f.subrs);
            this.charstrings = g;
            this.data = this.wrap(e3, p, this.charstrings, m, a3);
            this.seacs = this.getSeacs(f.charstrings);
          }
          get numGlyphs() {
            return this.charstrings.length + 1;
          }
          getCharset() {
            const e3 = [".notdef"];
            for (const { glyphName: t3 } of this.charstrings) e3.push(t3);
            return e3;
          }
          getGlyphMapping(e3) {
            const t3 = this.charstrings;
            if (e3.composite) {
              const a4 = /* @__PURE__ */ Object.create(null);
              for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) {
                a4[e3.cMap.charCodeOf(r3)] = r3 + 1;
              }
              return a4;
            }
            const a3 = [".notdef"];
            let r2, n2;
            for (n2 = 0; n2 < t3.length; n2++) a3.push(t3[n2].glyphName);
            const s2 = e3.builtInEncoding;
            if (s2) {
              r2 = /* @__PURE__ */ Object.create(null);
              for (const e4 in s2) {
                n2 = a3.indexOf(s2[e4]);
                n2 >= 0 && (r2[e4] = n2);
              }
            }
            return (0, i.type1FontGlyphMapping)(e3, r2, a3);
          }
          hasGlyphId(e3) {
            if (e3 < 0 || e3 >= this.numGlyphs) return false;
            if (0 === e3) return true;
            return this.charstrings[e3 - 1].charstring.length > 0;
          }
          getSeacs(e3) {
            const t3 = [];
            for (let a3 = 0, r2 = e3.length; a3 < r2; a3++) {
              const r3 = e3[a3];
              r3.seac && (t3[a3 + 1] = r3.seac);
            }
            return t3;
          }
          getType2Charstrings(e3) {
            const t3 = [];
            for (const a3 of e3) t3.push(a3.charstring);
            return t3;
          }
          getType2Subrs(e3) {
            let t3 = 0;
            const a3 = e3.length;
            t3 = a3 < 1133 ? 107 : a3 < 33769 ? 1131 : 32768;
            const r2 = [];
            let n2;
            for (n2 = 0; n2 < t3; n2++) r2.push([11]);
            for (n2 = 0; n2 < a3; n2++) r2.push(e3[n2]);
            return r2;
          }
          wrap(e3, t3, a3, n2, i2) {
            const s2 = new r.CFF();
            s2.header = new r.CFFHeader(1, 0, 4, 4);
            s2.names = [e3];
            const o2 = new r.CFFTopDict();
            o2.setByName("version", 391);
            o2.setByName("Notice", 392);
            o2.setByName("FullName", 393);
            o2.setByName("FamilyName", 394);
            o2.setByName("Weight", 395);
            o2.setByName("Encoding", null);
            o2.setByName("FontMatrix", i2.fontMatrix);
            o2.setByName("FontBBox", i2.bbox);
            o2.setByName("charset", null);
            o2.setByName("CharStrings", null);
            o2.setByName("Private", null);
            s2.topDict = o2;
            const c2 = new r.CFFStrings();
            c2.add("Version 0.11");
            c2.add("See original notice");
            c2.add(e3);
            c2.add(e3);
            c2.add("Medium");
            s2.strings = c2;
            s2.globalSubrIndex = new r.CFFIndex();
            const l = t3.length, h = [".notdef"];
            let u, d;
            for (u = 0; u < l; u++) {
              const e4 = a3[u].glyphName;
              -1 === r.CFFStandardStrings.indexOf(e4) && c2.add(e4);
              h.push(e4);
            }
            s2.charset = new r.CFFCharset(false, 0, h);
            const f = new r.CFFIndex();
            f.add([139, 14]);
            for (u = 0; u < l; u++) f.add(t3[u]);
            s2.charStrings = f;
            const g = new r.CFFPrivateDict();
            g.setByName("Subrs", null);
            const p = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
            for (u = 0, d = p.length; u < d; u++) {
              const e4 = p[u];
              if (!(e4 in i2.privateData)) continue;
              const t4 = i2.privateData[e4];
              if (Array.isArray(t4)) for (let e5 = t4.length - 1; e5 > 0; e5--) t4[e5] -= t4[e5 - 1];
              g.setByName(e4, t4);
            }
            s2.topDict.privateDict = g;
            const m = new r.CFFIndex();
            for (u = 0, d = n2.length; u < d; u++) m.add(n2[u]);
            g.subrsIndex = m;
            return new r.CFFCompiler(s2).compile();
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Type1Parser = void 0;
        var r = a2(37), n = a2(3), i = a2(8), s = a2(2);
        const o = [4], c = [5], l = [6], h = [7], u = [8], d = [12, 35], f = [14], g = [21], p = [22], m = [30], b = [31];
        class Type1CharString {
          constructor() {
            this.width = 0;
            this.lsb = 0;
            this.flexing = false;
            this.output = [];
            this.stack = [];
          }
          convert(e3, t3, a3) {
            const r2 = e3.length;
            let n2, i2, y, w = false;
            for (let S = 0; S < r2; S++) {
              let r3 = e3[S];
              if (r3 < 32) {
                12 === r3 && (r3 = (r3 << 8) + e3[++S]);
                switch (r3) {
                  case 1:
                  case 3:
                  case 9:
                  case 3072:
                  case 3073:
                  case 3074:
                  case 3105:
                    this.stack = [];
                    break;
                  case 4:
                    if (this.flexing) {
                      if (this.stack.length < 1) {
                        w = true;
                        break;
                      }
                      const e5 = this.stack.pop();
                      this.stack.push(0, e5);
                      break;
                    }
                    w = this.executeCommand(1, o);
                    break;
                  case 5:
                    w = this.executeCommand(2, c);
                    break;
                  case 6:
                    w = this.executeCommand(1, l);
                    break;
                  case 7:
                    w = this.executeCommand(1, h);
                    break;
                  case 8:
                    w = this.executeCommand(6, u);
                    break;
                  case 10:
                    if (this.stack.length < 1) {
                      w = true;
                      break;
                    }
                    y = this.stack.pop();
                    if (!t3[y]) {
                      w = true;
                      break;
                    }
                    w = this.convert(t3[y], t3, a3);
                    break;
                  case 11:
                    return w;
                  case 13:
                    if (this.stack.length < 2) {
                      w = true;
                      break;
                    }
                    n2 = this.stack.pop();
                    i2 = this.stack.pop();
                    this.lsb = i2;
                    this.width = n2;
                    this.stack.push(n2, i2);
                    w = this.executeCommand(2, p);
                    break;
                  case 14:
                    this.output.push(f[0]);
                    break;
                  case 21:
                    if (this.flexing) break;
                    w = this.executeCommand(2, g);
                    break;
                  case 22:
                    if (this.flexing) {
                      this.stack.push(0);
                      break;
                    }
                    w = this.executeCommand(1, p);
                    break;
                  case 30:
                    w = this.executeCommand(4, m);
                    break;
                  case 31:
                    w = this.executeCommand(4, b);
                    break;
                  case 3078:
                    if (a3) {
                      const e5 = this.stack.at(-5);
                      this.seac = this.stack.splice(-4, 4);
                      this.seac[0] += this.lsb - e5;
                      w = this.executeCommand(0, f);
                    } else w = this.executeCommand(4, f);
                    break;
                  case 3079:
                    if (this.stack.length < 4) {
                      w = true;
                      break;
                    }
                    this.stack.pop();
                    n2 = this.stack.pop();
                    const e4 = this.stack.pop();
                    i2 = this.stack.pop();
                    this.lsb = i2;
                    this.width = n2;
                    this.stack.push(n2, i2, e4);
                    w = this.executeCommand(3, g);
                    break;
                  case 3084:
                    if (this.stack.length < 2) {
                      w = true;
                      break;
                    }
                    const S2 = this.stack.pop(), x = this.stack.pop();
                    this.stack.push(x / S2);
                    break;
                  case 3088:
                    if (this.stack.length < 2) {
                      w = true;
                      break;
                    }
                    y = this.stack.pop();
                    const C = this.stack.pop();
                    if (0 === y && 3 === C) {
                      const e5 = this.stack.splice(-17, 17);
                      this.stack.push(e5[2] + e5[0], e5[3] + e5[1], e5[4], e5[5], e5[6], e5[7], e5[8], e5[9], e5[10], e5[11], e5[12], e5[13], e5[14]);
                      w = this.executeCommand(13, d, true);
                      this.flexing = false;
                      this.stack.push(e5[15], e5[16]);
                    } else 1 === y && 0 === C && (this.flexing = true);
                    break;
                  case 3089:
                    break;
                  default:
                    (0, s.warn)('Unknown type 1 charstring command of "' + r3 + '"');
                }
                if (w) break;
              } else {
                r3 <= 246 ? r3 -= 139 : r3 = r3 <= 250 ? 256 * (r3 - 247) + e3[++S] + 108 : r3 <= 254 ? -256 * (r3 - 251) - e3[++S] - 108 : (255 & e3[++S]) << 24 | (255 & e3[++S]) << 16 | (255 & e3[++S]) << 8 | (255 & e3[++S]) << 0;
                this.stack.push(r3);
              }
            }
            return w;
          }
          executeCommand(e3, t3, a3) {
            const r2 = this.stack.length;
            if (e3 > r2) return true;
            const n2 = r2 - e3;
            for (let e4 = n2; e4 < r2; e4++) {
              let t4 = this.stack[e4];
              if (Number.isInteger(t4)) this.output.push(28, t4 >> 8 & 255, 255 & t4);
              else {
                t4 = 65536 * t4 | 0;
                this.output.push(255, t4 >> 24 & 255, t4 >> 16 & 255, t4 >> 8 & 255, 255 & t4);
              }
            }
            this.output.push(...t3);
            a3 ? this.stack.splice(n2, e3) : this.stack.length = 0;
            return false;
          }
        }
        function isHexDigit(e3) {
          return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
        }
        function decrypt(e3, t3, a3) {
          if (a3 >= e3.length) return new Uint8Array(0);
          let r2, n2, i2 = 0 | t3;
          for (r2 = 0; r2 < a3; r2++) i2 = 52845 * (e3[r2] + i2) + 22719 & 65535;
          const s2 = e3.length - a3, o2 = new Uint8Array(s2);
          for (r2 = a3, n2 = 0; n2 < s2; r2++, n2++) {
            const t4 = e3[r2];
            o2[n2] = t4 ^ i2 >> 8;
            i2 = 52845 * (t4 + i2) + 22719 & 65535;
          }
          return o2;
        }
        function isSpecial(e3) {
          return 47 === e3 || 91 === e3 || 93 === e3 || 123 === e3 || 125 === e3 || 40 === e3 || 41 === e3;
        }
        t2.Type1Parser = class Type1Parser {
          constructor(e3, t3, a3) {
            if (t3) {
              const t4 = e3.getBytes(), a4 = !((isHexDigit(t4[0]) || (0, n.isWhiteSpace)(t4[0])) && isHexDigit(t4[1]) && isHexDigit(t4[2]) && isHexDigit(t4[3]) && isHexDigit(t4[4]) && isHexDigit(t4[5]) && isHexDigit(t4[6]) && isHexDigit(t4[7]));
              e3 = new i.Stream(a4 ? decrypt(t4, 55665, 4) : function decryptAscii(e4, t5, a5) {
                let r2 = 0 | t5;
                const n2 = e4.length, i2 = new Uint8Array(n2 >>> 1);
                let s2, o2;
                for (s2 = 0, o2 = 0; s2 < n2; s2++) {
                  const t6 = e4[s2];
                  if (!isHexDigit(t6)) continue;
                  s2++;
                  let a6;
                  for (; s2 < n2 && !isHexDigit(a6 = e4[s2]); ) s2++;
                  if (s2 < n2) {
                    const e5 = parseInt(String.fromCharCode(t6, a6), 16);
                    i2[o2++] = e5 ^ r2 >> 8;
                    r2 = 52845 * (e5 + r2) + 22719 & 65535;
                  }
                }
                return i2.slice(a5, o2);
              }(t4, 55665, 4));
            }
            this.seacAnalysisEnabled = !!a3;
            this.stream = e3;
            this.nextChar();
          }
          readNumberArray() {
            this.getToken();
            const e3 = [];
            for (; ; ) {
              const t3 = this.getToken();
              if (null === t3 || "]" === t3 || "}" === t3) break;
              e3.push(parseFloat(t3 || 0));
            }
            return e3;
          }
          readNumber() {
            const e3 = this.getToken();
            return parseFloat(e3 || 0);
          }
          readInt() {
            const e3 = this.getToken();
            return 0 | parseInt(e3 || 0, 10);
          }
          readBoolean() {
            return "true" === this.getToken() ? 1 : 0;
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          prevChar() {
            this.stream.skip(-2);
            return this.currentChar = this.stream.getByte();
          }
          getToken() {
            let e3 = false, t3 = this.currentChar;
            for (; ; ) {
              if (-1 === t3) return null;
              if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
              else if (37 === t3) e3 = true;
              else if (!(0, n.isWhiteSpace)(t3)) break;
              t3 = this.nextChar();
            }
            if (isSpecial(t3)) {
              this.nextChar();
              return String.fromCharCode(t3);
            }
            let a3 = "";
            do {
              a3 += String.fromCharCode(t3);
              t3 = this.nextChar();
            } while (t3 >= 0 && !(0, n.isWhiteSpace)(t3) && !isSpecial(t3));
            return a3;
          }
          readCharStrings(e3, t3) {
            return -1 === t3 ? e3 : decrypt(e3, 4330, t3);
          }
          extractFontProgram(e3) {
            const t3 = this.stream, a3 = [], r2 = [], n2 = /* @__PURE__ */ Object.create(null);
            n2.lenIV = 4;
            const i2 = { subrs: [], charstrings: [], properties: { privateData: n2 } };
            let s2, o2, c2, l2;
            for (; null !== (s2 = this.getToken()); ) if ("/" === s2) {
              s2 = this.getToken();
              switch (s2) {
                case "CharStrings":
                  this.getToken();
                  this.getToken();
                  this.getToken();
                  this.getToken();
                  for (; ; ) {
                    s2 = this.getToken();
                    if (null === s2 || "end" === s2) break;
                    if ("/" !== s2) continue;
                    const e5 = this.getToken();
                    o2 = this.readInt();
                    this.getToken();
                    c2 = o2 > 0 ? t3.getBytes(o2) : new Uint8Array(0);
                    l2 = i2.properties.privateData.lenIV;
                    const a4 = this.readCharStrings(c2, l2);
                    this.nextChar();
                    s2 = this.getToken();
                    "noaccess" === s2 ? this.getToken() : "/" === s2 && this.prevChar();
                    r2.push({ glyph: e5, encoded: a4 });
                  }
                  break;
                case "Subrs":
                  this.readInt();
                  this.getToken();
                  for (; "dup" === this.getToken(); ) {
                    const e5 = this.readInt();
                    o2 = this.readInt();
                    this.getToken();
                    c2 = o2 > 0 ? t3.getBytes(o2) : new Uint8Array(0);
                    l2 = i2.properties.privateData.lenIV;
                    const r3 = this.readCharStrings(c2, l2);
                    this.nextChar();
                    s2 = this.getToken();
                    "noaccess" === s2 && this.getToken();
                    a3[e5] = r3;
                  }
                  break;
                case "BlueValues":
                case "OtherBlues":
                case "FamilyBlues":
                case "FamilyOtherBlues":
                  const e4 = this.readNumberArray();
                  e4.length > 0 && e4.length, 0;
                  break;
                case "StemSnapH":
                case "StemSnapV":
                  i2.properties.privateData[s2] = this.readNumberArray();
                  break;
                case "StdHW":
                case "StdVW":
                  i2.properties.privateData[s2] = this.readNumberArray()[0];
                  break;
                case "BlueShift":
                case "lenIV":
                case "BlueFuzz":
                case "BlueScale":
                case "LanguageGroup":
                  i2.properties.privateData[s2] = this.readNumber();
                  break;
                case "ExpansionFactor":
                  i2.properties.privateData[s2] = this.readNumber() || 0.06;
                  break;
                case "ForceBold":
                  i2.properties.privateData[s2] = this.readBoolean();
              }
            }
            for (const { encoded: t4, glyph: n3 } of r2) {
              const r3 = new Type1CharString(), s3 = r3.convert(t4, a3, this.seacAnalysisEnabled);
              let o3 = r3.output;
              s3 && (o3 = [14]);
              const c3 = { glyphName: n3, charstring: o3, width: r3.width, lsb: r3.lsb, seac: r3.seac };
              ".notdef" === n3 ? i2.charstrings.unshift(c3) : i2.charstrings.push(c3);
              if (e3.builtInEncoding) {
                const t5 = e3.builtInEncoding.indexOf(n3);
                t5 > -1 && void 0 === e3.widths[t5] && t5 >= e3.firstChar && t5 <= e3.lastChar && (e3.widths[t5] = r3.width);
              }
            }
            return i2;
          }
          extractFontHeader(e3) {
            let t3;
            for (; null !== (t3 = this.getToken()); ) if ("/" === t3) {
              t3 = this.getToken();
              switch (t3) {
                case "FontMatrix":
                  const a3 = this.readNumberArray();
                  e3.fontMatrix = a3;
                  break;
                case "Encoding":
                  const n2 = this.getToken();
                  let i2;
                  if (/^\d+$/.test(n2)) {
                    i2 = [];
                    const e4 = 0 | parseInt(n2, 10);
                    this.getToken();
                    for (let a4 = 0; a4 < e4; a4++) {
                      t3 = this.getToken();
                      for (; "dup" !== t3 && "def" !== t3; ) {
                        t3 = this.getToken();
                        if (null === t3) return;
                      }
                      if ("def" === t3) break;
                      const e5 = this.readInt();
                      this.getToken();
                      const a5 = this.getToken();
                      i2[e5] = a5;
                      this.getToken();
                    }
                  } else i2 = (0, r.getEncoding)(n2);
                  e3.builtInEncoding = i2;
                  break;
                case "FontBBox":
                  const s2 = this.readNumberArray();
                  e3.ascent = Math.max(s2[3], s2[1]);
                  e3.descent = Math.min(s2[1], s2[3]);
                  e3.ascentScaled = true;
              }
            }
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Pattern = void 0;
        t2.clearPatternCaches = function clearPatternCaches() {
          f = /* @__PURE__ */ Object.create(null);
        };
        t2.getTilingPatternIR = function getTilingPatternIR(e3, t3, a3) {
          const n2 = t3.getArray("Matrix"), i2 = r.Util.normalizeRect(t3.getArray("BBox")), s2 = t3.get("XStep"), o2 = t3.get("YStep"), c2 = t3.get("PaintType"), l2 = t3.get("TilingType");
          if (i2[2] - i2[0] == 0 || i2[3] - i2[1] == 0) throw new r.FormatError(`Invalid getTilingPatternIR /BBox array: [${i2}].`);
          return ["TilingPattern", a3, e3, n2, i2, s2, o2, c2, l2];
        };
        var r = a2(2), n = a2(5), i = a2(12), s = a2(3);
        const o = 2, c = 3, l = 4, h = 5, u = 6, d = 7;
        t2.Pattern = class Pattern {
          constructor() {
            (0, r.unreachable)("Cannot initialize Pattern.");
          }
          static parseShading(e3, t3, a3, i2, f2) {
            const g = e3 instanceof n.BaseStream ? e3.dict : e3, p = g.get("ShadingType");
            try {
              switch (p) {
                case o:
                case c:
                  return new RadialAxialShading(g, t3, a3, i2, f2);
                case l:
                case h:
                case u:
                case d:
                  return new MeshShading(e3, t3, a3, i2, f2);
                default:
                  throw new r.FormatError("Unsupported ShadingType: " + p);
              }
            } catch (e4) {
              if (e4 instanceof s.MissingDataException) throw e4;
              (0, r.warn)(e4);
              return new DummyShading();
            }
          }
        };
        const _BaseShading = class _BaseShading {
          constructor() {
            this.constructor === _BaseShading && (0, r.unreachable)("Cannot initialize BaseShading.");
          }
          getIR() {
            (0, r.unreachable)("Abstract method `getIR` called.");
          }
        };
        __publicField(_BaseShading, "SMALL_NUMBER", 1e-6);
        let BaseShading = _BaseShading;
        class RadialAxialShading extends BaseShading {
          constructor(e3, t3, a3, n2, s2) {
            super();
            this.coordsArr = e3.getArray("Coords");
            this.shadingType = e3.get("ShadingType");
            const o2 = i.ColorSpace.parse({ cs: e3.getRaw("CS") || e3.getRaw("ColorSpace"), xref: t3, resources: a3, pdfFunctionFactory: n2, localColorSpaceCache: s2 }), l2 = e3.getArray("BBox");
            this.bbox = Array.isArray(l2) && 4 === l2.length ? r.Util.normalizeRect(l2) : null;
            let h2 = 0, u2 = 1;
            if (e3.has("Domain")) {
              const t4 = e3.getArray("Domain");
              h2 = t4[0];
              u2 = t4[1];
            }
            let d2 = false, f2 = false;
            if (e3.has("Extend")) {
              const t4 = e3.getArray("Extend");
              d2 = t4[0];
              f2 = t4[1];
            }
            if (!(this.shadingType !== c || d2 && f2)) {
              const [e4, t4, a4, n3, i2, s3] = this.coordsArr, o3 = Math.hypot(e4 - n3, t4 - i2);
              a4 <= s3 + o3 && s3 <= a4 + o3 && (0, r.warn)("Unsupported radial gradient.");
            }
            this.extendStart = d2;
            this.extendEnd = f2;
            const g = e3.getRaw("Function"), p = n2.createFromArray(g), m = (u2 - h2) / 840, b = this.colorStops = [];
            if (h2 >= u2 || m <= 0) {
              (0, r.info)("Bad shading domain.");
              return;
            }
            const y = new Float32Array(o2.numComps), w = new Float32Array(1);
            let S, x = 0;
            w[0] = h2;
            p(w, 0, y, 0);
            let C = o2.getRgb(y, 0);
            const k = r.Util.makeHexColor(C[0], C[1], C[2]);
            b.push([0, k]);
            let v = 1;
            w[0] = h2 + m;
            p(w, 0, y, 0);
            let F = o2.getRgb(y, 0), O = F[0] - C[0] + 1, T = F[1] - C[1] + 1, M = F[2] - C[2] + 1, D = F[0] - C[0] - 1, E = F[1] - C[1] - 1, N = F[2] - C[2] - 1;
            for (let e4 = 2; e4 < 840; e4++) {
              w[0] = h2 + e4 * m;
              p(w, 0, y, 0);
              S = o2.getRgb(y, 0);
              const t4 = e4 - x;
              O = Math.min(O, (S[0] - C[0] + 1) / t4);
              T = Math.min(T, (S[1] - C[1] + 1) / t4);
              M = Math.min(M, (S[2] - C[2] + 1) / t4);
              D = Math.max(D, (S[0] - C[0] - 1) / t4);
              E = Math.max(E, (S[1] - C[1] - 1) / t4);
              N = Math.max(N, (S[2] - C[2] - 1) / t4);
              if (!(D <= O && E <= T && N <= M)) {
                const e5 = r.Util.makeHexColor(F[0], F[1], F[2]);
                b.push([v / 840, e5]);
                O = S[0] - F[0] + 1;
                T = S[1] - F[1] + 1;
                M = S[2] - F[2] + 1;
                D = S[0] - F[0] - 1;
                E = S[1] - F[1] - 1;
                N = S[2] - F[2] - 1;
                x = v;
                C = F;
              }
              v = e4;
              F = S;
            }
            const R = r.Util.makeHexColor(F[0], F[1], F[2]);
            b.push([1, R]);
            let L = "transparent";
            if (e3.has("Background")) {
              S = o2.getRgb(e3.get("Background"), 0);
              L = r.Util.makeHexColor(S[0], S[1], S[2]);
            }
            if (!d2) {
              b.unshift([0, L]);
              b[1][0] += BaseShading.SMALL_NUMBER;
            }
            if (!f2) {
              b.at(-1)[0] -= BaseShading.SMALL_NUMBER;
              b.push([1, L]);
            }
            this.colorStops = b;
          }
          getIR() {
            const e3 = this.coordsArr, t3 = this.shadingType;
            let a3, n2, i2, s2, l2;
            if (t3 === o) {
              n2 = [e3[0], e3[1]];
              i2 = [e3[2], e3[3]];
              s2 = null;
              l2 = null;
              a3 = "axial";
            } else if (t3 === c) {
              n2 = [e3[0], e3[1]];
              i2 = [e3[3], e3[4]];
              s2 = e3[2];
              l2 = e3[5];
              a3 = "radial";
            } else (0, r.unreachable)(`getPattern type unknown: ${t3}`);
            return ["RadialAxial", a3, this.bbox, this.colorStops, n2, i2, s2, l2];
          }
        }
        class MeshStreamReader {
          constructor(e3, t3) {
            this.stream = e3;
            this.context = t3;
            this.buffer = 0;
            this.bufferLength = 0;
            const a3 = t3.numComps;
            this.tmpCompsBuf = new Float32Array(a3);
            const r2 = t3.colorSpace.numComps;
            this.tmpCsCompsBuf = t3.colorFn ? new Float32Array(r2) : this.tmpCompsBuf;
          }
          get hasData() {
            if (this.stream.end) return this.stream.pos < this.stream.end;
            if (this.bufferLength > 0) return true;
            const e3 = this.stream.getByte();
            if (e3 < 0) return false;
            this.buffer = e3;
            this.bufferLength = 8;
            return true;
          }
          readBits(e3) {
            let t3 = this.buffer, a3 = this.bufferLength;
            if (32 === e3) {
              if (0 === a3) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
              t3 = t3 << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
              const e4 = this.stream.getByte();
              this.buffer = e4 & (1 << a3) - 1;
              return (t3 << 8 - a3 | (255 & e4) >> a3) >>> 0;
            }
            if (8 === e3 && 0 === a3) return this.stream.getByte();
            for (; a3 < e3; ) {
              t3 = t3 << 8 | this.stream.getByte();
              a3 += 8;
            }
            a3 -= e3;
            this.bufferLength = a3;
            this.buffer = t3 & (1 << a3) - 1;
            return t3 >> a3;
          }
          align() {
            this.buffer = 0;
            this.bufferLength = 0;
          }
          readFlag() {
            return this.readBits(this.context.bitsPerFlag);
          }
          readCoordinate() {
            const e3 = this.context.bitsPerCoordinate, t3 = this.readBits(e3), a3 = this.readBits(e3), r2 = this.context.decode, n2 = e3 < 32 ? 1 / ((1 << e3) - 1) : 23283064365386963e-26;
            return [t3 * n2 * (r2[1] - r2[0]) + r2[0], a3 * n2 * (r2[3] - r2[2]) + r2[2]];
          }
          readComponents() {
            const e3 = this.context.numComps, t3 = this.context.bitsPerComponent, a3 = t3 < 32 ? 1 / ((1 << t3) - 1) : 23283064365386963e-26, r2 = this.context.decode, n2 = this.tmpCompsBuf;
            for (let i3 = 0, s2 = 4; i3 < e3; i3++, s2 += 2) {
              const e4 = this.readBits(t3);
              n2[i3] = e4 * a3 * (r2[s2 + 1] - r2[s2]) + r2[s2];
            }
            const i2 = this.tmpCsCompsBuf;
            this.context.colorFn && this.context.colorFn(n2, 0, i2, 0);
            return this.context.colorSpace.getRgb(i2, 0);
          }
        }
        let f = /* @__PURE__ */ Object.create(null);
        function getB(e3) {
          return f[e3] || (f[e3] = function buildB(e4) {
            const t3 = [];
            for (let a3 = 0; a3 <= e4; a3++) {
              const r2 = a3 / e4, n2 = 1 - r2;
              t3.push(new Float32Array([n2 ** 3, 3 * r2 * n2 ** 2, 3 * r2 ** 2 * n2, r2 ** 3]));
            }
            return t3;
          }(e3));
        }
        const _MeshShading = class _MeshShading extends BaseShading {
          constructor(e3, t3, a3, s2, o2) {
            super();
            if (!(e3 instanceof n.BaseStream)) throw new r.FormatError("Mesh data is not a stream");
            const c2 = e3.dict;
            this.shadingType = c2.get("ShadingType");
            const f2 = c2.getArray("BBox");
            this.bbox = Array.isArray(f2) && 4 === f2.length ? r.Util.normalizeRect(f2) : null;
            const g = i.ColorSpace.parse({ cs: c2.getRaw("CS") || c2.getRaw("ColorSpace"), xref: t3, resources: a3, pdfFunctionFactory: s2, localColorSpaceCache: o2 });
            this.background = c2.has("Background") ? g.getRgb(c2.get("Background"), 0) : null;
            const p = c2.getRaw("Function"), m = p ? s2.createFromArray(p) : null;
            this.coords = [];
            this.colors = [];
            this.figures = [];
            const b = { bitsPerCoordinate: c2.get("BitsPerCoordinate"), bitsPerComponent: c2.get("BitsPerComponent"), bitsPerFlag: c2.get("BitsPerFlag"), decode: c2.getArray("Decode"), colorFn: m, colorSpace: g, numComps: m ? 1 : g.numComps }, y = new MeshStreamReader(e3, b);
            let w = false;
            switch (this.shadingType) {
              case l:
                this._decodeType4Shading(y);
                break;
              case h:
                const e4 = 0 | c2.get("VerticesPerRow");
                if (e4 < 2) throw new r.FormatError("Invalid VerticesPerRow");
                this._decodeType5Shading(y, e4);
                break;
              case u:
                this._decodeType6Shading(y);
                w = true;
                break;
              case d:
                this._decodeType7Shading(y);
                w = true;
                break;
              default:
                (0, r.unreachable)("Unsupported mesh type.");
            }
            if (w) {
              this._updateBounds();
              for (let e4 = 0, t4 = this.figures.length; e4 < t4; e4++) this._buildFigureFromPatch(e4);
            }
            this._updateBounds();
            this._packData();
          }
          _decodeType4Shading(e3) {
            const t3 = this.coords, a3 = this.colors, n2 = [], i2 = [];
            let s2 = 0;
            for (; e3.hasData; ) {
              const o2 = e3.readFlag(), c2 = e3.readCoordinate(), l2 = e3.readComponents();
              if (0 === s2) {
                if (!(0 <= o2 && o2 <= 2)) throw new r.FormatError("Unknown type4 flag");
                switch (o2) {
                  case 0:
                    s2 = 3;
                    break;
                  case 1:
                    i2.push(i2.at(-2), i2.at(-1));
                    s2 = 1;
                    break;
                  case 2:
                    i2.push(i2.at(-3), i2.at(-1));
                    s2 = 1;
                }
                n2.push(o2);
              }
              i2.push(t3.length);
              t3.push(c2);
              a3.push(l2);
              s2--;
              e3.align();
            }
            this.figures.push({ type: "triangles", coords: new Int32Array(i2), colors: new Int32Array(i2) });
          }
          _decodeType5Shading(e3, t3) {
            const a3 = this.coords, r2 = this.colors, n2 = [];
            for (; e3.hasData; ) {
              const t4 = e3.readCoordinate(), i2 = e3.readComponents();
              n2.push(a3.length);
              a3.push(t4);
              r2.push(i2);
            }
            this.figures.push({ type: "lattice", coords: new Int32Array(n2), colors: new Int32Array(n2), verticesPerRow: t3 });
          }
          _decodeType6Shading(e3) {
            const t3 = this.coords, a3 = this.colors, n2 = new Int32Array(16), i2 = new Int32Array(4);
            for (; e3.hasData; ) {
              const s2 = e3.readFlag();
              if (!(0 <= s2 && s2 <= 3)) throw new r.FormatError("Unknown type6 flag");
              const o2 = t3.length;
              for (let a4 = 0, r2 = 0 !== s2 ? 8 : 12; a4 < r2; a4++) t3.push(e3.readCoordinate());
              const c2 = a3.length;
              for (let t4 = 0, r2 = 0 !== s2 ? 2 : 4; t4 < r2; t4++) a3.push(e3.readComponents());
              let l2, h2, u2, d2;
              switch (s2) {
                case 0:
                  n2[12] = o2 + 3;
                  n2[13] = o2 + 4;
                  n2[14] = o2 + 5;
                  n2[15] = o2 + 6;
                  n2[8] = o2 + 2;
                  n2[11] = o2 + 7;
                  n2[4] = o2 + 1;
                  n2[7] = o2 + 8;
                  n2[0] = o2;
                  n2[1] = o2 + 11;
                  n2[2] = o2 + 10;
                  n2[3] = o2 + 9;
                  i2[2] = c2 + 1;
                  i2[3] = c2 + 2;
                  i2[0] = c2;
                  i2[1] = c2 + 3;
                  break;
                case 1:
                  l2 = n2[12];
                  h2 = n2[13];
                  u2 = n2[14];
                  d2 = n2[15];
                  n2[12] = d2;
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = u2;
                  n2[11] = o2 + 3;
                  n2[4] = h2;
                  n2[7] = o2 + 4;
                  n2[0] = l2;
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  l2 = i2[2];
                  h2 = i2[3];
                  i2[2] = h2;
                  i2[3] = c2;
                  i2[0] = l2;
                  i2[1] = c2 + 1;
                  break;
                case 2:
                  l2 = n2[15];
                  h2 = n2[11];
                  n2[12] = n2[3];
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = n2[7];
                  n2[11] = o2 + 3;
                  n2[4] = h2;
                  n2[7] = o2 + 4;
                  n2[0] = l2;
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  l2 = i2[3];
                  i2[2] = i2[1];
                  i2[3] = c2;
                  i2[0] = l2;
                  i2[1] = c2 + 1;
                  break;
                case 3:
                  n2[12] = n2[0];
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = n2[1];
                  n2[11] = o2 + 3;
                  n2[4] = n2[2];
                  n2[7] = o2 + 4;
                  n2[0] = n2[3];
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  i2[2] = i2[0];
                  i2[3] = c2;
                  i2[0] = i2[1];
                  i2[1] = c2 + 1;
              }
              n2[5] = t3.length;
              t3.push([(-4 * t3[n2[0]][0] - t3[n2[15]][0] + 6 * (t3[n2[4]][0] + t3[n2[1]][0]) - 2 * (t3[n2[12]][0] + t3[n2[3]][0]) + 3 * (t3[n2[13]][0] + t3[n2[7]][0])) / 9, (-4 * t3[n2[0]][1] - t3[n2[15]][1] + 6 * (t3[n2[4]][1] + t3[n2[1]][1]) - 2 * (t3[n2[12]][1] + t3[n2[3]][1]) + 3 * (t3[n2[13]][1] + t3[n2[7]][1])) / 9]);
              n2[6] = t3.length;
              t3.push([(-4 * t3[n2[3]][0] - t3[n2[12]][0] + 6 * (t3[n2[2]][0] + t3[n2[7]][0]) - 2 * (t3[n2[0]][0] + t3[n2[15]][0]) + 3 * (t3[n2[4]][0] + t3[n2[14]][0])) / 9, (-4 * t3[n2[3]][1] - t3[n2[12]][1] + 6 * (t3[n2[2]][1] + t3[n2[7]][1]) - 2 * (t3[n2[0]][1] + t3[n2[15]][1]) + 3 * (t3[n2[4]][1] + t3[n2[14]][1])) / 9]);
              n2[9] = t3.length;
              t3.push([(-4 * t3[n2[12]][0] - t3[n2[3]][0] + 6 * (t3[n2[8]][0] + t3[n2[13]][0]) - 2 * (t3[n2[0]][0] + t3[n2[15]][0]) + 3 * (t3[n2[11]][0] + t3[n2[1]][0])) / 9, (-4 * t3[n2[12]][1] - t3[n2[3]][1] + 6 * (t3[n2[8]][1] + t3[n2[13]][1]) - 2 * (t3[n2[0]][1] + t3[n2[15]][1]) + 3 * (t3[n2[11]][1] + t3[n2[1]][1])) / 9]);
              n2[10] = t3.length;
              t3.push([(-4 * t3[n2[15]][0] - t3[n2[0]][0] + 6 * (t3[n2[11]][0] + t3[n2[14]][0]) - 2 * (t3[n2[12]][0] + t3[n2[3]][0]) + 3 * (t3[n2[2]][0] + t3[n2[8]][0])) / 9, (-4 * t3[n2[15]][1] - t3[n2[0]][1] + 6 * (t3[n2[11]][1] + t3[n2[14]][1]) - 2 * (t3[n2[12]][1] + t3[n2[3]][1]) + 3 * (t3[n2[2]][1] + t3[n2[8]][1])) / 9]);
              this.figures.push({ type: "patch", coords: new Int32Array(n2), colors: new Int32Array(i2) });
            }
          }
          _decodeType7Shading(e3) {
            const t3 = this.coords, a3 = this.colors, n2 = new Int32Array(16), i2 = new Int32Array(4);
            for (; e3.hasData; ) {
              const s2 = e3.readFlag();
              if (!(0 <= s2 && s2 <= 3)) throw new r.FormatError("Unknown type7 flag");
              const o2 = t3.length;
              for (let a4 = 0, r2 = 0 !== s2 ? 12 : 16; a4 < r2; a4++) t3.push(e3.readCoordinate());
              const c2 = a3.length;
              for (let t4 = 0, r2 = 0 !== s2 ? 2 : 4; t4 < r2; t4++) a3.push(e3.readComponents());
              let l2, h2, u2, d2;
              switch (s2) {
                case 0:
                  n2[12] = o2 + 3;
                  n2[13] = o2 + 4;
                  n2[14] = o2 + 5;
                  n2[15] = o2 + 6;
                  n2[8] = o2 + 2;
                  n2[9] = o2 + 13;
                  n2[10] = o2 + 14;
                  n2[11] = o2 + 7;
                  n2[4] = o2 + 1;
                  n2[5] = o2 + 12;
                  n2[6] = o2 + 15;
                  n2[7] = o2 + 8;
                  n2[0] = o2;
                  n2[1] = o2 + 11;
                  n2[2] = o2 + 10;
                  n2[3] = o2 + 9;
                  i2[2] = c2 + 1;
                  i2[3] = c2 + 2;
                  i2[0] = c2;
                  i2[1] = c2 + 3;
                  break;
                case 1:
                  l2 = n2[12];
                  h2 = n2[13];
                  u2 = n2[14];
                  d2 = n2[15];
                  n2[12] = d2;
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = u2;
                  n2[9] = o2 + 9;
                  n2[10] = o2 + 10;
                  n2[11] = o2 + 3;
                  n2[4] = h2;
                  n2[5] = o2 + 8;
                  n2[6] = o2 + 11;
                  n2[7] = o2 + 4;
                  n2[0] = l2;
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  l2 = i2[2];
                  h2 = i2[3];
                  i2[2] = h2;
                  i2[3] = c2;
                  i2[0] = l2;
                  i2[1] = c2 + 1;
                  break;
                case 2:
                  l2 = n2[15];
                  h2 = n2[11];
                  n2[12] = n2[3];
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = n2[7];
                  n2[9] = o2 + 9;
                  n2[10] = o2 + 10;
                  n2[11] = o2 + 3;
                  n2[4] = h2;
                  n2[5] = o2 + 8;
                  n2[6] = o2 + 11;
                  n2[7] = o2 + 4;
                  n2[0] = l2;
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  l2 = i2[3];
                  i2[2] = i2[1];
                  i2[3] = c2;
                  i2[0] = l2;
                  i2[1] = c2 + 1;
                  break;
                case 3:
                  n2[12] = n2[0];
                  n2[13] = o2 + 0;
                  n2[14] = o2 + 1;
                  n2[15] = o2 + 2;
                  n2[8] = n2[1];
                  n2[9] = o2 + 9;
                  n2[10] = o2 + 10;
                  n2[11] = o2 + 3;
                  n2[4] = n2[2];
                  n2[5] = o2 + 8;
                  n2[6] = o2 + 11;
                  n2[7] = o2 + 4;
                  n2[0] = n2[3];
                  n2[1] = o2 + 7;
                  n2[2] = o2 + 6;
                  n2[3] = o2 + 5;
                  i2[2] = i2[0];
                  i2[3] = c2;
                  i2[0] = i2[1];
                  i2[1] = c2 + 1;
              }
              this.figures.push({ type: "patch", coords: new Int32Array(n2), colors: new Int32Array(i2) });
            }
          }
          _buildFigureFromPatch(e3) {
            const t3 = this.figures[e3];
            (0, r.assert)("patch" === t3.type, "Unexpected patch mesh figure");
            const a3 = this.coords, n2 = this.colors, i2 = t3.coords, s2 = t3.colors, o2 = Math.min(a3[i2[0]][0], a3[i2[3]][0], a3[i2[12]][0], a3[i2[15]][0]), c2 = Math.min(a3[i2[0]][1], a3[i2[3]][1], a3[i2[12]][1], a3[i2[15]][1]), l2 = Math.max(a3[i2[0]][0], a3[i2[3]][0], a3[i2[12]][0], a3[i2[15]][0]), h2 = Math.max(a3[i2[0]][1], a3[i2[3]][1], a3[i2[12]][1], a3[i2[15]][1]);
            let u2 = Math.ceil((l2 - o2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
            u2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, u2));
            let d2 = Math.ceil((h2 - c2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
            d2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, d2));
            const f2 = u2 + 1, g = new Int32Array((d2 + 1) * f2), p = new Int32Array((d2 + 1) * f2);
            let m = 0;
            const b = new Uint8Array(3), y = new Uint8Array(3), w = n2[s2[0]], S = n2[s2[1]], x = n2[s2[2]], C = n2[s2[3]], k = getB(d2), v = getB(u2);
            for (let e4 = 0; e4 <= d2; e4++) {
              b[0] = (w[0] * (d2 - e4) + x[0] * e4) / d2 | 0;
              b[1] = (w[1] * (d2 - e4) + x[1] * e4) / d2 | 0;
              b[2] = (w[2] * (d2 - e4) + x[2] * e4) / d2 | 0;
              y[0] = (S[0] * (d2 - e4) + C[0] * e4) / d2 | 0;
              y[1] = (S[1] * (d2 - e4) + C[1] * e4) / d2 | 0;
              y[2] = (S[2] * (d2 - e4) + C[2] * e4) / d2 | 0;
              for (let t4 = 0; t4 <= u2; t4++, m++) {
                if (!(0 !== e4 && e4 !== d2 || 0 !== t4 && t4 !== u2)) continue;
                let r2 = 0, s3 = 0, o3 = 0;
                for (let n3 = 0; n3 <= 3; n3++) for (let c4 = 0; c4 <= 3; c4++, o3++) {
                  const l3 = k[e4][n3] * v[t4][c4];
                  r2 += a3[i2[o3]][0] * l3;
                  s3 += a3[i2[o3]][1] * l3;
                }
                g[m] = a3.length;
                a3.push([r2, s3]);
                p[m] = n2.length;
                const c3 = new Uint8Array(3);
                c3[0] = (b[0] * (u2 - t4) + y[0] * t4) / u2 | 0;
                c3[1] = (b[1] * (u2 - t4) + y[1] * t4) / u2 | 0;
                c3[2] = (b[2] * (u2 - t4) + y[2] * t4) / u2 | 0;
                n2.push(c3);
              }
            }
            g[0] = i2[0];
            p[0] = s2[0];
            g[u2] = i2[3];
            p[u2] = s2[1];
            g[f2 * d2] = i2[12];
            p[f2 * d2] = s2[2];
            g[f2 * d2 + u2] = i2[15];
            p[f2 * d2 + u2] = s2[3];
            this.figures[e3] = { type: "lattice", coords: g, colors: p, verticesPerRow: f2 };
          }
          _updateBounds() {
            let e3 = this.coords[0][0], t3 = this.coords[0][1], a3 = e3, r2 = t3;
            for (let n2 = 1, i2 = this.coords.length; n2 < i2; n2++) {
              const i3 = this.coords[n2][0], s2 = this.coords[n2][1];
              e3 = e3 > i3 ? i3 : e3;
              t3 = t3 > s2 ? s2 : t3;
              a3 = a3 < i3 ? i3 : a3;
              r2 = r2 < s2 ? s2 : r2;
            }
            this.bounds = [e3, t3, a3, r2];
          }
          _packData() {
            let e3, t3, a3, r2;
            const n2 = this.coords, i2 = new Float32Array(2 * n2.length);
            for (e3 = 0, a3 = 0, t3 = n2.length; e3 < t3; e3++) {
              const t4 = n2[e3];
              i2[a3++] = t4[0];
              i2[a3++] = t4[1];
            }
            this.coords = i2;
            const s2 = this.colors, o2 = new Uint8Array(3 * s2.length);
            for (e3 = 0, a3 = 0, t3 = s2.length; e3 < t3; e3++) {
              const t4 = s2[e3];
              o2[a3++] = t4[0];
              o2[a3++] = t4[1];
              o2[a3++] = t4[2];
            }
            this.colors = o2;
            const c2 = this.figures;
            for (e3 = 0, t3 = c2.length; e3 < t3; e3++) {
              const t4 = c2[e3], n3 = t4.coords, i3 = t4.colors;
              for (a3 = 0, r2 = n3.length; a3 < r2; a3++) {
                n3[a3] *= 2;
                i3[a3] *= 3;
              }
            }
          }
          getIR() {
            return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
          }
        };
        __publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
        __publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
        __publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
        let MeshShading = _MeshShading;
        class DummyShading extends BaseShading {
          getIR() {
            return ["Dummy"];
          }
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getXfaFontDict = function getXfaFontDict(e3) {
          const t3 = function getXfaFontWidths(e4) {
            const t4 = getXfaFontName(e4);
            if (!t4) return null;
            const { baseWidths: a4, baseMapping: r3, factors: n2 } = t4, i3 = n2 ? a4.map((e5, t5) => e5 * n2[t5]) : a4;
            let s2, o2 = -2;
            const c2 = [];
            for (const [e5, t5] of r3.map((e6, t6) => [e6, t6]).sort(([e6], [t6]) => e6 - t6)) if (-1 !== e5) if (e5 === o2 + 1) {
              s2.push(i3[t5]);
              o2 += 1;
            } else {
              o2 = e5;
              s2 = [i3[t5]];
              c2.push(e5, s2);
            }
            return c2;
          }(e3), a3 = new n.Dict(null);
          a3.set("BaseFont", n.Name.get(e3));
          a3.set("Type", n.Name.get("Font"));
          a3.set("Subtype", n.Name.get("CIDFontType2"));
          a3.set("Encoding", n.Name.get("Identity-H"));
          a3.set("CIDToGIDMap", n.Name.get("Identity"));
          a3.set("W", t3);
          a3.set("FirstChar", t3[0]);
          a3.set("LastChar", t3.at(-2) + t3.at(-1).length - 1);
          const r2 = new n.Dict(null);
          a3.set("FontDescriptor", r2);
          const i2 = new n.Dict(null);
          i2.set("Ordering", "Identity");
          i2.set("Registry", "Adobe");
          i2.set("Supplement", 0);
          a3.set("CIDSystemInfo", i2);
          return a3;
        };
        t2.getXfaFontName = getXfaFontName;
        var r = a2(52), n = a2(4), i = a2(53), s = a2(54), o = a2(55), c = a2(56), l = a2(3), h = a2(38);
        const u = (0, l.getLookupTableFactory)(function(e3) {
          e3["MyriadPro-Regular"] = e3["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: o.MyriadProRegularFactors, baseWidths: s.LiberationSansRegularWidths, baseMapping: s.LiberationSansRegularMapping, metrics: o.MyriadProRegularMetrics };
          e3["MyriadPro-Bold"] = e3["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: o.MyriadProBoldFactors, baseWidths: s.LiberationSansBoldWidths, baseMapping: s.LiberationSansBoldMapping, metrics: o.MyriadProBoldMetrics };
          e3["MyriadPro-It"] = e3["MyriadPro-Italic"] = e3["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: o.MyriadProItalicFactors, baseWidths: s.LiberationSansItalicWidths, baseMapping: s.LiberationSansItalicMapping, metrics: o.MyriadProItalicMetrics };
          e3["MyriadPro-BoldIt"] = e3["MyriadPro-BoldItalic"] = e3["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: o.MyriadProBoldItalicFactors, baseWidths: s.LiberationSansBoldItalicWidths, baseMapping: s.LiberationSansBoldItalicMapping, metrics: o.MyriadProBoldItalicMetrics };
          e3.ArialMT = e3.Arial = e3["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: s.LiberationSansRegularWidths, baseMapping: s.LiberationSansRegularMapping };
          e3["Arial-BoldMT"] = e3["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: s.LiberationSansBoldWidths, baseMapping: s.LiberationSansBoldMapping };
          e3["Arial-ItalicMT"] = e3["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: s.LiberationSansItalicWidths, baseMapping: s.LiberationSansItalicMapping };
          e3["Arial-BoldItalicMT"] = e3["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: s.LiberationSansBoldItalicWidths, baseMapping: s.LiberationSansBoldItalicMapping };
          e3["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: r.CalibriRegularFactors, baseWidths: s.LiberationSansRegularWidths, baseMapping: s.LiberationSansRegularMapping, metrics: r.CalibriRegularMetrics };
          e3["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: r.CalibriBoldFactors, baseWidths: s.LiberationSansBoldWidths, baseMapping: s.LiberationSansBoldMapping, metrics: r.CalibriBoldMetrics };
          e3["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: r.CalibriItalicFactors, baseWidths: s.LiberationSansItalicWidths, baseMapping: s.LiberationSansItalicMapping, metrics: r.CalibriItalicMetrics };
          e3["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: r.CalibriBoldItalicFactors, baseWidths: s.LiberationSansBoldItalicWidths, baseMapping: s.LiberationSansBoldItalicMapping, metrics: r.CalibriBoldItalicMetrics };
          e3["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: c.SegoeuiRegularFactors, baseWidths: s.LiberationSansRegularWidths, baseMapping: s.LiberationSansRegularMapping, metrics: c.SegoeuiRegularMetrics };
          e3["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: c.SegoeuiBoldFactors, baseWidths: s.LiberationSansBoldWidths, baseMapping: s.LiberationSansBoldMapping, metrics: c.SegoeuiBoldMetrics };
          e3["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: c.SegoeuiItalicFactors, baseWidths: s.LiberationSansItalicWidths, baseMapping: s.LiberationSansItalicMapping, metrics: c.SegoeuiItalicMetrics };
          e3["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: c.SegoeuiBoldItalicFactors, baseWidths: s.LiberationSansBoldItalicWidths, baseMapping: s.LiberationSansBoldItalicMapping, metrics: c.SegoeuiBoldItalicMetrics };
          e3["Helvetica-Regular"] = e3.Helvetica = { name: "LiberationSans-Regular", factors: i.HelveticaRegularFactors, baseWidths: s.LiberationSansRegularWidths, baseMapping: s.LiberationSansRegularMapping, metrics: i.HelveticaRegularMetrics };
          e3["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: i.HelveticaBoldFactors, baseWidths: s.LiberationSansBoldWidths, baseMapping: s.LiberationSansBoldMapping, metrics: i.HelveticaBoldMetrics };
          e3["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: i.HelveticaItalicFactors, baseWidths: s.LiberationSansItalicWidths, baseMapping: s.LiberationSansItalicMapping, metrics: i.HelveticaItalicMetrics };
          e3["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: i.HelveticaBoldItalicFactors, baseWidths: s.LiberationSansBoldItalicWidths, baseMapping: s.LiberationSansBoldItalicMapping, metrics: i.HelveticaBoldItalicMetrics };
        });
        function getXfaFontName(e3) {
          const t3 = (0, h.normalizeFontName)(e3);
          return u()[t3];
        }
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.CalibriRegularMetrics = t2.CalibriRegularFactors = t2.CalibriItalicMetrics = t2.CalibriItalicFactors = t2.CalibriBoldMetrics = t2.CalibriBoldItalicMetrics = t2.CalibriBoldItalicFactors = t2.CalibriBoldFactors = void 0;
        t2.CalibriBoldFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.CalibriBoldMetrics = { lineHeight: 1.2207, lineGap: 0.2207 };
        t2.CalibriBoldItalicFactors = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.CalibriBoldItalicMetrics = { lineHeight: 1.2207, lineGap: 0.2207 };
        t2.CalibriItalicFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.CalibriItalicMetrics = { lineHeight: 1.2207, lineGap: 0.2207 };
        t2.CalibriRegularFactors = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.CalibriRegularMetrics = { lineHeight: 1.2207, lineGap: 0.2207 };
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.HelveticaRegularMetrics = t2.HelveticaRegularFactors = t2.HelveticaItalicMetrics = t2.HelveticaItalicFactors = t2.HelveticaBoldMetrics = t2.HelveticaBoldItalicMetrics = t2.HelveticaBoldItalicFactors = t2.HelveticaBoldFactors = void 0;
        t2.HelveticaBoldFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.HelveticaBoldMetrics = { lineHeight: 1.2, lineGap: 0.2 };
        t2.HelveticaBoldItalicFactors = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.HelveticaBoldItalicMetrics = { lineHeight: 1.35, lineGap: 0.2 };
        t2.HelveticaItalicFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.HelveticaItalicMetrics = { lineHeight: 1.35, lineGap: 0.2 };
        t2.HelveticaRegularFactors = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.HelveticaRegularMetrics = { lineHeight: 1.2, lineGap: 0.2 };
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.LiberationSansRegularWidths = t2.LiberationSansRegularMapping = t2.LiberationSansItalicWidths = t2.LiberationSansItalicMapping = t2.LiberationSansBoldWidths = t2.LiberationSansBoldMapping = t2.LiberationSansBoldItalicWidths = t2.LiberationSansBoldItalicMapping = void 0;
        t2.LiberationSansBoldWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
        t2.LiberationSansBoldMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        t2.LiberationSansBoldItalicWidths = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
        t2.LiberationSansBoldItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        t2.LiberationSansItalicWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
        t2.LiberationSansItalicMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
        t2.LiberationSansRegularWidths = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
        t2.LiberationSansRegularMapping = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.MyriadProRegularMetrics = t2.MyriadProRegularFactors = t2.MyriadProItalicMetrics = t2.MyriadProItalicFactors = t2.MyriadProBoldMetrics = t2.MyriadProBoldItalicMetrics = t2.MyriadProBoldItalicFactors = t2.MyriadProBoldFactors = void 0;
        t2.MyriadProBoldFactors = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.MyriadProBoldMetrics = { lineHeight: 1.2, lineGap: 0.2 };
        t2.MyriadProBoldItalicFactors = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.MyriadProBoldItalicMetrics = { lineHeight: 1.2, lineGap: 0.2 };
        t2.MyriadProItalicFactors = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.MyriadProItalicMetrics = { lineHeight: 1.2, lineGap: 0.2 };
        t2.MyriadProRegularFactors = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.MyriadProRegularMetrics = { lineHeight: 1.2, lineGap: 0.2 };
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SegoeuiRegularMetrics = t2.SegoeuiRegularFactors = t2.SegoeuiItalicMetrics = t2.SegoeuiItalicFactors = t2.SegoeuiBoldMetrics = t2.SegoeuiBoldItalicMetrics = t2.SegoeuiBoldItalicFactors = t2.SegoeuiBoldFactors = void 0;
        t2.SegoeuiBoldFactors = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.SegoeuiBoldMetrics = { lineHeight: 1.33008, lineGap: 0 };
        t2.SegoeuiBoldItalicFactors = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.SegoeuiBoldItalicMetrics = { lineHeight: 1.33008, lineGap: 0 };
        t2.SegoeuiItalicFactors = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.SegoeuiItalicMetrics = { lineHeight: 1.33008, lineGap: 0 };
        t2.SegoeuiRegularFactors = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        t2.SegoeuiRegularMetrics = { lineHeight: 1.33008, lineGap: 0 };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PostScriptEvaluator = t2.PostScriptCompiler = t2.PDFFunctionFactory = void 0;
        t2.isPDFFunction = function isPDFFunction(e3) {
          let t3;
          if (e3 instanceof r.Dict) t3 = e3;
          else {
            if (!(e3 instanceof s.BaseStream)) return false;
            t3 = e3.dict;
          }
          return t3.has("FunctionType");
        };
        var r = a2(4), n = a2(2), i = a2(58), s = a2(5), o = a2(59);
        t2.PDFFunctionFactory = class PDFFunctionFactory {
          constructor({ xref: e3, isEvalSupported: t3 = true }) {
            this.xref = e3;
            this.isEvalSupported = false !== t3;
          }
          create(e3) {
            const t3 = this.getCached(e3);
            if (t3) return t3;
            const a3 = PDFFunction.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: e3 instanceof r.Ref ? this.xref.fetch(e3) : e3 });
            this._cache(e3, a3);
            return a3;
          }
          createFromArray(e3) {
            const t3 = this.getCached(e3);
            if (t3) return t3;
            const a3 = PDFFunction.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: e3 instanceof r.Ref ? this.xref.fetch(e3) : e3 });
            this._cache(e3, a3);
            return a3;
          }
          getCached(e3) {
            var _a;
            let t3;
            e3 instanceof r.Ref ? t3 = e3 : e3 instanceof r.Dict ? t3 = e3.objId : e3 instanceof s.BaseStream && (t3 = (_a = e3.dict) == null ? void 0 : _a.objId);
            if (t3) {
              const e4 = this._localFunctionCache.getByRef(t3);
              if (e4) return e4;
            }
            return null;
          }
          _cache(e3, t3) {
            var _a;
            if (!t3) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
            let a3;
            e3 instanceof r.Ref ? a3 = e3 : e3 instanceof r.Dict ? a3 = e3.objId : e3 instanceof s.BaseStream && (a3 = (_a = e3.dict) == null ? void 0 : _a.objId);
            a3 && this._localFunctionCache.set(null, a3, t3);
          }
          get _localFunctionCache() {
            return (0, n.shadow)(this, "_localFunctionCache", new o.LocalFunctionCache());
          }
        };
        function toNumberArray(e3) {
          if (!Array.isArray(e3)) return null;
          const t3 = e3.length;
          for (let a3 = 0; a3 < t3; a3++) if ("number" != typeof e3[a3]) {
            const a4 = new Array(t3);
            for (let r2 = 0; r2 < t3; r2++) a4[r2] = +e3[r2];
            return a4;
          }
          return e3;
        }
        class PDFFunction {
          static getSampleArray(e3, t3, a3, r2) {
            let n2, i2, s2 = 1;
            for (n2 = 0, i2 = e3.length; n2 < i2; n2++) s2 *= e3[n2];
            s2 *= t3;
            const o2 = new Array(s2);
            let c = 0, l = 0;
            const h = 1 / (2 ** a3 - 1), u = r2.getBytes((s2 * a3 + 7) / 8);
            let d = 0;
            for (n2 = 0; n2 < s2; n2++) {
              for (; c < a3; ) {
                l <<= 8;
                l |= u[d++];
                c += 8;
              }
              c -= a3;
              o2[n2] = (l >> c) * h;
              l &= (1 << c) - 1;
            }
            return o2;
          }
          static parse({ xref: e3, isEvalSupported: t3, fn: a3 }) {
            const r2 = a3.dict || a3;
            switch (r2.get("FunctionType")) {
              case 0:
                return this.constructSampled({ xref: e3, isEvalSupported: t3, fn: a3, dict: r2 });
              case 1:
                break;
              case 2:
                return this.constructInterpolated({ xref: e3, isEvalSupported: t3, dict: r2 });
              case 3:
                return this.constructStiched({ xref: e3, isEvalSupported: t3, dict: r2 });
              case 4:
                return this.constructPostScript({ xref: e3, isEvalSupported: t3, fn: a3, dict: r2 });
            }
            throw new n.FormatError("Unknown type of function");
          }
          static parseArray({ xref: e3, isEvalSupported: t3, fnObj: a3 }) {
            if (!Array.isArray(a3)) return this.parse({ xref: e3, isEvalSupported: t3, fn: a3 });
            const r2 = [];
            for (const n2 of a3) r2.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(n2) }));
            return function(e4, t4, a4, n2) {
              for (let i2 = 0, s2 = r2.length; i2 < s2; i2++) r2[i2](e4, t4, a4, n2 + i2);
            };
          }
          static constructSampled({ xref: e3, isEvalSupported: t3, fn: a3, dict: r2 }) {
            function toMultiArray(e4) {
              const t4 = e4.length, a4 = [];
              let r3 = 0;
              for (let n2 = 0; n2 < t4; n2 += 2) a4[r3++] = [e4[n2], e4[n2 + 1]];
              return a4;
            }
            function interpolate(e4, t4, a4, r3, n2) {
              return r3 + (n2 - r3) / (a4 - t4) * (e4 - t4);
            }
            let i2 = toNumberArray(r2.getArray("Domain")), s2 = toNumberArray(r2.getArray("Range"));
            if (!i2 || !s2) throw new n.FormatError("No domain or range");
            const o2 = i2.length / 2, c = s2.length / 2;
            i2 = toMultiArray(i2);
            s2 = toMultiArray(s2);
            const l = toNumberArray(r2.getArray("Size")), h = r2.get("BitsPerSample"), u = r2.get("Order") || 1;
            1 !== u && (0, n.info)("No support for cubic spline interpolation: " + u);
            let d = toNumberArray(r2.getArray("Encode"));
            if (d) d = toMultiArray(d);
            else {
              d = [];
              for (let e4 = 0; e4 < o2; ++e4) d.push([0, l[e4] - 1]);
            }
            let f = toNumberArray(r2.getArray("Decode"));
            f = f ? toMultiArray(f) : s2;
            const g = this.getSampleArray(l, c, h, a3);
            return function constructSampledFn(e4, t4, a4, r3) {
              const n2 = 1 << o2, h2 = new Float64Array(n2), u2 = new Uint32Array(n2);
              let p, m;
              for (m = 0; m < n2; m++) h2[m] = 1;
              let b = c, y = 1;
              for (p = 0; p < o2; ++p) {
                const a5 = i2[p][0], r4 = i2[p][1];
                let s3 = interpolate(Math.min(Math.max(e4[t4 + p], a5), r4), a5, r4, d[p][0], d[p][1]);
                const o3 = l[p];
                s3 = Math.min(Math.max(s3, 0), o3 - 1);
                const c2 = s3 < o3 - 1 ? Math.floor(s3) : s3 - 1, f2 = c2 + 1 - s3, g2 = s3 - c2, w = c2 * b, S = w + b;
                for (m = 0; m < n2; m++) if (m & y) {
                  h2[m] *= g2;
                  u2[m] += S;
                } else {
                  h2[m] *= f2;
                  u2[m] += w;
                }
                b *= o3;
                y <<= 1;
              }
              for (m = 0; m < c; ++m) {
                let e5 = 0;
                for (p = 0; p < n2; p++) e5 += g[u2[p] + m] * h2[p];
                e5 = interpolate(e5, 0, 1, f[m][0], f[m][1]);
                a4[r3 + m] = Math.min(Math.max(e5, s2[m][0]), s2[m][1]);
              }
            };
          }
          static constructInterpolated({ xref: e3, isEvalSupported: t3, dict: a3 }) {
            const r2 = toNumberArray(a3.getArray("C0")) || [0], n2 = toNumberArray(a3.getArray("C1")) || [1], i2 = a3.get("N"), s2 = [];
            for (let e4 = 0, t4 = r2.length; e4 < t4; ++e4) s2.push(n2[e4] - r2[e4]);
            const o2 = s2.length;
            return function constructInterpolatedFn(e4, t4, a4, n3) {
              const c = 1 === i2 ? e4[t4] : e4[t4] ** i2;
              for (let e5 = 0; e5 < o2; ++e5) a4[n3 + e5] = r2[e5] + c * s2[e5];
            };
          }
          static constructStiched({ xref: e3, isEvalSupported: t3, dict: a3 }) {
            const r2 = toNumberArray(a3.getArray("Domain"));
            if (!r2) throw new n.FormatError("No domain");
            if (1 !== r2.length / 2) throw new n.FormatError("Bad domain for stiched function");
            const i2 = [];
            for (const r3 of a3.get("Functions")) i2.push(this.parse({ xref: e3, isEvalSupported: t3, fn: e3.fetchIfRef(r3) }));
            const s2 = toNumberArray(a3.getArray("Bounds")), o2 = toNumberArray(a3.getArray("Encode")), c = new Float32Array(1);
            return function constructStichedFn(e4, t4, a4, n2) {
              const l = function constructStichedFromIRClip(e5, t5, a5) {
                e5 > a5 ? e5 = a5 : e5 < t5 && (e5 = t5);
                return e5;
              }(e4[t4], r2[0], r2[1]), h = s2.length;
              let u;
              for (u = 0; u < h && !(l < s2[u]); ++u) ;
              let d = r2[0];
              u > 0 && (d = s2[u - 1]);
              let f = r2[1];
              u < s2.length && (f = s2[u]);
              const g = o2[2 * u], p = o2[2 * u + 1];
              c[0] = d === f ? g : g + (l - d) * (p - g) / (f - d);
              i2[u](c, 0, a4, n2);
            };
          }
          static constructPostScript({ xref: e3, isEvalSupported: t3, fn: a3, dict: r2 }) {
            const s2 = toNumberArray(r2.getArray("Domain")), o2 = toNumberArray(r2.getArray("Range"));
            if (!s2) throw new n.FormatError("No domain.");
            if (!o2) throw new n.FormatError("No range.");
            const c = new i.PostScriptLexer(a3), l = new i.PostScriptParser(c).parse();
            if (t3 && n.FeatureTest.isEvalSupported) {
              const e4 = new PostScriptCompiler().compile(l, s2, o2);
              if (e4) return new Function("src", "srcOffset", "dest", "destOffset", e4);
            }
            (0, n.info)("Unable to compile PS function");
            const h = o2.length >> 1, u = s2.length >> 1, d = new PostScriptEvaluator(l), f = /* @__PURE__ */ Object.create(null);
            let g = 8192;
            const p = new Float32Array(u);
            return function constructPostScriptFn(e4, t4, a4, r3) {
              let n2, i2, s3 = "";
              const c2 = p;
              for (n2 = 0; n2 < u; n2++) {
                i2 = e4[t4 + n2];
                c2[n2] = i2;
                s3 += i2 + "_";
              }
              const l2 = f[s3];
              if (void 0 !== l2) {
                a4.set(l2, r3);
                return;
              }
              const m = new Float32Array(h), b = d.execute(c2), y = b.length - h;
              for (n2 = 0; n2 < h; n2++) {
                i2 = b[y + n2];
                let e5 = o2[2 * n2];
                if (i2 < e5) i2 = e5;
                else {
                  e5 = o2[2 * n2 + 1];
                  i2 > e5 && (i2 = e5);
                }
                m[n2] = i2;
              }
              if (g > 0) {
                g--;
                f[s3] = m;
              }
              a4.set(m, r3);
            };
          }
        }
        const _PostScriptStack = class _PostScriptStack {
          constructor(e3) {
            this.stack = e3 ? Array.from(e3) : [];
          }
          push(e3) {
            if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
            this.stack.push(e3);
          }
          pop() {
            if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
            return this.stack.pop();
          }
          copy(e3) {
            if (this.stack.length + e3 >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
            const t3 = this.stack;
            for (let a3 = t3.length - e3, r2 = e3 - 1; r2 >= 0; r2--, a3++) t3.push(t3[a3]);
          }
          index(e3) {
            this.push(this.stack[this.stack.length - e3 - 1]);
          }
          roll(e3, t3) {
            const a3 = this.stack, r2 = a3.length - e3, n2 = a3.length - 1, i2 = r2 + (t3 - Math.floor(t3 / e3) * e3);
            for (let e4 = r2, t4 = n2; e4 < t4; e4++, t4--) {
              const r3 = a3[e4];
              a3[e4] = a3[t4];
              a3[t4] = r3;
            }
            for (let e4 = r2, t4 = i2 - 1; e4 < t4; e4++, t4--) {
              const r3 = a3[e4];
              a3[e4] = a3[t4];
              a3[t4] = r3;
            }
            for (let e4 = i2, t4 = n2; e4 < t4; e4++, t4--) {
              const r3 = a3[e4];
              a3[e4] = a3[t4];
              a3[t4] = r3;
            }
          }
        };
        __publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
        let PostScriptStack = _PostScriptStack;
        class PostScriptEvaluator {
          constructor(e3) {
            this.operators = e3;
          }
          execute(e3) {
            const t3 = new PostScriptStack(e3);
            let a3 = 0;
            const r2 = this.operators, i2 = r2.length;
            let s2, o2, c;
            for (; a3 < i2; ) {
              s2 = r2[a3++];
              if ("number" != typeof s2) switch (s2) {
                case "jz":
                  c = t3.pop();
                  o2 = t3.pop();
                  o2 || (a3 = c);
                  break;
                case "j":
                  o2 = t3.pop();
                  a3 = o2;
                  break;
                case "abs":
                  o2 = t3.pop();
                  t3.push(Math.abs(o2));
                  break;
                case "add":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 + c);
                  break;
                case "and":
                  c = t3.pop();
                  o2 = t3.pop();
                  "boolean" == typeof o2 && "boolean" == typeof c ? t3.push(o2 && c) : t3.push(o2 & c);
                  break;
                case "atan":
                  c = t3.pop();
                  o2 = t3.pop();
                  o2 = Math.atan2(o2, c) / Math.PI * 180;
                  o2 < 0 && (o2 += 360);
                  t3.push(o2);
                  break;
                case "bitshift":
                  c = t3.pop();
                  o2 = t3.pop();
                  o2 > 0 ? t3.push(o2 << c) : t3.push(o2 >> c);
                  break;
                case "ceiling":
                  o2 = t3.pop();
                  t3.push(Math.ceil(o2));
                  break;
                case "copy":
                  o2 = t3.pop();
                  t3.copy(o2);
                  break;
                case "cos":
                  o2 = t3.pop();
                  t3.push(Math.cos(o2 % 360 / 180 * Math.PI));
                  break;
                case "cvi":
                  o2 = 0 | t3.pop();
                  t3.push(o2);
                  break;
                case "cvr":
                  break;
                case "div":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 / c);
                  break;
                case "dup":
                  t3.copy(1);
                  break;
                case "eq":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 === c);
                  break;
                case "exch":
                  t3.roll(2, 1);
                  break;
                case "exp":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 ** c);
                  break;
                case "false":
                  t3.push(false);
                  break;
                case "floor":
                  o2 = t3.pop();
                  t3.push(Math.floor(o2));
                  break;
                case "ge":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 >= c);
                  break;
                case "gt":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 > c);
                  break;
                case "idiv":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 / c | 0);
                  break;
                case "index":
                  o2 = t3.pop();
                  t3.index(o2);
                  break;
                case "le":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 <= c);
                  break;
                case "ln":
                  o2 = t3.pop();
                  t3.push(Math.log(o2));
                  break;
                case "log":
                  o2 = t3.pop();
                  t3.push(Math.log10(o2));
                  break;
                case "lt":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 < c);
                  break;
                case "mod":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 % c);
                  break;
                case "mul":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 * c);
                  break;
                case "ne":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 !== c);
                  break;
                case "neg":
                  o2 = t3.pop();
                  t3.push(-o2);
                  break;
                case "not":
                  o2 = t3.pop();
                  "boolean" == typeof o2 ? t3.push(!o2) : t3.push(~o2);
                  break;
                case "or":
                  c = t3.pop();
                  o2 = t3.pop();
                  "boolean" == typeof o2 && "boolean" == typeof c ? t3.push(o2 || c) : t3.push(o2 | c);
                  break;
                case "pop":
                  t3.pop();
                  break;
                case "roll":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.roll(o2, c);
                  break;
                case "round":
                  o2 = t3.pop();
                  t3.push(Math.round(o2));
                  break;
                case "sin":
                  o2 = t3.pop();
                  t3.push(Math.sin(o2 % 360 / 180 * Math.PI));
                  break;
                case "sqrt":
                  o2 = t3.pop();
                  t3.push(Math.sqrt(o2));
                  break;
                case "sub":
                  c = t3.pop();
                  o2 = t3.pop();
                  t3.push(o2 - c);
                  break;
                case "true":
                  t3.push(true);
                  break;
                case "truncate":
                  o2 = t3.pop();
                  o2 = o2 < 0 ? Math.ceil(o2) : Math.floor(o2);
                  t3.push(o2);
                  break;
                case "xor":
                  c = t3.pop();
                  o2 = t3.pop();
                  "boolean" == typeof o2 && "boolean" == typeof c ? t3.push(o2 !== c) : t3.push(o2 ^ c);
                  break;
                default:
                  throw new n.FormatError(`Unknown operator ${s2}`);
              }
              else t3.push(s2);
            }
            return t3.stack;
          }
        }
        t2.PostScriptEvaluator = PostScriptEvaluator;
        class AstNode {
          constructor(e3) {
            this.type = e3;
          }
          visit(e3) {
            (0, n.unreachable)("abstract method");
          }
        }
        class AstArgument extends AstNode {
          constructor(e3, t3, a3) {
            super("args");
            this.index = e3;
            this.min = t3;
            this.max = a3;
          }
          visit(e3) {
            e3.visitArgument(this);
          }
        }
        class AstLiteral extends AstNode {
          constructor(e3) {
            super("literal");
            this.number = e3;
            this.min = e3;
            this.max = e3;
          }
          visit(e3) {
            e3.visitLiteral(this);
          }
        }
        class AstBinaryOperation extends AstNode {
          constructor(e3, t3, a3, r2, n2) {
            super("binary");
            this.op = e3;
            this.arg1 = t3;
            this.arg2 = a3;
            this.min = r2;
            this.max = n2;
          }
          visit(e3) {
            e3.visitBinaryOperation(this);
          }
        }
        class AstMin extends AstNode {
          constructor(e3, t3) {
            super("max");
            this.arg = e3;
            this.min = e3.min;
            this.max = t3;
          }
          visit(e3) {
            e3.visitMin(this);
          }
        }
        class AstVariable extends AstNode {
          constructor(e3, t3, a3) {
            super("var");
            this.index = e3;
            this.min = t3;
            this.max = a3;
          }
          visit(e3) {
            e3.visitVariable(this);
          }
        }
        class AstVariableDefinition extends AstNode {
          constructor(e3, t3) {
            super("definition");
            this.variable = e3;
            this.arg = t3;
          }
          visit(e3) {
            e3.visitVariableDefinition(this);
          }
        }
        class ExpressionBuilderVisitor {
          constructor() {
            this.parts = [];
          }
          visitArgument(e3) {
            this.parts.push("Math.max(", e3.min, ", Math.min(", e3.max, ", src[srcOffset + ", e3.index, "]))");
          }
          visitVariable(e3) {
            this.parts.push("v", e3.index);
          }
          visitLiteral(e3) {
            this.parts.push(e3.number);
          }
          visitBinaryOperation(e3) {
            this.parts.push("(");
            e3.arg1.visit(this);
            this.parts.push(" ", e3.op, " ");
            e3.arg2.visit(this);
            this.parts.push(")");
          }
          visitVariableDefinition(e3) {
            this.parts.push("var ");
            e3.variable.visit(this);
            this.parts.push(" = ");
            e3.arg.visit(this);
            this.parts.push(";");
          }
          visitMin(e3) {
            this.parts.push("Math.min(");
            e3.arg.visit(this);
            this.parts.push(", ", e3.max, ")");
          }
          toString() {
            return this.parts.join("");
          }
        }
        function buildAddOperation(e3, t3) {
          return "literal" === t3.type && 0 === t3.number ? e3 : "literal" === e3.type && 0 === e3.number ? t3 : "literal" === t3.type && "literal" === e3.type ? new AstLiteral(e3.number + t3.number) : new AstBinaryOperation("+", e3, t3, e3.min + t3.min, e3.max + t3.max);
        }
        function buildMulOperation(e3, t3) {
          if ("literal" === t3.type) {
            if (0 === t3.number) return new AstLiteral(0);
            if (1 === t3.number) return e3;
            if ("literal" === e3.type) return new AstLiteral(e3.number * t3.number);
          }
          if ("literal" === e3.type) {
            if (0 === e3.number) return new AstLiteral(0);
            if (1 === e3.number) return t3;
          }
          const a3 = Math.min(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max), r2 = Math.max(e3.min * t3.min, e3.min * t3.max, e3.max * t3.min, e3.max * t3.max);
          return new AstBinaryOperation("*", e3, t3, a3, r2);
        }
        function buildSubOperation(e3, t3) {
          if ("literal" === t3.type) {
            if (0 === t3.number) return e3;
            if ("literal" === e3.type) return new AstLiteral(e3.number - t3.number);
          }
          return "binary" === t3.type && "-" === t3.op && "literal" === e3.type && 1 === e3.number && "literal" === t3.arg1.type && 1 === t3.arg1.number ? t3.arg2 : new AstBinaryOperation("-", e3, t3, e3.min - t3.max, e3.max - t3.min);
        }
        function buildMinOperation(e3, t3) {
          return e3.min >= t3 ? new AstLiteral(t3) : e3.max <= t3 ? e3 : new AstMin(e3, t3);
        }
        class PostScriptCompiler {
          compile(e3, t3, a3) {
            const r2 = [], n2 = [], i2 = t3.length >> 1, s2 = a3.length >> 1;
            let o2, c, l, h, u, d, f, g, p = 0;
            for (let e4 = 0; e4 < i2; e4++) r2.push(new AstArgument(e4, t3[2 * e4], t3[2 * e4 + 1]));
            for (let t4 = 0, a4 = e3.length; t4 < a4; t4++) {
              g = e3[t4];
              if ("number" != typeof g) switch (g) {
                case "add":
                  if (r2.length < 2) return null;
                  h = r2.pop();
                  l = r2.pop();
                  r2.push(buildAddOperation(l, h));
                  break;
                case "cvr":
                  if (r2.length < 1) return null;
                  break;
                case "mul":
                  if (r2.length < 2) return null;
                  h = r2.pop();
                  l = r2.pop();
                  r2.push(buildMulOperation(l, h));
                  break;
                case "sub":
                  if (r2.length < 2) return null;
                  h = r2.pop();
                  l = r2.pop();
                  r2.push(buildSubOperation(l, h));
                  break;
                case "exch":
                  if (r2.length < 2) return null;
                  u = r2.pop();
                  d = r2.pop();
                  r2.push(u, d);
                  break;
                case "pop":
                  if (r2.length < 1) return null;
                  r2.pop();
                  break;
                case "index":
                  if (r2.length < 1) return null;
                  l = r2.pop();
                  if ("literal" !== l.type) return null;
                  o2 = l.number;
                  if (o2 < 0 || !Number.isInteger(o2) || r2.length < o2) return null;
                  u = r2[r2.length - o2 - 1];
                  if ("literal" === u.type || "var" === u.type) {
                    r2.push(u);
                    break;
                  }
                  f = new AstVariable(p++, u.min, u.max);
                  r2[r2.length - o2 - 1] = f;
                  r2.push(f);
                  n2.push(new AstVariableDefinition(f, u));
                  break;
                case "dup":
                  if (r2.length < 1) return null;
                  if ("number" == typeof e3[t4 + 1] && "gt" === e3[t4 + 2] && e3[t4 + 3] === t4 + 7 && "jz" === e3[t4 + 4] && "pop" === e3[t4 + 5] && e3[t4 + 6] === e3[t4 + 1]) {
                    l = r2.pop();
                    r2.push(buildMinOperation(l, e3[t4 + 1]));
                    t4 += 6;
                    break;
                  }
                  u = r2.at(-1);
                  if ("literal" === u.type || "var" === u.type) {
                    r2.push(u);
                    break;
                  }
                  f = new AstVariable(p++, u.min, u.max);
                  r2[r2.length - 1] = f;
                  r2.push(f);
                  n2.push(new AstVariableDefinition(f, u));
                  break;
                case "roll":
                  if (r2.length < 2) return null;
                  h = r2.pop();
                  l = r2.pop();
                  if ("literal" !== h.type || "literal" !== l.type) return null;
                  c = h.number;
                  o2 = l.number;
                  if (o2 <= 0 || !Number.isInteger(o2) || !Number.isInteger(c) || r2.length < o2) return null;
                  c = (c % o2 + o2) % o2;
                  if (0 === c) break;
                  r2.push(...r2.splice(r2.length - o2, o2 - c));
                  break;
                default:
                  return null;
              }
              else r2.push(new AstLiteral(g));
            }
            if (r2.length !== s2) return null;
            const m = [];
            for (const e4 of n2) {
              const t4 = new ExpressionBuilderVisitor();
              e4.visit(t4);
              m.push(t4.toString());
            }
            for (let e4 = 0, t4 = r2.length; e4 < t4; e4++) {
              const t5 = r2[e4], n3 = new ExpressionBuilderVisitor();
              t5.visit(n3);
              const i3 = a3[2 * e4], s3 = a3[2 * e4 + 1], o3 = [n3.toString()];
              if (i3 > t5.min) {
                o3.unshift("Math.max(", i3, ", ");
                o3.push(")");
              }
              if (s3 < t5.max) {
                o3.unshift("Math.min(", s3, ", ");
                o3.push(")");
              }
              o3.unshift("dest[destOffset + ", e4, "] = ");
              o3.push(";");
              m.push(o3.join(""));
            }
            return m.join("\n");
          }
        }
        t2.PostScriptCompiler = PostScriptCompiler;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PostScriptParser = t2.PostScriptLexer = void 0;
        var r = a2(2), n = a2(4), i = a2(3);
        t2.PostScriptParser = class PostScriptParser {
          constructor(e3) {
            this.lexer = e3;
            this.operators = [];
            this.token = null;
            this.prev = null;
          }
          nextToken() {
            this.prev = this.token;
            this.token = this.lexer.getToken();
          }
          accept(e3) {
            if (this.token.type === e3) {
              this.nextToken();
              return true;
            }
            return false;
          }
          expect(e3) {
            if (this.accept(e3)) return true;
            throw new r.FormatError(`Unexpected symbol: found ${this.token.type} expected ${e3}.`);
          }
          parse() {
            this.nextToken();
            this.expect(s.LBRACE);
            this.parseBlock();
            this.expect(s.RBRACE);
            return this.operators;
          }
          parseBlock() {
            for (; ; ) if (this.accept(s.NUMBER)) this.operators.push(this.prev.value);
            else if (this.accept(s.OPERATOR)) this.operators.push(this.prev.value);
            else {
              if (!this.accept(s.LBRACE)) return;
              this.parseCondition();
            }
          }
          parseCondition() {
            const e3 = this.operators.length;
            this.operators.push(null, null);
            this.parseBlock();
            this.expect(s.RBRACE);
            if (this.accept(s.IF)) {
              this.operators[e3] = this.operators.length;
              this.operators[e3 + 1] = "jz";
            } else {
              if (!this.accept(s.LBRACE)) throw new r.FormatError("PS Function: error parsing conditional.");
              {
                const t3 = this.operators.length;
                this.operators.push(null, null);
                const a3 = this.operators.length;
                this.parseBlock();
                this.expect(s.RBRACE);
                this.expect(s.IFELSE);
                this.operators[t3] = this.operators.length;
                this.operators[t3 + 1] = "j";
                this.operators[e3] = a3;
                this.operators[e3 + 1] = "jz";
              }
            }
          }
        };
        const s = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
        class PostScriptToken {
          static get opCache() {
            return (0, r.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
          }
          constructor(e3, t3) {
            this.type = e3;
            this.value = t3;
          }
          static getOperator(e3) {
            var _a;
            return (_a = PostScriptToken.opCache)[e3] || (_a[e3] = new PostScriptToken(s.OPERATOR, e3));
          }
          static get LBRACE() {
            return (0, r.shadow)(this, "LBRACE", new PostScriptToken(s.LBRACE, "{"));
          }
          static get RBRACE() {
            return (0, r.shadow)(this, "RBRACE", new PostScriptToken(s.RBRACE, "}"));
          }
          static get IF() {
            return (0, r.shadow)(this, "IF", new PostScriptToken(s.IF, "IF"));
          }
          static get IFELSE() {
            return (0, r.shadow)(this, "IFELSE", new PostScriptToken(s.IFELSE, "IFELSE"));
          }
        }
        t2.PostScriptLexer = class PostScriptLexer {
          constructor(e3) {
            this.stream = e3;
            this.nextChar();
            this.strBuf = [];
          }
          nextChar() {
            return this.currentChar = this.stream.getByte();
          }
          getToken() {
            let e3 = false, t3 = this.currentChar;
            for (; ; ) {
              if (t3 < 0) return n.EOF;
              if (e3) 10 !== t3 && 13 !== t3 || (e3 = false);
              else if (37 === t3) e3 = true;
              else if (!(0, i.isWhiteSpace)(t3)) break;
              t3 = this.nextChar();
            }
            switch (0 | t3) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 43:
              case 45:
              case 46:
                return new PostScriptToken(s.NUMBER, this.getNumber());
              case 123:
                this.nextChar();
                return PostScriptToken.LBRACE;
              case 125:
                this.nextChar();
                return PostScriptToken.RBRACE;
            }
            const a3 = this.strBuf;
            a3.length = 0;
            a3[0] = String.fromCharCode(t3);
            for (; (t3 = this.nextChar()) >= 0 && (t3 >= 65 && t3 <= 90 || t3 >= 97 && t3 <= 122); ) a3.push(String.fromCharCode(t3));
            const r2 = a3.join("");
            switch (r2.toLowerCase()) {
              case "if":
                return PostScriptToken.IF;
              case "ifelse":
                return PostScriptToken.IFELSE;
              default:
                return PostScriptToken.getOperator(r2);
            }
          }
          getNumber() {
            let e3 = this.currentChar;
            const t3 = this.strBuf;
            t3.length = 0;
            t3[0] = String.fromCharCode(e3);
            for (; (e3 = this.nextChar()) >= 0 && (e3 >= 48 && e3 <= 57 || 45 === e3 || 46 === e3); ) t3.push(String.fromCharCode(e3));
            const a3 = parseFloat(t3.join(""));
            if (isNaN(a3)) throw new r.FormatError(`Invalid floating point number: ${a3}`);
            return a3;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.RegionalImageCache = t2.LocalTilingPatternCache = t2.LocalImageCache = t2.LocalGStateCache = t2.LocalFunctionCache = t2.LocalColorSpaceCache = t2.GlobalImageCache = void 0;
        var r = a2(2), n = a2(4);
        class BaseLocalCache {
          constructor(e3) {
            this.constructor === BaseLocalCache && (0, r.unreachable)("Cannot initialize BaseLocalCache.");
            this._onlyRefs = true === (e3 == null ? void 0 : e3.onlyRefs);
            if (!this._onlyRefs) {
              this._nameRefMap = /* @__PURE__ */ new Map();
              this._imageMap = /* @__PURE__ */ new Map();
            }
            this._imageCache = new n.RefSetCache();
          }
          getByName(e3) {
            this._onlyRefs && (0, r.unreachable)("Should not call `getByName` method.");
            const t3 = this._nameRefMap.get(e3);
            return t3 ? this.getByRef(t3) : this._imageMap.get(e3) || null;
          }
          getByRef(e3) {
            return this._imageCache.get(e3) || null;
          }
          set(e3, t3, a3) {
            (0, r.unreachable)("Abstract method `set` called.");
          }
        }
        t2.LocalImageCache = class LocalImageCache extends BaseLocalCache {
          set(e3, t3 = null, a3) {
            if ("string" != typeof e3) throw new Error('LocalImageCache.set - expected "name" argument.');
            if (t3) {
              if (this._imageCache.has(t3)) return;
              this._nameRefMap.set(e3, t3);
              this._imageCache.put(t3, a3);
            } else this._imageMap.has(e3) || this._imageMap.set(e3, a3);
          }
        };
        t2.LocalColorSpaceCache = class LocalColorSpaceCache extends BaseLocalCache {
          set(e3 = null, t3 = null, a3) {
            if ("string" != typeof e3 && !t3) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
            if (t3) {
              if (this._imageCache.has(t3)) return;
              null !== e3 && this._nameRefMap.set(e3, t3);
              this._imageCache.put(t3, a3);
            } else this._imageMap.has(e3) || this._imageMap.set(e3, a3);
          }
        };
        t2.LocalFunctionCache = class LocalFunctionCache extends BaseLocalCache {
          constructor(e3) {
            super({ onlyRefs: true });
          }
          set(e3 = null, t3, a3) {
            if (!t3) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
            this._imageCache.has(t3) || this._imageCache.put(t3, a3);
          }
        };
        t2.LocalGStateCache = class LocalGStateCache extends BaseLocalCache {
          set(e3, t3 = null, a3) {
            if ("string" != typeof e3) throw new Error('LocalGStateCache.set - expected "name" argument.');
            if (t3) {
              if (this._imageCache.has(t3)) return;
              this._nameRefMap.set(e3, t3);
              this._imageCache.put(t3, a3);
            } else this._imageMap.has(e3) || this._imageMap.set(e3, a3);
          }
        };
        t2.LocalTilingPatternCache = class LocalTilingPatternCache extends BaseLocalCache {
          constructor(e3) {
            super({ onlyRefs: true });
          }
          set(e3 = null, t3, a3) {
            if (!t3) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
            this._imageCache.has(t3) || this._imageCache.put(t3, a3);
          }
        };
        t2.RegionalImageCache = class RegionalImageCache extends BaseLocalCache {
          constructor(e3) {
            super({ onlyRefs: true });
          }
          set(e3 = null, t3, a3) {
            if (!t3) throw new Error('RegionalImageCache.set - expected "ref" argument.');
            this._imageCache.has(t3) || this._imageCache.put(t3, a3);
          }
        };
        const _GlobalImageCache = class _GlobalImageCache {
          constructor() {
            this._refCache = new n.RefSetCache();
            this._imageCache = new n.RefSetCache();
          }
          get _byteSize() {
            let e3 = 0;
            for (const t3 of this._imageCache) e3 += t3.byteSize;
            return e3;
          }
          get _cacheLimitReached() {
            return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this._byteSize < _GlobalImageCache.MAX_BYTE_SIZE);
          }
          shouldCache(e3, t3) {
            let a3 = this._refCache.get(e3);
            if (!a3) {
              a3 = /* @__PURE__ */ new Set();
              this._refCache.put(e3, a3);
            }
            a3.add(t3);
            return !(a3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e3) && this._cacheLimitReached);
          }
          addByteSize(e3, t3) {
            const a3 = this._imageCache.get(e3);
            a3 && (a3.byteSize || (a3.byteSize = t3));
          }
          getData(e3, t3) {
            const a3 = this._refCache.get(e3);
            if (!a3) return null;
            if (a3.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
            const r2 = this._imageCache.get(e3);
            if (!r2) return null;
            a3.add(t3);
            return r2;
          }
          setData(e3, t3) {
            if (!this._refCache.has(e3)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
            this._imageCache.has(e3) || (this._cacheLimitReached ? (0, r.warn)("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e3, t3));
          }
          clear(e3 = false) {
            e3 || this._refCache.clear();
            this._imageCache.clear();
          }
        };
        __publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
        __publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
        __publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5 * r.MAX_IMAGE_SIZE_TO_CACHE);
        let GlobalImageCache = _GlobalImageCache;
        t2.GlobalImageCache = GlobalImageCache;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.bidi = function bidi(e3, t3 = -1, a3 = false) {
          let c = true;
          const l = e3.length;
          if (0 === l || a3) return createBidiText(e3, c, a3);
          s.length = l;
          o.length = l;
          let h, u, d = 0;
          for (h = 0; h < l; ++h) {
            s[h] = e3.charAt(h);
            const t4 = e3.charCodeAt(h);
            let a4 = "L";
            if (t4 <= 255) a4 = n[t4];
            else if (1424 <= t4 && t4 <= 1524) a4 = "R";
            else if (1536 <= t4 && t4 <= 1791) {
              a4 = i[255 & t4];
              a4 || (0, r.warn)("Bidi: invalid Unicode character " + t4.toString(16));
            } else (1792 <= t4 && t4 <= 2220 || 64336 <= t4 && t4 <= 65023 || 65136 <= t4 && t4 <= 65279) && (a4 = "AL");
            "R" !== a4 && "AL" !== a4 && "AN" !== a4 || d++;
            o[h] = a4;
          }
          if (0 === d) {
            c = true;
            return createBidiText(e3, c);
          }
          if (-1 === t3) if (d / l < 0.3 && l > 4) {
            c = true;
            t3 = 0;
          } else {
            c = false;
            t3 = 1;
          }
          const f = [];
          for (h = 0; h < l; ++h) f[h] = t3;
          const g = isOdd(t3) ? "R" : "L", p = g, m = p;
          let b, y = p;
          for (h = 0; h < l; ++h) "NSM" === o[h] ? o[h] = y : y = o[h];
          y = p;
          for (h = 0; h < l; ++h) {
            b = o[h];
            "EN" === b ? o[h] = "AL" === y ? "AN" : "EN" : "R" !== b && "L" !== b && "AL" !== b || (y = b);
          }
          for (h = 0; h < l; ++h) {
            b = o[h];
            "AL" === b && (o[h] = "R");
          }
          for (h = 1; h < l - 1; ++h) {
            "ES" === o[h] && "EN" === o[h - 1] && "EN" === o[h + 1] && (o[h] = "EN");
            "CS" !== o[h] || "EN" !== o[h - 1] && "AN" !== o[h - 1] || o[h + 1] !== o[h - 1] || (o[h] = o[h - 1]);
          }
          for (h = 0; h < l; ++h) if ("EN" === o[h]) {
            for (let e4 = h - 1; e4 >= 0 && "ET" === o[e4]; --e4) o[e4] = "EN";
            for (let e4 = h + 1; e4 < l && "ET" === o[e4]; ++e4) o[e4] = "EN";
          }
          for (h = 0; h < l; ++h) {
            b = o[h];
            "WS" !== b && "ES" !== b && "ET" !== b && "CS" !== b || (o[h] = "ON");
          }
          y = p;
          for (h = 0; h < l; ++h) {
            b = o[h];
            "EN" === b ? o[h] = "L" === y ? "L" : "EN" : "R" !== b && "L" !== b || (y = b);
          }
          for (h = 0; h < l; ++h) if ("ON" === o[h]) {
            const e4 = findUnequal(o, h + 1, "ON");
            let t4 = p;
            h > 0 && (t4 = o[h - 1]);
            let a4 = m;
            e4 + 1 < l && (a4 = o[e4 + 1]);
            "L" !== t4 && (t4 = "R");
            "L" !== a4 && (a4 = "R");
            t4 === a4 && setValues(o, h, e4, t4);
            h = e4 - 1;
          }
          for (h = 0; h < l; ++h) "ON" === o[h] && (o[h] = g);
          for (h = 0; h < l; ++h) {
            b = o[h];
            isEven(f[h]) ? "R" === b ? f[h] += 1 : "AN" !== b && "EN" !== b || (f[h] += 2) : "L" !== b && "AN" !== b && "EN" !== b || (f[h] += 1);
          }
          let w, S = -1, x = 99;
          for (h = 0, u = f.length; h < u; ++h) {
            w = f[h];
            S < w && (S = w);
            x > w && isOdd(w) && (x = w);
          }
          for (w = S; w >= x; --w) {
            let e4 = -1;
            for (h = 0, u = f.length; h < u; ++h) if (f[h] < w) {
              if (e4 >= 0) {
                reverseValues(s, e4, h);
                e4 = -1;
              }
            } else e4 < 0 && (e4 = h);
            e4 >= 0 && reverseValues(s, e4, f.length);
          }
          for (h = 0, u = s.length; h < u; ++h) {
            const e4 = s[h];
            "<" !== e4 && ">" !== e4 || (s[h] = "");
          }
          return createBidiText(s.join(""), c);
        };
        var r = a2(2);
        const n = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], i = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
        function isOdd(e3) {
          return 0 != (1 & e3);
        }
        function isEven(e3) {
          return 0 == (1 & e3);
        }
        function findUnequal(e3, t3, a3) {
          let r2, n2;
          for (r2 = t3, n2 = e3.length; r2 < n2; ++r2) if (e3[r2] !== a3) return r2;
          return r2;
        }
        function setValues(e3, t3, a3, r2) {
          for (let n2 = t3; n2 < a3; ++n2) e3[n2] = r2;
        }
        function reverseValues(e3, t3, a3) {
          for (let r2 = t3, n2 = a3 - 1; r2 < n2; ++r2, --n2) {
            const t4 = e3[r2];
            e3[r2] = e3[n2];
            e3[n2] = t4;
          }
        }
        function createBidiText(e3, t3, a3 = false) {
          let r2 = "ltr";
          a3 ? r2 = "ttb" : t3 || (r2 = "rtl");
          return { str: e3, dir: r2 };
        }
        const s = [], o = [];
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getFontSubstitution = function getFontSubstitution(e3, t3, a3, u, d) {
          const f = u = (0, r.normalizeFontName)(u);
          let g = e3.get(f);
          if (g) return g;
          let p = l.get(u);
          if (!p) {
            for (const [e4, t4] of h) if (u.startsWith(e4)) {
              u = `${t4}${u.substring(e4.length)}`;
              p = l.get(u);
              break;
            }
          }
          let m = false;
          if (!p) {
            p = l.get(d);
            m = true;
          }
          const b = `${t3.getDocId()}_s${t3.createFontId()}`;
          if (!p) {
            if (!(0, n.validateFontName)(u)) {
              e3.set(f, null);
              return null;
            }
            const t4 = /bold/gi.test(u), a4 = /oblique|italic/gi.test(u);
            g = { css: b, guessFallback: true, loadedName: b, baseFontName: u, src: `local(${u})`, style: t4 && a4 && c || t4 && s || a4 && o || i };
            e3.set(f, g);
            return g;
          }
          const y = [];
          m && (0, n.validateFontName)(u) && y.push(`local(${u})`);
          const { style: w, ultimate: S } = generateFont(p, y, a3), x = null === S;
          g = { css: `${b}${x ? "" : `,${S}`}`, guessFallback: x, loadedName: b, baseFontName: u, src: y.join(","), style: w };
          e3.set(f, g);
          return g;
        };
        var r = a2(38), n = a2(3);
        const i = { style: "normal", weight: "normal" }, s = { style: "normal", weight: "bold" }, o = { style: "italic", weight: "normal" }, c = { style: "italic", weight: "bold" }, l = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: i, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: s, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: o, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: c, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: i, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: s, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: o, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: c, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"], style: i, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: s, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: o, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: c, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: i, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: s, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: o, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: c, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: i, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: s, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: o, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: c, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: i }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]), h = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
        function generateFont({ alias: e3, local: t3, path: a3, fallback: r2, style: n2, ultimate: i2 }, h2, u, d = true, f = true, g = "") {
          const p = { style: null, ultimate: null };
          if (t3) {
            const e4 = g ? ` ${g}` : "";
            for (const a4 of t3) h2.push(`local(${a4}${e4})`);
          }
          if (e3) {
            const t4 = l.get(e3), i3 = g || function getStyleToAppend(e4) {
              switch (e4) {
                case s:
                  return "Bold";
                case o:
                  return "Italic";
                case c:
                  return "Bold Italic";
                default:
                  if ("bold" === (e4 == null ? void 0 : e4.weight)) return "Bold";
                  if ("italic" === (e4 == null ? void 0 : e4.style)) return "Italic";
              }
              return "";
            }(n2);
            Object.assign(p, generateFont(t4, h2, u, d && !r2, f && !a3, i3));
          }
          n2 && (p.style = n2);
          i2 && (p.ultimate = i2);
          if (d && r2) {
            const e4 = l.get(r2), { ultimate: t4 } = generateFont(e4, h2, u, d, f && !a3, g);
            p.ultimate || (p.ultimate = t4);
          }
          f && a3 && u && h2.push(`url(${u}${a3})`);
          return p;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ImageResizer = void 0;
        var r = a2(2);
        class ImageResizer {
          constructor(e3, t3) {
            this._imgData = e3;
            this._isMask = t3;
          }
          static needsToBeResized(e3, t3) {
            if (e3 <= this._goodSquareLength && t3 <= this._goodSquareLength) return false;
            const { MAX_DIM: a3 } = this;
            if (e3 > a3 || t3 > a3) return true;
            const r2 = e3 * t3;
            if (this._hasMaxArea) return r2 > this.MAX_AREA;
            if (r2 < this._goodSquareLength ** 2) return false;
            if (this._areGoodDims(e3, t3)) {
              this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(e3 * t3)));
              return false;
            }
            this._goodSquareLength = this._guessMax(this._goodSquareLength, a3, 128, 0);
            return r2 > (this.MAX_AREA = this._goodSquareLength ** 2);
          }
          static get MAX_DIM() {
            return (0, r.shadow)(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
          }
          static get MAX_AREA() {
            this._hasMaxArea = true;
            return (0, r.shadow)(this, "MAX_AREA", this._guessMax(ImageResizer._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);
          }
          static set MAX_AREA(e3) {
            if (e3 >= 0) {
              this._hasMaxArea = true;
              (0, r.shadow)(this, "MAX_AREA", e3);
            }
          }
          static setMaxArea(e3) {
            this._hasMaxArea || (this.MAX_AREA = e3 >> 2);
          }
          static _areGoodDims(e3, t3) {
            try {
              const a3 = new OffscreenCanvas(e3, t3), r2 = a3.getContext("2d");
              r2.fillRect(0, 0, 1, 1);
              const n = r2.getImageData(0, 0, 1, 1).data[3];
              a3.width = a3.height = 1;
              return 0 !== n;
            } catch {
              return false;
            }
          }
          static _guessMax(e3, t3, a3, r2) {
            for (; e3 + a3 + 1 < t3; ) {
              const a4 = Math.floor((e3 + t3) / 2), n = r2 || a4;
              this._areGoodDims(a4, n) ? e3 = a4 : t3 = a4;
            }
            return e3;
          }
          static async createImage(e3, t3 = false) {
            return new ImageResizer(e3, t3)._createImage();
          }
          async _createImage() {
            const e3 = this._encodeBMP(), t3 = new Blob([e3.buffer], { type: "image/bmp" }), a3 = createImageBitmap(t3), { MAX_AREA: r2, MAX_DIM: n } = ImageResizer, { _imgData: i } = this, { width: s, height: o } = i, c = Math.max(s / n, o / n, Math.sqrt(s * o / r2)), l = Math.max(c, 2), h = Math.round(10 * (c + 1.25)) / 10 / l, u = Math.floor(Math.log2(h)), d = new Array(u + 2).fill(2);
            d[0] = l;
            d.splice(-1, 1, h / (1 << u));
            let f = s, g = o, p = await a3;
            for (const e4 of d) {
              const t4 = f, a4 = g;
              f = Math.floor(f / e4) - 1;
              g = Math.floor(g / e4) - 1;
              const r3 = new OffscreenCanvas(f, g);
              r3.getContext("2d").drawImage(p, 0, 0, t4, a4, 0, 0, f, g);
              p = r3.transferToImageBitmap();
            }
            i.data = null;
            i.bitmap = p;
            i.width = f;
            i.height = g;
            return i;
          }
          _encodeBMP() {
            const { width: e3, height: t3, kind: a3 } = this._imgData;
            let n, i = this._imgData.data, s = new Uint8Array(0), o = s, c = 0;
            switch (a3) {
              case r.ImageKind.GRAYSCALE_1BPP: {
                n = 1;
                s = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
                const a5 = e3 + 7 >> 3, r2 = a5 + 3 & -4;
                if (a5 !== r2) {
                  const e4 = new Uint8Array(r2 * t3);
                  let n2 = 0;
                  for (let s2 = 0, o2 = t3 * a5; s2 < o2; s2 += a5, n2 += r2) e4.set(i.subarray(s2, s2 + a5), n2);
                  i = e4;
                }
                break;
              }
              case r.ImageKind.RGB_24BPP:
                n = 24;
                if (3 & e3) {
                  const a5 = 3 * e3, r2 = a5 + 3 & -4, n2 = r2 - a5, s2 = new Uint8Array(r2 * t3);
                  let o2 = 0;
                  for (let e4 = 0, r3 = t3 * a5; e4 < r3; e4 += a5) {
                    const t4 = i.subarray(e4, e4 + a5);
                    for (let e5 = 0; e5 < a5; e5 += 3) {
                      s2[o2++] = t4[e5 + 2];
                      s2[o2++] = t4[e5 + 1];
                      s2[o2++] = t4[e5];
                    }
                    o2 += n2;
                  }
                  i = s2;
                } else for (let e4 = 0, t4 = i.length; e4 < t4; e4 += 3) {
                  const t5 = i[e4];
                  i[e4] = i[e4 + 2];
                  i[e4 + 2] = t5;
                }
                break;
              case r.ImageKind.RGBA_32BPP:
                n = 32;
                c = 3;
                o = new Uint8Array(68);
                const a4 = new DataView(o.buffer);
                if (r.FeatureTest.isLittleEndian) {
                  a4.setUint32(0, 255, true);
                  a4.setUint32(4, 65280, true);
                  a4.setUint32(8, 16711680, true);
                  a4.setUint32(12, 4278190080, true);
                } else {
                  a4.setUint32(0, 4278190080, true);
                  a4.setUint32(4, 16711680, true);
                  a4.setUint32(8, 65280, true);
                  a4.setUint32(12, 255, true);
                }
                break;
              default:
                throw new Error("invalid format");
            }
            let l = 0;
            const h = 40 + o.length, u = 14 + h + s.length + i.length, d = new Uint8Array(u), f = new DataView(d.buffer);
            f.setUint16(l, 19778, true);
            l += 2;
            f.setUint32(l, u, true);
            l += 4;
            f.setUint32(l, 0, true);
            l += 4;
            f.setUint32(l, 14 + h + s.length, true);
            l += 4;
            f.setUint32(l, h, true);
            l += 4;
            f.setInt32(l, e3, true);
            l += 4;
            f.setInt32(l, -t3, true);
            l += 4;
            f.setUint16(l, 1, true);
            l += 2;
            f.setUint16(l, n, true);
            l += 2;
            f.setUint32(l, c, true);
            l += 4;
            f.setUint32(l, 0, true);
            l += 4;
            f.setInt32(l, 0, true);
            l += 4;
            f.setInt32(l, 0, true);
            l += 4;
            f.setUint32(l, s.length / 4, true);
            l += 4;
            f.setUint32(l, 0, true);
            l += 4;
            d.set(o, l);
            l += o.length;
            d.set(s, l);
            l += s.length;
            d.set(i, l);
            return d;
          }
        }
        t2.ImageResizer = ImageResizer;
        ImageResizer._goodSquareLength = 2048;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.MurmurHash3_64 = void 0;
        var r = a2(2);
        const n = 3285377520, i = 4294901760, s = 65535;
        t2.MurmurHash3_64 = class MurmurHash3_64 {
          constructor(e3) {
            this.h1 = e3 ? 4294967295 & e3 : n;
            this.h2 = e3 ? 4294967295 & e3 : n;
          }
          update(e3) {
            let t3, a3;
            if ("string" == typeof e3) {
              t3 = new Uint8Array(2 * e3.length);
              a3 = 0;
              for (let r2 = 0, n3 = e3.length; r2 < n3; r2++) {
                const n4 = e3.charCodeAt(r2);
                if (n4 <= 255) t3[a3++] = n4;
                else {
                  t3[a3++] = n4 >>> 8;
                  t3[a3++] = 255 & n4;
                }
              }
            } else {
              if (!(0, r.isArrayBuffer)(e3)) throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              t3 = e3.slice();
              a3 = t3.byteLength;
            }
            const n2 = a3 >> 2, o = a3 - 4 * n2, c = new Uint32Array(t3.buffer, 0, n2);
            let l = 0, h = 0, u = this.h1, d = this.h2;
            const f = 3432918353, g = 461845907, p = 11601, m = 13715;
            for (let e4 = 0; e4 < n2; e4++) if (1 & e4) {
              l = c[e4];
              l = l * f & i | l * p & s;
              l = l << 15 | l >>> 17;
              l = l * g & i | l * m & s;
              u ^= l;
              u = u << 13 | u >>> 19;
              u = 5 * u + 3864292196;
            } else {
              h = c[e4];
              h = h * f & i | h * p & s;
              h = h << 15 | h >>> 17;
              h = h * g & i | h * m & s;
              d ^= h;
              d = d << 13 | d >>> 19;
              d = 5 * d + 3864292196;
            }
            l = 0;
            switch (o) {
              case 3:
                l ^= t3[4 * n2 + 2] << 16;
              case 2:
                l ^= t3[4 * n2 + 1] << 8;
              case 1:
                l ^= t3[4 * n2];
                l = l * f & i | l * p & s;
                l = l << 15 | l >>> 17;
                l = l * g & i | l * m & s;
                1 & n2 ? u ^= l : d ^= l;
            }
            this.h1 = u;
            this.h2 = d;
          }
          hexdigest() {
            let e3 = this.h1, t3 = this.h2;
            e3 ^= t3 >>> 1;
            e3 = 3981806797 * e3 & i | 36045 * e3 & s;
            t3 = 4283543511 * t3 & i | (2950163797 * (t3 << 16 | e3 >>> 16) & i) >>> 16;
            e3 ^= t3 >>> 1;
            e3 = 444984403 * e3 & i | 60499 * e3 & s;
            t3 = 3301882366 * t3 & i | (3120437893 * (t3 << 16 | e3 >>> 16) & i) >>> 16;
            e3 ^= t3 >>> 1;
            return (e3 >>> 0).toString(16).padStart(8, "0") + (t3 >>> 0).toString(16).padStart(8, "0");
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.OperatorList = void 0;
        var r = a2(2);
        function addState(e3, t3, a3, r2, n2) {
          let i = e3;
          for (let e4 = 0, a4 = t3.length - 1; e4 < a4; e4++) {
            const a5 = t3[e4];
            i = i[a5] || (i[a5] = []);
          }
          i[t3.at(-1)] = { checkFn: a3, iterateFn: r2, processFn: n2 };
        }
        const n = [];
        addState(n, [r.OPS.save, r.OPS.transform, r.OPS.paintInlineImageXObject, r.OPS.restore], null, function iterateInlineImageGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = (t3 - (e3.iCurr - 3)) % 4;
          switch (n2) {
            case 0:
              return a3[t3] === r.OPS.save;
            case 1:
              return a3[t3] === r.OPS.transform;
            case 2:
              return a3[t3] === r.OPS.paintInlineImageXObject;
            case 3:
              return a3[t3] === r.OPS.restore;
          }
          throw new Error(`iterateInlineImageGroup - invalid pos: ${n2}`);
        }, function foundInlineImageGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = e3.argsArray, i = e3.iCurr, s = i - 3, o = i - 2, c = i - 1, l = Math.min(Math.floor((t3 - s) / 4), 200);
          if (l < 10) return t3 - (t3 - s) % 4;
          let h = 0;
          const u = [];
          let d = 0, f = 1, g = 1;
          for (let e4 = 0; e4 < l; e4++) {
            const t4 = n2[o + (e4 << 2)], a4 = n2[c + (e4 << 2)][0];
            if (f + a4.width > 1e3) {
              h = Math.max(h, f);
              g += d + 2;
              f = 0;
              d = 0;
            }
            u.push({ transform: t4, x: f, y: g, w: a4.width, h: a4.height });
            f += a4.width + 2;
            d = Math.max(d, a4.height);
          }
          const p = Math.max(h, f) + 1, m = g + d + 1, b = new Uint8Array(p * m * 4), y = p << 2;
          for (let e4 = 0; e4 < l; e4++) {
            const t4 = n2[c + (e4 << 2)][0].data, a4 = u[e4].w << 2;
            let r2 = 0, i2 = u[e4].x + u[e4].y * p << 2;
            b.set(t4.subarray(0, a4), i2 - y);
            for (let n3 = 0, s2 = u[e4].h; n3 < s2; n3++) {
              b.set(t4.subarray(r2, r2 + a4), i2);
              r2 += a4;
              i2 += y;
            }
            b.set(t4.subarray(r2 - a4, r2), i2);
            for (; i2 >= 0; ) {
              t4[i2 - 4] = t4[i2];
              t4[i2 - 3] = t4[i2 + 1];
              t4[i2 - 2] = t4[i2 + 2];
              t4[i2 - 1] = t4[i2 + 3];
              t4[i2 + a4] = t4[i2 + a4 - 4];
              t4[i2 + a4 + 1] = t4[i2 + a4 - 3];
              t4[i2 + a4 + 2] = t4[i2 + a4 - 2];
              t4[i2 + a4 + 3] = t4[i2 + a4 - 1];
              i2 -= y;
            }
          }
          const w = { width: p, height: m };
          if (e3.isOffscreenCanvasSupported) {
            const e4 = new OffscreenCanvas(p, m);
            e4.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(b.buffer), p, m), 0, 0);
            w.bitmap = e4.transferToImageBitmap();
            w.data = null;
          } else {
            w.kind = r.ImageKind.RGBA_32BPP;
            w.data = b;
          }
          a3.splice(s, 4 * l, r.OPS.paintInlineImageXObjectGroup);
          n2.splice(s, 4 * l, [w, u]);
          return s + 1;
        });
        addState(n, [r.OPS.save, r.OPS.transform, r.OPS.paintImageMaskXObject, r.OPS.restore], null, function iterateImageMaskGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = (t3 - (e3.iCurr - 3)) % 4;
          switch (n2) {
            case 0:
              return a3[t3] === r.OPS.save;
            case 1:
              return a3[t3] === r.OPS.transform;
            case 2:
              return a3[t3] === r.OPS.paintImageMaskXObject;
            case 3:
              return a3[t3] === r.OPS.restore;
          }
          throw new Error(`iterateImageMaskGroup - invalid pos: ${n2}`);
        }, function foundImageMaskGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = e3.argsArray, i = e3.iCurr, s = i - 3, o = i - 2, c = i - 1;
          let l = Math.floor((t3 - s) / 4);
          if (l < 10) return t3 - (t3 - s) % 4;
          let h, u, d = false;
          const f = n2[c][0], g = n2[o][0], p = n2[o][1], m = n2[o][2], b = n2[o][3];
          if (p === m) {
            d = true;
            h = o + 4;
            let e4 = c + 4;
            for (let t4 = 1; t4 < l; t4++, h += 4, e4 += 4) {
              u = n2[h];
              if (n2[e4][0] !== f || u[0] !== g || u[1] !== p || u[2] !== m || u[3] !== b) {
                t4 < 10 ? d = false : l = t4;
                break;
              }
            }
          }
          if (d) {
            l = Math.min(l, 1e3);
            const e4 = new Float32Array(2 * l);
            h = o;
            for (let t4 = 0; t4 < l; t4++, h += 4) {
              u = n2[h];
              e4[t4 << 1] = u[4];
              e4[1 + (t4 << 1)] = u[5];
            }
            a3.splice(s, 4 * l, r.OPS.paintImageMaskXObjectRepeat);
            n2.splice(s, 4 * l, [f, g, p, m, b, e4]);
          } else {
            l = Math.min(l, 100);
            const e4 = [];
            for (let t4 = 0; t4 < l; t4++) {
              u = n2[o + (t4 << 2)];
              const a4 = n2[c + (t4 << 2)][0];
              e4.push({ data: a4.data, width: a4.width, height: a4.height, interpolate: a4.interpolate, count: a4.count, transform: u });
            }
            a3.splice(s, 4 * l, r.OPS.paintImageMaskXObjectGroup);
            n2.splice(s, 4 * l, [e4]);
          }
          return s + 1;
        });
        addState(n, [r.OPS.save, r.OPS.transform, r.OPS.paintImageXObject, r.OPS.restore], function(e3) {
          const t3 = e3.argsArray, a3 = e3.iCurr - 2;
          return 0 === t3[a3][1] && 0 === t3[a3][2];
        }, function iterateImageGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = e3.argsArray, i = (t3 - (e3.iCurr - 3)) % 4;
          switch (i) {
            case 0:
              return a3[t3] === r.OPS.save;
            case 1:
              if (a3[t3] !== r.OPS.transform) return false;
              const i2 = e3.iCurr - 2, s = n2[i2][0], o = n2[i2][3];
              return n2[t3][0] === s && 0 === n2[t3][1] && 0 === n2[t3][2] && n2[t3][3] === o;
            case 2:
              if (a3[t3] !== r.OPS.paintImageXObject) return false;
              const c = n2[e3.iCurr - 1][0];
              return n2[t3][0] === c;
            case 3:
              return a3[t3] === r.OPS.restore;
          }
          throw new Error(`iterateImageGroup - invalid pos: ${i}`);
        }, function(e3, t3) {
          const a3 = e3.fnArray, n2 = e3.argsArray, i = e3.iCurr, s = i - 3, o = i - 2, c = n2[i - 1][0], l = n2[o][0], h = n2[o][3], u = Math.min(Math.floor((t3 - s) / 4), 1e3);
          if (u < 3) return t3 - (t3 - s) % 4;
          const d = new Float32Array(2 * u);
          let f = o;
          for (let e4 = 0; e4 < u; e4++, f += 4) {
            const t4 = n2[f];
            d[e4 << 1] = t4[4];
            d[1 + (e4 << 1)] = t4[5];
          }
          const g = [c, l, h, d];
          a3.splice(s, 4 * u, r.OPS.paintImageXObjectRepeat);
          n2.splice(s, 4 * u, g);
          return s + 1;
        });
        addState(n, [r.OPS.beginText, r.OPS.setFont, r.OPS.setTextMatrix, r.OPS.showText, r.OPS.endText], null, function iterateShowTextGroup(e3, t3) {
          const a3 = e3.fnArray, n2 = e3.argsArray, i = (t3 - (e3.iCurr - 4)) % 5;
          switch (i) {
            case 0:
              return a3[t3] === r.OPS.beginText;
            case 1:
              return a3[t3] === r.OPS.setFont;
            case 2:
              return a3[t3] === r.OPS.setTextMatrix;
            case 3:
              if (a3[t3] !== r.OPS.showText) return false;
              const i2 = e3.iCurr - 3, s = n2[i2][0], o = n2[i2][1];
              return n2[t3][0] === s && n2[t3][1] === o;
            case 4:
              return a3[t3] === r.OPS.endText;
          }
          throw new Error(`iterateShowTextGroup - invalid pos: ${i}`);
        }, function(e3, t3) {
          const a3 = e3.fnArray, r2 = e3.argsArray, n2 = e3.iCurr, i = n2 - 4, s = n2 - 3, o = n2 - 2, c = n2 - 1, l = n2, h = r2[s][0], u = r2[s][1];
          let d = Math.min(Math.floor((t3 - i) / 5), 1e3);
          if (d < 3) return t3 - (t3 - i) % 5;
          let f = i;
          if (i >= 4 && a3[i - 4] === a3[s] && a3[i - 3] === a3[o] && a3[i - 2] === a3[c] && a3[i - 1] === a3[l] && r2[i - 4][0] === h && r2[i - 4][1] === u) {
            d++;
            f -= 5;
          }
          let g = f + 4;
          for (let e4 = 1; e4 < d; e4++) {
            a3.splice(g, 3);
            r2.splice(g, 3);
            g += 2;
          }
          return g + 1;
        });
        class NullOptimizer {
          constructor(e3) {
            this.queue = e3;
          }
          _optimize() {
          }
          push(e3, t3) {
            this.queue.fnArray.push(e3);
            this.queue.argsArray.push(t3);
            this._optimize();
          }
          flush() {
          }
          reset() {
          }
        }
        class QueueOptimizer extends NullOptimizer {
          constructor(e3) {
            super(e3);
            this.state = null;
            this.context = { iCurr: 0, fnArray: e3.fnArray, argsArray: e3.argsArray, isOffscreenCanvasSupported: false };
            this.match = null;
            this.lastProcessed = 0;
          }
          set isOffscreenCanvasSupported(e3) {
            this.context.isOffscreenCanvasSupported = e3;
          }
          _optimize() {
            const e3 = this.queue.fnArray;
            let t3 = this.lastProcessed, a3 = e3.length, r2 = this.state, i = this.match;
            if (!r2 && !i && t3 + 1 === a3 && !n[e3[t3]]) {
              this.lastProcessed = a3;
              return;
            }
            const s = this.context;
            for (; t3 < a3; ) {
              if (i) {
                if ((0, i.iterateFn)(s, t3)) {
                  t3++;
                  continue;
                }
                t3 = (0, i.processFn)(s, t3 + 1);
                a3 = e3.length;
                i = null;
                r2 = null;
                if (t3 >= a3) break;
              }
              r2 = (r2 || n)[e3[t3]];
              if (r2 && !Array.isArray(r2)) {
                s.iCurr = t3;
                t3++;
                if (!r2.checkFn || (0, r2.checkFn)(s)) {
                  i = r2;
                  r2 = null;
                } else r2 = null;
              } else t3++;
            }
            this.state = r2;
            this.match = i;
            this.lastProcessed = t3;
          }
          flush() {
            for (; this.match; ) {
              const e3 = this.queue.fnArray.length;
              this.lastProcessed = (0, this.match.processFn)(this.context, e3);
              this.match = null;
              this.state = null;
              this._optimize();
            }
          }
          reset() {
            this.state = null;
            this.match = null;
            this.lastProcessed = 0;
          }
        }
        const _OperatorList = class _OperatorList {
          constructor(e3 = 0, t3) {
            this._streamSink = t3;
            this.fnArray = [];
            this.argsArray = [];
            this.optimizer = !t3 || e3 & r.RenderingIntentFlag.OPLIST ? new NullOptimizer(this) : new QueueOptimizer(this);
            this.dependencies = /* @__PURE__ */ new Set();
            this._totalLength = 0;
            this.weight = 0;
            this._resolved = t3 ? null : Promise.resolve();
          }
          set isOffscreenCanvasSupported(e3) {
            this.optimizer.isOffscreenCanvasSupported = e3;
          }
          get length() {
            return this.argsArray.length;
          }
          get ready() {
            return this._resolved || this._streamSink.ready;
          }
          get totalLength() {
            return this._totalLength + this.length;
          }
          addOp(e3, t3) {
            this.optimizer.push(e3, t3);
            this.weight++;
            this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e3 === r.OPS.restore || e3 === r.OPS.endText)) && this.flush();
          }
          addImageOps(e3, t3, a3) {
            void 0 !== a3 && this.addOp(r.OPS.beginMarkedContentProps, ["OC", a3]);
            this.addOp(e3, t3);
            void 0 !== a3 && this.addOp(r.OPS.endMarkedContent, []);
          }
          addDependency(e3) {
            if (!this.dependencies.has(e3)) {
              this.dependencies.add(e3);
              this.addOp(r.OPS.dependency, [e3]);
            }
          }
          addDependencies(e3) {
            for (const t3 of e3) this.addDependency(t3);
          }
          addOpList(e3) {
            if (e3 instanceof _OperatorList) {
              for (const t3 of e3.dependencies) this.dependencies.add(t3);
              for (let t3 = 0, a3 = e3.length; t3 < a3; t3++) this.addOp(e3.fnArray[t3], e3.argsArray[t3]);
            } else (0, r.warn)('addOpList - ignoring invalid "opList" parameter.');
          }
          getIR() {
            return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
          }
          get _transfers() {
            var _a;
            const e3 = [], { fnArray: t3, argsArray: a3, length: n2 } = this;
            for (let i = 0; i < n2; i++) switch (t3[i]) {
              case r.OPS.paintInlineImageXObject:
              case r.OPS.paintInlineImageXObjectGroup:
              case r.OPS.paintImageMaskXObject:
                const t4 = a3[i][0];
                !t4.cached && ((_a = t4.data) == null ? void 0 : _a.buffer) instanceof ArrayBuffer && e3.push(t4.data.buffer);
            }
            return e3;
          }
          flush(e3 = false, t3 = null) {
            this.optimizer.flush();
            const a3 = this.length;
            this._totalLength += a3;
            this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e3, separateAnnots: t3, length: a3 }, 1, this._transfers);
            this.dependencies.clear();
            this.fnArray.length = 0;
            this.argsArray.length = 0;
            this.weight = 0;
            this.optimizer.reset();
          }
        };
        __publicField(_OperatorList, "CHUNK_SIZE", 1e3);
        __publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
        let OperatorList = _OperatorList;
        t2.OperatorList = OperatorList;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PDFImage = void 0;
        var r = a2(2), n = a2(28), i = a2(5), s = a2(12), o = a2(18), c = a2(62), l = a2(26), h = a2(30), u = a2(4);
        function decodeAndClamp(e3, t3, a3, r2) {
          (e3 = t3 + e3 * a3) < 0 ? e3 = 0 : e3 > r2 && (e3 = r2);
          return e3;
        }
        function resizeImageMask(e3, t3, a3, r2, n2, i2) {
          const s2 = n2 * i2;
          let o2;
          o2 = t3 <= 8 ? new Uint8Array(s2) : t3 <= 16 ? new Uint16Array(s2) : new Uint32Array(s2);
          const c2 = a3 / n2, l2 = r2 / i2;
          let h2, u2, d, f, g = 0;
          const p = new Uint16Array(n2), m = a3;
          for (h2 = 0; h2 < n2; h2++) p[h2] = Math.floor(h2 * c2);
          for (h2 = 0; h2 < i2; h2++) {
            d = Math.floor(h2 * l2) * m;
            for (u2 = 0; u2 < n2; u2++) {
              f = d + p[u2];
              o2[g++] = e3[f];
            }
          }
          return o2;
        }
        class PDFImage {
          constructor({ xref: e3, res: t3, image: a3, isInline: n2 = false, smask: o2 = null, mask: c2 = null, isMask: l2 = false, pdfFunctionFactory: d, localColorSpaceCache: f }) {
            var _a;
            this.image = a3;
            const g = a3.dict, p = g.get("F", "Filter");
            let m;
            if (p instanceof u.Name) m = p.name;
            else if (Array.isArray(p)) {
              const t4 = e3.fetchIfRef(p[0]);
              t4 instanceof u.Name && (m = t4.name);
            }
            switch (m) {
              case "JPXDecode":
                const e4 = new h.JpxImage();
                e4.parseImageProperties(a3.stream);
                a3.stream.reset();
                a3.width = e4.width;
                a3.height = e4.height;
                a3.bitsPerComponent = e4.bitsPerComponent;
                a3.numComps = e4.componentsCount;
                break;
              case "JBIG2Decode":
                a3.bitsPerComponent = 1;
                a3.numComps = 1;
            }
            let b = g.get("W", "Width"), y = g.get("H", "Height");
            if (Number.isInteger(a3.width) && a3.width > 0 && Number.isInteger(a3.height) && a3.height > 0 && (a3.width !== b || a3.height !== y)) {
              (0, r.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
              b = a3.width;
              y = a3.height;
            }
            if (b < 1 || y < 1) throw new r.FormatError(`Invalid image width: ${b} or height: ${y}`);
            this.width = b;
            this.height = y;
            this.interpolate = g.get("I", "Interpolate");
            this.imageMask = g.get("IM", "ImageMask") || false;
            this.matte = g.get("Matte") || false;
            let w = a3.bitsPerComponent;
            if (!w) {
              w = g.get("BPC", "BitsPerComponent");
              if (!w) {
                if (!this.imageMask) throw new r.FormatError(`Bits per component missing in image: ${this.imageMask}`);
                w = 1;
              }
            }
            this.bpc = w;
            if (!this.imageMask) {
              let i2 = g.getRaw("CS") || g.getRaw("ColorSpace");
              if (!i2) {
                (0, r.info)("JPX images (which do not require color spaces)");
                switch (a3.numComps) {
                  case 1:
                    i2 = u.Name.get("DeviceGray");
                    break;
                  case 3:
                    i2 = u.Name.get("DeviceRGB");
                    break;
                  case 4:
                    i2 = u.Name.get("DeviceCMYK");
                    break;
                  default:
                    throw new Error(`JPX images with ${a3.numComps} color components not supported.`);
                }
              }
              this.colorSpace = s.ColorSpace.parse({ cs: i2, xref: e3, resources: n2 ? t3 : null, pdfFunctionFactory: d, localColorSpaceCache: f });
              this.numComps = this.colorSpace.numComps;
            }
            this.decode = g.getArray("D", "Decode");
            this.needsDecode = false;
            if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, w) || l2 && !s.ColorSpace.isDefaultDecode(this.decode, 1))) {
              this.needsDecode = true;
              const e4 = (1 << w) - 1;
              this.decodeCoefficients = [];
              this.decodeAddends = [];
              const t4 = "Indexed" === ((_a = this.colorSpace) == null ? void 0 : _a.name);
              for (let a4 = 0, r2 = 0; a4 < this.decode.length; a4 += 2, ++r2) {
                const n3 = this.decode[a4], i2 = this.decode[a4 + 1];
                this.decodeCoefficients[r2] = t4 ? (i2 - n3) / e4 : i2 - n3;
                this.decodeAddends[r2] = t4 ? n3 : e4 * n3;
              }
            }
            if (o2) this.smask = new PDFImage({ xref: e3, res: t3, image: o2, isInline: n2, pdfFunctionFactory: d, localColorSpaceCache: f });
            else if (c2) if (c2 instanceof i.BaseStream) {
              c2.dict.get("IM", "ImageMask") ? this.mask = new PDFImage({ xref: e3, res: t3, image: c2, isInline: n2, isMask: true, pdfFunctionFactory: d, localColorSpaceCache: f }) : (0, r.warn)("Ignoring /Mask in image without /ImageMask.");
            } else this.mask = c2;
          }
          static async buildImage({ xref: e3, res: t3, image: a3, isInline: n2 = false, pdfFunctionFactory: s2, localColorSpaceCache: o2 }) {
            const c2 = a3;
            let l2 = null, h2 = null;
            const u2 = a3.dict.get("SMask"), d = a3.dict.get("Mask");
            u2 ? u2 instanceof i.BaseStream ? l2 = u2 : (0, r.warn)("Unsupported /SMask format.") : d && (d instanceof i.BaseStream || Array.isArray(d) ? h2 = d : (0, r.warn)("Unsupported /Mask format."));
            return new PDFImage({ xref: e3, res: t3, image: c2, isInline: n2, smask: l2, mask: h2, pdfFunctionFactory: s2, localColorSpaceCache: o2 });
          }
          static createRawMask({ imgArray: e3, width: t3, height: a3, imageIsFromDecodeStream: r2, inverseDecode: n2, interpolate: i2 }) {
            const s2 = (t3 + 7 >> 3) * a3, o2 = e3.byteLength;
            let c2, l2;
            if (!r2 || n2 && !(s2 === o2)) if (n2) {
              c2 = new Uint8Array(s2);
              c2.set(e3);
              c2.fill(255, o2);
            } else c2 = new Uint8Array(e3);
            else c2 = e3;
            if (n2) for (l2 = 0; l2 < o2; l2++) c2[l2] ^= 255;
            return { data: c2, width: t3, height: a3, interpolate: i2 };
          }
          static async createMask({ imgArray: e3, width: t3, height: a3, imageIsFromDecodeStream: i2, inverseDecode: s2, interpolate: o2, isOffscreenCanvasSupported: l2 = false }) {
            const h2 = 1 === t3 && 1 === a3 && s2 === (0 === e3.length || !!(128 & e3[0]));
            if (h2) return { isSingleOpaquePixel: h2 };
            if (l2) {
              if (c.ImageResizer.needsToBeResized(t3, a3)) {
                const i4 = new Uint8ClampedArray(t3 * a3 * 4);
                (0, n.convertBlackAndWhiteToRGBA)({ src: e3, dest: i4, width: t3, height: a3, nonBlackColor: 0, inverseDecode: s2 });
                return c.ImageResizer.createImage({ kind: r.ImageKind.RGBA_32BPP, data: i4, width: t3, height: a3, interpolate: o2 });
              }
              const i3 = new OffscreenCanvas(t3, a3), l3 = i3.getContext("2d"), h3 = l3.createImageData(t3, a3);
              (0, n.convertBlackAndWhiteToRGBA)({ src: e3, dest: h3.data, width: t3, height: a3, nonBlackColor: 0, inverseDecode: s2 });
              l3.putImageData(h3, 0, 0);
              return { data: null, width: t3, height: a3, interpolate: o2, bitmap: i3.transferToImageBitmap() };
            }
            return this.createRawMask({ imgArray: e3, width: t3, height: a3, inverseDecode: s2, imageIsFromDecodeStream: i2, interpolate: o2 });
          }
          get drawWidth() {
            var _a, _b;
            return Math.max(this.width, ((_a = this.smask) == null ? void 0 : _a.width) || 0, ((_b = this.mask) == null ? void 0 : _b.width) || 0);
          }
          get drawHeight() {
            var _a, _b;
            return Math.max(this.height, ((_a = this.smask) == null ? void 0 : _a.height) || 0, ((_b = this.mask) == null ? void 0 : _b.height) || 0);
          }
          decodeBuffer(e3) {
            const t3 = this.bpc, a3 = this.numComps, r2 = this.decodeAddends, n2 = this.decodeCoefficients, i2 = (1 << t3) - 1;
            let s2, o2;
            if (1 === t3) {
              for (s2 = 0, o2 = e3.length; s2 < o2; s2++) e3[s2] = +!e3[s2];
              return;
            }
            let c2 = 0;
            for (s2 = 0, o2 = this.width * this.height; s2 < o2; s2++) for (let t4 = 0; t4 < a3; t4++) {
              e3[c2] = decodeAndClamp(e3[c2], r2[t4], n2[t4], i2);
              c2++;
            }
          }
          getComponents(e3) {
            const t3 = this.bpc;
            if (8 === t3) return e3;
            const a3 = this.width, r2 = this.height, n2 = this.numComps, i2 = a3 * r2 * n2;
            let s2, o2 = 0;
            s2 = t3 <= 8 ? new Uint8Array(i2) : t3 <= 16 ? new Uint16Array(i2) : new Uint32Array(i2);
            const c2 = a3 * n2, l2 = (1 << t3) - 1;
            let h2, u2, d = 0;
            if (1 === t3) {
              let t4, a4, n3;
              for (let i3 = 0; i3 < r2; i3++) {
                a4 = d + (-8 & c2);
                n3 = d + c2;
                for (; d < a4; ) {
                  u2 = e3[o2++];
                  s2[d] = u2 >> 7 & 1;
                  s2[d + 1] = u2 >> 6 & 1;
                  s2[d + 2] = u2 >> 5 & 1;
                  s2[d + 3] = u2 >> 4 & 1;
                  s2[d + 4] = u2 >> 3 & 1;
                  s2[d + 5] = u2 >> 2 & 1;
                  s2[d + 6] = u2 >> 1 & 1;
                  s2[d + 7] = 1 & u2;
                  d += 8;
                }
                if (d < n3) {
                  u2 = e3[o2++];
                  t4 = 128;
                  for (; d < n3; ) {
                    s2[d++] = +!!(u2 & t4);
                    t4 >>= 1;
                  }
                }
              }
            } else {
              let a4 = 0;
              u2 = 0;
              for (d = 0, h2 = i2; d < h2; ++d) {
                if (d % c2 == 0) {
                  u2 = 0;
                  a4 = 0;
                }
                for (; a4 < t3; ) {
                  u2 = u2 << 8 | e3[o2++];
                  a4 += 8;
                }
                const r3 = a4 - t3;
                let n3 = u2 >> r3;
                n3 < 0 ? n3 = 0 : n3 > l2 && (n3 = l2);
                s2[d] = n3;
                u2 &= (1 << r3) - 1;
                a4 = r3;
              }
            }
            return s2;
          }
          fillOpacity(e3, t3, a3, n2, i2) {
            const s2 = this.smask, o2 = this.mask;
            let c2, l2, h2, u2, d, f;
            if (s2) {
              l2 = s2.width;
              h2 = s2.height;
              c2 = new Uint8ClampedArray(l2 * h2);
              s2.fillGrayBuffer(c2);
              l2 === t3 && h2 === a3 || (c2 = resizeImageMask(c2, s2.bpc, l2, h2, t3, a3));
            } else if (o2) if (o2 instanceof PDFImage) {
              l2 = o2.width;
              h2 = o2.height;
              c2 = new Uint8ClampedArray(l2 * h2);
              o2.numComps = 1;
              o2.fillGrayBuffer(c2);
              for (u2 = 0, d = l2 * h2; u2 < d; ++u2) c2[u2] = 255 - c2[u2];
              l2 === t3 && h2 === a3 || (c2 = resizeImageMask(c2, o2.bpc, l2, h2, t3, a3));
            } else {
              if (!Array.isArray(o2)) throw new r.FormatError("Unknown mask format.");
              {
                c2 = new Uint8ClampedArray(t3 * a3);
                const e4 = this.numComps;
                for (u2 = 0, d = t3 * a3; u2 < d; ++u2) {
                  let t4 = 0;
                  const a4 = u2 * e4;
                  for (f = 0; f < e4; ++f) {
                    const e5 = i2[a4 + f], r2 = 2 * f;
                    if (e5 < o2[r2] || e5 > o2[r2 + 1]) {
                      t4 = 255;
                      break;
                    }
                  }
                  c2[u2] = t4;
                }
              }
            }
            if (c2) for (u2 = 0, f = 3, d = t3 * n2; u2 < d; ++u2, f += 4) e3[f] = c2[u2];
            else for (u2 = 0, f = 3, d = t3 * n2; u2 < d; ++u2, f += 4) e3[f] = 255;
          }
          undoPreblend(e3, t3, a3) {
            var _a;
            const r2 = (_a = this.smask) == null ? void 0 : _a.matte;
            if (!r2) return;
            const n2 = this.colorSpace.getRgb(r2, 0), i2 = n2[0], s2 = n2[1], o2 = n2[2], c2 = t3 * a3 * 4;
            for (let t4 = 0; t4 < c2; t4 += 4) {
              const a4 = e3[t4 + 3];
              if (0 === a4) {
                e3[t4] = 255;
                e3[t4 + 1] = 255;
                e3[t4 + 2] = 255;
                continue;
              }
              const r3 = 255 / a4;
              e3[t4] = (e3[t4] - i2) * r3 + i2;
              e3[t4 + 1] = (e3[t4 + 1] - s2) * r3 + s2;
              e3[t4 + 2] = (e3[t4 + 2] - o2) * r3 + o2;
            }
          }
          async createImageData(e3 = false, t3 = false) {
            const a3 = this.drawWidth, n2 = this.drawHeight, i2 = { width: a3, height: n2, interpolate: this.interpolate, kind: 0, data: null }, s2 = this.numComps, o2 = this.width, h2 = this.height, u2 = this.bpc, d = o2 * s2 * u2 + 7 >> 3, f = t3 && c.ImageResizer.needsToBeResized(a3, n2);
            if (!e3) {
              let e4;
              "DeviceGray" === this.colorSpace.name && 1 === u2 ? e4 = r.ImageKind.GRAYSCALE_1BPP : "DeviceRGB" !== this.colorSpace.name || 8 !== u2 || this.needsDecode || (e4 = r.ImageKind.RGB_24BPP);
              if (e4 && !this.smask && !this.mask && a3 === o2 && n2 === h2) {
                const s3 = this.getImageBytes(h2 * d, {});
                if (t3) return f ? c.ImageResizer.createImage({ data: s3, kind: e4, width: a3, height: n2, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e4, o2, h2, s3);
                i2.kind = e4;
                i2.data = s3;
                if (this.needsDecode) {
                  (0, r.assert)(e4 === r.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                  const t4 = i2.data;
                  for (let e5 = 0, a4 = t4.length; e5 < a4; e5++) t4[e5] ^= 255;
                }
                return i2;
              }
              if (this.image instanceof l.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                let e5 = h2 * d;
                if (t3 && !f) {
                  let t4 = false;
                  switch (this.colorSpace.name) {
                    case "DeviceGray":
                      e5 *= 4;
                      t4 = true;
                      break;
                    case "DeviceRGB":
                      e5 = e5 / 3 * 4;
                      t4 = true;
                      break;
                    case "DeviceCMYK":
                      t4 = true;
                  }
                  if (t4) {
                    const t5 = this.getImageBytes(e5, { drawWidth: a3, drawHeight: n2, forceRGBA: true });
                    return this.createBitmap(r.ImageKind.RGBA_32BPP, a3, n2, t5);
                  }
                } else switch (this.colorSpace.name) {
                  case "DeviceGray":
                    e5 *= 3;
                  case "DeviceRGB":
                  case "DeviceCMYK":
                    i2.kind = r.ImageKind.RGB_24BPP;
                    i2.data = this.getImageBytes(e5, { drawWidth: a3, drawHeight: n2, forceRGB: true });
                    return f ? c.ImageResizer.createImage(i2) : i2;
                }
              }
            }
            const g = this.getImageBytes(h2 * d, { internal: true }), p = 0 | g.length / d * n2 / h2, m = this.getComponents(g);
            let b, y, w, S, x, C;
            if (t3 && !f) {
              w = new OffscreenCanvas(a3, n2);
              S = w.getContext("2d");
              x = S.createImageData(a3, n2);
              C = x.data;
            }
            i2.kind = r.ImageKind.RGBA_32BPP;
            if (e3 || this.smask || this.mask) {
              t3 && !f || (C = new Uint8ClampedArray(a3 * n2 * 4));
              b = 1;
              y = true;
              this.fillOpacity(C, a3, n2, p, m);
            } else {
              if (!t3 || f) {
                i2.kind = r.ImageKind.RGB_24BPP;
                C = new Uint8ClampedArray(a3 * n2 * 3);
                b = 0;
              } else {
                new Uint32Array(C.buffer).fill(r.FeatureTest.isLittleEndian ? 4278190080 : 255);
                b = 1;
              }
              y = false;
            }
            this.needsDecode && this.decodeBuffer(m);
            this.colorSpace.fillRgb(C, o2, h2, a3, n2, p, u2, m, b);
            y && this.undoPreblend(C, a3, p);
            if (t3 && !f) {
              S.putImageData(x, 0, 0);
              return { data: null, width: a3, height: n2, bitmap: w.transferToImageBitmap(), interpolate: this.interpolate };
            }
            i2.data = C;
            return f ? c.ImageResizer.createImage(i2) : i2;
          }
          fillGrayBuffer(e3) {
            const t3 = this.numComps;
            if (1 !== t3) throw new r.FormatError(`Reading gray scale from a color image: ${t3}`);
            const a3 = this.width, n2 = this.height, i2 = this.bpc, s2 = a3 * t3 * i2 + 7 >> 3, o2 = this.getImageBytes(n2 * s2, { internal: true }), c2 = this.getComponents(o2);
            let l2, h2;
            if (1 === i2) {
              h2 = a3 * n2;
              if (this.needsDecode) for (l2 = 0; l2 < h2; ++l2) e3[l2] = c2[l2] - 1 & 255;
              else for (l2 = 0; l2 < h2; ++l2) e3[l2] = 255 & -c2[l2];
              return;
            }
            this.needsDecode && this.decodeBuffer(c2);
            h2 = a3 * n2;
            const u2 = 255 / ((1 << i2) - 1);
            for (l2 = 0; l2 < h2; ++l2) e3[l2] = u2 * c2[l2];
          }
          createBitmap(e3, t3, a3, i2) {
            const s2 = new OffscreenCanvas(t3, a3), o2 = s2.getContext("2d");
            let c2;
            if (e3 === r.ImageKind.RGBA_32BPP) c2 = new ImageData(i2, t3, a3);
            else {
              c2 = o2.createImageData(t3, a3);
              (0, n.convertToRGBA)({ kind: e3, src: i2, dest: new Uint32Array(c2.data.buffer), width: t3, height: a3, inverseDecode: this.needsDecode });
            }
            o2.putImageData(c2, 0, 0);
            return { data: null, width: t3, height: a3, bitmap: s2.transferToImageBitmap(), interpolate: this.interpolate };
          }
          getImageBytes(e3, { drawWidth: t3, drawHeight: a3, forceRGBA: n2 = false, forceRGB: i2 = false, internal: s2 = false }) {
            this.image.reset();
            this.image.drawWidth = t3 || this.width;
            this.image.drawHeight = a3 || this.height;
            this.image.forceRGBA = !!n2;
            this.image.forceRGB = !!i2;
            const c2 = this.image.getBytes(e3);
            if (s2 || this.image instanceof o.DecodeStream) return c2;
            (0, r.assert)(c2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
            return new Uint8Array(c2);
          }
        }
        t2.PDFImage = PDFImage;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Catalog = void 0;
        var r = a2(3), n = a2(2), i = a2(4), s = a2(67), o = a2(5), c = a2(68), l = a2(12), h = a2(69), u = a2(59), d = a2(70), f = a2(72);
        function fetchDestination(e3) {
          e3 instanceof i.Dict && (e3 = e3.get("D"));
          return Array.isArray(e3) ? e3 : null;
        }
        class Catalog {
          constructor(e3, t3) {
            this.pdfManager = e3;
            this.xref = t3;
            this._catDict = t3.getCatalogObj();
            if (!(this._catDict instanceof i.Dict)) throw new n.FormatError("Catalog object is not a dictionary.");
            this.toplevelPagesDict;
            this._actualNumPages = null;
            this.fontCache = new i.RefSetCache();
            this.builtInCMapCache = /* @__PURE__ */ new Map();
            this.standardFontDataCache = /* @__PURE__ */ new Map();
            this.globalImageCache = new u.GlobalImageCache();
            this.pageKidsCountCache = new i.RefSetCache();
            this.pageIndexCache = new i.RefSetCache();
            this.nonBlendModesSet = new i.RefSet();
            this.systemFontCache = /* @__PURE__ */ new Map();
          }
          cloneDict() {
            return this._catDict.clone();
          }
          get version() {
            const e3 = this._catDict.get("Version");
            if (e3 instanceof i.Name) {
              if (r.PDF_VERSION_REGEXP.test(e3.name)) return (0, n.shadow)(this, "version", e3.name);
              (0, n.warn)(`Invalid PDF catalog version: ${e3.name}`);
            }
            return (0, n.shadow)(this, "version", null);
          }
          get lang() {
            const e3 = this._catDict.get("Lang");
            return (0, n.shadow)(this, "lang", "string" == typeof e3 ? (0, n.stringToPDFString)(e3) : null);
          }
          get needsRendering() {
            const e3 = this._catDict.get("NeedsRendering");
            return (0, n.shadow)(this, "needsRendering", "boolean" == typeof e3 && e3);
          }
          get collection() {
            let e3 = null;
            try {
              const t3 = this._catDict.get("Collection");
              t3 instanceof i.Dict && t3.size > 0 && (e3 = t3);
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.info)("Cannot fetch Collection entry; assuming no collection is present.");
            }
            return (0, n.shadow)(this, "collection", e3);
          }
          get acroForm() {
            let e3 = null;
            try {
              const t3 = this._catDict.get("AcroForm");
              t3 instanceof i.Dict && t3.size > 0 && (e3 = t3);
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
            }
            return (0, n.shadow)(this, "acroForm", e3);
          }
          get acroFormRef() {
            const e3 = this._catDict.getRaw("AcroForm");
            return (0, n.shadow)(this, "acroFormRef", e3 instanceof i.Ref ? e3 : null);
          }
          get metadata() {
            var _a;
            const e3 = this._catDict.getRaw("Metadata");
            if (!(e3 instanceof i.Ref)) return (0, n.shadow)(this, "metadata", null);
            let t3 = null;
            try {
              const a3 = this.xref.fetch(e3, !((_a = this.xref.encrypt) == null ? void 0 : _a.encryptMetadata));
              if (a3 instanceof o.BaseStream && a3.dict instanceof i.Dict) {
                const e4 = a3.dict.get("Type"), r2 = a3.dict.get("Subtype");
                if ((0, i.isName)(e4, "Metadata") && (0, i.isName)(r2, "XML")) {
                  const e5 = (0, n.stringToUTF8String)(a3.getString());
                  e5 && (t3 = new d.MetadataParser(e5).serializable);
                }
              }
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.info)(`Skipping invalid Metadata: "${e4}".`);
            }
            return (0, n.shadow)(this, "metadata", t3);
          }
          get markInfo() {
            let e3 = null;
            try {
              e3 = this._readMarkInfo();
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)("Unable to read mark info.");
            }
            return (0, n.shadow)(this, "markInfo", e3);
          }
          _readMarkInfo() {
            const e3 = this._catDict.get("MarkInfo");
            if (!(e3 instanceof i.Dict)) return null;
            const t3 = { Marked: false, UserProperties: false, Suspects: false };
            for (const a3 in t3) {
              const r2 = e3.get(a3);
              "boolean" == typeof r2 && (t3[a3] = r2);
            }
            return t3;
          }
          get structTreeRoot() {
            let e3 = null;
            try {
              e3 = this._readStructTreeRoot();
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)("Unable read to structTreeRoot info.");
            }
            return (0, n.shadow)(this, "structTreeRoot", e3);
          }
          _readStructTreeRoot() {
            const e3 = this._catDict.getRaw("StructTreeRoot"), t3 = this.xref.fetchIfRef(e3);
            if (!(t3 instanceof i.Dict)) return null;
            const a3 = new f.StructTreeRoot(t3, e3);
            a3.init();
            return a3;
          }
          get toplevelPagesDict() {
            const e3 = this._catDict.get("Pages");
            if (!(e3 instanceof i.Dict)) throw new n.FormatError("Invalid top-level pages dictionary.");
            return (0, n.shadow)(this, "toplevelPagesDict", e3);
          }
          get documentOutline() {
            let e3 = null;
            try {
              e3 = this._readDocumentOutline();
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)("Unable to read document outline.");
            }
            return (0, n.shadow)(this, "documentOutline", e3);
          }
          _readDocumentOutline() {
            let e3 = this._catDict.get("Outlines");
            if (!(e3 instanceof i.Dict)) return null;
            e3 = e3.getRaw("First");
            if (!(e3 instanceof i.Ref)) return null;
            const t3 = { items: [] }, a3 = [{ obj: e3, parent: t3 }], r2 = new i.RefSet();
            r2.put(e3);
            const s2 = this.xref, o2 = new Uint8ClampedArray(3);
            for (; a3.length > 0; ) {
              const t4 = a3.shift(), c2 = s2.fetchIfRef(t4.obj);
              if (null === c2) continue;
              if (!c2.has("Title")) throw new n.FormatError("Invalid outline item encountered.");
              const h2 = { url: null, dest: null, action: null };
              Catalog.parseDestDictionary({ destDict: c2, resultObj: h2, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
              const u2 = c2.get("Title"), d2 = c2.get("F") || 0, f2 = c2.getArray("C"), g = c2.get("Count");
              let p = o2;
              !Array.isArray(f2) || 3 !== f2.length || 0 === f2[0] && 0 === f2[1] && 0 === f2[2] || (p = l.ColorSpace.singletons.rgb.getRgb(f2, 0));
              const m = { action: h2.action, attachment: h2.attachment, dest: h2.dest, url: h2.url, unsafeUrl: h2.unsafeUrl, newWindow: h2.newWindow, setOCGState: h2.setOCGState, title: (0, n.stringToPDFString)(u2), color: p, count: Number.isInteger(g) ? g : void 0, bold: !!(2 & d2), italic: !!(1 & d2), items: [] };
              t4.parent.items.push(m);
              e3 = c2.getRaw("First");
              if (e3 instanceof i.Ref && !r2.has(e3)) {
                a3.push({ obj: e3, parent: m });
                r2.put(e3);
              }
              e3 = c2.getRaw("Next");
              if (e3 instanceof i.Ref && !r2.has(e3)) {
                a3.push({ obj: e3, parent: t4.parent });
                r2.put(e3);
              }
            }
            return t3.items.length > 0 ? t3.items : null;
          }
          get permissions() {
            let e3 = null;
            try {
              e3 = this._readPermissions();
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)("Unable to read permissions.");
            }
            return (0, n.shadow)(this, "permissions", e3);
          }
          _readPermissions() {
            const e3 = this.xref.trailer.get("Encrypt");
            if (!(e3 instanceof i.Dict)) return null;
            let t3 = e3.get("P");
            if ("number" != typeof t3) return null;
            t3 += 2 ** 32;
            const a3 = [];
            for (const e4 in n.PermissionFlag) {
              const r2 = n.PermissionFlag[e4];
              t3 & r2 && a3.push(r2);
            }
            return a3;
          }
          get optionalContentConfig() {
            let e3 = null;
            try {
              const t3 = this._catDict.get("OCProperties");
              if (!t3) return (0, n.shadow)(this, "optionalContentConfig", null);
              const a3 = t3.get("D");
              if (!a3) return (0, n.shadow)(this, "optionalContentConfig", null);
              const r2 = t3.get("OCGs");
              if (!Array.isArray(r2)) return (0, n.shadow)(this, "optionalContentConfig", null);
              const s2 = [], o2 = [];
              for (const e4 of r2) {
                if (!(e4 instanceof i.Ref)) continue;
                o2.push(e4);
                const t4 = this.xref.fetchIfRef(e4);
                s2.push({ id: e4.toString(), name: "string" == typeof t4.get("Name") ? (0, n.stringToPDFString)(t4.get("Name")) : null, intent: "string" == typeof t4.get("Intent") ? (0, n.stringToPDFString)(t4.get("Intent")) : null });
              }
              e3 = this._readOptionalContentConfig(a3, o2);
              e3.groups = s2;
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)(`Unable to read optional content config: ${e4}`);
            }
            return (0, n.shadow)(this, "optionalContentConfig", e3);
          }
          _readOptionalContentConfig(e3, t3) {
            function parseOnOff(e4) {
              const a4 = [];
              if (Array.isArray(e4)) for (const r3 of e4) r3 instanceof i.Ref && t3.includes(r3) && a4.push(r3.toString());
              return a4;
            }
            function parseOrder(e4, a4 = 0) {
              if (!Array.isArray(e4)) return null;
              const n2 = [];
              for (const s4 of e4) {
                if (s4 instanceof i.Ref && t3.includes(s4)) {
                  r2.put(s4);
                  n2.push(s4.toString());
                  continue;
                }
                const e5 = parseNestedOrder(s4, a4);
                e5 && n2.push(e5);
              }
              if (a4 > 0) return n2;
              const s3 = [];
              for (const e5 of t3) r2.has(e5) || s3.push(e5.toString());
              s3.length && n2.push({ name: null, order: s3 });
              return n2;
            }
            function parseNestedOrder(e4, t4) {
              if (++t4 > s2) {
                (0, n.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS.");
                return null;
              }
              const r3 = a3.fetchIfRef(e4);
              if (!Array.isArray(r3)) return null;
              const i2 = a3.fetchIfRef(r3[0]);
              if ("string" != typeof i2) return null;
              const o2 = parseOrder(r3.slice(1), t4);
              return o2 && o2.length ? { name: (0, n.stringToPDFString)(i2), order: o2 } : null;
            }
            const a3 = this.xref, r2 = new i.RefSet(), s2 = 10;
            return { name: "string" == typeof e3.get("Name") ? (0, n.stringToPDFString)(e3.get("Name")) : null, creator: "string" == typeof e3.get("Creator") ? (0, n.stringToPDFString)(e3.get("Creator")) : null, baseState: e3.get("BaseState") instanceof i.Name ? e3.get("BaseState").name : null, on: parseOnOff(e3.get("ON")), off: parseOnOff(e3.get("OFF")), order: parseOrder(e3.get("Order")), groups: null };
          }
          setActualNumPages(e3 = null) {
            this._actualNumPages = e3;
          }
          get hasActualNumPages() {
            return null !== this._actualNumPages;
          }
          get _pagesCount() {
            const e3 = this.toplevelPagesDict.get("Count");
            if (!Number.isInteger(e3)) throw new n.FormatError("Page count in top-level pages dictionary is not an integer.");
            return (0, n.shadow)(this, "_pagesCount", e3);
          }
          get numPages() {
            return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
          }
          get destinations() {
            const e3 = this._readDests(), t3 = /* @__PURE__ */ Object.create(null);
            if (e3 instanceof s.NameTree) for (const [a3, r2] of e3.getAll()) {
              const e4 = fetchDestination(r2);
              e4 && (t3[(0, n.stringToPDFString)(a3)] = e4);
            }
            else e3 instanceof i.Dict && e3.forEach(function(e4, a3) {
              const r2 = fetchDestination(a3);
              r2 && (t3[e4] = r2);
            });
            return (0, n.shadow)(this, "destinations", t3);
          }
          getDestination(e3) {
            const t3 = this._readDests();
            if (t3 instanceof s.NameTree) {
              const a3 = fetchDestination(t3.get(e3));
              if (a3) return a3;
              const r2 = this.destinations[e3];
              if (r2) {
                (0, n.warn)(`Found "${e3}" at an incorrect position in the NameTree.`);
                return r2;
              }
            } else if (t3 instanceof i.Dict) {
              const a3 = fetchDestination(t3.get(e3));
              if (a3) return a3;
            }
            return null;
          }
          _readDests() {
            const e3 = this._catDict.get("Names");
            return (e3 == null ? void 0 : e3.has("Dests")) ? new s.NameTree(e3.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
          }
          get pageLabels() {
            let e3 = null;
            try {
              e3 = this._readPageLabels();
            } catch (e4) {
              if (e4 instanceof r.MissingDataException) throw e4;
              (0, n.warn)("Unable to read page labels.");
            }
            return (0, n.shadow)(this, "pageLabels", e3);
          }
          _readPageLabels() {
            const e3 = this._catDict.getRaw("PageLabels");
            if (!e3) return null;
            const t3 = new Array(this.numPages);
            let a3 = null, o2 = "";
            const c2 = new s.NumberTree(e3, this.xref).getAll();
            let l2 = "", h2 = 1;
            for (let e4 = 0, s2 = this.numPages; e4 < s2; e4++) {
              const s3 = c2.get(e4);
              if (void 0 !== s3) {
                if (!(s3 instanceof i.Dict)) throw new n.FormatError("PageLabel is not a dictionary.");
                if (s3.has("Type") && !(0, i.isName)(s3.get("Type"), "PageLabel")) throw new n.FormatError("Invalid type in PageLabel dictionary.");
                if (s3.has("S")) {
                  const e5 = s3.get("S");
                  if (!(e5 instanceof i.Name)) throw new n.FormatError("Invalid style in PageLabel dictionary.");
                  a3 = e5.name;
                } else a3 = null;
                if (s3.has("P")) {
                  const e5 = s3.get("P");
                  if ("string" != typeof e5) throw new n.FormatError("Invalid prefix in PageLabel dictionary.");
                  o2 = (0, n.stringToPDFString)(e5);
                } else o2 = "";
                if (s3.has("St")) {
                  const e5 = s3.get("St");
                  if (!(Number.isInteger(e5) && e5 >= 1)) throw new n.FormatError("Invalid start in PageLabel dictionary.");
                  h2 = e5;
                } else h2 = 1;
              }
              switch (a3) {
                case "D":
                  l2 = h2;
                  break;
                case "R":
                case "r":
                  l2 = (0, r.toRomanNumerals)(h2, "r" === a3);
                  break;
                case "A":
                case "a":
                  const e5 = 26, t4 = "a" === a3 ? 97 : 65, i2 = h2 - 1;
                  l2 = String.fromCharCode(t4 + i2 % e5).repeat(Math.floor(i2 / e5) + 1);
                  break;
                default:
                  if (a3) throw new n.FormatError(`Invalid style "${a3}" in PageLabel dictionary.`);
                  l2 = "";
              }
              t3[e4] = o2 + l2;
              h2++;
            }
            return t3;
          }
          get pageLayout() {
            const e3 = this._catDict.get("PageLayout");
            let t3 = "";
            if (e3 instanceof i.Name) switch (e3.name) {
              case "SinglePage":
              case "OneColumn":
              case "TwoColumnLeft":
              case "TwoColumnRight":
              case "TwoPageLeft":
              case "TwoPageRight":
                t3 = e3.name;
            }
            return (0, n.shadow)(this, "pageLayout", t3);
          }
          get pageMode() {
            const e3 = this._catDict.get("PageMode");
            let t3 = "UseNone";
            if (e3 instanceof i.Name) switch (e3.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "FullScreen":
              case "UseOC":
              case "UseAttachments":
                t3 = e3.name;
            }
            return (0, n.shadow)(this, "pageMode", t3);
          }
          get viewerPreferences() {
            const e3 = this._catDict.get("ViewerPreferences");
            if (!(e3 instanceof i.Dict)) return (0, n.shadow)(this, "viewerPreferences", null);
            let t3 = null;
            for (const a3 of e3.getKeys()) {
              const r2 = e3.get(a3);
              let s2;
              switch (a3) {
                case "HideToolbar":
                case "HideMenubar":
                case "HideWindowUI":
                case "FitWindow":
                case "CenterWindow":
                case "DisplayDocTitle":
                case "PickTrayByPDFSize":
                  "boolean" == typeof r2 && (s2 = r2);
                  break;
                case "NonFullScreenPageMode":
                  if (r2 instanceof i.Name) switch (r2.name) {
                    case "UseNone":
                    case "UseOutlines":
                    case "UseThumbs":
                    case "UseOC":
                      s2 = r2.name;
                      break;
                    default:
                      s2 = "UseNone";
                  }
                  break;
                case "Direction":
                  if (r2 instanceof i.Name) switch (r2.name) {
                    case "L2R":
                    case "R2L":
                      s2 = r2.name;
                      break;
                    default:
                      s2 = "L2R";
                  }
                  break;
                case "ViewArea":
                case "ViewClip":
                case "PrintArea":
                case "PrintClip":
                  if (r2 instanceof i.Name) switch (r2.name) {
                    case "MediaBox":
                    case "CropBox":
                    case "BleedBox":
                    case "TrimBox":
                    case "ArtBox":
                      s2 = r2.name;
                      break;
                    default:
                      s2 = "CropBox";
                  }
                  break;
                case "PrintScaling":
                  if (r2 instanceof i.Name) switch (r2.name) {
                    case "None":
                    case "AppDefault":
                      s2 = r2.name;
                      break;
                    default:
                      s2 = "AppDefault";
                  }
                  break;
                case "Duplex":
                  if (r2 instanceof i.Name) switch (r2.name) {
                    case "Simplex":
                    case "DuplexFlipShortEdge":
                    case "DuplexFlipLongEdge":
                      s2 = r2.name;
                      break;
                    default:
                      s2 = "None";
                  }
                  break;
                case "PrintPageRange":
                  if (Array.isArray(r2) && r2.length % 2 == 0) {
                    r2.every((e4, t4, a4) => Number.isInteger(e4) && e4 > 0 && (0 === t4 || e4 >= a4[t4 - 1]) && e4 <= this.numPages) && (s2 = r2);
                  }
                  break;
                case "NumCopies":
                  Number.isInteger(r2) && r2 > 0 && (s2 = r2);
                  break;
                default:
                  (0, n.warn)(`Ignoring non-standard key in ViewerPreferences: ${a3}.`);
                  continue;
              }
              if (void 0 !== s2) {
                t3 || (t3 = /* @__PURE__ */ Object.create(null));
                t3[a3] = s2;
              } else (0, n.warn)(`Bad value, for key "${a3}", in ViewerPreferences: ${r2}.`);
            }
            return (0, n.shadow)(this, "viewerPreferences", t3);
          }
          get openAction() {
            const e3 = this._catDict.get("OpenAction"), t3 = /* @__PURE__ */ Object.create(null);
            if (e3 instanceof i.Dict) {
              const a3 = new i.Dict(this.xref);
              a3.set("A", e3);
              const r2 = { url: null, dest: null, action: null };
              Catalog.parseDestDictionary({ destDict: a3, resultObj: r2 });
              Array.isArray(r2.dest) ? t3.dest = r2.dest : r2.action && (t3.action = r2.action);
            } else Array.isArray(e3) && (t3.dest = e3);
            return (0, n.shadow)(this, "openAction", (0, n.objectSize)(t3) > 0 ? t3 : null);
          }
          get attachments() {
            const e3 = this._catDict.get("Names");
            let t3 = null;
            if (e3 instanceof i.Dict && e3.has("EmbeddedFiles")) {
              const a3 = new s.NameTree(e3.getRaw("EmbeddedFiles"), this.xref);
              for (const [e4, r2] of a3.getAll()) {
                const a4 = new h.FileSpec(r2, this.xref);
                t3 || (t3 = /* @__PURE__ */ Object.create(null));
                t3[(0, n.stringToPDFString)(e4)] = a4.serializable;
              }
            }
            return (0, n.shadow)(this, "attachments", t3);
          }
          get xfaImages() {
            const e3 = this._catDict.get("Names");
            let t3 = null;
            if (e3 instanceof i.Dict && e3.has("XFAImages")) {
              const a3 = new s.NameTree(e3.getRaw("XFAImages"), this.xref);
              for (const [e4, r2] of a3.getAll()) {
                t3 || (t3 = new i.Dict(this.xref));
                t3.set((0, n.stringToPDFString)(e4), r2);
              }
            }
            return (0, n.shadow)(this, "xfaImages", t3);
          }
          _collectJavaScript() {
            const e3 = this._catDict.get("Names");
            let t3 = null;
            function appendIfJavaScriptDict(e4, a4) {
              if (!(a4 instanceof i.Dict)) return;
              if (!(0, i.isName)(a4.get("S"), "JavaScript")) return;
              let r2 = a4.get("JS");
              if (r2 instanceof o.BaseStream) r2 = r2.getString();
              else if ("string" != typeof r2) return;
              r2 = (0, n.stringToPDFString)(r2).replaceAll("\0", "");
              r2 && (t3 || (t3 = /* @__PURE__ */ new Map())).set(e4, r2);
            }
            if (e3 instanceof i.Dict && e3.has("JavaScript")) {
              const t4 = new s.NameTree(e3.getRaw("JavaScript"), this.xref);
              for (const [e4, a4] of t4.getAll()) appendIfJavaScriptDict((0, n.stringToPDFString)(e4), a4);
            }
            const a3 = this._catDict.get("OpenAction");
            a3 && appendIfJavaScriptDict("OpenAction", a3);
            return t3;
          }
          get jsActions() {
            const e3 = this._collectJavaScript();
            let t3 = (0, r.collectActions)(this.xref, this._catDict, n.DocumentActionEventType);
            if (e3) {
              t3 || (t3 = /* @__PURE__ */ Object.create(null));
              for (const [a3, r2] of e3) a3 in t3 ? t3[a3].push(r2) : t3[a3] = [r2];
            }
            return (0, n.shadow)(this, "jsActions", t3);
          }
          async fontFallback(e3, t3) {
            const a3 = await Promise.all(this.fontCache);
            for (const r2 of a3) if (r2.loadedName === e3) {
              r2.fallback(t3);
              return;
            }
          }
          async cleanup(e3 = false) {
            (0, c.clearGlobalCaches)();
            this.globalImageCache.clear(e3);
            this.pageKidsCountCache.clear();
            this.pageIndexCache.clear();
            this.nonBlendModesSet.clear();
            const t3 = await Promise.all(this.fontCache);
            for (const { dict: e4 } of t3) delete e4.cacheKey;
            this.fontCache.clear();
            this.builtInCMapCache.clear();
            this.standardFontDataCache.clear();
            this.systemFontCache.clear();
          }
          async getPageDict(e3) {
            const t3 = [this.toplevelPagesDict], a3 = new i.RefSet(), r2 = this._catDict.getRaw("Pages");
            r2 instanceof i.Ref && a3.put(r2);
            const s2 = this.xref, o2 = this.pageKidsCountCache, c2 = this.pageIndexCache;
            let l2 = 0;
            for (; t3.length; ) {
              const r3 = t3.pop();
              if (r3 instanceof i.Ref) {
                const h3 = o2.get(r3);
                if (h3 >= 0 && l2 + h3 <= e3) {
                  l2 += h3;
                  continue;
                }
                if (a3.has(r3)) throw new n.FormatError("Pages tree contains circular reference.");
                a3.put(r3);
                const u3 = await s2.fetchAsync(r3);
                if (u3 instanceof i.Dict) {
                  let t4 = u3.getRaw("Type");
                  t4 instanceof i.Ref && (t4 = await s2.fetchAsync(t4));
                  if ((0, i.isName)(t4, "Page") || !u3.has("Kids")) {
                    o2.has(r3) || o2.put(r3, 1);
                    c2.has(r3) || c2.put(r3, l2);
                    if (l2 === e3) return [u3, r3];
                    l2++;
                    continue;
                  }
                }
                t3.push(u3);
                continue;
              }
              if (!(r3 instanceof i.Dict)) throw new n.FormatError("Page dictionary kid reference points to wrong type of object.");
              const { objId: h2 } = r3;
              let u2 = r3.getRaw("Count");
              u2 instanceof i.Ref && (u2 = await s2.fetchAsync(u2));
              if (Number.isInteger(u2) && u2 >= 0) {
                h2 && !o2.has(h2) && o2.put(h2, u2);
                if (l2 + u2 <= e3) {
                  l2 += u2;
                  continue;
                }
              }
              let d2 = r3.getRaw("Kids");
              d2 instanceof i.Ref && (d2 = await s2.fetchAsync(d2));
              if (!Array.isArray(d2)) {
                let t4 = r3.getRaw("Type");
                t4 instanceof i.Ref && (t4 = await s2.fetchAsync(t4));
                if ((0, i.isName)(t4, "Page") || !r3.has("Kids")) {
                  if (l2 === e3) return [r3, null];
                  l2++;
                  continue;
                }
                throw new n.FormatError("Page dictionary kids object is not an array.");
              }
              for (let e4 = d2.length - 1; e4 >= 0; e4--) t3.push(d2[e4]);
            }
            throw new Error(`Page index ${e3} not found.`);
          }
          async getAllPageDicts(e3 = false) {
            const { ignoreErrors: t3 } = this.pdfManager.evaluatorOptions, a3 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], s2 = new i.RefSet(), o2 = this._catDict.getRaw("Pages");
            o2 instanceof i.Ref && s2.put(o2);
            const c2 = /* @__PURE__ */ new Map(), l2 = this.xref, h2 = this.pageIndexCache;
            let u2 = 0;
            function addPageDict(e4, t4) {
              t4 && !h2.has(t4) && h2.put(t4, u2);
              c2.set(u2++, [e4, t4]);
            }
            function addPageError(a4) {
              if (a4 instanceof r.XRefEntryException && !e3) throw a4;
              if (e3 && t3 && 0 === u2) {
                (0, n.warn)(`getAllPageDicts - Skipping invalid first page: "${a4}".`);
                a4 = i.Dict.empty;
              }
              c2.set(u2++, [a4, null]);
            }
            for (; a3.length > 0; ) {
              const e4 = a3.at(-1), { currentNode: t4, posInKids: r2 } = e4;
              let o3 = t4.getRaw("Kids");
              if (o3 instanceof i.Ref) try {
                o3 = await l2.fetchAsync(o3);
              } catch (e5) {
                addPageError(e5);
                break;
              }
              if (!Array.isArray(o3)) {
                addPageError(new n.FormatError("Page dictionary kids object is not an array."));
                break;
              }
              if (r2 >= o3.length) {
                a3.pop();
                continue;
              }
              const c3 = o3[r2];
              let h3;
              if (c3 instanceof i.Ref) {
                if (s2.has(c3)) {
                  addPageError(new n.FormatError("Pages tree contains circular reference."));
                  break;
                }
                s2.put(c3);
                try {
                  h3 = await l2.fetchAsync(c3);
                } catch (e5) {
                  addPageError(e5);
                  break;
                }
              } else h3 = c3;
              if (!(h3 instanceof i.Dict)) {
                addPageError(new n.FormatError("Page dictionary kid reference points to wrong type of object."));
                break;
              }
              let u3 = h3.getRaw("Type");
              if (u3 instanceof i.Ref) try {
                u3 = await l2.fetchAsync(u3);
              } catch (e5) {
                addPageError(e5);
                break;
              }
              (0, i.isName)(u3, "Page") || !h3.has("Kids") ? addPageDict(h3, c3 instanceof i.Ref ? c3 : null) : a3.push({ currentNode: h3, posInKids: 0 });
              e4.posInKids++;
            }
            return c2;
          }
          getPageIndex(e3) {
            const t3 = this.pageIndexCache.get(e3);
            if (void 0 !== t3) return Promise.resolve(t3);
            const a3 = this.xref;
            let r2 = 0;
            const next = (t4) => function pagesBeforeRef(t5) {
              let r3, s2 = 0;
              return a3.fetchAsync(t5).then(function(a4) {
                if ((0, i.isRefsEqual)(t5, e3) && !(0, i.isDict)(a4, "Page") && !(a4 instanceof i.Dict && !a4.has("Type") && a4.has("Contents"))) throw new n.FormatError("The reference does not point to a /Page dictionary.");
                if (!a4) return null;
                if (!(a4 instanceof i.Dict)) throw new n.FormatError("Node must be a dictionary.");
                r3 = a4.getRaw("Parent");
                return a4.getAsync("Parent");
              }).then(function(e4) {
                if (!e4) return null;
                if (!(e4 instanceof i.Dict)) throw new n.FormatError("Parent must be a dictionary.");
                return e4.getAsync("Kids");
              }).then(function(e4) {
                if (!e4) return null;
                const o2 = [];
                let c2 = false;
                for (const r4 of e4) {
                  if (!(r4 instanceof i.Ref)) throw new n.FormatError("Kid must be a reference.");
                  if ((0, i.isRefsEqual)(r4, t5)) {
                    c2 = true;
                    break;
                  }
                  o2.push(a3.fetchAsync(r4).then(function(e5) {
                    if (!(e5 instanceof i.Dict)) throw new n.FormatError("Kid node must be a dictionary.");
                    e5.has("Count") ? s2 += e5.get("Count") : s2++;
                  }));
                }
                if (!c2) throw new n.FormatError("Kid reference not found in parent's kids.");
                return Promise.all(o2).then(function() {
                  return [s2, r3];
                });
              });
            }(t4).then((t5) => {
              if (!t5) {
                this.pageIndexCache.put(e3, r2);
                return r2;
              }
              const [a4, n2] = t5;
              r2 += a4;
              return next(n2);
            });
            return next(e3);
          }
          get baseUrl() {
            const e3 = this._catDict.get("URI");
            if (e3 instanceof i.Dict) {
              const t3 = e3.get("Base");
              if ("string" == typeof t3) {
                const e4 = (0, n.createValidAbsoluteUrl)(t3, null, { tryConvertEncoding: true });
                if (e4) return (0, n.shadow)(this, "baseUrl", e4.href);
              }
            }
            return (0, n.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
          }
          static parseDestDictionary({ destDict: e3, resultObj: t3, docBaseUrl: a3 = null, docAttachments: s2 = null }) {
            if (!(e3 instanceof i.Dict)) {
              (0, n.warn)("parseDestDictionary: `destDict` must be a dictionary.");
              return;
            }
            let c2, l2, h2 = e3.get("A");
            if (!(h2 instanceof i.Dict)) if (e3.has("Dest")) h2 = e3.get("Dest");
            else {
              h2 = e3.get("AA");
              h2 instanceof i.Dict && (h2.has("D") ? h2 = h2.get("D") : h2.has("U") && (h2 = h2.get("U")));
            }
            if (h2 instanceof i.Dict) {
              const e4 = h2.get("S");
              if (!(e4 instanceof i.Name)) {
                (0, n.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                return;
              }
              const a4 = e4.name;
              switch (a4) {
                case "ResetForm":
                  const e5 = h2.get("Flags"), u2 = 0 == (1 & ("number" == typeof e5 ? e5 : 0)), d2 = [], f2 = [];
                  for (const e6 of h2.get("Fields") || []) e6 instanceof i.Ref ? f2.push(e6.toString()) : "string" == typeof e6 && d2.push((0, n.stringToPDFString)(e6));
                  t3.resetForm = { fields: d2, refs: f2, include: u2 };
                  break;
                case "URI":
                  c2 = h2.get("URI");
                  c2 instanceof i.Name && (c2 = "/" + c2.name);
                  break;
                case "GoTo":
                  l2 = h2.get("D");
                  break;
                case "Launch":
                case "GoToR":
                  const g = h2.get("F");
                  g instanceof i.Dict ? c2 = g.get("F") || null : "string" == typeof g && (c2 = g);
                  let p = h2.get("D");
                  if (p) {
                    p instanceof i.Name && (p = p.name);
                    if ("string" == typeof c2) {
                      const e6 = c2.split("#")[0];
                      "string" == typeof p ? c2 = e6 + "#" + p : Array.isArray(p) && (c2 = e6 + "#" + JSON.stringify(p));
                    }
                  }
                  const m = h2.get("NewWindow");
                  "boolean" == typeof m && (t3.newWindow = m);
                  break;
                case "GoToE":
                  const b = h2.get("T");
                  let y;
                  if (s2 && b instanceof i.Dict) {
                    const e6 = b.get("R"), t4 = b.get("N");
                    (0, i.isName)(e6, "C") && "string" == typeof t4 && (y = s2[(0, n.stringToPDFString)(t4)]);
                  }
                  y ? t3.attachment = y : (0, n.warn)('parseDestDictionary - unimplemented "GoToE" action.');
                  break;
                case "Named":
                  const w = h2.get("N");
                  w instanceof i.Name && (t3.action = w.name);
                  break;
                case "SetOCGState":
                  const S = h2.get("State"), x = h2.get("PreserveRB");
                  if (!Array.isArray(S) || 0 === S.length) break;
                  const C = [];
                  for (const e6 of S) if (e6 instanceof i.Name) switch (e6.name) {
                    case "ON":
                    case "OFF":
                    case "Toggle":
                      C.push(e6.name);
                  }
                  else e6 instanceof i.Ref && C.push(e6.toString());
                  if (C.length !== S.length) break;
                  t3.setOCGState = { state: C, preserveRB: "boolean" != typeof x || x };
                  break;
                case "JavaScript":
                  const k = h2.get("JS");
                  let v;
                  k instanceof o.BaseStream ? v = k.getString() : "string" == typeof k && (v = k);
                  const F = v && (0, r.recoverJsURL)((0, n.stringToPDFString)(v));
                  if (F) {
                    c2 = F.url;
                    t3.newWindow = F.newWindow;
                    break;
                  }
                default:
                  if ("JavaScript" === a4 || "SubmitForm" === a4) break;
                  (0, n.warn)(`parseDestDictionary - unsupported action: "${a4}".`);
              }
            } else e3.has("Dest") && (l2 = e3.get("Dest"));
            if ("string" == typeof c2) {
              const e4 = (0, n.createValidAbsoluteUrl)(c2, a3, { addDefaultProtocol: true, tryConvertEncoding: true });
              e4 && (t3.url = e4.href);
              t3.unsafeUrl = c2;
            }
            if (l2) {
              l2 instanceof i.Name && (l2 = l2.name);
              "string" == typeof l2 ? t3.dest = (0, n.stringToPDFString)(l2) : Array.isArray(l2) && (t3.dest = l2);
            }
          }
        }
        t2.Catalog = Catalog;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NumberTree = t2.NameTree = void 0;
        var r = a2(4), n = a2(2);
        class NameOrNumberTree {
          constructor(e3, t3, a3) {
            this.constructor === NameOrNumberTree && (0, n.unreachable)("Cannot initialize NameOrNumberTree.");
            this.root = e3;
            this.xref = t3;
            this._type = a3;
          }
          getAll() {
            const e3 = /* @__PURE__ */ new Map();
            if (!this.root) return e3;
            const t3 = this.xref, a3 = new r.RefSet();
            a3.put(this.root);
            const i = [this.root];
            for (; i.length > 0; ) {
              const s = t3.fetchIfRef(i.shift());
              if (!(s instanceof r.Dict)) continue;
              if (s.has("Kids")) {
                const e4 = s.get("Kids");
                if (!Array.isArray(e4)) continue;
                for (const t4 of e4) {
                  if (a3.has(t4)) throw new n.FormatError(`Duplicate entry in "${this._type}" tree.`);
                  i.push(t4);
                  a3.put(t4);
                }
                continue;
              }
              const o = s.get(this._type);
              if (Array.isArray(o)) for (let a4 = 0, r2 = o.length; a4 < r2; a4 += 2) e3.set(t3.fetchIfRef(o[a4]), t3.fetchIfRef(o[a4 + 1]));
            }
            return e3;
          }
          get(e3) {
            if (!this.root) return null;
            const t3 = this.xref;
            let a3 = t3.fetchIfRef(this.root), r2 = 0;
            for (; a3.has("Kids"); ) {
              if (++r2 > 10) {
                (0, n.warn)(`Search depth limit reached for "${this._type}" tree.`);
                return null;
              }
              const i2 = a3.get("Kids");
              if (!Array.isArray(i2)) return null;
              let s = 0, o = i2.length - 1;
              for (; s <= o; ) {
                const r3 = s + o >> 1, n2 = t3.fetchIfRef(i2[r3]), c = n2.get("Limits");
                if (e3 < t3.fetchIfRef(c[0])) o = r3 - 1;
                else {
                  if (!(e3 > t3.fetchIfRef(c[1]))) {
                    a3 = n2;
                    break;
                  }
                  s = r3 + 1;
                }
              }
              if (s > o) return null;
            }
            const i = a3.get(this._type);
            if (Array.isArray(i)) {
              let a4 = 0, r3 = i.length - 2;
              for (; a4 <= r3; ) {
                const n2 = a4 + r3 >> 1, s = n2 + (1 & n2), o = t3.fetchIfRef(i[s]);
                if (e3 < o) r3 = s - 2;
                else {
                  if (!(e3 > o)) return t3.fetchIfRef(i[s + 1]);
                  a4 = s + 2;
                }
              }
            }
            return null;
          }
        }
        t2.NameTree = class NameTree extends NameOrNumberTree {
          constructor(e3, t3) {
            super(e3, t3, "Names");
          }
        };
        t2.NumberTree = class NumberTree extends NameOrNumberTree {
          constructor(e3, t3) {
            super(e3, t3, "Nums");
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.clearGlobalCaches = function clearGlobalCaches() {
          (0, r.clearPatternCaches)();
          (0, n.clearPrimitiveCaches)();
          (0, i.clearUnicodeCaches)();
        };
        var r = a2(50), n = a2(4), i = a2(40);
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.FileSpec = void 0;
        var r = a2(2), n = a2(5), i = a2(4);
        function pickPlatformItem(e3) {
          return e3.has("UF") ? e3.get("UF") : e3.has("F") ? e3.get("F") : e3.has("Unix") ? e3.get("Unix") : e3.has("Mac") ? e3.get("Mac") : e3.has("DOS") ? e3.get("DOS") : null;
        }
        t2.FileSpec = class FileSpec {
          constructor(e3, t3) {
            if (e3 instanceof i.Dict) {
              this.xref = t3;
              this.root = e3;
              e3.has("FS") && (this.fs = e3.get("FS"));
              this.description = e3.has("Desc") ? (0, r.stringToPDFString)(e3.get("Desc")) : "";
              e3.has("RF") && (0, r.warn)("Related file specifications are not supported");
              this.contentAvailable = true;
              if (!e3.has("EF")) {
                this.contentAvailable = false;
                (0, r.warn)("Non-embedded file specifications are not supported");
              }
            }
          }
          get filename() {
            if (!this._filename && this.root) {
              const e3 = pickPlatformItem(this.root) || "unnamed";
              this._filename = (0, r.stringToPDFString)(e3).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
            }
            return this._filename;
          }
          get content() {
            if (!this.contentAvailable) return null;
            !this.contentRef && this.root && (this.contentRef = pickPlatformItem(this.root.get("EF")));
            let e3 = null;
            if (this.contentRef) {
              const t3 = this.xref.fetchIfRef(this.contentRef);
              t3 instanceof n.BaseStream ? e3 = t3.getBytes() : (0, r.warn)("Embedded file specification points to non-existing/invalid content");
            } else (0, r.warn)("Embedded file specification does not have a content");
            return e3;
          }
          get serializable() {
            return { filename: this.filename, content: this.content };
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.MetadataParser = void 0;
        var r = a2(71);
        t2.MetadataParser = class MetadataParser {
          constructor(e3) {
            e3 = this._repair(e3);
            const t3 = new r.SimpleXMLParser({ lowerCaseName: true }).parseFromString(e3);
            this._metadataMap = /* @__PURE__ */ new Map();
            this._data = e3;
            t3 && this._parse(t3);
          }
          _repair(e3) {
            return e3.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e4, t3) {
              const a3 = t3.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e5, t4, a4, r3) {
                return String.fromCharCode(64 * t4 + 8 * a4 + 1 * r3);
              }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e5, t4) {
                switch (t4) {
                  case "amp":
                    return "&";
                  case "apos":
                    return "'";
                  case "gt":
                    return ">";
                  case "lt":
                    return "<";
                  case "quot":
                    return '"';
                }
                throw new Error(`_repair: ${t4} isn't defined.`);
              }), r2 = [">"];
              for (let e5 = 0, t4 = a3.length; e5 < t4; e5 += 2) {
                const t5 = 256 * a3.charCodeAt(e5) + a3.charCodeAt(e5 + 1);
                t5 >= 32 && t5 < 127 && 60 !== t5 && 62 !== t5 && 38 !== t5 ? r2.push(String.fromCharCode(t5)) : r2.push("&#x" + (65536 + t5).toString(16).substring(1) + ";");
              }
              return r2.join("");
            });
          }
          _getSequence(e3) {
            const t3 = e3.nodeName;
            return "rdf:bag" !== t3 && "rdf:seq" !== t3 && "rdf:alt" !== t3 ? null : e3.childNodes.filter((e4) => "rdf:li" === e4.nodeName);
          }
          _parseArray(e3) {
            if (!e3.hasChildNodes()) return;
            const [t3] = e3.childNodes, a3 = this._getSequence(t3) || [];
            this._metadataMap.set(e3.nodeName, a3.map((e4) => e4.textContent.trim()));
          }
          _parse(e3) {
            let t3 = e3.documentElement;
            if ("rdf:rdf" !== t3.nodeName) {
              t3 = t3.firstChild;
              for (; t3 && "rdf:rdf" !== t3.nodeName; ) t3 = t3.nextSibling;
            }
            if (t3 && "rdf:rdf" === t3.nodeName && t3.hasChildNodes()) {
              for (const e4 of t3.childNodes) if ("rdf:description" === e4.nodeName) for (const t4 of e4.childNodes) {
                const e5 = t4.nodeName;
                switch (e5) {
                  case "#text":
                    continue;
                  case "dc:creator":
                  case "dc:subject":
                    this._parseArray(t4);
                    continue;
                }
                this._metadataMap.set(e5, t4.textContent.trim());
              }
            }
          }
          get serializable() {
            return { parsedData: this._metadataMap, rawData: this._data };
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XMLParserErrorCode = t2.XMLParserBase = t2.SimpleXMLParser = t2.SimpleDOMNode = void 0;
        var r = a2(3);
        const n = { NoError: 0, EndOfDocument: -1, UnterminatedCdat: -2, UnterminatedXmlDeclaration: -3, UnterminatedDoctypeDeclaration: -4, UnterminatedComment: -5, MalformedElement: -6, OutOfMemory: -7, UnterminatedAttributeValue: -8, UnterminatedElement: -9, ElementNeverBegun: -10 };
        t2.XMLParserErrorCode = n;
        function isWhitespace(e3, t3) {
          const a3 = e3[t3];
          return " " === a3 || "\n" === a3 || "\r" === a3 || "	" === a3;
        }
        class XMLParserBase {
          _resolveEntities(e3) {
            return e3.replaceAll(/&([^;]+);/g, (e4, t3) => {
              if ("#x" === t3.substring(0, 2)) return String.fromCodePoint(parseInt(t3.substring(2), 16));
              if ("#" === t3.substring(0, 1)) return String.fromCodePoint(parseInt(t3.substring(1), 10));
              switch (t3) {
                case "lt":
                  return "<";
                case "gt":
                  return ">";
                case "amp":
                  return "&";
                case "quot":
                  return '"';
                case "apos":
                  return "'";
              }
              return this.onResolveEntity(t3);
            });
          }
          _parseContent(e3, t3) {
            const a3 = [];
            let r2 = t3;
            function skipWs() {
              for (; r2 < e3.length && isWhitespace(e3, r2); ) ++r2;
            }
            for (; r2 < e3.length && !isWhitespace(e3, r2) && ">" !== e3[r2] && "/" !== e3[r2]; ) ++r2;
            const n2 = e3.substring(t3, r2);
            skipWs();
            for (; r2 < e3.length && ">" !== e3[r2] && "/" !== e3[r2] && "?" !== e3[r2]; ) {
              skipWs();
              let t4 = "", n3 = "";
              for (; r2 < e3.length && !isWhitespace(e3, r2) && "=" !== e3[r2]; ) {
                t4 += e3[r2];
                ++r2;
              }
              skipWs();
              if ("=" !== e3[r2]) return null;
              ++r2;
              skipWs();
              const i = e3[r2];
              if ('"' !== i && "'" !== i) return null;
              const s = e3.indexOf(i, ++r2);
              if (s < 0) return null;
              n3 = e3.substring(r2, s);
              a3.push({ name: t4, value: this._resolveEntities(n3) });
              r2 = s + 1;
              skipWs();
            }
            return { name: n2, attributes: a3, parsed: r2 - t3 };
          }
          _parseProcessingInstruction(e3, t3) {
            let a3 = t3;
            for (; a3 < e3.length && !isWhitespace(e3, a3) && ">" !== e3[a3] && "?" !== e3[a3] && "/" !== e3[a3]; ) ++a3;
            const r2 = e3.substring(t3, a3);
            !function skipWs() {
              for (; a3 < e3.length && isWhitespace(e3, a3); ) ++a3;
            }();
            const n2 = a3;
            for (; a3 < e3.length && ("?" !== e3[a3] || ">" !== e3[a3 + 1]); ) ++a3;
            return { name: r2, value: e3.substring(n2, a3), parsed: a3 - t3 };
          }
          parseXml(e3) {
            let t3 = 0;
            for (; t3 < e3.length; ) {
              let a3 = t3;
              if ("<" === e3[t3]) {
                ++a3;
                let t4;
                switch (e3[a3]) {
                  case "/":
                    ++a3;
                    t4 = e3.indexOf(">", a3);
                    if (t4 < 0) {
                      this.onError(n.UnterminatedElement);
                      return;
                    }
                    this.onEndElement(e3.substring(a3, t4));
                    a3 = t4 + 1;
                    break;
                  case "?":
                    ++a3;
                    const r2 = this._parseProcessingInstruction(e3, a3);
                    if ("?>" !== e3.substring(a3 + r2.parsed, a3 + r2.parsed + 2)) {
                      this.onError(n.UnterminatedXmlDeclaration);
                      return;
                    }
                    this.onPi(r2.name, r2.value);
                    a3 += r2.parsed + 2;
                    break;
                  case "!":
                    if ("--" === e3.substring(a3 + 1, a3 + 3)) {
                      t4 = e3.indexOf("-->", a3 + 3);
                      if (t4 < 0) {
                        this.onError(n.UnterminatedComment);
                        return;
                      }
                      this.onComment(e3.substring(a3 + 3, t4));
                      a3 = t4 + 3;
                    } else if ("[CDATA[" === e3.substring(a3 + 1, a3 + 8)) {
                      t4 = e3.indexOf("]]>", a3 + 8);
                      if (t4 < 0) {
                        this.onError(n.UnterminatedCdat);
                        return;
                      }
                      this.onCdata(e3.substring(a3 + 8, t4));
                      a3 = t4 + 3;
                    } else {
                      if ("DOCTYPE" !== e3.substring(a3 + 1, a3 + 8)) {
                        this.onError(n.MalformedElement);
                        return;
                      }
                      {
                        const r3 = e3.indexOf("[", a3 + 8);
                        let i2 = false;
                        t4 = e3.indexOf(">", a3 + 8);
                        if (t4 < 0) {
                          this.onError(n.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        if (r3 > 0 && t4 > r3) {
                          t4 = e3.indexOf("]>", a3 + 8);
                          if (t4 < 0) {
                            this.onError(n.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          i2 = true;
                        }
                        const s2 = e3.substring(a3 + 8, t4 + (i2 ? 1 : 0));
                        this.onDoctype(s2);
                        a3 = t4 + (i2 ? 2 : 1);
                      }
                    }
                    break;
                  default:
                    const i = this._parseContent(e3, a3);
                    if (null === i) {
                      this.onError(n.MalformedElement);
                      return;
                    }
                    let s = false;
                    if ("/>" === e3.substring(a3 + i.parsed, a3 + i.parsed + 2)) s = true;
                    else if (">" !== e3.substring(a3 + i.parsed, a3 + i.parsed + 1)) {
                      this.onError(n.UnterminatedElement);
                      return;
                    }
                    this.onBeginElement(i.name, i.attributes, s);
                    a3 += i.parsed + (s ? 2 : 1);
                }
              } else {
                for (; a3 < e3.length && "<" !== e3[a3]; ) a3++;
                const r2 = e3.substring(t3, a3);
                this.onText(this._resolveEntities(r2));
              }
              t3 = a3;
            }
          }
          onResolveEntity(e3) {
            return `&${e3};`;
          }
          onPi(e3, t3) {
          }
          onComment(e3) {
          }
          onCdata(e3) {
          }
          onDoctype(e3) {
          }
          onText(e3) {
          }
          onBeginElement(e3, t3, a3) {
          }
          onEndElement(e3) {
          }
          onError(e3) {
          }
        }
        t2.XMLParserBase = XMLParserBase;
        class SimpleDOMNode {
          constructor(e3, t3) {
            this.nodeName = e3;
            this.nodeValue = t3;
            Object.defineProperty(this, "parentNode", { value: null, writable: true });
          }
          get firstChild() {
            var _a;
            return (_a = this.childNodes) == null ? void 0 : _a[0];
          }
          get nextSibling() {
            const e3 = this.parentNode.childNodes;
            if (!e3) return;
            const t3 = e3.indexOf(this);
            return -1 !== t3 ? e3[t3 + 1] : void 0;
          }
          get textContent() {
            return this.childNodes ? this.childNodes.map(function(e3) {
              return e3.textContent;
            }).join("") : this.nodeValue || "";
          }
          get children() {
            return this.childNodes || [];
          }
          hasChildNodes() {
            var _a;
            return ((_a = this.childNodes) == null ? void 0 : _a.length) > 0;
          }
          searchNode(e3, t3) {
            var _a;
            if (t3 >= e3.length) return this;
            const a3 = e3[t3];
            if (a3.name.startsWith("#") && t3 < e3.length - 1) return this.searchNode(e3, t3 + 1);
            const r2 = [];
            let n2 = this;
            for (; ; ) {
              if (a3.name === n2.nodeName) {
                if (0 !== a3.pos) {
                  if (0 === r2.length) return null;
                  {
                    const [i] = r2.pop();
                    let s = 0;
                    for (const r3 of i.childNodes) if (a3.name === r3.nodeName) {
                      if (s === a3.pos) return r3.searchNode(e3, t3 + 1);
                      s++;
                    }
                    return n2.searchNode(e3, t3 + 1);
                  }
                }
                {
                  const a4 = n2.searchNode(e3, t3 + 1);
                  if (null !== a4) return a4;
                }
              }
              if (((_a = n2.childNodes) == null ? void 0 : _a.length) > 0) {
                r2.push([n2, 0]);
                n2 = n2.childNodes[0];
              } else {
                if (0 === r2.length) return null;
                for (; 0 !== r2.length; ) {
                  const [e4, t4] = r2.pop(), a4 = t4 + 1;
                  if (a4 < e4.childNodes.length) {
                    r2.push([e4, a4]);
                    n2 = e4.childNodes[a4];
                    break;
                  }
                }
                if (0 === r2.length) return null;
              }
            }
          }
          dump(e3) {
            if ("#text" !== this.nodeName) {
              e3.push(`<${this.nodeName}`);
              if (this.attributes) for (const t3 of this.attributes) e3.push(` ${t3.name}="${(0, r.encodeToXmlString)(t3.value)}"`);
              if (this.hasChildNodes()) {
                e3.push(">");
                for (const t3 of this.childNodes) t3.dump(e3);
                e3.push(`</${this.nodeName}>`);
              } else this.nodeValue ? e3.push(`>${(0, r.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : e3.push("/>");
            } else e3.push((0, r.encodeToXmlString)(this.nodeValue));
          }
        }
        t2.SimpleDOMNode = SimpleDOMNode;
        t2.SimpleXMLParser = class SimpleXMLParser extends XMLParserBase {
          constructor({ hasAttributes: e3 = false, lowerCaseName: t3 = false }) {
            super();
            this._currentFragment = null;
            this._stack = null;
            this._errorCode = n.NoError;
            this._hasAttributes = e3;
            this._lowerCaseName = t3;
          }
          parseFromString(e3) {
            this._currentFragment = [];
            this._stack = [];
            this._errorCode = n.NoError;
            this.parseXml(e3);
            if (this._errorCode !== n.NoError) return;
            const [t3] = this._currentFragment;
            return t3 ? { documentElement: t3 } : void 0;
          }
          onText(e3) {
            if (function isWhitespaceString(e4) {
              for (let t4 = 0, a3 = e4.length; t4 < a3; t4++) if (!isWhitespace(e4, t4)) return false;
              return true;
            }(e3)) return;
            const t3 = new SimpleDOMNode("#text", e3);
            this._currentFragment.push(t3);
          }
          onCdata(e3) {
            const t3 = new SimpleDOMNode("#text", e3);
            this._currentFragment.push(t3);
          }
          onBeginElement(e3, t3, a3) {
            this._lowerCaseName && (e3 = e3.toLowerCase());
            const r2 = new SimpleDOMNode(e3);
            r2.childNodes = [];
            this._hasAttributes && (r2.attributes = t3);
            this._currentFragment.push(r2);
            if (!a3) {
              this._stack.push(this._currentFragment);
              this._currentFragment = r2.childNodes;
            }
          }
          onEndElement(e3) {
            this._currentFragment = this._stack.pop() || [];
            const t3 = this._currentFragment.at(-1);
            if (!t3) return null;
            for (const e4 of t3.childNodes) e4.parentNode = t3;
            return t3;
          }
          onError(e3) {
            this._errorCode = e3;
          }
        };
      }, (e2, t2, a2) => {
        var _StructTreeRoot_instances, C_fn, _StructTreeRoot_static, k_fn, v_fn, F_fn;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.StructTreeRoot = t2.StructTreePage = void 0;
        var r = a2(2), n = a2(4), i = a2(67), s = a2(73);
        const o = 1, c = 2, l = 3, h = 4, u = 5;
        const _StructTreeRoot = class _StructTreeRoot {
          constructor(e3, t3) {
            __privateAdd(this, _StructTreeRoot_instances);
            this.dict = e3;
            this.ref = t3 instanceof n.Ref ? t3 : null;
            this.roleMap = /* @__PURE__ */ new Map();
            this.structParentIds = null;
          }
          init() {
            this.readRoleMap();
          }
          addAnnotationIdToPage(e3, t3) {
            __privateMethod(this, _StructTreeRoot_instances, C_fn).call(this, e3, t3, h);
          }
          readRoleMap() {
            const e3 = this.dict.get("RoleMap");
            e3 instanceof n.Dict && e3.forEach((e4, t3) => {
              t3 instanceof n.Name && this.roleMap.set(e4, t3.name);
            });
          }
          static async canCreateStructureTree({ catalogRef: e3, pdfManager: t3, newAnnotationsByPage: a3 }) {
            var _a;
            if (!(e3 instanceof n.Ref)) {
              (0, r.warn)("Cannot save the struct tree: no catalog reference.");
              return false;
            }
            let i2 = 0, s2 = true;
            for (const [e4, o2] of a3) {
              const { ref: a4 } = await t3.getPage(e4);
              if (!(a4 instanceof n.Ref)) {
                (0, r.warn)(`Cannot save the struct tree: page ${e4} has no ref.`);
                s2 = true;
                break;
              }
              for (const e5 of o2) if ((_a = e5.accessibilityData) == null ? void 0 : _a.type) {
                e5.parentTreeId = i2++;
                s2 = false;
              }
            }
            if (s2) {
              for (const e4 of a3.values()) for (const t4 of e4) delete t4.parentTreeId;
              return false;
            }
            return true;
          }
          static async createStructureTree({ newAnnotationsByPage: e3, xref: t3, catalogRef: a3, pdfManager: r2, newRefs: i2 }) {
            const o2 = r2.catalog.cloneDict(), c2 = t3.getNewTemporaryRef();
            o2.set("StructTreeRoot", c2);
            const l2 = [];
            await (0, s.writeObject)(a3, o2, l2, t3);
            i2.push({ ref: a3, data: l2.join("") });
            const h2 = new n.Dict(t3);
            h2.set("Type", n.Name.get("StructTreeRoot"));
            const u2 = t3.getNewTemporaryRef();
            h2.set("ParentTree", u2);
            const d = [];
            h2.set("K", d);
            const f = new n.Dict(t3), g = [];
            f.set("Nums", g);
            const p = await __privateMethod(this, _StructTreeRoot_static, k_fn).call(this, { newAnnotationsByPage: e3, structTreeRootRef: c2, kids: d, nums: g, xref: t3, pdfManager: r2, newRefs: i2, buffer: l2 });
            h2.set("ParentTreeNextKey", p);
            l2.length = 0;
            await (0, s.writeObject)(u2, f, l2, t3);
            i2.push({ ref: u2, data: l2.join("") });
            l2.length = 0;
            await (0, s.writeObject)(c2, h2, l2, t3);
            i2.push({ ref: c2, data: l2.join("") });
          }
          async canUpdateStructTree({ pdfManager: e3, newAnnotationsByPage: t3 }) {
            var _a, _b;
            if (!this.ref) {
              (0, r.warn)("Cannot update the struct tree: no root reference.");
              return false;
            }
            let a3 = this.dict.get("ParentTreeNextKey");
            if (!Number.isInteger(a3) || a3 < 0) {
              (0, r.warn)("Cannot update the struct tree: invalid next key.");
              return false;
            }
            const i2 = this.dict.get("ParentTree");
            if (!(i2 instanceof n.Dict)) {
              (0, r.warn)("Cannot update the struct tree: ParentTree isn't a dict.");
              return false;
            }
            const s2 = i2.get("Nums");
            if (!Array.isArray(s2)) {
              (0, r.warn)("Cannot update the struct tree: nums isn't an array.");
              return false;
            }
            const { numPages: o2 } = e3.catalog;
            for (const a4 of t3.keys()) {
              const { pageDict: t4, ref: i3 } = await e3.getPage(a4);
              if (!(i3 instanceof n.Ref)) {
                (0, r.warn)(`Cannot save the struct tree: page ${a4} has no ref.`);
                return false;
              }
              const s3 = t4.get("StructParents");
              if (!Number.isInteger(s3) || s3 < 0 || s3 >= o2) {
                (0, r.warn)(`Cannot save the struct tree: page ${a4} has no id.`);
                return false;
              }
            }
            let c2 = true;
            for (const [r2, n2] of t3) {
              const { pageDict: t4 } = await e3.getPage(r2);
              __privateMethod(_a = _StructTreeRoot, _StructTreeRoot_static, v_fn).call(_a, { elements: n2, xref: this.dict.xref, pageDict: t4, parentTree: i2 });
              for (const e4 of n2) if ((_b = e4.accessibilityData) == null ? void 0 : _b.type) {
                e4.parentTreeId = a3++;
                c2 = false;
              }
            }
            if (c2) {
              for (const e4 of t3.values()) for (const t4 of e4) {
                delete t4.parentTreeId;
                delete t4.structTreeParent;
              }
              return false;
            }
            return true;
          }
          async updateStructureTree({ newAnnotationsByPage: e3, pdfManager: t3, newRefs: a3 }) {
            var _a;
            const r2 = this.dict.xref, i2 = this.dict.clone(), o2 = this.ref;
            let c2, l2 = i2.getRaw("ParentTree");
            if (l2 instanceof n.Ref) c2 = r2.fetch(l2);
            else {
              c2 = l2;
              l2 = r2.getNewTemporaryRef();
              i2.set("ParentTree", l2);
            }
            c2 = c2.clone();
            let h2 = c2.getRaw("Nums"), u2 = null;
            if (h2 instanceof n.Ref) {
              u2 = h2;
              h2 = r2.fetch(u2);
            }
            h2 = h2.slice();
            u2 || c2.set("Nums", h2);
            let d = i2.getRaw("K"), f = null;
            if (d instanceof n.Ref) {
              f = d;
              d = r2.fetch(f);
            } else {
              f = r2.getNewTemporaryRef();
              i2.set("K", f);
            }
            d = Array.isArray(d) ? d.slice() : [d];
            const g = [], p = await __privateMethod(_a = _StructTreeRoot, _StructTreeRoot_static, k_fn).call(_a, { newAnnotationsByPage: e3, structTreeRootRef: o2, kids: d, nums: h2, xref: r2, pdfManager: t3, newRefs: a3, buffer: g });
            i2.set("ParentTreeNextKey", p);
            g.length = 0;
            await (0, s.writeObject)(f, d, g, r2);
            a3.push({ ref: f, data: g.join("") });
            if (u2) {
              g.length = 0;
              await (0, s.writeObject)(u2, h2, g, r2);
              a3.push({ ref: u2, data: g.join("") });
            }
            g.length = 0;
            await (0, s.writeObject)(l2, c2, g, r2);
            a3.push({ ref: l2, data: g.join("") });
            g.length = 0;
            await (0, s.writeObject)(o2, i2, g, r2);
            a3.push({ ref: o2, data: g.join("") });
          }
        };
        _StructTreeRoot_instances = new WeakSet();
        C_fn = function(e3, t3, a3) {
          if (!(e3 instanceof n.Ref) || t3 < 0) return;
          this.structParentIds || (this.structParentIds = new n.RefSetCache());
          let r2 = this.structParentIds.get(e3);
          if (!r2) {
            r2 = [];
            this.structParentIds.put(e3, r2);
          }
          r2.push([t3, a3]);
        };
        _StructTreeRoot_static = new WeakSet();
        k_fn = async function({ newAnnotationsByPage: e3, structTreeRootRef: t3, kids: a3, nums: r2, xref: i2, pdfManager: o2, newRefs: c2, buffer: l2 }) {
          const h2 = n.Name.get("OBJR");
          let u2 = -1 / 0;
          for (const [d, f] of e3) {
            const { ref: e4 } = await o2.getPage(d);
            for (const { accessibilityData: { type: o3, title: d2, lang: g, alt: p, expanded: m, actualText: b }, ref: y, parentTreeId: w, structTreeParent: S } of f) {
              u2 = Math.max(u2, w);
              const f2 = i2.getNewTemporaryRef(), x = new n.Dict(i2);
              x.set("S", n.Name.get(o3));
              d2 && x.set("T", d2);
              g && x.set("Lang", g);
              p && x.set("Alt", p);
              m && x.set("E", m);
              b && x.set("ActualText", b);
              S ? await __privateMethod(this, _StructTreeRoot_static, F_fn).call(this, { structTreeParent: S, tagDict: x, newTagRef: f2, fallbackRef: t3, xref: i2, newRefs: c2, buffer: l2 }) : x.set("P", t3);
              const C = new n.Dict(i2);
              x.set("K", C);
              C.set("Type", h2);
              C.set("Pg", e4);
              C.set("Obj", y);
              l2.length = 0;
              await (0, s.writeObject)(f2, x, l2, i2);
              c2.push({ ref: f2, data: l2.join("") });
              r2.push(w, f2);
              a3.push(f2);
            }
          }
          return u2 + 1;
        };
        v_fn = function({ elements: e3, xref: t3, pageDict: a3, parentTree: r2 }) {
          const s2 = /* @__PURE__ */ new Map();
          for (const t4 of e3) if (t4.structTreeParentId) {
            const e4 = parseInt(t4.structTreeParentId.split("_mc")[1], 10);
            s2.set(e4, t4);
          }
          const o2 = a3.get("StructParents"), c2 = new i.NumberTree(r2, t3).get(o2);
          if (!Array.isArray(c2)) return;
          const updateElement = (e4, a4, r3) => {
            const i2 = s2.get(e4);
            if (i2) {
              const e5 = a4.getRaw("P"), s3 = t3.fetchIfRef(e5);
              e5 instanceof n.Ref && s3 instanceof n.Dict && (i2.structTreeParent = { ref: r3, dict: a4 });
              return true;
            }
            return false;
          };
          for (const e4 of c2) {
            if (!(e4 instanceof n.Ref)) continue;
            const a4 = t3.fetch(e4), r3 = a4.get("K");
            if (Number.isInteger(r3)) updateElement(r3, a4, e4);
            else if (Array.isArray(r3)) for (let n2 of r3) {
              n2 = t3.fetchIfRef(n2);
              if (Number.isInteger(n2) && updateElement(n2, a4, e4)) break;
            }
          }
        };
        F_fn = async function({ structTreeParent: { ref: e3, dict: t3 }, tagDict: a3, newTagRef: i2, fallbackRef: o2, xref: c2, newRefs: l2, buffer: h2 }) {
          const u2 = t3.getRaw("P");
          let d = c2.fetchIfRef(u2);
          a3.set("P", u2);
          let f, g = false, p = d.getRaw("K");
          if (p instanceof n.Ref) f = c2.fetch(p);
          else {
            f = p;
            p = c2.getNewTemporaryRef();
            d = d.clone();
            d.set("K", p);
            g = true;
          }
          if (Array.isArray(f)) {
            const t4 = f.indexOf(e3);
            if (!(t4 >= 0)) {
              (0, r.warn)("Cannot update the struct tree: parent kid not found.");
              a3.set("P", o2);
              return;
            }
            f = f.slice();
            f.splice(t4 + 1, 0, i2);
          } else if (f instanceof n.Dict) {
            f = [p, i2];
            p = c2.getNewTemporaryRef();
            d.set("K", p);
            g = true;
          }
          h2.length = 0;
          await (0, s.writeObject)(p, f, h2, c2);
          l2.push({ ref: p, data: h2.join("") });
          if (g) {
            h2.length = 0;
            await (0, s.writeObject)(u2, d, h2, c2);
            l2.push({ ref: u2, data: h2.join("") });
          }
        };
        __privateAdd(_StructTreeRoot, _StructTreeRoot_static);
        let StructTreeRoot = _StructTreeRoot;
        t2.StructTreeRoot = StructTreeRoot;
        class StructElementNode {
          constructor(e3, t3) {
            this.tree = e3;
            this.dict = t3;
            this.kids = [];
            this.parseKids();
          }
          get role() {
            const e3 = this.dict.get("S"), t3 = e3 instanceof n.Name ? e3.name : "", { root: a3 } = this.tree;
            return a3.roleMap.has(t3) ? a3.roleMap.get(t3) : t3;
          }
          parseKids() {
            let e3 = null;
            const t3 = this.dict.getRaw("Pg");
            t3 instanceof n.Ref && (e3 = t3.toString());
            const a3 = this.dict.get("K");
            if (Array.isArray(a3)) for (const t4 of a3) {
              const a4 = this.parseKid(e3, t4);
              a4 && this.kids.push(a4);
            }
            else {
              const t4 = this.parseKid(e3, a3);
              t4 && this.kids.push(t4);
            }
          }
          parseKid(e3, t3) {
            if (Number.isInteger(t3)) return this.tree.pageDict.objId !== e3 ? null : new StructElement({ type: o, mcid: t3, pageObjId: e3 });
            let a3 = null;
            t3 instanceof n.Ref ? a3 = this.dict.xref.fetch(t3) : t3 instanceof n.Dict && (a3 = t3);
            if (!a3) return null;
            const r2 = a3.getRaw("Pg");
            r2 instanceof n.Ref && (e3 = r2.toString());
            const i2 = a3.get("Type") instanceof n.Name ? a3.get("Type").name : null;
            if ("MCR" === i2) {
              if (this.tree.pageDict.objId !== e3) return null;
              const t4 = a3.getRaw("Stm");
              return new StructElement({ type: c, refObjId: t4 instanceof n.Ref ? t4.toString() : null, pageObjId: e3, mcid: a3.get("MCID") });
            }
            if ("OBJR" === i2) {
              if (this.tree.pageDict.objId !== e3) return null;
              const t4 = a3.getRaw("Obj");
              return new StructElement({ type: l, refObjId: t4 instanceof n.Ref ? t4.toString() : null, pageObjId: e3 });
            }
            return new StructElement({ type: u, dict: a3 });
          }
        }
        class StructElement {
          constructor({ type: e3, dict: t3 = null, mcid: a3 = null, pageObjId: r2 = null, refObjId: n2 = null }) {
            this.type = e3;
            this.dict = t3;
            this.mcid = a3;
            this.pageObjId = r2;
            this.refObjId = n2;
            this.parentNode = null;
          }
        }
        t2.StructTreePage = class StructTreePage {
          constructor(e3, t3) {
            this.root = e3;
            this.rootDict = e3 ? e3.dict : null;
            this.pageDict = t3;
            this.nodes = [];
          }
          parse(e3) {
            var _a, _b;
            if (!this.root || !this.rootDict) return;
            const t3 = this.rootDict.get("ParentTree");
            if (!t3) return;
            const a3 = this.pageDict.get("StructParents"), r2 = e3 instanceof n.Ref && ((_a = this.root.structParentIds) == null ? void 0 : _a.get(e3));
            if (!Number.isInteger(a3) && !r2) return;
            const s2 = /* @__PURE__ */ new Map(), o2 = new i.NumberTree(t3, this.rootDict.xref);
            if (Number.isInteger(a3)) {
              const e4 = o2.get(a3);
              if (Array.isArray(e4)) for (const t4 of e4) t4 instanceof n.Ref && this.addNode(this.rootDict.xref.fetch(t4), s2);
            }
            if (r2) for (const [e4, t4] of r2) {
              const a4 = o2.get(e4);
              if (a4) {
                const e5 = this.addNode(this.rootDict.xref.fetchIfRef(a4), s2);
                1 === ((_b = e5 == null ? void 0 : e5.kids) == null ? void 0 : _b.length) && e5.kids[0].type === l && (e5.kids[0].type = t4);
              }
            }
          }
          addNode(e3, t3, a3 = 0) {
            if (a3 > 40) {
              (0, r.warn)("StructTree MAX_DEPTH reached.");
              return null;
            }
            if (t3.has(e3)) return t3.get(e3);
            const i2 = new StructElementNode(this, e3);
            t3.set(e3, i2);
            const s2 = e3.get("P");
            if (!s2 || (0, n.isName)(s2.get("Type"), "StructTreeRoot")) {
              this.addTopLevelNode(e3, i2) || t3.delete(e3);
              return i2;
            }
            const o2 = this.addNode(s2, t3, a3 + 1);
            if (!o2) return i2;
            let c2 = false;
            for (const t4 of o2.kids) if (t4.type === u && t4.dict === e3) {
              t4.parentNode = i2;
              c2 = true;
            }
            c2 || t3.delete(e3);
            return i2;
          }
          addTopLevelNode(e3, t3) {
            const a3 = this.rootDict.get("K");
            if (!a3) return false;
            if (a3 instanceof n.Dict) {
              if (a3.objId !== e3.objId) return false;
              this.nodes[0] = t3;
              return true;
            }
            if (!Array.isArray(a3)) return true;
            let r2 = false;
            for (let n2 = 0; n2 < a3.length; n2++) {
              const i2 = a3[n2];
              if ((i2 == null ? void 0 : i2.toString()) === e3.objId) {
                this.nodes[n2] = t3;
                r2 = true;
              }
            }
            return r2;
          }
          get serializable() {
            function nodeToSerializable(e4, t3, a3 = 0) {
              if (a3 > 40) {
                (0, r.warn)("StructTree too deep to be fully serialized.");
                return;
              }
              const n2 = /* @__PURE__ */ Object.create(null);
              n2.role = e4.role;
              n2.children = [];
              t3.children.push(n2);
              const i2 = e4.dict.get("Alt");
              "string" == typeof i2 && (n2.alt = (0, r.stringToPDFString)(i2));
              const s2 = e4.dict.get("Lang");
              "string" == typeof s2 && (n2.lang = (0, r.stringToPDFString)(s2));
              for (const t4 of e4.kids) {
                const e5 = t4.type === u ? t4.parentNode : null;
                e5 ? nodeToSerializable(e5, n2, a3 + 1) : t4.type === o || t4.type === c ? n2.children.push({ type: "content", id: `p${t4.pageObjId}_mc${t4.mcid}` }) : t4.type === l ? n2.children.push({ type: "object", id: t4.refObjId }) : t4.type === h && n2.children.push({ type: "annotation", id: `${r.AnnotationPrefix}${t4.refObjId}` });
              }
            }
            const e3 = /* @__PURE__ */ Object.create(null);
            e3.children = [];
            e3.role = "Root";
            for (const t3 of this.nodes) t3 && nodeToSerializable(t3, e3);
            return e3;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.incrementalUpdate = async function incrementalUpdate({ originalData: e3, xrefInfo: t3, newRefs: a3, xref: o2 = null, hasXfa: l = false, xfaDatasetsRef: h = null, hasXfaDatasetsEntry: u = false, needAppearances: d, acroFormRef: f = null, acroForm: g = null, xfaData: p = null }) {
          await async function updateAcroform({ xref: e4, acroForm: t4, acroFormRef: a4, hasXfa: n2, hasXfaDatasetsEntry: i2, xfaDatasetsRef: s2, needAppearances: o3, newRefs: c2 }) {
            !n2 || i2 || s2 || (0, r.warn)("XFA - Cannot save it");
            if (!o3 && (!n2 || !s2 || i2)) return;
            const l2 = t4.clone();
            if (n2 && !i2) {
              const e5 = t4.get("XFA").slice();
              e5.splice(2, 0, "datasets");
              e5.splice(3, 0, s2);
              l2.set("XFA", e5);
            }
            o3 && l2.set("NeedAppearances", true);
            const h2 = [];
            await writeObject(a4, l2, h2, e4);
            c2.push({ ref: a4, data: h2.join("") });
          }({ xref: o2, acroForm: g, acroFormRef: f, hasXfa: l, hasXfaDatasetsEntry: u, xfaDatasetsRef: h, needAppearances: d, newRefs: a3 });
          l && function updateXFA({ xfaData: e4, xfaDatasetsRef: t4, newRefs: a4, xref: n2 }) {
            if (null === e4) {
              e4 = function writeXFADataForAcroform(e5, t5) {
                const a5 = new s.SimpleXMLParser({ hasAttributes: true }).parseFromString(e5);
                for (const { xfa: e6 } of t5) {
                  if (!e6) continue;
                  const { path: t6, value: n4 } = e6;
                  if (!t6) continue;
                  const o4 = (0, i.parseXFAPath)(t6);
                  let c3 = a5.documentElement.searchNode(o4, 0);
                  !c3 && o4.length > 1 && (c3 = a5.documentElement.searchNode([o4.at(-1)], 0));
                  c3 ? c3.childNodes = Array.isArray(n4) ? n4.map((e7) => new s.SimpleDOMNode("value", e7)) : [new s.SimpleDOMNode("#text", n4)] : (0, r.warn)(`Node not found for path: ${t6}`);
                }
                const n3 = [];
                a5.documentElement.dump(n3);
                return n3.join("");
              }(n2.fetchIfRef(t4).getString(), a4);
            }
            const o3 = n2.encrypt;
            if (o3) {
              e4 = o3.createCipherTransform(t4.num, t4.gen).encryptString(e4);
            }
            const c2 = `${t4.num} ${t4.gen} obj
<< /Type /EmbeddedFile /Length ${e4.length}>>
stream
` + e4 + "\nendstream\nendobj\n";
            a4.push({ ref: t4, data: c2 });
          }({ xfaData: p, xfaDatasetsRef: h, newRefs: a3, xref: o2 });
          const m = new n.Dict(null), b = t3.newRef;
          let y, w;
          const S = e3.at(-1);
          if (10 === S || 13 === S) {
            y = [];
            w = e3.length;
          } else {
            y = ["\n"];
            w = e3.length + 1;
          }
          m.set("Size", b.num + 1);
          m.set("Prev", t3.startXRef);
          m.set("Type", n.Name.get("XRef"));
          null !== t3.rootRef && m.set("Root", t3.rootRef);
          null !== t3.infoRef && m.set("Info", t3.infoRef);
          null !== t3.encryptRef && m.set("Encrypt", t3.encryptRef);
          a3.push({ ref: b, data: "" });
          a3 = a3.sort((e4, t4) => e4.ref.num - t4.ref.num);
          const x = [[0, 1, 65535]], C = [0, 1];
          let k = 0;
          for (const { ref: e4, data: t4 } of a3) {
            k = Math.max(k, w);
            x.push([1, w, Math.min(e4.gen, 65535)]);
            w += t4.length;
            C.push(e4.num, 1);
            y.push(t4);
          }
          m.set("Index", C);
          if (Array.isArray(t3.fileIds) && t3.fileIds.length > 0) {
            const e4 = function computeMD5(e5, t4) {
              const a4 = Math.floor(Date.now() / 1e3), n2 = t4.filename || "", i2 = [a4.toString(), n2, e5.toString()];
              let s2 = i2.reduce((e6, t5) => e6 + t5.length, 0);
              for (const e6 of Object.values(t4.info)) {
                i2.push(e6);
                s2 += e6.length;
              }
              const o3 = new Uint8Array(s2);
              let l2 = 0;
              for (const e6 of i2) {
                writeString(e6, l2, o3);
                l2 += e6.length;
              }
              return (0, r.bytesToString)((0, c.calculateMD5)(o3));
            }(w, t3);
            m.set("ID", [t3.fileIds[0], e4]);
          }
          const v = [1, Math.ceil(Math.log2(k) / 8), 2], F = (v[0] + v[1] + v[2]) * x.length;
          m.set("W", v);
          m.set("Length", F);
          y.push(`${b.num} ${b.gen} obj
`);
          await writeDict(m, y, null);
          y.push(" stream\n");
          const O = y.reduce((e4, t4) => e4 + t4.length, 0), T = `
endstream
endobj
startxref
${w}
%%EOF
`, M = new Uint8Array(e3.length + O + F + T.length);
          M.set(e3);
          let D = e3.length;
          for (const e4 of y) {
            writeString(e4, D, M);
            D += e4.length;
          }
          for (const [e4, t4, a4] of x) {
            D = writeInt(e4, v[0], D, M);
            D = writeInt(t4, v[1], D, M);
            D = writeInt(a4, v[2], D, M);
          }
          writeString(T, D, M);
          return M;
        };
        t2.writeDict = writeDict;
        t2.writeObject = writeObject;
        var r = a2(2), n = a2(4), i = a2(3), s = a2(71), o = a2(5), c = a2(74);
        async function writeObject(e3, t3, a3, { encrypt: r2 = null }) {
          const i2 = r2 == null ? void 0 : r2.createCipherTransform(e3.num, e3.gen);
          a3.push(`${e3.num} ${e3.gen} obj
`);
          t3 instanceof n.Dict ? await writeDict(t3, a3, i2) : t3 instanceof o.BaseStream ? await writeStream(t3, a3, i2) : Array.isArray(t3) && await writeArray(t3, a3, i2);
          a3.push("\nendobj\n");
        }
        async function writeDict(e3, t3, a3) {
          t3.push("<<");
          for (const r2 of e3.getKeys()) {
            t3.push(` /${(0, i.escapePDFName)(r2)} `);
            await writeValue(e3.getRaw(r2), t3, a3);
          }
          t3.push(">>");
        }
        async function writeStream(e3, t3, a3) {
          let i2 = e3.getString();
          const { dict: s2 } = e3, [o2, c2] = await Promise.all([s2.getAsync("Filter"), s2.getAsync("DecodeParms")]), l = Array.isArray(o2) ? await s2.xref.fetchIfRefAsync(o2[0]) : o2, h = (0, n.isName)(l, "FlateDecode");
          if ("undefined" != typeof CompressionStream && (i2.length >= 256 || h)) try {
            const e4 = (0, r.stringToBytes)(i2), t4 = new CompressionStream("deflate"), a4 = t4.writable.getWriter();
            a4.write(e4);
            a4.close();
            const l2 = await new Response(t4.readable).arrayBuffer();
            i2 = (0, r.bytesToString)(new Uint8Array(l2));
            let u, d;
            if (o2) {
              if (!h) {
                u = Array.isArray(o2) ? [n.Name.get("FlateDecode"), ...o2] : [n.Name.get("FlateDecode"), o2];
                c2 && (d = Array.isArray(c2) ? [null, ...c2] : [null, c2]);
              }
            } else u = n.Name.get("FlateDecode");
            u && s2.set("Filter", u);
            d && s2.set("DecodeParms", d);
          } catch (e4) {
            (0, r.info)(`writeStream - cannot compress data: "${e4}".`);
          }
          a3 && (i2 = a3.encryptString(i2));
          s2.set("Length", i2.length);
          await writeDict(s2, t3, a3);
          t3.push(" stream\n", i2, "\nendstream");
        }
        async function writeArray(e3, t3, a3) {
          t3.push("[");
          let r2 = true;
          for (const n2 of e3) {
            r2 ? r2 = false : t3.push(" ");
            await writeValue(n2, t3, a3);
          }
          t3.push("]");
        }
        async function writeValue(e3, t3, a3) {
          if (e3 instanceof n.Name) t3.push(`/${(0, i.escapePDFName)(e3.name)}`);
          else if (e3 instanceof n.Ref) t3.push(`${e3.num} ${e3.gen} R`);
          else if (Array.isArray(e3)) await writeArray(e3, t3, a3);
          else if ("string" == typeof e3) {
            a3 && (e3 = a3.encryptString(e3));
            t3.push(`(${(0, i.escapeString)(e3)})`);
          } else "number" == typeof e3 ? t3.push((0, i.numberToString)(e3)) : "boolean" == typeof e3 ? t3.push(e3.toString()) : e3 instanceof n.Dict ? await writeDict(e3, t3, a3) : e3 instanceof o.BaseStream ? await writeStream(e3, t3, a3) : null === e3 ? t3.push("null") : (0, r.warn)(`Unhandled value in writer: ${typeof e3}, please file a bug.`);
        }
        function writeInt(e3, t3, a3, r2) {
          for (let n2 = t3 + a3 - 1; n2 > a3 - 1; n2--) {
            r2[n2] = 255 & e3;
            e3 >>= 8;
          }
          return a3 + t3;
        }
        function writeString(e3, t3, a3) {
          for (let r2 = 0, n2 = e3.length; r2 < n2; r2++) a3[t3 + r2] = 255 & e3.charCodeAt(r2);
        }
      }, (e2, t2, a2) => {
        var _O, _CipherTransformFactory_instances, I_fn, T_fn, M_fn, P_fn, D_fn;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.calculateSHA256 = t2.calculateMD5 = t2.PDF20 = t2.PDF17 = t2.CipherTransformFactory = t2.ARCFourCipher = t2.AES256Cipher = t2.AES128Cipher = void 0;
        t2.calculateSHA384 = calculateSHA384;
        t2.calculateSHA512 = void 0;
        var r = a2(2), n = a2(4), i = a2(75);
        class ARCFourCipher {
          constructor(e3) {
            this.a = 0;
            this.b = 0;
            const t3 = new Uint8Array(256), a3 = e3.length;
            for (let e4 = 0; e4 < 256; ++e4) t3[e4] = e4;
            for (let r2 = 0, n2 = 0; r2 < 256; ++r2) {
              const i2 = t3[r2];
              n2 = n2 + i2 + e3[r2 % a3] & 255;
              t3[r2] = t3[n2];
              t3[n2] = i2;
            }
            this.s = t3;
          }
          encryptBlock(e3) {
            let t3 = this.a, a3 = this.b;
            const r2 = this.s, n2 = e3.length, i2 = new Uint8Array(n2);
            for (let s2 = 0; s2 < n2; ++s2) {
              t3 = t3 + 1 & 255;
              const n3 = r2[t3];
              a3 = a3 + n3 & 255;
              const o2 = r2[a3];
              r2[t3] = o2;
              r2[a3] = n3;
              i2[s2] = e3[s2] ^ r2[n3 + o2 & 255];
            }
            this.a = t3;
            this.b = a3;
            return i2;
          }
          decryptBlock(e3) {
            return this.encryptBlock(e3);
          }
          encrypt(e3) {
            return this.encryptBlock(e3);
          }
        }
        t2.ARCFourCipher = ARCFourCipher;
        const s = function calculateMD5Closure() {
          const e3 = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t3 = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
          return function hash(a3, r2, n2) {
            let i2 = 1732584193, s2 = -271733879, o2 = -1732584194, c2 = 271733878;
            const l = n2 + 72 & -64, h = new Uint8Array(l);
            let u, d;
            for (u = 0; u < n2; ++u) h[u] = a3[r2++];
            h[u++] = 128;
            const f = l - 8;
            for (; u < f; ) h[u++] = 0;
            h[u++] = n2 << 3 & 255;
            h[u++] = n2 >> 5 & 255;
            h[u++] = n2 >> 13 & 255;
            h[u++] = n2 >> 21 & 255;
            h[u++] = n2 >>> 29 & 255;
            h[u++] = 0;
            h[u++] = 0;
            h[u++] = 0;
            const g = new Int32Array(16);
            for (u = 0; u < l; ) {
              for (d = 0; d < 16; ++d, u += 4) g[d] = h[u] | h[u + 1] << 8 | h[u + 2] << 16 | h[u + 3] << 24;
              let a4, r3, n3 = i2, l2 = s2, f2 = o2, p = c2;
              for (d = 0; d < 64; ++d) {
                if (d < 16) {
                  a4 = l2 & f2 | ~l2 & p;
                  r3 = d;
                } else if (d < 32) {
                  a4 = p & l2 | ~p & f2;
                  r3 = 5 * d + 1 & 15;
                } else if (d < 48) {
                  a4 = l2 ^ f2 ^ p;
                  r3 = 3 * d + 5 & 15;
                } else {
                  a4 = f2 ^ (l2 | ~p);
                  r3 = 7 * d & 15;
                }
                const i3 = p, s3 = n3 + a4 + t3[d] + g[r3] | 0, o3 = e3[d];
                p = f2;
                f2 = l2;
                l2 = l2 + (s3 << o3 | s3 >>> 32 - o3) | 0;
                n3 = i3;
              }
              i2 = i2 + n3 | 0;
              s2 = s2 + l2 | 0;
              o2 = o2 + f2 | 0;
              c2 = c2 + p | 0;
            }
            return new Uint8Array([255 & i2, i2 >> 8 & 255, i2 >> 16 & 255, i2 >>> 24 & 255, 255 & s2, s2 >> 8 & 255, s2 >> 16 & 255, s2 >>> 24 & 255, 255 & o2, o2 >> 8 & 255, o2 >> 16 & 255, o2 >>> 24 & 255, 255 & c2, c2 >> 8 & 255, c2 >> 16 & 255, c2 >>> 24 & 255]);
          };
        }();
        t2.calculateMD5 = s;
        class Word64 {
          constructor(e3, t3) {
            this.high = 0 | e3;
            this.low = 0 | t3;
          }
          and(e3) {
            this.high &= e3.high;
            this.low &= e3.low;
          }
          xor(e3) {
            this.high ^= e3.high;
            this.low ^= e3.low;
          }
          or(e3) {
            this.high |= e3.high;
            this.low |= e3.low;
          }
          shiftRight(e3) {
            if (e3 >= 32) {
              this.low = this.high >>> e3 - 32 | 0;
              this.high = 0;
            } else {
              this.low = this.low >>> e3 | this.high << 32 - e3;
              this.high = this.high >>> e3 | 0;
            }
          }
          shiftLeft(e3) {
            if (e3 >= 32) {
              this.high = this.low << e3 - 32;
              this.low = 0;
            } else {
              this.high = this.high << e3 | this.low >>> 32 - e3;
              this.low <<= e3;
            }
          }
          rotateRight(e3) {
            let t3, a3;
            if (32 & e3) {
              a3 = this.low;
              t3 = this.high;
            } else {
              t3 = this.low;
              a3 = this.high;
            }
            e3 &= 31;
            this.low = t3 >>> e3 | a3 << 32 - e3;
            this.high = a3 >>> e3 | t3 << 32 - e3;
          }
          not() {
            this.high = ~this.high;
            this.low = ~this.low;
          }
          add(e3) {
            const t3 = (this.low >>> 0) + (e3.low >>> 0);
            let a3 = (this.high >>> 0) + (e3.high >>> 0);
            t3 > 4294967295 && (a3 += 1);
            this.low = 0 | t3;
            this.high = 0 | a3;
          }
          copyTo(e3, t3) {
            e3[t3] = this.high >>> 24 & 255;
            e3[t3 + 1] = this.high >> 16 & 255;
            e3[t3 + 2] = this.high >> 8 & 255;
            e3[t3 + 3] = 255 & this.high;
            e3[t3 + 4] = this.low >>> 24 & 255;
            e3[t3 + 5] = this.low >> 16 & 255;
            e3[t3 + 6] = this.low >> 8 & 255;
            e3[t3 + 7] = 255 & this.low;
          }
          assign(e3) {
            this.high = e3.high;
            this.low = e3.low;
          }
        }
        const o = /* @__PURE__ */ function calculateSHA256Closure() {
          function rotr(e4, t3) {
            return e4 >>> t3 | e4 << 32 - t3;
          }
          function ch(e4, t3, a3) {
            return e4 & t3 ^ ~e4 & a3;
          }
          function maj(e4, t3, a3) {
            return e4 & t3 ^ e4 & a3 ^ t3 & a3;
          }
          function sigma(e4) {
            return rotr(e4, 2) ^ rotr(e4, 13) ^ rotr(e4, 22);
          }
          function sigmaPrime(e4) {
            return rotr(e4, 6) ^ rotr(e4, 11) ^ rotr(e4, 25);
          }
          function littleSigma(e4) {
            return rotr(e4, 7) ^ rotr(e4, 18) ^ e4 >>> 3;
          }
          const e3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
          return function hash(t3, a3, r2) {
            let n2 = 1779033703, i2 = 3144134277, s2 = 1013904242, o2 = 2773480762, c2 = 1359893119, l = 2600822924, h = 528734635, u = 1541459225;
            const d = 64 * Math.ceil((r2 + 9) / 64), f = new Uint8Array(d);
            let g, p;
            for (g = 0; g < r2; ++g) f[g] = t3[a3++];
            f[g++] = 128;
            const m = d - 8;
            for (; g < m; ) f[g++] = 0;
            f[g++] = 0;
            f[g++] = 0;
            f[g++] = 0;
            f[g++] = r2 >>> 29 & 255;
            f[g++] = r2 >> 21 & 255;
            f[g++] = r2 >> 13 & 255;
            f[g++] = r2 >> 5 & 255;
            f[g++] = r2 << 3 & 255;
            const b = new Uint32Array(64);
            for (g = 0; g < d; ) {
              for (p = 0; p < 16; ++p) {
                b[p] = f[g] << 24 | f[g + 1] << 16 | f[g + 2] << 8 | f[g + 3];
                g += 4;
              }
              for (p = 16; p < 64; ++p) b[p] = (rotr(y = b[p - 2], 17) ^ rotr(y, 19) ^ y >>> 10) + b[p - 7] + littleSigma(b[p - 15]) + b[p - 16] | 0;
              let t4, a4, r3 = n2, d2 = i2, m2 = s2, w = o2, S = c2, x = l, C = h, k = u;
              for (p = 0; p < 64; ++p) {
                t4 = k + sigmaPrime(S) + ch(S, x, C) + e3[p] + b[p];
                a4 = sigma(r3) + maj(r3, d2, m2);
                k = C;
                C = x;
                x = S;
                S = w + t4 | 0;
                w = m2;
                m2 = d2;
                d2 = r3;
                r3 = t4 + a4 | 0;
              }
              n2 = n2 + r3 | 0;
              i2 = i2 + d2 | 0;
              s2 = s2 + m2 | 0;
              o2 = o2 + w | 0;
              c2 = c2 + S | 0;
              l = l + x | 0;
              h = h + C | 0;
              u = u + k | 0;
            }
            var y;
            return new Uint8Array([n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, 255 & i2, s2 >> 24 & 255, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, o2 >> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u]);
          };
        }();
        t2.calculateSHA256 = o;
        const c = function calculateSHA512Closure() {
          function ch(e4, t3, a3, r2, n2) {
            e4.assign(t3);
            e4.and(a3);
            n2.assign(t3);
            n2.not();
            n2.and(r2);
            e4.xor(n2);
          }
          function maj(e4, t3, a3, r2, n2) {
            e4.assign(t3);
            e4.and(a3);
            n2.assign(t3);
            n2.and(r2);
            e4.xor(n2);
            n2.assign(a3);
            n2.and(r2);
            e4.xor(n2);
          }
          function sigma(e4, t3, a3) {
            e4.assign(t3);
            e4.rotateRight(28);
            a3.assign(t3);
            a3.rotateRight(34);
            e4.xor(a3);
            a3.assign(t3);
            a3.rotateRight(39);
            e4.xor(a3);
          }
          function sigmaPrime(e4, t3, a3) {
            e4.assign(t3);
            e4.rotateRight(14);
            a3.assign(t3);
            a3.rotateRight(18);
            e4.xor(a3);
            a3.assign(t3);
            a3.rotateRight(41);
            e4.xor(a3);
          }
          function littleSigma(e4, t3, a3) {
            e4.assign(t3);
            e4.rotateRight(1);
            a3.assign(t3);
            a3.rotateRight(8);
            e4.xor(a3);
            a3.assign(t3);
            a3.shiftRight(7);
            e4.xor(a3);
          }
          function littleSigmaPrime(e4, t3, a3) {
            e4.assign(t3);
            e4.rotateRight(19);
            a3.assign(t3);
            a3.rotateRight(61);
            e4.xor(a3);
            a3.assign(t3);
            a3.shiftRight(6);
            e4.xor(a3);
          }
          const e3 = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
          return function hash(t3, a3, r2, n2 = false) {
            let i2, s2, o2, c2, l, h, u, d;
            if (n2) {
              i2 = new Word64(3418070365, 3238371032);
              s2 = new Word64(1654270250, 914150663);
              o2 = new Word64(2438529370, 812702999);
              c2 = new Word64(355462360, 4144912697);
              l = new Word64(1731405415, 4290775857);
              h = new Word64(2394180231, 1750603025);
              u = new Word64(3675008525, 1694076839);
              d = new Word64(1203062813, 3204075428);
            } else {
              i2 = new Word64(1779033703, 4089235720);
              s2 = new Word64(3144134277, 2227873595);
              o2 = new Word64(1013904242, 4271175723);
              c2 = new Word64(2773480762, 1595750129);
              l = new Word64(1359893119, 2917565137);
              h = new Word64(2600822924, 725511199);
              u = new Word64(528734635, 4215389547);
              d = new Word64(1541459225, 327033209);
            }
            const f = 128 * Math.ceil((r2 + 17) / 128), g = new Uint8Array(f);
            let p, m;
            for (p = 0; p < r2; ++p) g[p] = t3[a3++];
            g[p++] = 128;
            const b = f - 16;
            for (; p < b; ) g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = 0;
            g[p++] = r2 >>> 29 & 255;
            g[p++] = r2 >> 21 & 255;
            g[p++] = r2 >> 13 & 255;
            g[p++] = r2 >> 5 & 255;
            g[p++] = r2 << 3 & 255;
            const y = new Array(80);
            for (p = 0; p < 80; p++) y[p] = new Word64(0, 0);
            let w = new Word64(0, 0), S = new Word64(0, 0), x = new Word64(0, 0), C = new Word64(0, 0), k = new Word64(0, 0), v = new Word64(0, 0), F = new Word64(0, 0), O = new Word64(0, 0);
            const T = new Word64(0, 0), M = new Word64(0, 0), D = new Word64(0, 0), E = new Word64(0, 0);
            let N, R;
            for (p = 0; p < f; ) {
              for (m = 0; m < 16; ++m) {
                y[m].high = g[p] << 24 | g[p + 1] << 16 | g[p + 2] << 8 | g[p + 3];
                y[m].low = g[p + 4] << 24 | g[p + 5] << 16 | g[p + 6] << 8 | g[p + 7];
                p += 8;
              }
              for (m = 16; m < 80; ++m) {
                N = y[m];
                littleSigmaPrime(N, y[m - 2], E);
                N.add(y[m - 7]);
                littleSigma(D, y[m - 15], E);
                N.add(D);
                N.add(y[m - 16]);
              }
              w.assign(i2);
              S.assign(s2);
              x.assign(o2);
              C.assign(c2);
              k.assign(l);
              v.assign(h);
              F.assign(u);
              O.assign(d);
              for (m = 0; m < 80; ++m) {
                T.assign(O);
                sigmaPrime(D, k, E);
                T.add(D);
                ch(D, k, v, F, E);
                T.add(D);
                T.add(e3[m]);
                T.add(y[m]);
                sigma(M, w, E);
                maj(D, w, S, x, E);
                M.add(D);
                N = O;
                O = F;
                F = v;
                v = k;
                C.add(T);
                k = C;
                C = x;
                x = S;
                S = w;
                N.assign(T);
                N.add(M);
                w = N;
              }
              i2.add(w);
              s2.add(S);
              o2.add(x);
              c2.add(C);
              l.add(k);
              h.add(v);
              u.add(F);
              d.add(O);
            }
            if (n2) {
              R = new Uint8Array(48);
              i2.copyTo(R, 0);
              s2.copyTo(R, 8);
              o2.copyTo(R, 16);
              c2.copyTo(R, 24);
              l.copyTo(R, 32);
              h.copyTo(R, 40);
            } else {
              R = new Uint8Array(64);
              i2.copyTo(R, 0);
              s2.copyTo(R, 8);
              o2.copyTo(R, 16);
              c2.copyTo(R, 24);
              l.copyTo(R, 32);
              h.copyTo(R, 40);
              u.copyTo(R, 48);
              d.copyTo(R, 56);
            }
            return R;
          };
        }();
        t2.calculateSHA512 = c;
        function calculateSHA384(e3, t3, a3) {
          return c(e3, t3, a3, true);
        }
        class NullCipher {
          decryptBlock(e3) {
            return e3;
          }
          encrypt(e3) {
            return e3;
          }
        }
        class AESBaseCipher {
          constructor() {
            this.constructor === AESBaseCipher && (0, r.unreachable)("Cannot initialize AESBaseCipher.");
            this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
            this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
            this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
            this._mixCol = new Uint8Array(256);
            for (let e3 = 0; e3 < 256; e3++) this._mixCol[e3] = e3 < 128 ? e3 << 1 : e3 << 1 ^ 27;
            this.buffer = new Uint8Array(16);
            this.bufferPosition = 0;
          }
          _expandKey(e3) {
            (0, r.unreachable)("Cannot call `_expandKey` on the base class");
          }
          _decrypt(e3, t3) {
            let a3, r2, n2;
            const i2 = new Uint8Array(16);
            i2.set(e3);
            for (let e4 = 0, a4 = this._keySize; e4 < 16; ++e4, ++a4) i2[e4] ^= t3[a4];
            for (let e4 = this._cyclesOfRepetition - 1; e4 >= 1; --e4) {
              a3 = i2[13];
              i2[13] = i2[9];
              i2[9] = i2[5];
              i2[5] = i2[1];
              i2[1] = a3;
              a3 = i2[14];
              r2 = i2[10];
              i2[14] = i2[6];
              i2[10] = i2[2];
              i2[6] = a3;
              i2[2] = r2;
              a3 = i2[15];
              r2 = i2[11];
              n2 = i2[7];
              i2[15] = i2[3];
              i2[11] = a3;
              i2[7] = r2;
              i2[3] = n2;
              for (let e5 = 0; e5 < 16; ++e5) i2[e5] = this._inv_s[i2[e5]];
              for (let a4 = 0, r3 = 16 * e4; a4 < 16; ++a4, ++r3) i2[a4] ^= t3[r3];
              for (let e5 = 0; e5 < 16; e5 += 4) {
                const t4 = this._mix[i2[e5]], r3 = this._mix[i2[e5 + 1]], n3 = this._mix[i2[e5 + 2]], s2 = this._mix[i2[e5 + 3]];
                a3 = t4 ^ r3 >>> 8 ^ r3 << 24 ^ n3 >>> 16 ^ n3 << 16 ^ s2 >>> 24 ^ s2 << 8;
                i2[e5] = a3 >>> 24 & 255;
                i2[e5 + 1] = a3 >> 16 & 255;
                i2[e5 + 2] = a3 >> 8 & 255;
                i2[e5 + 3] = 255 & a3;
              }
            }
            a3 = i2[13];
            i2[13] = i2[9];
            i2[9] = i2[5];
            i2[5] = i2[1];
            i2[1] = a3;
            a3 = i2[14];
            r2 = i2[10];
            i2[14] = i2[6];
            i2[10] = i2[2];
            i2[6] = a3;
            i2[2] = r2;
            a3 = i2[15];
            r2 = i2[11];
            n2 = i2[7];
            i2[15] = i2[3];
            i2[11] = a3;
            i2[7] = r2;
            i2[3] = n2;
            for (let e4 = 0; e4 < 16; ++e4) {
              i2[e4] = this._inv_s[i2[e4]];
              i2[e4] ^= t3[e4];
            }
            return i2;
          }
          _encrypt(e3, t3) {
            const a3 = this._s;
            let r2, n2, i2;
            const s2 = new Uint8Array(16);
            s2.set(e3);
            for (let e4 = 0; e4 < 16; ++e4) s2[e4] ^= t3[e4];
            for (let e4 = 1; e4 < this._cyclesOfRepetition; e4++) {
              for (let e5 = 0; e5 < 16; ++e5) s2[e5] = a3[s2[e5]];
              i2 = s2[1];
              s2[1] = s2[5];
              s2[5] = s2[9];
              s2[9] = s2[13];
              s2[13] = i2;
              i2 = s2[2];
              n2 = s2[6];
              s2[2] = s2[10];
              s2[6] = s2[14];
              s2[10] = i2;
              s2[14] = n2;
              i2 = s2[3];
              n2 = s2[7];
              r2 = s2[11];
              s2[3] = s2[15];
              s2[7] = i2;
              s2[11] = n2;
              s2[15] = r2;
              for (let e5 = 0; e5 < 16; e5 += 4) {
                const t4 = s2[e5 + 0], a4 = s2[e5 + 1], n3 = s2[e5 + 2], i3 = s2[e5 + 3];
                r2 = t4 ^ a4 ^ n3 ^ i3;
                s2[e5 + 0] ^= r2 ^ this._mixCol[t4 ^ a4];
                s2[e5 + 1] ^= r2 ^ this._mixCol[a4 ^ n3];
                s2[e5 + 2] ^= r2 ^ this._mixCol[n3 ^ i3];
                s2[e5 + 3] ^= r2 ^ this._mixCol[i3 ^ t4];
              }
              for (let a4 = 0, r3 = 16 * e4; a4 < 16; ++a4, ++r3) s2[a4] ^= t3[r3];
            }
            for (let e4 = 0; e4 < 16; ++e4) s2[e4] = a3[s2[e4]];
            i2 = s2[1];
            s2[1] = s2[5];
            s2[5] = s2[9];
            s2[9] = s2[13];
            s2[13] = i2;
            i2 = s2[2];
            n2 = s2[6];
            s2[2] = s2[10];
            s2[6] = s2[14];
            s2[10] = i2;
            s2[14] = n2;
            i2 = s2[3];
            n2 = s2[7];
            r2 = s2[11];
            s2[3] = s2[15];
            s2[7] = i2;
            s2[11] = n2;
            s2[15] = r2;
            for (let e4 = 0, a4 = this._keySize; e4 < 16; ++e4, ++a4) s2[e4] ^= t3[a4];
            return s2;
          }
          _decryptBlock2(e3, t3) {
            const a3 = e3.length;
            let r2 = this.buffer, n2 = this.bufferPosition;
            const i2 = [];
            let s2 = this.iv;
            for (let t4 = 0; t4 < a3; ++t4) {
              r2[n2] = e3[t4];
              ++n2;
              if (n2 < 16) continue;
              const a4 = this._decrypt(r2, this._key);
              for (let e4 = 0; e4 < 16; ++e4) a4[e4] ^= s2[e4];
              s2 = r2;
              i2.push(a4);
              r2 = new Uint8Array(16);
              n2 = 0;
            }
            this.buffer = r2;
            this.bufferLength = n2;
            this.iv = s2;
            if (0 === i2.length) return new Uint8Array(0);
            let o2 = 16 * i2.length;
            if (t3) {
              const e4 = i2.at(-1);
              let t4 = e4[15];
              if (t4 <= 16) {
                for (let a4 = 15, r3 = 16 - t4; a4 >= r3; --a4) if (e4[a4] !== t4) {
                  t4 = 0;
                  break;
                }
                o2 -= t4;
                i2[i2.length - 1] = e4.subarray(0, 16 - t4);
              }
            }
            const c2 = new Uint8Array(o2);
            for (let e4 = 0, t4 = 0, a4 = i2.length; e4 < a4; ++e4, t4 += 16) c2.set(i2[e4], t4);
            return c2;
          }
          decryptBlock(e3, t3, a3 = null) {
            const r2 = e3.length, n2 = this.buffer;
            let i2 = this.bufferPosition;
            if (a3) this.iv = a3;
            else {
              for (let t4 = 0; i2 < 16 && t4 < r2; ++t4, ++i2) n2[i2] = e3[t4];
              if (i2 < 16) {
                this.bufferLength = i2;
                return new Uint8Array(0);
              }
              this.iv = n2;
              e3 = e3.subarray(16);
            }
            this.buffer = new Uint8Array(16);
            this.bufferLength = 0;
            this.decryptBlock = this._decryptBlock2;
            return this.decryptBlock(e3, t3);
          }
          encrypt(e3, t3) {
            const a3 = e3.length;
            let r2 = this.buffer, n2 = this.bufferPosition;
            const i2 = [];
            t3 || (t3 = new Uint8Array(16));
            for (let s3 = 0; s3 < a3; ++s3) {
              r2[n2] = e3[s3];
              ++n2;
              if (n2 < 16) continue;
              for (let e4 = 0; e4 < 16; ++e4) r2[e4] ^= t3[e4];
              const a4 = this._encrypt(r2, this._key);
              t3 = a4;
              i2.push(a4);
              r2 = new Uint8Array(16);
              n2 = 0;
            }
            this.buffer = r2;
            this.bufferLength = n2;
            this.iv = t3;
            if (0 === i2.length) return new Uint8Array(0);
            const s2 = 16 * i2.length, o2 = new Uint8Array(s2);
            for (let e4 = 0, t4 = 0, a4 = i2.length; e4 < a4; ++e4, t4 += 16) o2.set(i2[e4], t4);
            return o2;
          }
        }
        class AES128Cipher extends AESBaseCipher {
          constructor(e3) {
            super();
            this._cyclesOfRepetition = 10;
            this._keySize = 160;
            this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
            this._key = this._expandKey(e3);
          }
          _expandKey(e3) {
            const t3 = this._s, a3 = this._rcon, r2 = new Uint8Array(176);
            r2.set(e3);
            for (let e4 = 16, n2 = 1; e4 < 176; ++n2) {
              let i2 = r2[e4 - 3], s2 = r2[e4 - 2], o2 = r2[e4 - 1], c2 = r2[e4 - 4];
              i2 = t3[i2];
              s2 = t3[s2];
              o2 = t3[o2];
              c2 = t3[c2];
              i2 ^= a3[n2];
              for (let t4 = 0; t4 < 4; ++t4) {
                r2[e4] = i2 ^= r2[e4 - 16];
                e4++;
                r2[e4] = s2 ^= r2[e4 - 16];
                e4++;
                r2[e4] = o2 ^= r2[e4 - 16];
                e4++;
                r2[e4] = c2 ^= r2[e4 - 16];
                e4++;
              }
            }
            return r2;
          }
        }
        t2.AES128Cipher = AES128Cipher;
        class AES256Cipher extends AESBaseCipher {
          constructor(e3) {
            super();
            this._cyclesOfRepetition = 14;
            this._keySize = 224;
            this._key = this._expandKey(e3);
          }
          _expandKey(e3) {
            const t3 = this._s, a3 = new Uint8Array(240);
            a3.set(e3);
            let r2, n2, i2, s2, o2 = 1;
            for (let e4 = 32, c2 = 1; e4 < 240; ++c2) {
              if (e4 % 32 == 16) {
                r2 = t3[r2];
                n2 = t3[n2];
                i2 = t3[i2];
                s2 = t3[s2];
              } else if (e4 % 32 == 0) {
                r2 = a3[e4 - 3];
                n2 = a3[e4 - 2];
                i2 = a3[e4 - 1];
                s2 = a3[e4 - 4];
                r2 = t3[r2];
                n2 = t3[n2];
                i2 = t3[i2];
                s2 = t3[s2];
                r2 ^= o2;
                (o2 <<= 1) >= 256 && (o2 = 255 & (27 ^ o2));
              }
              for (let t4 = 0; t4 < 4; ++t4) {
                a3[e4] = r2 ^= a3[e4 - 32];
                e4++;
                a3[e4] = n2 ^= a3[e4 - 32];
                e4++;
                a3[e4] = i2 ^= a3[e4 - 32];
                e4++;
                a3[e4] = s2 ^= a3[e4 - 32];
                e4++;
              }
            }
            return a3;
          }
        }
        t2.AES256Cipher = AES256Cipher;
        class PDF17 {
          checkOwnerPassword(e3, t3, a3, n2) {
            const i2 = new Uint8Array(e3.length + 56);
            i2.set(e3, 0);
            i2.set(t3, e3.length);
            i2.set(a3, e3.length + t3.length);
            const s2 = o(i2, 0, i2.length);
            return (0, r.isArrayEqual)(s2, n2);
          }
          checkUserPassword(e3, t3, a3) {
            const n2 = new Uint8Array(e3.length + 8);
            n2.set(e3, 0);
            n2.set(t3, e3.length);
            const i2 = o(n2, 0, n2.length);
            return (0, r.isArrayEqual)(i2, a3);
          }
          getOwnerKey(e3, t3, a3, r2) {
            const n2 = new Uint8Array(e3.length + 56);
            n2.set(e3, 0);
            n2.set(t3, e3.length);
            n2.set(a3, e3.length + t3.length);
            const i2 = o(n2, 0, n2.length);
            return new AES256Cipher(i2).decryptBlock(r2, false, new Uint8Array(16));
          }
          getUserKey(e3, t3, a3) {
            const r2 = new Uint8Array(e3.length + 8);
            r2.set(e3, 0);
            r2.set(t3, e3.length);
            const n2 = o(r2, 0, r2.length);
            return new AES256Cipher(n2).decryptBlock(a3, false, new Uint8Array(16));
          }
        }
        t2.PDF17 = PDF17;
        class PDF20 {
          _hash(e3, t3, a3) {
            let r2 = o(t3, 0, t3.length).subarray(0, 32), n2 = [0], i2 = 0;
            for (; i2 < 64 || n2.at(-1) > i2 - 32; ) {
              const t4 = e3.length + r2.length + a3.length, s2 = new Uint8Array(t4);
              let l = 0;
              s2.set(e3, l);
              l += e3.length;
              s2.set(r2, l);
              l += r2.length;
              s2.set(a3, l);
              const h = new Uint8Array(64 * t4);
              for (let e4 = 0, a4 = 0; e4 < 64; e4++, a4 += t4) h.set(s2, a4);
              n2 = new AES128Cipher(r2.subarray(0, 16)).encrypt(h, r2.subarray(16, 32));
              const u = n2.slice(0, 16).reduce((e4, t5) => e4 + t5, 0) % 3;
              0 === u ? r2 = o(n2, 0, n2.length) : 1 === u ? r2 = calculateSHA384(n2, 0, n2.length) : 2 === u && (r2 = c(n2, 0, n2.length));
              i2++;
            }
            return r2.subarray(0, 32);
          }
          checkOwnerPassword(e3, t3, a3, n2) {
            const i2 = new Uint8Array(e3.length + 56);
            i2.set(e3, 0);
            i2.set(t3, e3.length);
            i2.set(a3, e3.length + t3.length);
            const s2 = this._hash(e3, i2, a3);
            return (0, r.isArrayEqual)(s2, n2);
          }
          checkUserPassword(e3, t3, a3) {
            const n2 = new Uint8Array(e3.length + 8);
            n2.set(e3, 0);
            n2.set(t3, e3.length);
            const i2 = this._hash(e3, n2, []);
            return (0, r.isArrayEqual)(i2, a3);
          }
          getOwnerKey(e3, t3, a3, r2) {
            const n2 = new Uint8Array(e3.length + 56);
            n2.set(e3, 0);
            n2.set(t3, e3.length);
            n2.set(a3, e3.length + t3.length);
            const i2 = this._hash(e3, n2, a3);
            return new AES256Cipher(i2).decryptBlock(r2, false, new Uint8Array(16));
          }
          getUserKey(e3, t3, a3) {
            const r2 = new Uint8Array(e3.length + 8);
            r2.set(e3, 0);
            r2.set(t3, e3.length);
            const n2 = this._hash(e3, r2, []);
            return new AES256Cipher(n2).decryptBlock(a3, false, new Uint8Array(16));
          }
        }
        t2.PDF20 = PDF20;
        class CipherTransform {
          constructor(e3, t3) {
            this.StringCipherConstructor = e3;
            this.StreamCipherConstructor = t3;
          }
          createStream(e3, t3) {
            const a3 = new this.StreamCipherConstructor();
            return new i.DecryptStream(e3, t3, function cipherTransformDecryptStream(e4, t4) {
              return a3.decryptBlock(e4, t4);
            });
          }
          decryptString(e3) {
            const t3 = new this.StringCipherConstructor();
            let a3 = (0, r.stringToBytes)(e3);
            a3 = t3.decryptBlock(a3, true);
            return (0, r.bytesToString)(a3);
          }
          encryptString(e3) {
            const t3 = new this.StringCipherConstructor();
            if (t3 instanceof AESBaseCipher) {
              const a4 = 16 - e3.length % 16;
              e3 += String.fromCharCode(a4).repeat(a4);
              const n2 = new Uint8Array(16);
              if ("undefined" != typeof crypto) crypto.getRandomValues(n2);
              else for (let e4 = 0; e4 < 16; e4++) n2[e4] = Math.floor(256 * Math.random());
              let i2 = (0, r.stringToBytes)(e3);
              i2 = t3.encrypt(i2, n2);
              const s2 = new Uint8Array(16 + i2.length);
              s2.set(n2);
              s2.set(i2, 16);
              return (0, r.bytesToString)(s2);
            }
            let a3 = (0, r.stringToBytes)(e3);
            a3 = t3.encrypt(a3);
            return (0, r.bytesToString)(a3);
          }
        }
        const _CipherTransformFactory = class _CipherTransformFactory {
          constructor(e3, t3, a3) {
            __privateAdd(this, _CipherTransformFactory_instances);
            const i2 = e3.get("Filter");
            if (!(0, n.isName)(i2, "Standard")) throw new r.FormatError("unknown encryption method");
            this.filterName = i2.name;
            this.dict = e3;
            const s2 = e3.get("V");
            if (!Number.isInteger(s2) || 1 !== s2 && 2 !== s2 && 4 !== s2 && 5 !== s2) throw new r.FormatError("unsupported encryption algorithm");
            this.algorithm = s2;
            let o2 = e3.get("Length");
            if (!o2) if (s2 <= 3) o2 = 40;
            else {
              const t4 = e3.get("CF"), a4 = e3.get("StmF");
              if (t4 instanceof n.Dict && a4 instanceof n.Name) {
                t4.suppressEncryption = true;
                const e4 = t4.get(a4.name);
                o2 = (e4 == null ? void 0 : e4.get("Length")) || 128;
                o2 < 40 && (o2 <<= 3);
              }
            }
            if (!Number.isInteger(o2) || o2 < 40 || o2 % 8 != 0) throw new r.FormatError("invalid key length");
            const c2 = (0, r.stringToBytes)(e3.get("O")), l = (0, r.stringToBytes)(e3.get("U")), h = c2.subarray(0, 32), u = l.subarray(0, 32), d = e3.get("P"), f = e3.get("R"), g = (4 === s2 || 5 === s2) && false !== e3.get("EncryptMetadata");
            this.encryptMetadata = g;
            const p = (0, r.stringToBytes)(t3);
            let m, b;
            if (a3) {
              if (6 === f) try {
                a3 = (0, r.utf8StringToString)(a3);
              } catch {
                (0, r.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
              }
              m = (0, r.stringToBytes)(a3);
            }
            if (5 !== s2) b = __privateMethod(this, _CipherTransformFactory_instances, T_fn).call(this, p, m, h, u, d, f, o2, g);
            else {
              const t4 = c2.subarray(32, 40), a4 = c2.subarray(40, 48), n2 = l.subarray(0, 48), i3 = l.subarray(32, 40), s3 = l.subarray(40, 48), o3 = (0, r.stringToBytes)(e3.get("OE")), d2 = (0, r.stringToBytes)(e3.get("UE")), g2 = (0, r.stringToBytes)(e3.get("Perms"));
              b = __privateMethod(this, _CipherTransformFactory_instances, I_fn).call(this, f, m, h, t4, a4, n2, u, i3, s3, o3, d2, g2);
            }
            if (!b && !a3) throw new r.PasswordException("No password given", r.PasswordResponses.NEED_PASSWORD);
            if (!b && a3) {
              const e4 = __privateMethod(this, _CipherTransformFactory_instances, M_fn).call(this, m, h, f, o2);
              b = __privateMethod(this, _CipherTransformFactory_instances, T_fn).call(this, p, e4, h, u, d, f, o2, g);
            }
            if (!b) throw new r.PasswordException("Incorrect Password", r.PasswordResponses.INCORRECT_PASSWORD);
            this.encryptionKey = b;
            if (s2 >= 4) {
              const t4 = e3.get("CF");
              t4 instanceof n.Dict && (t4.suppressEncryption = true);
              this.cf = t4;
              this.stmf = e3.get("StmF") || n.Name.get("Identity");
              this.strf = e3.get("StrF") || n.Name.get("Identity");
              this.eff = e3.get("EFF") || this.stmf;
            }
          }
          createCipherTransform(e3, t3) {
            if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(__privateMethod(this, _CipherTransformFactory_instances, D_fn).call(this, this.cf, this.strf, e3, t3, this.encryptionKey), __privateMethod(this, _CipherTransformFactory_instances, D_fn).call(this, this.cf, this.stmf, e3, t3, this.encryptionKey));
            const a3 = __privateMethod(this, _CipherTransformFactory_instances, P_fn).call(this, e3, t3, this.encryptionKey, false), cipherConstructor = function() {
              return new ARCFourCipher(a3);
            };
            return new CipherTransform(cipherConstructor, cipherConstructor);
          }
        };
        _O = new WeakMap();
        _CipherTransformFactory_instances = new WeakSet();
        I_fn = function(e3, t3, a3, r2, n2, i2, s2, o2, c2, l, h, u) {
          if (t3) {
            const e4 = Math.min(127, t3.length);
            t3 = t3.subarray(0, e4);
          } else t3 = [];
          const d = 6 === e3 ? new PDF20() : new PDF17();
          return d.checkUserPassword(t3, o2, s2) ? d.getUserKey(t3, c2, h) : t3.length && d.checkOwnerPassword(t3, r2, i2, a3) ? d.getOwnerKey(t3, n2, i2, l) : null;
        };
        T_fn = function(e3, t3, a3, r2, n2, i2, o2, c2) {
          const l = 40 + a3.length + e3.length, h = new Uint8Array(l);
          let u, d, f = 0;
          if (t3) {
            d = Math.min(32, t3.length);
            for (; f < d; ++f) h[f] = t3[f];
          }
          u = 0;
          for (; f < 32; ) h[f++] = __privateGet(_CipherTransformFactory, _O)[u++];
          for (u = 0, d = a3.length; u < d; ++u) h[f++] = a3[u];
          h[f++] = 255 & n2;
          h[f++] = n2 >> 8 & 255;
          h[f++] = n2 >> 16 & 255;
          h[f++] = n2 >>> 24 & 255;
          for (u = 0, d = e3.length; u < d; ++u) h[f++] = e3[u];
          if (i2 >= 4 && !c2) {
            h[f++] = 255;
            h[f++] = 255;
            h[f++] = 255;
            h[f++] = 255;
          }
          let g = s(h, 0, f);
          const p = o2 >> 3;
          if (i2 >= 3) for (u = 0; u < 50; ++u) g = s(g, 0, p);
          const m = g.subarray(0, p);
          let b, y;
          if (i2 >= 3) {
            for (f = 0; f < 32; ++f) h[f] = __privateGet(_CipherTransformFactory, _O)[f];
            for (u = 0, d = e3.length; u < d; ++u) h[f++] = e3[u];
            b = new ARCFourCipher(m);
            y = b.encryptBlock(s(h, 0, f));
            d = m.length;
            const t4 = new Uint8Array(d);
            for (u = 1; u <= 19; ++u) {
              for (let e4 = 0; e4 < d; ++e4) t4[e4] = m[e4] ^ u;
              b = new ARCFourCipher(t4);
              y = b.encryptBlock(y);
            }
            for (u = 0, d = y.length; u < d; ++u) if (r2[u] !== y[u]) return null;
          } else {
            b = new ARCFourCipher(m);
            y = b.encryptBlock(__privateGet(_CipherTransformFactory, _O));
            for (u = 0, d = y.length; u < d; ++u) if (r2[u] !== y[u]) return null;
          }
          return m;
        };
        M_fn = function(e3, t3, a3, r2) {
          const n2 = new Uint8Array(32);
          let i2 = 0;
          const o2 = Math.min(32, e3.length);
          for (; i2 < o2; ++i2) n2[i2] = e3[i2];
          let c2 = 0;
          for (; i2 < 32; ) n2[i2++] = __privateGet(_CipherTransformFactory, _O)[c2++];
          let l = s(n2, 0, i2);
          const h = r2 >> 3;
          if (a3 >= 3) for (c2 = 0; c2 < 50; ++c2) l = s(l, 0, l.length);
          let u, d;
          if (a3 >= 3) {
            d = t3;
            const e4 = new Uint8Array(h);
            for (c2 = 19; c2 >= 0; c2--) {
              for (let t4 = 0; t4 < h; ++t4) e4[t4] = l[t4] ^ c2;
              u = new ARCFourCipher(e4);
              d = u.encryptBlock(d);
            }
          } else {
            u = new ARCFourCipher(l.subarray(0, h));
            d = u.encryptBlock(t3);
          }
          return d;
        };
        P_fn = function(e3, t3, a3, r2 = false) {
          const n2 = new Uint8Array(a3.length + 9), i2 = a3.length;
          let o2;
          for (o2 = 0; o2 < i2; ++o2) n2[o2] = a3[o2];
          n2[o2++] = 255 & e3;
          n2[o2++] = e3 >> 8 & 255;
          n2[o2++] = e3 >> 16 & 255;
          n2[o2++] = 255 & t3;
          n2[o2++] = t3 >> 8 & 255;
          if (r2) {
            n2[o2++] = 115;
            n2[o2++] = 65;
            n2[o2++] = 108;
            n2[o2++] = 84;
          }
          return s(n2, 0, o2).subarray(0, Math.min(a3.length + 5, 16));
        };
        D_fn = function(e3, t3, a3, i2, s2) {
          if (!(t3 instanceof n.Name)) throw new r.FormatError("Invalid crypt filter name.");
          const o2 = this, c2 = e3.get(t3.name), l = c2 == null ? void 0 : c2.get("CFM");
          if (!l || "None" === l.name) return function() {
            return new NullCipher();
          };
          if ("V2" === l.name) return function() {
            var _a;
            return new ARCFourCipher(__privateMethod(_a = o2, _CipherTransformFactory_instances, P_fn).call(_a, a3, i2, s2, false));
          };
          if ("AESV2" === l.name) return function() {
            var _a;
            return new AES128Cipher(__privateMethod(_a = o2, _CipherTransformFactory_instances, P_fn).call(_a, a3, i2, s2, true));
          };
          if ("AESV3" === l.name) return function() {
            return new AES256Cipher(s2);
          };
          throw new r.FormatError("Unknown crypto method");
        };
        __privateAdd(_CipherTransformFactory, _O, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
        let CipherTransformFactory = _CipherTransformFactory;
        t2.CipherTransformFactory = CipherTransformFactory;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DecryptStream = void 0;
        var r = a2(18);
        class DecryptStream extends r.DecodeStream {
          constructor(e3, t3, a3) {
            super(t3);
            this.str = e3;
            this.dict = e3.dict;
            this.decrypt = a3;
            this.nextChunk = null;
            this.initialized = false;
          }
          readBlock() {
            var _a;
            let e3;
            if (this.initialized) e3 = this.nextChunk;
            else {
              e3 = this.str.getBytes(512);
              this.initialized = true;
            }
            if (!e3 || 0 === e3.length) {
              this.eof = true;
              return;
            }
            this.nextChunk = this.str.getBytes(512);
            const t3 = ((_a = this.nextChunk) == null ? void 0 : _a.length) > 0;
            e3 = (0, this.decrypt)(e3, !t3);
            const a3 = this.bufferLength, r2 = a3 + e3.length;
            this.ensureBuffer(r2).set(e3, a3);
            this.bufferLength = r2;
          }
        }
        t2.DecryptStream = DecryptStream;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ObjectLoader = void 0;
        var r = a2(4), n = a2(5), i = a2(3), s = a2(2);
        function addChildren(e3, t3) {
          if (e3 instanceof r.Dict) e3 = e3.getRawValues();
          else if (e3 instanceof n.BaseStream) e3 = e3.dict.getRawValues();
          else if (!Array.isArray(e3)) return;
          for (const i2 of e3) ((a3 = i2) instanceof r.Ref || a3 instanceof r.Dict || a3 instanceof n.BaseStream || Array.isArray(a3)) && t3.push(i2);
          var a3;
        }
        t2.ObjectLoader = class ObjectLoader {
          constructor(e3, t3, a3) {
            this.dict = e3;
            this.keys = t3;
            this.xref = a3;
            this.refSet = null;
          }
          async load() {
            if (this.xref.stream.isDataLoaded) return;
            const { keys: e3, dict: t3 } = this;
            this.refSet = new r.RefSet();
            const a3 = [];
            for (const r2 of e3) {
              const e4 = t3.getRaw(r2);
              void 0 !== e4 && a3.push(e4);
            }
            return this._walk(a3);
          }
          async _walk(e3) {
            const t3 = [], a3 = [];
            for (; e3.length; ) {
              let o = e3.pop();
              if (o instanceof r.Ref) {
                if (this.refSet.has(o)) continue;
                try {
                  this.refSet.put(o);
                  o = this.xref.fetch(o);
                } catch (e4) {
                  if (!(e4 instanceof i.MissingDataException)) {
                    (0, s.warn)(`ObjectLoader._walk - requesting all data: "${e4}".`);
                    this.refSet = null;
                    const { manager: t4 } = this.xref.stream;
                    return t4.requestAllChunks();
                  }
                  t3.push(o);
                  a3.push({ begin: e4.begin, end: e4.end });
                }
              }
              if (o instanceof n.BaseStream) {
                const e4 = o.getBaseStreams();
                if (e4) {
                  let r2 = false;
                  for (const t4 of e4) if (!t4.isDataLoaded) {
                    r2 = true;
                    a3.push({ begin: t4.start, end: t4.end });
                  }
                  r2 && t3.push(o);
                }
              }
              addChildren(o, e3);
            }
            if (a3.length) {
              await this.xref.stream.manager.requestRanges(a3);
              for (const e4 of t3) e4 instanceof r.Ref && this.refSet.remove(e4);
              return this._walk(t3);
            }
            this.refSet = null;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XFAFactory = void 0;
        var r = a2(78), n = a2(79), i = a2(89), s = a2(85), o = a2(84), c = a2(2), l = a2(90), h = a2(100);
        class XFAFactory {
          constructor(e3) {
            try {
              this.root = new l.XFAParser().parse(XFAFactory._createDocument(e3));
              const t3 = new n.Binder(this.root);
              this.form = t3.bind();
              this.dataHandler = new i.DataHandler(this.root, t3.getData());
              this.form[r.$globalData].template = this.form;
            } catch (e4) {
              (0, c.warn)(`XFA - an error occurred during parsing and binding: ${e4}`);
            }
          }
          isValid() {
            return this.root && this.form;
          }
          _createPagesHelper() {
            const e3 = this.form[r.$toPages]();
            return new Promise((t3, a3) => {
              const nextIteration = () => {
                try {
                  const a4 = e3.next();
                  a4.done ? t3(a4.value) : setTimeout(nextIteration, 0);
                } catch (e4) {
                  a3(e4);
                }
              };
              setTimeout(nextIteration, 0);
            });
          }
          async _createPages() {
            try {
              this.pages = await this._createPagesHelper();
              this.dims = this.pages.children.map((e3) => {
                const { width: t3, height: a3 } = e3.attributes.style;
                return [0, 0, parseInt(t3), parseInt(a3)];
              });
            } catch (e3) {
              (0, c.warn)(`XFA - an error occurred during layout: ${e3}`);
            }
          }
          getBoundingBox(e3) {
            return this.dims[e3];
          }
          async getNumPages() {
            this.pages || await this._createPages();
            return this.dims.length;
          }
          setImages(e3) {
            this.form[r.$globalData].images = e3;
          }
          setFonts(e3) {
            this.form[r.$globalData].fontFinder = new s.FontFinder(e3);
            const t3 = [];
            for (let e4 of this.form[r.$globalData].usedTypefaces) {
              e4 = (0, o.stripQuotes)(e4);
              this.form[r.$globalData].fontFinder.find(e4) || t3.push(e4);
            }
            return t3.length > 0 ? t3 : null;
          }
          appendFonts(e3, t3) {
            this.form[r.$globalData].fontFinder.add(e3, t3);
          }
          async getPages() {
            this.pages || await this._createPages();
            const e3 = this.pages;
            this.pages = null;
            return e3;
          }
          serializeData(e3) {
            return this.dataHandler.serialize(e3);
          }
          static _createDocument(e3) {
            return e3["/xdp:xdp"] ? Object.values(e3).join("") : e3["xdp:xdp"];
          }
          static getRichTextAsHtml(e3) {
            if (!e3 || "string" != typeof e3) return null;
            try {
              let t3 = new l.XFAParser(h.XhtmlNamespace, true).parse(e3);
              if (!["body", "xhtml"].includes(t3[r.$nodeName])) {
                const e4 = h.XhtmlNamespace.body({});
                e4[r.$appendChild](t3);
                t3 = e4;
              }
              const a3 = t3[r.$toHTML]();
              if (!a3.success) return null;
              const { html: n2 } = a3, { attributes: i2 } = n2;
              if (i2) {
                i2.class && (i2.class = i2.class.filter((e4) => !e4.startsWith("xfa")));
                i2.dir = "auto";
              }
              return { html: n2, str: t3[r.$text]() };
            } catch (e4) {
              (0, c.warn)(`XFA - an error occurred during parsing of rich text: ${e4}`);
            }
            return null;
          }
        }
        t2.XFAFactory = XFAFactory;
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.$uid = t2.$toStyle = t2.$toString = t2.$toPages = t2.$toHTML = t2.$text = t2.$tabIndex = t2.$setValue = t2.$setSetAttributes = t2.$setId = t2.$searchNode = t2.$root = t2.$resolvePrototypes = t2.$removeChild = t2.$pushPara = t2.$pushGlyphs = t2.$popPara = t2.$onText = t2.$onChildCheck = t2.$onChild = t2.$nsAttributes = t2.$nodeName = t2.$namespaceId = t2.$lastAttribute = t2.$isUsable = t2.$isTransparent = t2.$isThereMoreWidth = t2.$isSplittable = t2.$isNsAgnostic = t2.$isDescendent = t2.$isDataValue = t2.$isCDATAXml = t2.$isBindable = t2.$insertAt = t2.$indexOf = t2.$ids = t2.$hasSettableValue = t2.$globalData = t2.$getTemplateRoot = t2.$getSubformParent = t2.$getRealChildrenByNameIt = t2.$getParent = t2.$getNextPage = t2.$getExtra = t2.$getDataValue = t2.$getContainedChildren = t2.$getChildrenByNameIt = t2.$getChildrenByName = t2.$getChildrenByClass = t2.$getChildren = t2.$getAvailableSpace = t2.$getAttributes = t2.$getAttributeIt = t2.$flushHTML = t2.$finalize = t2.$extra = t2.$dump = t2.$data = t2.$content = t2.$consumed = t2.$clone = t2.$cleanup = t2.$cleanPage = t2.$clean = t2.$childrenToHTML = t2.$appendChild = t2.$addHTML = t2.$acceptWhitespace = void 0;
        const a2 = Symbol();
        t2.$acceptWhitespace = a2;
        const r = Symbol();
        t2.$addHTML = r;
        const n = Symbol();
        t2.$appendChild = n;
        const i = Symbol();
        t2.$childrenToHTML = i;
        const s = Symbol();
        t2.$clean = s;
        const o = Symbol();
        t2.$cleanPage = o;
        const c = Symbol();
        t2.$cleanup = c;
        const l = Symbol();
        t2.$clone = l;
        const h = Symbol();
        t2.$consumed = h;
        const u = Symbol("content");
        t2.$content = u;
        const d = Symbol("data");
        t2.$data = d;
        const f = Symbol();
        t2.$dump = f;
        const g = Symbol("extra");
        t2.$extra = g;
        const p = Symbol();
        t2.$finalize = p;
        const m = Symbol();
        t2.$flushHTML = m;
        const b = Symbol();
        t2.$getAttributeIt = b;
        const y = Symbol();
        t2.$getAttributes = y;
        const w = Symbol();
        t2.$getAvailableSpace = w;
        const S = Symbol();
        t2.$getChildrenByClass = S;
        const x = Symbol();
        t2.$getChildrenByName = x;
        const C = Symbol();
        t2.$getChildrenByNameIt = C;
        const k = Symbol();
        t2.$getDataValue = k;
        const v = Symbol();
        t2.$getExtra = v;
        const F = Symbol();
        t2.$getRealChildrenByNameIt = F;
        const O = Symbol();
        t2.$getChildren = O;
        const T = Symbol();
        t2.$getContainedChildren = T;
        const M = Symbol();
        t2.$getNextPage = M;
        const D = Symbol();
        t2.$getSubformParent = D;
        const E = Symbol();
        t2.$getParent = E;
        const N = Symbol();
        t2.$getTemplateRoot = N;
        const R = Symbol();
        t2.$globalData = R;
        const L = Symbol();
        t2.$hasSettableValue = L;
        const $ = Symbol();
        t2.$ids = $;
        const _ = Symbol();
        t2.$indexOf = _;
        const j = Symbol();
        t2.$insertAt = j;
        const U = Symbol();
        t2.$isCDATAXml = U;
        const X = Symbol();
        t2.$isBindable = X;
        const H = Symbol();
        t2.$isDataValue = H;
        const q = Symbol();
        t2.$isDescendent = q;
        const z = Symbol();
        t2.$isNsAgnostic = z;
        const W = Symbol();
        t2.$isSplittable = W;
        const G = Symbol();
        t2.$isThereMoreWidth = G;
        const V = Symbol();
        t2.$isTransparent = V;
        const K = Symbol();
        t2.$isUsable = K;
        const J = Symbol();
        t2.$lastAttribute = J;
        const Y = Symbol("namespaceId");
        t2.$namespaceId = Y;
        const Z = Symbol("nodeName");
        t2.$nodeName = Z;
        const Q = Symbol();
        t2.$nsAttributes = Q;
        const ee = Symbol();
        t2.$onChild = ee;
        const te = Symbol();
        t2.$onChildCheck = te;
        const ae = Symbol();
        t2.$onText = ae;
        const re = Symbol();
        t2.$pushGlyphs = re;
        const ne = Symbol();
        t2.$popPara = ne;
        const ie = Symbol();
        t2.$pushPara = ie;
        const se = Symbol();
        t2.$removeChild = se;
        const oe = Symbol("root");
        t2.$root = oe;
        const ce = Symbol();
        t2.$resolvePrototypes = ce;
        const le = Symbol();
        t2.$searchNode = le;
        const he = Symbol();
        t2.$setId = he;
        const ue = Symbol();
        t2.$setSetAttributes = ue;
        const de = Symbol();
        t2.$setValue = de;
        const fe = Symbol();
        t2.$tabIndex = fe;
        const ge = Symbol();
        t2.$text = ge;
        const pe = Symbol();
        t2.$toPages = pe;
        const me = Symbol();
        t2.$toHTML = me;
        const be = Symbol();
        t2.$toString = be;
        const ye = Symbol();
        t2.$toStyle = ye;
        const we = Symbol("uid");
        t2.$uid = we;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Binder = void 0;
        var r = a2(78), n = a2(80), i = a2(88), s = a2(87), o = a2(81), c = a2(2);
        const l = o.NamespaceIds.datasets.id;
        function createText(e3) {
          const t3 = new n.Text({});
          t3[r.$content] = e3;
          return t3;
        }
        t2.Binder = class Binder {
          constructor(e3) {
            var _a;
            this.root = e3;
            this.datasets = e3.datasets;
            this.data = ((_a = e3.datasets) == null ? void 0 : _a.data) || new s.XmlObject(o.NamespaceIds.datasets.id, "data");
            this.emptyMerge = 0 === this.data[r.$getChildren]().length;
            this.root.form = this.form = e3.template[r.$clone]();
          }
          _isConsumeData() {
            return !this.emptyMerge && this._mergeMode;
          }
          _isMatchTemplate() {
            return !this._isConsumeData();
          }
          bind() {
            this._bindElement(this.form, this.data);
            return this.form;
          }
          getData() {
            return this.data;
          }
          _bindValue(e3, t3, a3) {
            var _a, _b;
            e3[r.$data] = t3;
            if (e3[r.$hasSettableValue]()) if (t3[r.$isDataValue]()) {
              const a4 = t3[r.$getDataValue]();
              e3[r.$setValue](createText(a4));
            } else if (e3 instanceof n.Field && "multiSelect" === ((_b = (_a = e3.ui) == null ? void 0 : _a.choiceList) == null ? void 0 : _b.open)) {
              const a4 = t3[r.$getChildren]().map((e4) => e4[r.$content].trim()).join("\n");
              e3[r.$setValue](createText(a4));
            } else this._isConsumeData() && (0, c.warn)("XFA - Nodes haven't the same type.");
            else !t3[r.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(e3, t3) : (0, c.warn)("XFA - Nodes haven't the same type.");
          }
          _findDataByNameToConsume(e3, t3, a3, n2) {
            if (!e3) return null;
            let i2, s2;
            for (let n3 = 0; n3 < 3; n3++) {
              i2 = a3[r.$getRealChildrenByNameIt](e3, false, true);
              for (; ; ) {
                s2 = i2.next().value;
                if (!s2) break;
                if (t3 === s2[r.$isDataValue]()) return s2;
              }
              if (a3[r.$namespaceId] === o.NamespaceIds.datasets.id && "data" === a3[r.$nodeName]) break;
              a3 = a3[r.$getParent]();
            }
            if (!n2) return null;
            i2 = this.data[r.$getRealChildrenByNameIt](e3, true, false);
            s2 = i2.next().value;
            if (s2) return s2;
            i2 = this.data[r.$getAttributeIt](e3, true);
            s2 = i2.next().value;
            return (s2 == null ? void 0 : s2[r.$isDataValue]()) ? s2 : null;
          }
          _setProperties(e3, t3) {
            if (e3.hasOwnProperty("setProperty")) for (const { ref: a3, target: o2, connection: l2 } of e3.setProperty.children) {
              if (l2) continue;
              if (!a3) continue;
              const h = (0, i.searchNode)(this.root, t3, a3, false, false);
              if (!h) {
                (0, c.warn)(`XFA - Invalid reference: ${a3}.`);
                continue;
              }
              const [u] = h;
              if (!u[r.$isDescendent](this.data)) {
                (0, c.warn)("XFA - Invalid node: must be a data node.");
                continue;
              }
              const d = (0, i.searchNode)(this.root, e3, o2, false, false);
              if (!d) {
                (0, c.warn)(`XFA - Invalid target: ${o2}.`);
                continue;
              }
              const [f] = d;
              if (!f[r.$isDescendent](e3)) {
                (0, c.warn)("XFA - Invalid target: must be a property or subproperty.");
                continue;
              }
              const g = f[r.$getParent]();
              if (f instanceof n.SetProperty || g instanceof n.SetProperty) {
                (0, c.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                continue;
              }
              if (f instanceof n.BindItems || g instanceof n.BindItems) {
                (0, c.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                continue;
              }
              const p = u[r.$text](), m = f[r.$nodeName];
              if (f instanceof s.XFAAttribute) {
                const e4 = /* @__PURE__ */ Object.create(null);
                e4[m] = p;
                const t4 = Reflect.construct(Object.getPrototypeOf(g).constructor, [e4]);
                g[m] = t4[m];
              } else if (f.hasOwnProperty(r.$content)) {
                f[r.$data] = u;
                f[r.$content] = p;
                f[r.$finalize]();
              } else (0, c.warn)("XFA - Invalid node to use in setProperty");
            }
          }
          _bindItems(e3, t3) {
            if (!e3.hasOwnProperty("items") || !e3.hasOwnProperty("bindItems") || e3.bindItems.isEmpty()) return;
            for (const t4 of e3.items.children) e3[r.$removeChild](t4);
            e3.items.clear();
            const a3 = new n.Items({}), s2 = new n.Items({});
            e3[r.$appendChild](a3);
            e3.items.push(a3);
            e3[r.$appendChild](s2);
            e3.items.push(s2);
            for (const { ref: n2, labelRef: o2, valueRef: l2, connection: h } of e3.bindItems.children) {
              if (h) continue;
              if (!n2) continue;
              const e4 = (0, i.searchNode)(this.root, t3, n2, false, false);
              if (e4) for (const t4 of e4) {
                if (!t4[r.$isDescendent](this.datasets)) {
                  (0, c.warn)(`XFA - Invalid ref (${n2}): must be a datasets child.`);
                  continue;
                }
                const e5 = (0, i.searchNode)(this.root, t4, o2, true, false);
                if (!e5) {
                  (0, c.warn)(`XFA - Invalid label: ${o2}.`);
                  continue;
                }
                const [h2] = e5;
                if (!h2[r.$isDescendent](this.datasets)) {
                  (0, c.warn)("XFA - Invalid label: must be a datasets child.");
                  continue;
                }
                const u = (0, i.searchNode)(this.root, t4, l2, true, false);
                if (!u) {
                  (0, c.warn)(`XFA - Invalid value: ${l2}.`);
                  continue;
                }
                const [d] = u;
                if (!d[r.$isDescendent](this.datasets)) {
                  (0, c.warn)("XFA - Invalid value: must be a datasets child.");
                  continue;
                }
                const f = createText(h2[r.$text]()), g = createText(d[r.$text]());
                a3[r.$appendChild](f);
                a3.text.push(f);
                s2[r.$appendChild](g);
                s2.text.push(g);
              }
              else (0, c.warn)(`XFA - Invalid reference: ${n2}.`);
            }
          }
          _bindOccurrences(e3, t3, a3) {
            let n2;
            if (t3.length > 1) {
              n2 = e3[r.$clone]();
              n2[r.$removeChild](n2.occur);
              n2.occur = null;
            }
            this._bindValue(e3, t3[0], a3);
            this._setProperties(e3, t3[0]);
            this._bindItems(e3, t3[0]);
            if (1 === t3.length) return;
            const i2 = e3[r.$getParent](), s2 = e3[r.$nodeName], o2 = i2[r.$indexOf](e3);
            for (let e4 = 1, c2 = t3.length; e4 < c2; e4++) {
              const c3 = t3[e4], l2 = n2[r.$clone]();
              i2[s2].push(l2);
              i2[r.$insertAt](o2 + e4, l2);
              this._bindValue(l2, c3, a3);
              this._setProperties(l2, c3);
              this._bindItems(l2, c3);
            }
          }
          _createOccurrences(e3) {
            if (!this.emptyMerge) return;
            const { occur: t3 } = e3;
            if (!t3 || t3.initial <= 1) return;
            const a3 = e3[r.$getParent](), n2 = e3[r.$nodeName];
            if (!(a3[n2] instanceof s.XFAObjectArray)) return;
            let i2;
            i2 = e3.name ? a3[n2].children.filter((t4) => t4.name === e3.name).length : a3[n2].children.length;
            const o2 = a3[r.$indexOf](e3) + 1, c2 = t3.initial - i2;
            if (c2) {
              const t4 = e3[r.$clone]();
              t4[r.$removeChild](t4.occur);
              t4.occur = null;
              a3[n2].push(t4);
              a3[r.$insertAt](o2, t4);
              for (let e4 = 1; e4 < c2; e4++) {
                const i3 = t4[r.$clone]();
                a3[n2].push(i3);
                a3[r.$insertAt](o2 + e4, i3);
              }
            }
          }
          _getOccurInfo(e3) {
            const { name: t3, occur: a3 } = e3;
            if (!a3 || !t3) return [1, 1];
            const r2 = -1 === a3.max ? 1 / 0 : a3.max;
            return [a3.min, r2];
          }
          _setAndBind(e3, t3) {
            this._setProperties(e3, t3);
            this._bindItems(e3, t3);
            this._bindElement(e3, t3);
          }
          _bindElement(e3, t3) {
            const a3 = [];
            this._createOccurrences(e3);
            for (const n2 of e3[r.$getChildren]()) {
              if (n2[r.$data]) continue;
              if (void 0 === this._mergeMode && "subform" === n2[r.$nodeName]) {
                this._mergeMode = "consumeData" === n2.mergeMode;
                const e5 = t3[r.$getChildren]();
                if (e5.length > 0) this._bindOccurrences(n2, [e5[0]], null);
                else if (this.emptyMerge) {
                  const e6 = t3[r.$namespaceId] === l ? -1 : t3[r.$namespaceId], a4 = n2[r.$data] = new s.XmlObject(e6, n2.name || "root");
                  t3[r.$appendChild](a4);
                  this._bindElement(n2, a4);
                }
                continue;
              }
              if (!n2[r.$isBindable]()) continue;
              let e4 = false, o2 = null, h = null, u = null;
              if (n2.bind) {
                switch (n2.bind.match) {
                  case "none":
                    this._setAndBind(n2, t3);
                    continue;
                  case "global":
                    e4 = true;
                    break;
                  case "dataRef":
                    if (!n2.bind.ref) {
                      (0, c.warn)(`XFA - ref is empty in node ${n2[r.$nodeName]}.`);
                      this._setAndBind(n2, t3);
                      continue;
                    }
                    h = n2.bind.ref;
                }
                n2.bind.picture && (o2 = n2.bind.picture[r.$content]);
              }
              const [d, f] = this._getOccurInfo(n2);
              if (h) {
                u = (0, i.searchNode)(this.root, t3, h, true, false);
                if (null === u) {
                  u = (0, i.createDataNode)(this.data, t3, h);
                  if (!u) continue;
                  this._isConsumeData() && (u[r.$consumed] = true);
                  this._setAndBind(n2, u);
                  continue;
                }
                this._isConsumeData() && (u = u.filter((e5) => !e5[r.$consumed]));
                u.length > f ? u = u.slice(0, f) : 0 === u.length && (u = null);
                u && this._isConsumeData() && u.forEach((e5) => {
                  e5[r.$consumed] = true;
                });
              } else {
                if (!n2.name) {
                  this._setAndBind(n2, t3);
                  continue;
                }
                if (this._isConsumeData()) {
                  const a4 = [];
                  for (; a4.length < f; ) {
                    const i2 = this._findDataByNameToConsume(n2.name, n2[r.$hasSettableValue](), t3, e4);
                    if (!i2) break;
                    i2[r.$consumed] = true;
                    a4.push(i2);
                  }
                  u = a4.length > 0 ? a4 : null;
                } else {
                  u = t3[r.$getRealChildrenByNameIt](n2.name, false, this.emptyMerge).next().value;
                  if (!u) {
                    if (0 === d) {
                      a3.push(n2);
                      continue;
                    }
                    const e5 = t3[r.$namespaceId] === l ? -1 : t3[r.$namespaceId];
                    u = n2[r.$data] = new s.XmlObject(e5, n2.name);
                    this.emptyMerge && (u[r.$consumed] = true);
                    t3[r.$appendChild](u);
                    this._setAndBind(n2, u);
                    continue;
                  }
                  this.emptyMerge && (u[r.$consumed] = true);
                  u = [u];
                }
              }
              u ? this._bindOccurrences(n2, u, o2) : d > 0 ? this._setAndBind(n2, t3) : a3.push(n2);
            }
            a3.forEach((e4) => e4[r.$getParent]()[r.$removeChild](e4));
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Value = t2.Text = t2.TemplateNamespace = t2.Template = t2.SetProperty = t2.Items = t2.Field = t2.BindItems = void 0;
        var r = a2(78), n = a2(81), i = a2(82), s = a2(83), o = a2(87), c = a2(84), l = a2(2), h = a2(85), u = a2(3), d = a2(88);
        const f = n.NamespaceIds.template.id, g = "http://www.w3.org/2000/svg", p = /^H(\d+)$/, m = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), b = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
        function getBorderDims(e3) {
          if (!e3 || !e3.border) return { w: 0, h: 0 };
          const t3 = e3.border[r.$getExtra]();
          return t3 ? { w: t3.widths[0] + t3.widths[2] + t3.insets[0] + t3.insets[2], h: t3.widths[1] + t3.widths[3] + t3.insets[1] + t3.insets[3] } : { w: 0, h: 0 };
        }
        function hasMargin(e3) {
          return e3.margin && (e3.margin.topInset || e3.margin.rightInset || e3.margin.bottomInset || e3.margin.leftInset);
        }
        function _setValue(e3, t3) {
          if (!e3.value) {
            const t4 = new Value({});
            e3[r.$appendChild](t4);
            e3.value = t4;
          }
          e3.value[r.$setValue](t3);
        }
        function* getContainedChildren(e3) {
          for (const t3 of e3[r.$getChildren]()) t3 instanceof SubformSet ? yield* t3[r.$getContainedChildren]() : yield t3;
        }
        function isRequired(e3) {
          var _a;
          return "error" === ((_a = e3.validate) == null ? void 0 : _a.nullTest);
        }
        function setTabIndex(e3) {
          for (; e3; ) {
            if (!e3.traversal) {
              e3[r.$tabIndex] = e3[r.$getParent]()[r.$tabIndex];
              return;
            }
            if (e3[r.$tabIndex]) return;
            let t3 = null;
            for (const a4 of e3.traversal[r.$getChildren]()) if ("next" === a4.operation) {
              t3 = a4;
              break;
            }
            if (!t3 || !t3.ref) {
              e3[r.$tabIndex] = e3[r.$getParent]()[r.$tabIndex];
              return;
            }
            const a3 = e3[r.$getTemplateRoot]();
            e3[r.$tabIndex] = ++a3[r.$tabIndex];
            const n2 = a3[r.$searchNode](t3.ref, e3);
            if (!n2) return;
            e3 = n2[0];
          }
        }
        function applyAssist(e3, t3) {
          var _a;
          const a3 = e3.assist;
          if (a3) {
            const e4 = a3[r.$toHTML]();
            e4 && (t3.title = e4);
            const n2 = a3.role.match(p);
            if (n2) {
              const e5 = "heading", a4 = n2[1];
              t3.role = e5;
              t3["aria-level"] = a4;
            }
          }
          if ("table" === e3.layout) t3.role = "table";
          else if ("row" === e3.layout) t3.role = "row";
          else {
            const a4 = e3[r.$getParent]();
            "row" === a4.layout && (t3.role = "TH" === ((_a = a4.assist) == null ? void 0 : _a.role) ? "columnheader" : "cell");
          }
        }
        function ariaLabel(e3) {
          if (!e3.assist) return null;
          const t3 = e3.assist;
          return t3.speak && "" !== t3.speak[r.$content] ? t3.speak[r.$content] : t3.toolTip ? t3.toolTip[r.$content] : null;
        }
        function valueToHtml(e3) {
          return c.HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e3 }] });
        }
        function setFirstUnsplittable(e3) {
          const t3 = e3[r.$getTemplateRoot]();
          if (null === t3[r.$extra].firstUnsplittable) {
            t3[r.$extra].firstUnsplittable = e3;
            t3[r.$extra].noLayoutFailure = true;
          }
        }
        function unsetFirstUnsplittable(e3) {
          const t3 = e3[r.$getTemplateRoot]();
          t3[r.$extra].firstUnsplittable === e3 && (t3[r.$extra].noLayoutFailure = false);
        }
        function handleBreak(e3) {
          if (e3[r.$extra]) return false;
          e3[r.$extra] = /* @__PURE__ */ Object.create(null);
          if ("auto" === e3.targetType) return false;
          const t3 = e3[r.$getTemplateRoot]();
          let a3 = null;
          if (e3.target) {
            a3 = t3[r.$searchNode](e3.target, e3[r.$getParent]());
            if (!a3) return false;
            a3 = a3[0];
          }
          const { currentPageArea: n2, currentContentArea: i2 } = t3[r.$extra];
          if ("pageArea" === e3.targetType) {
            a3 instanceof PageArea || (a3 = null);
            if (e3.startNew) {
              e3[r.$extra].target = a3 || n2;
              return true;
            }
            if (a3 && a3 !== n2) {
              e3[r.$extra].target = a3;
              return true;
            }
            return false;
          }
          a3 instanceof ContentArea || (a3 = null);
          const s2 = a3 && a3[r.$getParent]();
          let o2, c2 = s2;
          if (e3.startNew) if (a3) {
            const e4 = s2.contentArea.children, t4 = e4.indexOf(i2), r2 = e4.indexOf(a3);
            -1 !== t4 && t4 < r2 && (c2 = null);
            o2 = r2 - 1;
          } else o2 = n2.contentArea.children.indexOf(i2);
          else {
            if (!a3 || a3 === i2) return false;
            o2 = s2.contentArea.children.indexOf(a3) - 1;
            c2 = s2 === n2 ? null : s2;
          }
          e3[r.$extra].target = c2;
          e3[r.$extra].index = o2;
          return true;
        }
        function handleOverflow(e3, t3, a3) {
          const n2 = e3[r.$getTemplateRoot](), i2 = n2[r.$extra].noLayoutFailure, s2 = t3[r.$getSubformParent];
          t3[r.$getSubformParent] = () => e3;
          n2[r.$extra].noLayoutFailure = true;
          const o2 = t3[r.$toHTML](a3);
          e3[r.$addHTML](o2.html, o2.bbox);
          n2[r.$extra].noLayoutFailure = i2;
          t3[r.$getSubformParent] = s2;
        }
        class AppearanceFilter extends o.StringObject {
          constructor(e3) {
            super(f, "appearanceFilter");
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Arc extends o.XFAObject {
          constructor(e3) {
            super(f, "arc", true);
            this.circular = (0, c.getInteger)({ data: e3.circular, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.hand = (0, c.getStringOption)(e3.hand, ["even", "left", "right"]);
            this.id = e3.id || "";
            this.startAngle = (0, c.getFloat)({ data: e3.startAngle, defaultValue: 0, validate: (e4) => true });
            this.sweepAngle = (0, c.getFloat)({ data: e3.sweepAngle, defaultValue: 360, validate: (e4) => true });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.edge = null;
            this.fill = null;
          }
          [r.$toHTML]() {
            var _a;
            const e3 = this.edge || new Edge({}), t3 = e3[r.$toStyle](), a3 = /* @__PURE__ */ Object.create(null);
            "visible" === ((_a = this.fill) == null ? void 0 : _a.presence) ? Object.assign(a3, this.fill[r.$toStyle]()) : a3.fill = "transparent";
            a3.strokeWidth = (0, s.measureToString)("visible" === e3.presence ? e3.thickness : 0);
            a3.stroke = t3.color;
            let n2;
            const i2 = { xmlns: g, style: { width: "100%", height: "100%", overflow: "visible" } };
            if (360 === this.sweepAngle) n2 = { name: "ellipse", attributes: { xmlns: g, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: a3 } };
            else {
              const e4 = this.startAngle * Math.PI / 180, t4 = this.sweepAngle * Math.PI / 180, r2 = this.sweepAngle > 180 ? 1 : 0, [s2, o3, c2, l2] = [50 * (1 + Math.cos(e4)), 50 * (1 - Math.sin(e4)), 50 * (1 + Math.cos(e4 + t4)), 50 * (1 - Math.sin(e4 + t4))];
              n2 = { name: "path", attributes: { xmlns: g, d: `M ${s2} ${o3} A 50 50 0 ${r2} 0 ${c2} ${l2}`, vectorEffect: "non-scaling-stroke", style: a3 } };
              Object.assign(i2, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
            }
            const o2 = { name: "svg", children: [n2], attributes: i2 };
            if (hasMargin(this[r.$getParent]()[r.$getParent]())) return c.HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [o2] });
            o2.attributes.style.position = "absolute";
            return c.HTMLResult.success(o2);
          }
        }
        class Area extends o.XFAObject {
          constructor(e3) {
            super(f, "area", true);
            this.colSpan = (0, c.getInteger)({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.desc = null;
            this.extras = null;
            this.area = new o.XFAObjectArray();
            this.draw = new o.XFAObjectArray();
            this.exObject = new o.XFAObjectArray();
            this.exclGroup = new o.XFAObjectArray();
            this.field = new o.XFAObjectArray();
            this.subform = new o.XFAObjectArray();
            this.subformSet = new o.XFAObjectArray();
          }
          *[r.$getContainedChildren]() {
            yield* getContainedChildren(this);
          }
          [r.$isTransparent]() {
            return true;
          }
          [r.$isBindable]() {
            return true;
          }
          [r.$addHTML](e3, t3) {
            const [a3, n2, i2, s2] = t3;
            this[r.$extra].width = Math.max(this[r.$extra].width, a3 + i2);
            this[r.$extra].height = Math.max(this[r.$extra].height, n2 + s2);
            this[r.$extra].children.push(e3);
          }
          [r.$getAvailableSpace]() {
            return this[r.$extra].availableSpace;
          }
          [r.$toHTML](e3) {
            const t3 = (0, s.toStyle)(this, "position"), a3 = { style: t3, id: this[r.$uid], class: ["xfaArea"] };
            (0, s.isPrintOnly)(this) && a3.class.push("xfaPrintOnly");
            this.name && (a3.xfaName = this.name);
            const n2 = [];
            this[r.$extra] = { children: n2, width: 0, height: 0, availableSpace: e3 };
            const i2 = this[r.$childrenToHTML]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
            if (!i2.success) {
              if (i2.isBreak()) return i2;
              delete this[r.$extra];
              return c.HTMLResult.FAILURE;
            }
            t3.width = (0, s.measureToString)(this[r.$extra].width);
            t3.height = (0, s.measureToString)(this[r.$extra].height);
            const o2 = { name: "div", attributes: a3, children: n2 }, l2 = [this.x, this.y, this[r.$extra].width, this[r.$extra].height];
            delete this[r.$extra];
            return c.HTMLResult.success(o2, l2);
          }
        }
        class Assist extends o.XFAObject {
          constructor(e3) {
            super(f, "assist", true);
            this.id = e3.id || "";
            this.role = e3.role || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.speak = null;
            this.toolTip = null;
          }
          [r.$toHTML]() {
            var _a;
            return ((_a = this.toolTip) == null ? void 0 : _a[r.$content]) || null;
          }
        }
        class Barcode extends o.XFAObject {
          constructor(e3) {
            super(f, "barcode", true);
            this.charEncoding = (0, c.getKeyword)({ data: e3.charEncoding ? e3.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) });
            this.checksum = (0, c.getStringOption)(e3.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
            this.dataColumnCount = (0, c.getInteger)({ data: e3.dataColumnCount, defaultValue: -1, validate: (e4) => e4 >= 0 });
            this.dataLength = (0, c.getInteger)({ data: e3.dataLength, defaultValue: -1, validate: (e4) => e4 >= 0 });
            this.dataPrep = (0, c.getStringOption)(e3.dataPrep, ["none", "flateCompress"]);
            this.dataRowCount = (0, c.getInteger)({ data: e3.dataRowCount, defaultValue: -1, validate: (e4) => e4 >= 0 });
            this.endChar = e3.endChar || "";
            this.errorCorrectionLevel = (0, c.getInteger)({ data: e3.errorCorrectionLevel, defaultValue: -1, validate: (e4) => e4 >= 0 && e4 <= 8 });
            this.id = e3.id || "";
            this.moduleHeight = (0, c.getMeasurement)(e3.moduleHeight, "5mm");
            this.moduleWidth = (0, c.getMeasurement)(e3.moduleWidth, "0.25mm");
            this.printCheckDigit = (0, c.getInteger)({ data: e3.printCheckDigit, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.rowColumnRatio = (0, c.getRatio)(e3.rowColumnRatio);
            this.startChar = e3.startChar || "";
            this.textLocation = (0, c.getStringOption)(e3.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
            this.truncate = (0, c.getInteger)({ data: e3.truncate, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.type = (0, c.getStringOption)(e3.type ? e3.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
            this.upsMode = (0, c.getStringOption)(e3.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.wideNarrowRatio = (0, c.getRatio)(e3.wideNarrowRatio);
            this.encrypt = null;
            this.extras = null;
          }
        }
        class Bind extends o.XFAObject {
          constructor(e3) {
            super(f, "bind", true);
            this.match = (0, c.getStringOption)(e3.match, ["once", "dataRef", "global", "none"]);
            this.ref = e3.ref || "";
            this.picture = null;
          }
        }
        class BindItems extends o.XFAObject {
          constructor(e3) {
            super(f, "bindItems");
            this.connection = e3.connection || "";
            this.labelRef = e3.labelRef || "";
            this.ref = e3.ref || "";
            this.valueRef = e3.valueRef || "";
          }
        }
        t2.BindItems = BindItems;
        class Bookend extends o.XFAObject {
          constructor(e3) {
            super(f, "bookend");
            this.id = e3.id || "";
            this.leader = e3.leader || "";
            this.trailer = e3.trailer || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class BooleanElement extends o.Option01 {
          constructor(e3) {
            super(f, "boolean");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$toHTML](e3) {
            return valueToHtml(1 === this[r.$content] ? "1" : "0");
          }
        }
        class Border extends o.XFAObject {
          constructor(e3) {
            super(f, "border", true);
            this.break = (0, c.getStringOption)(e3.break, ["close", "open"]);
            this.hand = (0, c.getStringOption)(e3.hand, ["even", "left", "right"]);
            this.id = e3.id || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.corner = new o.XFAObjectArray(4);
            this.edge = new o.XFAObjectArray(4);
            this.extras = null;
            this.fill = null;
            this.margin = null;
          }
          [r.$getExtra]() {
            if (!this[r.$extra]) {
              const e3 = this.edge.children.slice();
              if (e3.length < 4) {
                const t4 = e3.at(-1) || new Edge({});
                for (let a4 = e3.length; a4 < 4; a4++) e3.push(t4);
              }
              const t3 = e3.map((e4) => e4.thickness), a3 = [0, 0, 0, 0];
              if (this.margin) {
                a3[0] = this.margin.topInset;
                a3[1] = this.margin.rightInset;
                a3[2] = this.margin.bottomInset;
                a3[3] = this.margin.leftInset;
              }
              this[r.$extra] = { widths: t3, insets: a3, edges: e3 };
            }
            return this[r.$extra];
          }
          [r.$toStyle]() {
            var _a;
            const { edges: e3 } = this[r.$getExtra](), t3 = e3.map((e4) => {
              const t4 = e4[r.$toStyle]();
              t4.color || (t4.color = "#000000");
              return t4;
            }), a3 = /* @__PURE__ */ Object.create(null);
            this.margin && Object.assign(a3, this.margin[r.$toStyle]());
            "visible" === ((_a = this.fill) == null ? void 0 : _a.presence) && Object.assign(a3, this.fill[r.$toStyle]());
            if (this.corner.children.some((e4) => 0 !== e4.radius)) {
              const e4 = this.corner.children.map((e5) => e5[r.$toStyle]());
              if (2 === e4.length || 3 === e4.length) {
                const t4 = e4.at(-1);
                for (let a4 = e4.length; a4 < 4; a4++) e4.push(t4);
              }
              a3.borderRadius = e4.map((e5) => e5.radius).join(" ");
            }
            switch (this.presence) {
              case "invisible":
              case "hidden":
                a3.borderStyle = "";
                break;
              case "inactive":
                a3.borderStyle = "none";
                break;
              default:
                a3.borderStyle = t3.map((e4) => e4.style).join(" ");
            }
            a3.borderWidth = t3.map((e4) => e4.width).join(" ");
            a3.borderColor = t3.map((e4) => e4.color).join(" ");
            return a3;
          }
        }
        class Break extends o.XFAObject {
          constructor(e3) {
            super(f, "break", true);
            this.after = (0, c.getStringOption)(e3.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
            this.afterTarget = e3.afterTarget || "";
            this.before = (0, c.getStringOption)(e3.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
            this.beforeTarget = e3.beforeTarget || "";
            this.bookendLeader = e3.bookendLeader || "";
            this.bookendTrailer = e3.bookendTrailer || "";
            this.id = e3.id || "";
            this.overflowLeader = e3.overflowLeader || "";
            this.overflowTarget = e3.overflowTarget || "";
            this.overflowTrailer = e3.overflowTrailer || "";
            this.startNew = (0, c.getInteger)({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
        }
        class BreakAfter extends o.XFAObject {
          constructor(e3) {
            super(f, "breakAfter", true);
            this.id = e3.id || "";
            this.leader = e3.leader || "";
            this.startNew = (0, c.getInteger)({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.target = e3.target || "";
            this.targetType = (0, c.getStringOption)(e3.targetType, ["auto", "contentArea", "pageArea"]);
            this.trailer = e3.trailer || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.script = null;
          }
        }
        class BreakBefore extends o.XFAObject {
          constructor(e3) {
            super(f, "breakBefore", true);
            this.id = e3.id || "";
            this.leader = e3.leader || "";
            this.startNew = (0, c.getInteger)({ data: e3.startNew, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.target = e3.target || "";
            this.targetType = (0, c.getStringOption)(e3.targetType, ["auto", "contentArea", "pageArea"]);
            this.trailer = e3.trailer || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.script = null;
          }
          [r.$toHTML](e3) {
            this[r.$extra] = {};
            return c.HTMLResult.FAILURE;
          }
        }
        class Button extends o.XFAObject {
          constructor(e3) {
            super(f, "button", true);
            this.highlight = (0, c.getStringOption)(e3.highlight, ["inverted", "none", "outline", "push"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
          [r.$toHTML](e3) {
            const t3 = this[r.$getParent]()[r.$getParent](), a3 = { name: "button", attributes: { id: this[r.$uid], class: ["xfaButton"], style: {} }, children: [] };
            for (const e4 of t3.event.children) {
              if ("click" !== e4.activity || !e4.script) continue;
              const t4 = (0, u.recoverJsURL)(e4.script[r.$content]);
              if (!t4) continue;
              const n2 = (0, s.fixURL)(t4.url);
              n2 && a3.children.push({ name: "a", attributes: { id: "link" + this[r.$uid], href: n2, newWindow: t4.newWindow, class: ["xfaLink"], style: {} }, children: [] });
            }
            return c.HTMLResult.success(a3);
          }
        }
        class Calculate extends o.XFAObject {
          constructor(e3) {
            super(f, "calculate", true);
            this.id = e3.id || "";
            this.override = (0, c.getStringOption)(e3.override, ["disabled", "error", "ignore", "warning"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.message = null;
            this.script = null;
          }
        }
        class Caption extends o.XFAObject {
          constructor(e3) {
            super(f, "caption", true);
            this.id = e3.id || "";
            this.placement = (0, c.getStringOption)(e3.placement, ["left", "bottom", "inline", "right", "top"]);
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.reserve = Math.ceil((0, c.getMeasurement)(e3.reserve));
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.font = null;
            this.margin = null;
            this.para = null;
            this.value = null;
          }
          [r.$setValue](e3) {
            _setValue(this, e3);
          }
          [r.$getExtra](e3) {
            if (!this[r.$extra]) {
              let { width: t3, height: a3 } = e3;
              switch (this.placement) {
                case "left":
                case "right":
                case "inline":
                  t3 = this.reserve <= 0 ? t3 : this.reserve;
                  break;
                case "top":
                case "bottom":
                  a3 = this.reserve <= 0 ? a3 : this.reserve;
              }
              this[r.$extra] = (0, s.layoutNode)(this, { width: t3, height: a3 });
            }
            return this[r.$extra];
          }
          [r.$toHTML](e3) {
            if (!this.value) return c.HTMLResult.EMPTY;
            this[r.$pushPara]();
            const t3 = this.value[r.$toHTML](e3).html;
            if (!t3) {
              this[r.$popPara]();
              return c.HTMLResult.EMPTY;
            }
            const a3 = this.reserve;
            if (this.reserve <= 0) {
              const { w: t4, h: a4 } = this[r.$getExtra](e3);
              switch (this.placement) {
                case "left":
                case "right":
                case "inline":
                  this.reserve = t4;
                  break;
                case "top":
                case "bottom":
                  this.reserve = a4;
              }
            }
            const n2 = [];
            "string" == typeof t3 ? n2.push({ name: "#text", value: t3 }) : n2.push(t3);
            const i2 = (0, s.toStyle)(this, "font", "margin", "visibility");
            switch (this.placement) {
              case "left":
              case "right":
                this.reserve > 0 && (i2.width = (0, s.measureToString)(this.reserve));
                break;
              case "top":
              case "bottom":
                this.reserve > 0 && (i2.height = (0, s.measureToString)(this.reserve));
            }
            (0, s.setPara)(this, null, t3);
            this[r.$popPara]();
            this.reserve = a3;
            return c.HTMLResult.success({ name: "div", attributes: { style: i2, class: ["xfaCaption"] }, children: n2 });
          }
        }
        class Certificate extends o.StringObject {
          constructor(e3) {
            super(f, "certificate");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Certificates extends o.XFAObject {
          constructor(e3) {
            super(f, "certificates", true);
            this.credentialServerPolicy = (0, c.getStringOption)(e3.credentialServerPolicy, ["optional", "required"]);
            this.id = e3.id || "";
            this.url = e3.url || "";
            this.urlPolicy = e3.urlPolicy || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.encryption = null;
            this.issuers = null;
            this.keyUsage = null;
            this.oids = null;
            this.signing = null;
            this.subjectDNs = null;
          }
        }
        class CheckButton extends o.XFAObject {
          constructor(e3) {
            super(f, "checkButton", true);
            this.id = e3.id || "";
            this.mark = (0, c.getStringOption)(e3.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
            this.shape = (0, c.getStringOption)(e3.shape, ["square", "round"]);
            this.size = (0, c.getMeasurement)(e3.size, "10pt");
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            var _a, _b, _c;
            const t3 = (0, s.toStyle)("margin"), a3 = (0, s.measureToString)(this.size);
            t3.width = t3.height = a3;
            let n2, i2, o2;
            const l2 = this[r.$getParent]()[r.$getParent](), h2 = l2.items.children.length && l2.items.children[0][r.$toHTML]().html || [], u2 = { on: (void 0 !== h2[0] ? h2[0] : "on").toString(), off: (void 0 !== h2[1] ? h2[1] : "off").toString() }, d2 = (((_a = l2.value) == null ? void 0 : _a[r.$text]()) || "off") === u2.on || void 0, f2 = l2[r.$getSubformParent](), g2 = l2[r.$uid];
            let p2;
            if (f2 instanceof ExclGroup) {
              o2 = f2[r.$uid];
              n2 = "radio";
              i2 = "xfaRadio";
              p2 = ((_b = f2[r.$data]) == null ? void 0 : _b[r.$uid]) || f2[r.$uid];
            } else {
              n2 = "checkbox";
              i2 = "xfaCheckbox";
              p2 = ((_c = l2[r.$data]) == null ? void 0 : _c[r.$uid]) || l2[r.$uid];
            }
            const m2 = { name: "input", attributes: { class: [i2], style: t3, fieldId: g2, dataId: p2, type: n2, checked: d2, xfaOn: u2.on, xfaOff: u2.off, "aria-label": ariaLabel(l2), "aria-required": false } };
            o2 && (m2.attributes.name = o2);
            if (isRequired(l2)) {
              m2.attributes["aria-required"] = true;
              m2.attributes.required = true;
            }
            return c.HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [m2] });
          }
        }
        class ChoiceList extends o.XFAObject {
          constructor(e3) {
            super(f, "choiceList", true);
            this.commitOn = (0, c.getStringOption)(e3.commitOn, ["select", "exit"]);
            this.id = e3.id || "";
            this.open = (0, c.getStringOption)(e3.open, ["userControl", "always", "multiSelect", "onEntry"]);
            this.textEntry = (0, c.getInteger)({ data: e3.textEntry, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            var _a, _b, _c;
            const t3 = (0, s.toStyle)(this, "border", "margin"), a3 = this[r.$getParent]()[r.$getParent](), n2 = { fontSize: `calc(${((_a = a3.font) == null ? void 0 : _a.size) || 10}px * var(--scale-factor))` }, i2 = [];
            if (a3.items.children.length > 0) {
              const e4 = a3.items;
              let t4 = 0, s2 = 0;
              if (2 === e4.children.length) {
                t4 = e4.children[0].save;
                s2 = 1 - t4;
              }
              const o3 = e4.children[t4][r.$toHTML]().html, c2 = e4.children[s2][r.$toHTML]().html;
              let l2 = false;
              const h2 = ((_b = a3.value) == null ? void 0 : _b[r.$text]()) || "";
              for (let e5 = 0, t5 = o3.length; e5 < t5; e5++) {
                const t6 = { name: "option", attributes: { value: c2[e5] || o3[e5], style: n2 }, value: o3[e5] };
                c2[e5] === h2 && (t6.attributes.selected = l2 = true);
                i2.push(t6);
              }
              l2 || i2.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
            }
            const o2 = { class: ["xfaSelect"], fieldId: a3[r.$uid], dataId: ((_c = a3[r.$data]) == null ? void 0 : _c[r.$uid]) || a3[r.$uid], style: t3, "aria-label": ariaLabel(a3), "aria-required": false };
            if (isRequired(a3)) {
              o2["aria-required"] = true;
              o2.required = true;
            }
            "multiSelect" === this.open && (o2.multiple = true);
            return c.HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: i2, attributes: o2 }] });
          }
        }
        class Color extends o.XFAObject {
          constructor(e3) {
            super(f, "color", true);
            this.cSpace = (0, c.getStringOption)(e3.cSpace, ["SRGB"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.value = e3.value ? (0, c.getColor)(e3.value) : "";
            this.extras = null;
          }
          [r.$hasSettableValue]() {
            return false;
          }
          [r.$toStyle]() {
            return this.value ? l.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
          }
        }
        class Comb extends o.XFAObject {
          constructor(e3) {
            super(f, "comb");
            this.id = e3.id || "";
            this.numberOfCells = (0, c.getInteger)({ data: e3.numberOfCells, defaultValue: 0, validate: (e4) => e4 >= 0 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Connect extends o.XFAObject {
          constructor(e3) {
            super(f, "connect", true);
            this.connection = e3.connection || "";
            this.id = e3.id || "";
            this.ref = e3.ref || "";
            this.usage = (0, c.getStringOption)(e3.usage, ["exportAndImport", "exportOnly", "importOnly"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.picture = null;
          }
        }
        class ContentArea extends o.XFAObject {
          constructor(e3) {
            super(f, "contentArea", true);
            this.h = (0, c.getMeasurement)(e3.h);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.w = (0, c.getMeasurement)(e3.w);
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.desc = null;
            this.extras = null;
          }
          [r.$toHTML](e3) {
            const t3 = { left: (0, s.measureToString)(this.x), top: (0, s.measureToString)(this.y), width: (0, s.measureToString)(this.w), height: (0, s.measureToString)(this.h) }, a3 = ["xfaContentarea"];
            (0, s.isPrintOnly)(this) && a3.push("xfaPrintOnly");
            return c.HTMLResult.success({ name: "div", children: [], attributes: { style: t3, class: a3, id: this[r.$uid] } });
          }
        }
        class Corner extends o.XFAObject {
          constructor(e3) {
            super(f, "corner", true);
            this.id = e3.id || "";
            this.inverted = (0, c.getInteger)({ data: e3.inverted, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.join = (0, c.getStringOption)(e3.join, ["square", "round"]);
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.radius = (0, c.getMeasurement)(e3.radius);
            this.stroke = (0, c.getStringOption)(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
            this.thickness = (0, c.getMeasurement)(e3.thickness, "0.5pt");
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle]() {
            const e3 = (0, s.toStyle)(this, "visibility");
            e3.radius = (0, s.measureToString)("square" === this.join ? 0 : this.radius);
            return e3;
          }
        }
        class DateElement extends o.ContentObject {
          constructor(e3) {
            super(f, "date");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = this[r.$content].trim();
            this[r.$content] = e3 ? new Date(e3) : null;
          }
          [r.$toHTML](e3) {
            return valueToHtml(this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class DateTime extends o.ContentObject {
          constructor(e3) {
            super(f, "dateTime");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = this[r.$content].trim();
            this[r.$content] = e3 ? new Date(e3) : null;
          }
          [r.$toHTML](e3) {
            return valueToHtml(this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class DateTimeEdit extends o.XFAObject {
          constructor(e3) {
            super(f, "dateTimeEdit", true);
            this.hScrollPolicy = (0, c.getStringOption)(e3.hScrollPolicy, ["auto", "off", "on"]);
            this.id = e3.id || "";
            this.picker = (0, c.getStringOption)(e3.picker, ["host", "none"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.comb = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            var _a;
            const t3 = (0, s.toStyle)(this, "border", "font", "margin"), a3 = this[r.$getParent]()[r.$getParent](), n2 = { name: "input", attributes: { type: "text", fieldId: a3[r.$uid], dataId: ((_a = a3[r.$data]) == null ? void 0 : _a[r.$uid]) || a3[r.$uid], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } };
            if (isRequired(a3)) {
              n2.attributes["aria-required"] = true;
              n2.attributes.required = true;
            }
            return c.HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [n2] });
          }
        }
        class Decimal extends o.ContentObject {
          constructor(e3) {
            super(f, "decimal");
            this.fracDigits = (0, c.getInteger)({ data: e3.fracDigits, defaultValue: 2, validate: (e4) => true });
            this.id = e3.id || "";
            this.leadDigits = (0, c.getInteger)({ data: e3.leadDigits, defaultValue: -1, validate: (e4) => true });
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = parseFloat(this[r.$content].trim());
            this[r.$content] = isNaN(e3) ? null : e3;
          }
          [r.$toHTML](e3) {
            return valueToHtml(null !== this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class DefaultUi extends o.XFAObject {
          constructor(e3) {
            super(f, "defaultUi", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
        }
        class Desc extends o.XFAObject {
          constructor(e3) {
            super(f, "desc", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.boolean = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
          }
        }
        class DigestMethod extends o.OptionObject {
          constructor(e3) {
            super(f, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class DigestMethods extends o.XFAObject {
          constructor(e3) {
            super(f, "digestMethods", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.digestMethod = new o.XFAObjectArray();
          }
        }
        class Draw extends o.XFAObject {
          constructor(e3) {
            super(f, "draw", true);
            this.anchorType = (0, c.getStringOption)(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
            this.colSpan = (0, c.getInteger)({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
            this.h = e3.h ? (0, c.getMeasurement)(e3.h) : "";
            this.hAlign = (0, c.getStringOption)(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
            this.id = e3.id || "";
            this.locale = e3.locale || "";
            this.maxH = (0, c.getMeasurement)(e3.maxH, "0pt");
            this.maxW = (0, c.getMeasurement)(e3.maxW, "0pt");
            this.minH = (0, c.getMeasurement)(e3.minH, "0pt");
            this.minW = (0, c.getMeasurement)(e3.minW, "0pt");
            this.name = e3.name || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.rotate = (0, c.getInteger)({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.w = e3.w ? (0, c.getMeasurement)(e3.w) : "";
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.assist = null;
            this.border = null;
            this.caption = null;
            this.desc = null;
            this.extras = null;
            this.font = null;
            this.keep = null;
            this.margin = null;
            this.para = null;
            this.traversal = null;
            this.ui = null;
            this.value = null;
            this.setProperty = new o.XFAObjectArray();
          }
          [r.$setValue](e3) {
            _setValue(this, e3);
          }
          [r.$toHTML](e3) {
            setTabIndex(this);
            if ("hidden" === this.presence || "inactive" === this.presence) return c.HTMLResult.EMPTY;
            (0, s.fixDimensions)(this);
            this[r.$pushPara]();
            const t3 = this.w, a3 = this.h, { w: n2, h: o2, isBroken: l2 } = (0, s.layoutNode)(this, e3);
            if (n2 && "" === this.w) {
              if (l2 && this[r.$getSubformParent]()[r.$isThereMoreWidth]()) {
                this[r.$popPara]();
                return c.HTMLResult.FAILURE;
              }
              this.w = n2;
            }
            o2 && "" === this.h && (this.h = o2);
            setFirstUnsplittable(this);
            if (!(0, i.checkDimensions)(this, e3)) {
              this.w = t3;
              this.h = a3;
              this[r.$popPara]();
              return c.HTMLResult.FAILURE;
            }
            unsetFirstUnsplittable(this);
            const h2 = (0, s.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
            (0, s.setMinMaxDimensions)(this, h2);
            if (h2.margin) {
              h2.padding = h2.margin;
              delete h2.margin;
            }
            const u2 = ["xfaDraw"];
            this.font && u2.push("xfaFont");
            (0, s.isPrintOnly)(this) && u2.push("xfaPrintOnly");
            const d2 = { style: h2, id: this[r.$uid], class: u2 };
            this.name && (d2.xfaName = this.name);
            const f2 = { name: "div", attributes: d2, children: [] };
            applyAssist(this, d2);
            const g2 = (0, s.computeBbox)(this, f2, e3), p2 = this.value ? this.value[r.$toHTML](e3).html : null;
            if (null === p2) {
              this.w = t3;
              this.h = a3;
              this[r.$popPara]();
              return c.HTMLResult.success((0, s.createWrapper)(this, f2), g2);
            }
            f2.children.push(p2);
            (0, s.setPara)(this, h2, p2);
            this.w = t3;
            this.h = a3;
            this[r.$popPara]();
            return c.HTMLResult.success((0, s.createWrapper)(this, f2), g2);
          }
        }
        class Edge extends o.XFAObject {
          constructor(e3) {
            super(f, "edge", true);
            this.cap = (0, c.getStringOption)(e3.cap, ["square", "butt", "round"]);
            this.id = e3.id || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.stroke = (0, c.getStringOption)(e3.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
            this.thickness = (0, c.getMeasurement)(e3.thickness, "0.5pt");
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle]() {
            const e3 = (0, s.toStyle)(this, "visibility");
            Object.assign(e3, { linecap: this.cap, width: (0, s.measureToString)(this.thickness), color: this.color ? this.color[r.$toStyle]() : "#000000", style: "" });
            if ("visible" !== this.presence) e3.style = "none";
            else switch (this.stroke) {
              case "solid":
                e3.style = "solid";
                break;
              case "dashDot":
              case "dashDotDot":
              case "dashed":
                e3.style = "dashed";
                break;
              case "dotted":
                e3.style = "dotted";
                break;
              case "embossed":
                e3.style = "ridge";
                break;
              case "etched":
                e3.style = "groove";
                break;
              case "lowered":
                e3.style = "inset";
                break;
              case "raised":
                e3.style = "outset";
            }
            return e3;
          }
        }
        class Encoding extends o.OptionObject {
          constructor(e3) {
            super(f, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Encodings extends o.XFAObject {
          constructor(e3) {
            super(f, "encodings", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.encoding = new o.XFAObjectArray();
          }
        }
        class Encrypt extends o.XFAObject {
          constructor(e3) {
            super(f, "encrypt", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.certificate = null;
          }
        }
        class EncryptData extends o.XFAObject {
          constructor(e3) {
            super(f, "encryptData", true);
            this.id = e3.id || "";
            this.operation = (0, c.getStringOption)(e3.operation, ["encrypt", "decrypt"]);
            this.target = e3.target || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.filter = null;
            this.manifest = null;
          }
        }
        class Encryption extends o.XFAObject {
          constructor(e3) {
            super(f, "encryption", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.certificate = new o.XFAObjectArray();
          }
        }
        class EncryptionMethod extends o.OptionObject {
          constructor(e3) {
            super(f, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class EncryptionMethods extends o.XFAObject {
          constructor(e3) {
            super(f, "encryptionMethods", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.encryptionMethod = new o.XFAObjectArray();
          }
        }
        class Event extends o.XFAObject {
          constructor(e3) {
            super(f, "event", true);
            this.activity = (0, c.getStringOption)(e3.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
            this.id = e3.id || "";
            this.listen = (0, c.getStringOption)(e3.listen, ["refOnly", "refAndDescendents"]);
            this.name = e3.name || "";
            this.ref = e3.ref || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.encryptData = null;
            this.execute = null;
            this.script = null;
            this.signData = null;
            this.submit = null;
          }
        }
        class ExData extends o.ContentObject {
          constructor(e3) {
            super(f, "exData");
            this.contentType = e3.contentType || "";
            this.href = e3.href || "";
            this.id = e3.id || "";
            this.maxLength = (0, c.getInteger)({ data: e3.maxLength, defaultValue: -1, validate: (e4) => e4 >= -1 });
            this.name = e3.name || "";
            this.rid = e3.rid || "";
            this.transferEncoding = (0, c.getStringOption)(e3.transferEncoding, ["none", "base64", "package"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$isCDATAXml]() {
            return "text/html" === this.contentType;
          }
          [r.$onChild](e3) {
            if ("text/html" === this.contentType && e3[r.$namespaceId] === n.NamespaceIds.xhtml.id) {
              this[r.$content] = e3;
              return true;
            }
            if ("text/xml" === this.contentType) {
              this[r.$content] = e3;
              return true;
            }
            return false;
          }
          [r.$toHTML](e3) {
            return "text/html" === this.contentType && this[r.$content] ? this[r.$content][r.$toHTML](e3) : c.HTMLResult.EMPTY;
          }
        }
        class ExObject extends o.XFAObject {
          constructor(e3) {
            super(f, "exObject", true);
            this.archive = e3.archive || "";
            this.classId = e3.classId || "";
            this.codeBase = e3.codeBase || "";
            this.codeType = e3.codeType || "";
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.boolean = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.exObject = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
          }
        }
        class ExclGroup extends o.XFAObject {
          constructor(e3) {
            super(f, "exclGroup", true);
            this.access = (0, c.getStringOption)(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
            this.accessKey = e3.accessKey || "";
            this.anchorType = (0, c.getStringOption)(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
            this.colSpan = (0, c.getInteger)({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
            this.h = e3.h ? (0, c.getMeasurement)(e3.h) : "";
            this.hAlign = (0, c.getStringOption)(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
            this.id = e3.id || "";
            this.layout = (0, c.getStringOption)(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
            this.maxH = (0, c.getMeasurement)(e3.maxH, "0pt");
            this.maxW = (0, c.getMeasurement)(e3.maxW, "0pt");
            this.minH = (0, c.getMeasurement)(e3.minH, "0pt");
            this.minW = (0, c.getMeasurement)(e3.minW, "0pt");
            this.name = e3.name || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.w = e3.w ? (0, c.getMeasurement)(e3.w) : "";
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.assist = null;
            this.bind = null;
            this.border = null;
            this.calculate = null;
            this.caption = null;
            this.desc = null;
            this.extras = null;
            this.margin = null;
            this.para = null;
            this.traversal = null;
            this.validate = null;
            this.connect = new o.XFAObjectArray();
            this.event = new o.XFAObjectArray();
            this.field = new o.XFAObjectArray();
            this.setProperty = new o.XFAObjectArray();
          }
          [r.$isBindable]() {
            return true;
          }
          [r.$hasSettableValue]() {
            return true;
          }
          [r.$setValue](e3) {
            for (const t3 of this.field.children) {
              if (!t3.value) {
                const e4 = new Value({});
                t3[r.$appendChild](e4);
                t3.value = e4;
              }
              t3.value[r.$setValue](e3);
            }
          }
          [r.$isThereMoreWidth]() {
            return this.layout.endsWith("-tb") && 0 === this[r.$extra].attempt && this[r.$extra].numberInLine > 0 || this[r.$getParent]()[r.$isThereMoreWidth]();
          }
          [r.$isSplittable]() {
            var _a;
            const e3 = this[r.$getSubformParent]();
            if (!e3[r.$isSplittable]()) return false;
            if (void 0 !== this[r.$extra]._isSplittable) return this[r.$extra]._isSplittable;
            if ("position" === this.layout || this.layout.includes("row")) {
              this[r.$extra]._isSplittable = false;
              return false;
            }
            if (((_a = e3.layout) == null ? void 0 : _a.endsWith("-tb")) && 0 !== e3[r.$extra].numberInLine) return false;
            this[r.$extra]._isSplittable = true;
            return true;
          }
          [r.$flushHTML]() {
            return (0, i.flushHTML)(this);
          }
          [r.$addHTML](e3, t3) {
            (0, i.addHTML)(this, e3, t3);
          }
          [r.$getAvailableSpace]() {
            return (0, i.getAvailableSpace)(this);
          }
          [r.$toHTML](e3) {
            setTabIndex(this);
            if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return c.HTMLResult.EMPTY;
            (0, s.fixDimensions)(this);
            const t3 = [], a3 = { id: this[r.$uid], class: [] };
            (0, s.setAccess)(this, a3.class);
            this[r.$extra] || (this[r.$extra] = /* @__PURE__ */ Object.create(null));
            Object.assign(this[r.$extra], { children: t3, attributes: a3, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
            const n2 = this[r.$isSplittable]();
            n2 || setFirstUnsplittable(this);
            if (!(0, i.checkDimensions)(this, e3)) return c.HTMLResult.FAILURE;
            const o2 = /* @__PURE__ */ new Set(["field"]);
            if (this.layout.includes("row")) {
              const e4 = this[r.$getSubformParent]().columnWidths;
              if (Array.isArray(e4) && e4.length > 0) {
                this[r.$extra].columnWidths = e4;
                this[r.$extra].currentColumn = 0;
              }
            }
            const l2 = (0, s.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), h2 = ["xfaExclgroup"], u2 = (0, s.layoutClass)(this);
            u2 && h2.push(u2);
            (0, s.isPrintOnly)(this) && h2.push("xfaPrintOnly");
            a3.style = l2;
            a3.class = h2;
            this.name && (a3.xfaName = this.name);
            this[r.$pushPara]();
            const d2 = "lr-tb" === this.layout || "rl-tb" === this.layout, f2 = d2 ? 2 : 1;
            for (; this[r.$extra].attempt < f2; this[r.$extra].attempt++) {
              d2 && 1 === this[r.$extra].attempt && (this[r.$extra].numberInLine = 0);
              const e4 = this[r.$childrenToHTML]({ filter: o2, include: true });
              if (e4.success) break;
              if (e4.isBreak()) {
                this[r.$popPara]();
                return e4;
              }
              if (d2 && 0 === this[r.$extra].attempt && 0 === this[r.$extra].numberInLine && !this[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) {
                this[r.$extra].attempt = f2;
                break;
              }
            }
            this[r.$popPara]();
            n2 || unsetFirstUnsplittable(this);
            if (this[r.$extra].attempt === f2) {
              n2 || delete this[r.$extra];
              return c.HTMLResult.FAILURE;
            }
            let g2 = 0, p2 = 0;
            if (this.margin) {
              g2 = this.margin.leftInset + this.margin.rightInset;
              p2 = this.margin.topInset + this.margin.bottomInset;
            }
            const m2 = Math.max(this[r.$extra].width + g2, this.w || 0), b2 = Math.max(this[r.$extra].height + p2, this.h || 0), y = [this.x, this.y, m2, b2];
            "" === this.w && (l2.width = (0, s.measureToString)(m2));
            "" === this.h && (l2.height = (0, s.measureToString)(b2));
            const w = { name: "div", attributes: a3, children: t3 };
            applyAssist(this, a3);
            delete this[r.$extra];
            return c.HTMLResult.success((0, s.createWrapper)(this, w), y);
          }
        }
        class Execute extends o.XFAObject {
          constructor(e3) {
            super(f, "execute");
            this.connection = e3.connection || "";
            this.executeType = (0, c.getStringOption)(e3.executeType, ["import", "remerge"]);
            this.id = e3.id || "";
            this.runAt = (0, c.getStringOption)(e3.runAt, ["client", "both", "server"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Extras extends o.XFAObject {
          constructor(e3) {
            super(f, "extras", true);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.boolean = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.extras = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
          }
        }
        class Field extends o.XFAObject {
          constructor(e3) {
            super(f, "field", true);
            this.access = (0, c.getStringOption)(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
            this.accessKey = e3.accessKey || "";
            this.anchorType = (0, c.getStringOption)(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
            this.colSpan = (0, c.getInteger)({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
            this.h = e3.h ? (0, c.getMeasurement)(e3.h) : "";
            this.hAlign = (0, c.getStringOption)(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
            this.id = e3.id || "";
            this.locale = e3.locale || "";
            this.maxH = (0, c.getMeasurement)(e3.maxH, "0pt");
            this.maxW = (0, c.getMeasurement)(e3.maxW, "0pt");
            this.minH = (0, c.getMeasurement)(e3.minH, "0pt");
            this.minW = (0, c.getMeasurement)(e3.minW, "0pt");
            this.name = e3.name || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.rotate = (0, c.getInteger)({ data: e3.rotate, defaultValue: 0, validate: (e4) => e4 % 90 == 0 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.w = e3.w ? (0, c.getMeasurement)(e3.w) : "";
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.assist = null;
            this.bind = null;
            this.border = null;
            this.calculate = null;
            this.caption = null;
            this.desc = null;
            this.extras = null;
            this.font = null;
            this.format = null;
            this.items = new o.XFAObjectArray(2);
            this.keep = null;
            this.margin = null;
            this.para = null;
            this.traversal = null;
            this.ui = null;
            this.validate = null;
            this.value = null;
            this.bindItems = new o.XFAObjectArray();
            this.connect = new o.XFAObjectArray();
            this.event = new o.XFAObjectArray();
            this.setProperty = new o.XFAObjectArray();
          }
          [r.$isBindable]() {
            return true;
          }
          [r.$setValue](e3) {
            _setValue(this, e3);
          }
          [r.$toHTML](e3) {
            var _a, _b, _c;
            setTabIndex(this);
            if (!this.ui) {
              this.ui = new Ui({});
              this.ui[r.$globalData] = this[r.$globalData];
              this[r.$appendChild](this.ui);
              let e4;
              switch (this.items.children.length) {
                case 0:
                  e4 = new TextEdit({});
                  this.ui.textEdit = e4;
                  break;
                case 1:
                  e4 = new CheckButton({});
                  this.ui.checkButton = e4;
                  break;
                case 2:
                  e4 = new ChoiceList({});
                  this.ui.choiceList = e4;
              }
              this.ui[r.$appendChild](e4);
            }
            if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return c.HTMLResult.EMPTY;
            this.caption && delete this.caption[r.$extra];
            this[r.$pushPara]();
            const t3 = this.caption ? this.caption[r.$toHTML](e3).html : null, a3 = this.w, n2 = this.h;
            let o2 = 0, l2 = 0;
            if (this.margin) {
              o2 = this.margin.leftInset + this.margin.rightInset;
              l2 = this.margin.topInset + this.margin.bottomInset;
            }
            let u2 = null;
            if ("" === this.w || "" === this.h) {
              let t4 = null, a4 = null, n3 = 0, i2 = 0;
              if (this.ui.checkButton) n3 = i2 = this.ui.checkButton.size;
              else {
                const { w: t5, h: a5 } = (0, s.layoutNode)(this, e3);
                if (null !== t5) {
                  n3 = t5;
                  i2 = a5;
                } else i2 = (0, h.getMetrics)(this.font, true).lineNoGap;
              }
              u2 = getBorderDims(this.ui[r.$getExtra]());
              n3 += u2.w;
              i2 += u2.h;
              if (this.caption) {
                const { w: s2, h: o3, isBroken: l3 } = this.caption[r.$getExtra](e3);
                if (l3 && this[r.$getSubformParent]()[r.$isThereMoreWidth]()) {
                  this[r.$popPara]();
                  return c.HTMLResult.FAILURE;
                }
                t4 = s2;
                a4 = o3;
                switch (this.caption.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    t4 += n3;
                    break;
                  case "top":
                  case "bottom":
                    a4 += i2;
                }
              } else {
                t4 = n3;
                a4 = i2;
              }
              if (t4 && "" === this.w) {
                t4 += o2;
                this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t4 ? t4 : this.minW);
              }
              if (a4 && "" === this.h) {
                a4 += l2;
                this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < a4 ? a4 : this.minH);
              }
            }
            this[r.$popPara]();
            (0, s.fixDimensions)(this);
            setFirstUnsplittable(this);
            if (!(0, i.checkDimensions)(this, e3)) {
              this.w = a3;
              this.h = n2;
              this[r.$popPara]();
              return c.HTMLResult.FAILURE;
            }
            unsetFirstUnsplittable(this);
            const d2 = (0, s.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
            (0, s.setMinMaxDimensions)(this, d2);
            const f2 = ["xfaField"];
            this.font && f2.push("xfaFont");
            (0, s.isPrintOnly)(this) && f2.push("xfaPrintOnly");
            const g2 = { style: d2, id: this[r.$uid], class: f2 };
            if (d2.margin) {
              d2.padding = d2.margin;
              delete d2.margin;
            }
            (0, s.setAccess)(this, f2);
            this.name && (g2.xfaName = this.name);
            const p2 = [], m2 = { name: "div", attributes: g2, children: p2 };
            applyAssist(this, g2);
            const b2 = this.border ? this.border[r.$toStyle]() : null, y = (0, s.computeBbox)(this, m2, e3), w = this.ui[r.$toHTML]().html;
            if (!w) {
              Object.assign(d2, b2);
              return c.HTMLResult.success((0, s.createWrapper)(this, m2), y);
            }
            this[r.$tabIndex] && (((_a = w.children) == null ? void 0 : _a[0]) ? w.children[0].attributes.tabindex = this[r.$tabIndex] : w.attributes.tabindex = this[r.$tabIndex]);
            w.attributes.style || (w.attributes.style = /* @__PURE__ */ Object.create(null));
            let S = null;
            if (this.ui.button) {
              1 === w.children.length && ([S] = w.children.splice(0, 1));
              Object.assign(w.attributes.style, b2);
            } else Object.assign(d2, b2);
            p2.push(w);
            if (this.value) {
              if (this.ui.imageEdit) w.children.push(this.value[r.$toHTML]().html);
              else if (!this.ui.button) {
                let e4 = "";
                if (this.value.exData) e4 = this.value.exData[r.$text]();
                else if (this.value.text) e4 = this.value.text[r.$getExtra]();
                else {
                  const t4 = this.value[r.$toHTML]().html;
                  null !== t4 && (e4 = t4.children[0].value);
                }
                this.ui.textEdit && ((_b = this.value.text) == null ? void 0 : _b.maxChars) && (w.children[0].attributes.maxLength = this.value.text.maxChars);
                if (e4) {
                  if (this.ui.numericEdit) {
                    e4 = parseFloat(e4);
                    e4 = isNaN(e4) ? "" : e4.toString();
                  }
                  "textarea" === w.children[0].name ? w.children[0].attributes.textContent = e4 : w.children[0].attributes.value = e4;
                }
              }
            }
            if (!this.ui.imageEdit && ((_c = w.children) == null ? void 0 : _c[0]) && this.h) {
              u2 = u2 || getBorderDims(this.ui[r.$getExtra]());
              let t4 = 0;
              if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                t4 = this.caption.reserve;
                t4 <= 0 && (t4 = this.caption[r.$getExtra](e3).h);
                const a4 = this.h - t4 - l2 - u2.h;
                w.children[0].attributes.style.height = (0, s.measureToString)(a4);
              } else w.children[0].attributes.style.height = "100%";
            }
            S && w.children.push(S);
            if (!t3) {
              w.attributes.class && w.attributes.class.push("xfaLeft");
              this.w = a3;
              this.h = n2;
              return c.HTMLResult.success((0, s.createWrapper)(this, m2), y);
            }
            if (this.ui.button) {
              d2.padding && delete d2.padding;
              "div" === t3.name && (t3.name = "span");
              w.children.push(t3);
              return c.HTMLResult.success(m2, y);
            }
            this.ui.checkButton && (t3.attributes.class[0] = "xfaCaptionForCheckButton");
            w.attributes.class || (w.attributes.class = []);
            w.children.splice(0, 0, t3);
            switch (this.caption.placement) {
              case "left":
              case "inline":
                w.attributes.class.push("xfaLeft");
                break;
              case "right":
                w.attributes.class.push("xfaRight");
                break;
              case "top":
                w.attributes.class.push("xfaTop");
                break;
              case "bottom":
                w.attributes.class.push("xfaBottom");
            }
            this.w = a3;
            this.h = n2;
            return c.HTMLResult.success((0, s.createWrapper)(this, m2), y);
          }
        }
        t2.Field = Field;
        class Fill extends o.XFAObject {
          constructor(e3) {
            super(f, "fill", true);
            this.id = e3.id || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
            this.linear = null;
            this.pattern = null;
            this.radial = null;
            this.solid = null;
            this.stipple = null;
          }
          [r.$toStyle]() {
            var _a;
            const e3 = this[r.$getParent](), t3 = e3[r.$getParent]()[r.$getParent](), a3 = /* @__PURE__ */ Object.create(null);
            let n2 = "color", i2 = n2;
            if (e3 instanceof Border) {
              n2 = "background-color";
              i2 = "background";
              t3 instanceof Ui && (a3.backgroundColor = "white");
            }
            if (e3 instanceof Rectangle || e3 instanceof Arc) {
              n2 = i2 = "fill";
              a3.fill = "white";
            }
            for (const e4 of Object.getOwnPropertyNames(this)) {
              if ("extras" === e4 || "color" === e4) continue;
              const t4 = this[e4];
              if (!(t4 instanceof o.XFAObject)) continue;
              const s2 = t4[r.$toStyle](this.color);
              s2 && (a3[s2.startsWith("#") ? n2 : i2] = s2);
              return a3;
            }
            if ((_a = this.color) == null ? void 0 : _a.value) {
              const e4 = this.color[r.$toStyle]();
              a3[e4.startsWith("#") ? n2 : i2] = e4;
            }
            return a3;
          }
        }
        class Filter extends o.XFAObject {
          constructor(e3) {
            super(f, "filter", true);
            this.addRevocationInfo = (0, c.getStringOption)(e3.addRevocationInfo, ["", "required", "optional", "none"]);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.version = (0, c.getInteger)({ data: this.version, defaultValue: 5, validate: (e4) => e4 >= 1 && e4 <= 5 });
            this.appearanceFilter = null;
            this.certificates = null;
            this.digestMethods = null;
            this.encodings = null;
            this.encryptionMethods = null;
            this.handler = null;
            this.lockDocument = null;
            this.mdp = null;
            this.reasons = null;
            this.timeStamp = null;
          }
        }
        class Float extends o.ContentObject {
          constructor(e3) {
            super(f, "float");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = parseFloat(this[r.$content].trim());
            this[r.$content] = isNaN(e3) ? null : e3;
          }
          [r.$toHTML](e3) {
            return valueToHtml(null !== this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class Font extends o.XFAObject {
          constructor(e3) {
            super(f, "font", true);
            this.baselineShift = (0, c.getMeasurement)(e3.baselineShift);
            this.fontHorizontalScale = (0, c.getFloat)({ data: e3.fontHorizontalScale, defaultValue: 100, validate: (e4) => e4 >= 0 });
            this.fontVerticalScale = (0, c.getFloat)({ data: e3.fontVerticalScale, defaultValue: 100, validate: (e4) => e4 >= 0 });
            this.id = e3.id || "";
            this.kerningMode = (0, c.getStringOption)(e3.kerningMode, ["none", "pair"]);
            this.letterSpacing = (0, c.getMeasurement)(e3.letterSpacing, "0");
            this.lineThrough = (0, c.getInteger)({ data: e3.lineThrough, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
            this.lineThroughPeriod = (0, c.getStringOption)(e3.lineThroughPeriod, ["all", "word"]);
            this.overline = (0, c.getInteger)({ data: e3.overline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
            this.overlinePeriod = (0, c.getStringOption)(e3.overlinePeriod, ["all", "word"]);
            this.posture = (0, c.getStringOption)(e3.posture, ["normal", "italic"]);
            this.size = (0, c.getMeasurement)(e3.size, "10pt");
            this.typeface = e3.typeface || "Courier";
            this.underline = (0, c.getInteger)({ data: e3.underline, defaultValue: 0, validate: (e4) => 1 === e4 || 2 === e4 });
            this.underlinePeriod = (0, c.getStringOption)(e3.underlinePeriod, ["all", "word"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.weight = (0, c.getStringOption)(e3.weight, ["normal", "bold"]);
            this.extras = null;
            this.fill = null;
          }
          [r.$clean](e3) {
            super[r.$clean](e3);
            this[r.$globalData].usedTypefaces.add(this.typeface);
          }
          [r.$toStyle]() {
            const e3 = (0, s.toStyle)(this, "fill"), t3 = e3.color;
            if (t3) {
              if ("#000000" === t3) delete e3.color;
              else if (!t3.startsWith("#")) {
                e3.background = t3;
                e3.backgroundClip = "text";
                e3.color = "transparent";
              }
            }
            this.baselineShift && (e3.verticalAlign = (0, s.measureToString)(this.baselineShift));
            e3.fontKerning = "none" === this.kerningMode ? "none" : "normal";
            e3.letterSpacing = (0, s.measureToString)(this.letterSpacing);
            if (0 !== this.lineThrough) {
              e3.textDecoration = "line-through";
              2 === this.lineThrough && (e3.textDecorationStyle = "double");
            }
            if (0 !== this.overline) {
              e3.textDecoration = "overline";
              2 === this.overline && (e3.textDecorationStyle = "double");
            }
            e3.fontStyle = this.posture;
            e3.fontSize = (0, s.measureToString)(0.99 * this.size);
            (0, s.setFontFamily)(this, this, this[r.$globalData].fontFinder, e3);
            if (0 !== this.underline) {
              e3.textDecoration = "underline";
              2 === this.underline && (e3.textDecorationStyle = "double");
            }
            e3.fontWeight = this.weight;
            return e3;
          }
        }
        class Format extends o.XFAObject {
          constructor(e3) {
            super(f, "format", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.picture = null;
          }
        }
        class Handler extends o.StringObject {
          constructor(e3) {
            super(f, "handler");
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Hyphenation extends o.XFAObject {
          constructor(e3) {
            super(f, "hyphenation");
            this.excludeAllCaps = (0, c.getInteger)({ data: e3.excludeAllCaps, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.excludeInitialCap = (0, c.getInteger)({ data: e3.excludeInitialCap, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.hyphenate = (0, c.getInteger)({ data: e3.hyphenate, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.id = e3.id || "";
            this.pushCharacterCount = (0, c.getInteger)({ data: e3.pushCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 });
            this.remainCharacterCount = (0, c.getInteger)({ data: e3.remainCharacterCount, defaultValue: 3, validate: (e4) => e4 >= 0 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.wordCharacterCount = (0, c.getInteger)({ data: e3.wordCharacterCount, defaultValue: 7, validate: (e4) => e4 >= 0 });
          }
        }
        class Image extends o.StringObject {
          constructor(e3) {
            super(f, "image");
            this.aspect = (0, c.getStringOption)(e3.aspect, ["fit", "actual", "height", "none", "width"]);
            this.contentType = e3.contentType || "";
            this.href = e3.href || "";
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.transferEncoding = (0, c.getStringOption)(e3.transferEncoding, ["base64", "none", "package"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$toHTML]() {
            if (this.contentType && !m.has(this.contentType.toLowerCase())) return c.HTMLResult.EMPTY;
            let e3 = this[r.$globalData].images && this[r.$globalData].images.get(this.href);
            if (!e3 && (this.href || !this[r.$content])) return c.HTMLResult.EMPTY;
            e3 || "base64" !== this.transferEncoding || (e3 = (0, l.stringToBytes)(atob(this[r.$content])));
            if (!e3) return c.HTMLResult.EMPTY;
            if (!this.contentType) {
              for (const [t4, a4] of b) if (e3.length > t4.length && t4.every((t5, a5) => t5 === e3[a5])) {
                this.contentType = a4;
                break;
              }
              if (!this.contentType) return c.HTMLResult.EMPTY;
            }
            const t3 = new Blob([e3], { type: this.contentType });
            let a3;
            switch (this.aspect) {
              case "fit":
              case "actual":
                break;
              case "height":
                a3 = { height: "100%", objectFit: "fill" };
                break;
              case "none":
                a3 = { width: "100%", height: "100%", objectFit: "fill" };
                break;
              case "width":
                a3 = { width: "100%", objectFit: "fill" };
            }
            const n2 = this[r.$getParent]();
            return c.HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: a3, src: URL.createObjectURL(t3), alt: n2 ? ariaLabel(n2[r.$getParent]()) : null } });
          }
        }
        class ImageEdit extends o.XFAObject {
          constructor(e3) {
            super(f, "imageEdit", true);
            this.data = (0, c.getStringOption)(e3.data, ["link", "embed"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            return "embed" === this.data ? c.HTMLResult.success({ name: "div", children: [], attributes: {} }) : c.HTMLResult.EMPTY;
          }
        }
        class Integer extends o.ContentObject {
          constructor(e3) {
            super(f, "integer");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = parseInt(this[r.$content].trim(), 10);
            this[r.$content] = isNaN(e3) ? null : e3;
          }
          [r.$toHTML](e3) {
            return valueToHtml(null !== this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class Issuers extends o.XFAObject {
          constructor(e3) {
            super(f, "issuers", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.certificate = new o.XFAObjectArray();
          }
        }
        class Items extends o.XFAObject {
          constructor(e3) {
            super(f, "items", true);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.ref = e3.ref || "";
            this.save = (0, c.getInteger)({ data: e3.save, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.boolean = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
          }
          [r.$toHTML]() {
            const e3 = [];
            for (const t3 of this[r.$getChildren]()) e3.push(t3[r.$text]());
            return c.HTMLResult.success(e3);
          }
        }
        t2.Items = Items;
        class Keep extends o.XFAObject {
          constructor(e3) {
            super(f, "keep", true);
            this.id = e3.id || "";
            const t3 = ["none", "contentArea", "pageArea"];
            this.intact = (0, c.getStringOption)(e3.intact, t3);
            this.next = (0, c.getStringOption)(e3.next, t3);
            this.previous = (0, c.getStringOption)(e3.previous, t3);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
        }
        class KeyUsage extends o.XFAObject {
          constructor(e3) {
            super(f, "keyUsage");
            const t3 = ["", "yes", "no"];
            this.crlSign = (0, c.getStringOption)(e3.crlSign, t3);
            this.dataEncipherment = (0, c.getStringOption)(e3.dataEncipherment, t3);
            this.decipherOnly = (0, c.getStringOption)(e3.decipherOnly, t3);
            this.digitalSignature = (0, c.getStringOption)(e3.digitalSignature, t3);
            this.encipherOnly = (0, c.getStringOption)(e3.encipherOnly, t3);
            this.id = e3.id || "";
            this.keyAgreement = (0, c.getStringOption)(e3.keyAgreement, t3);
            this.keyCertSign = (0, c.getStringOption)(e3.keyCertSign, t3);
            this.keyEncipherment = (0, c.getStringOption)(e3.keyEncipherment, t3);
            this.nonRepudiation = (0, c.getStringOption)(e3.nonRepudiation, t3);
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Line extends o.XFAObject {
          constructor(e3) {
            super(f, "line", true);
            this.hand = (0, c.getStringOption)(e3.hand, ["even", "left", "right"]);
            this.id = e3.id || "";
            this.slope = (0, c.getStringOption)(e3.slope, ["\\", "/"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.edge = null;
          }
          [r.$toHTML]() {
            const e3 = this[r.$getParent]()[r.$getParent](), t3 = this.edge || new Edge({}), a3 = t3[r.$toStyle](), n2 = /* @__PURE__ */ Object.create(null), i2 = "visible" === t3.presence ? t3.thickness : 0;
            n2.strokeWidth = (0, s.measureToString)(i2);
            n2.stroke = a3.color;
            let o2, l2, h2, u2, d2 = "100%", f2 = "100%";
            if (e3.w <= i2) {
              [o2, l2, h2, u2] = ["50%", 0, "50%", "100%"];
              d2 = n2.strokeWidth;
            } else if (e3.h <= i2) {
              [o2, l2, h2, u2] = [0, "50%", "100%", "50%"];
              f2 = n2.strokeWidth;
            } else "\\" === this.slope ? [o2, l2, h2, u2] = [0, 0, "100%", "100%"] : [o2, l2, h2, u2] = [0, "100%", "100%", 0];
            const p2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: g, x1: o2, y1: l2, x2: h2, y2: u2, style: n2 } }], attributes: { xmlns: g, width: d2, height: f2, style: { overflow: "visible" } } };
            if (hasMargin(e3)) return c.HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [p2] });
            p2.attributes.style.position = "absolute";
            return c.HTMLResult.success(p2);
          }
        }
        class Linear extends o.XFAObject {
          constructor(e3) {
            super(f, "linear", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["toRight", "toBottom", "toLeft", "toTop"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle](e3) {
            e3 = e3 ? e3[r.$toStyle]() : "#FFFFFF";
            return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e3}, ${this.color ? this.color[r.$toStyle]() : "#000000"})`;
          }
        }
        class LockDocument extends o.ContentObject {
          constructor(e3) {
            super(f, "lockDocument");
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            this[r.$content] = (0, c.getStringOption)(this[r.$content], ["auto", "0", "1"]);
          }
        }
        class Manifest extends o.XFAObject {
          constructor(e3) {
            super(f, "manifest", true);
            this.action = (0, c.getStringOption)(e3.action, ["include", "all", "exclude"]);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.ref = new o.XFAObjectArray();
          }
        }
        class Margin extends o.XFAObject {
          constructor(e3) {
            super(f, "margin", true);
            this.bottomInset = (0, c.getMeasurement)(e3.bottomInset, "0");
            this.id = e3.id || "";
            this.leftInset = (0, c.getMeasurement)(e3.leftInset, "0");
            this.rightInset = (0, c.getMeasurement)(e3.rightInset, "0");
            this.topInset = (0, c.getMeasurement)(e3.topInset, "0");
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
          [r.$toStyle]() {
            return { margin: (0, s.measureToString)(this.topInset) + " " + (0, s.measureToString)(this.rightInset) + " " + (0, s.measureToString)(this.bottomInset) + " " + (0, s.measureToString)(this.leftInset) };
          }
        }
        class Mdp extends o.XFAObject {
          constructor(e3) {
            super(f, "mdp");
            this.id = e3.id || "";
            this.permissions = (0, c.getInteger)({ data: e3.permissions, defaultValue: 2, validate: (e4) => 1 === e4 || 3 === e4 });
            this.signatureType = (0, c.getStringOption)(e3.signatureType, ["filler", "author"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Medium extends o.XFAObject {
          constructor(e3) {
            super(f, "medium");
            this.id = e3.id || "";
            this.imagingBBox = (0, c.getBBox)(e3.imagingBBox);
            this.long = (0, c.getMeasurement)(e3.long);
            this.orientation = (0, c.getStringOption)(e3.orientation, ["portrait", "landscape"]);
            this.short = (0, c.getMeasurement)(e3.short);
            this.stock = e3.stock || "";
            this.trayIn = (0, c.getStringOption)(e3.trayIn, ["auto", "delegate", "pageFront"]);
            this.trayOut = (0, c.getStringOption)(e3.trayOut, ["auto", "delegate"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Message extends o.XFAObject {
          constructor(e3) {
            super(f, "message", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.text = new o.XFAObjectArray();
          }
        }
        class NumericEdit extends o.XFAObject {
          constructor(e3) {
            super(f, "numericEdit", true);
            this.hScrollPolicy = (0, c.getStringOption)(e3.hScrollPolicy, ["auto", "off", "on"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.comb = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            var _a;
            const t3 = (0, s.toStyle)(this, "border", "font", "margin"), a3 = this[r.$getParent]()[r.$getParent](), n2 = { name: "input", attributes: { type: "text", fieldId: a3[r.$uid], dataId: ((_a = a3[r.$data]) == null ? void 0 : _a[r.$uid]) || a3[r.$uid], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(a3), "aria-required": false } };
            if (isRequired(a3)) {
              n2.attributes["aria-required"] = true;
              n2.attributes.required = true;
            }
            return c.HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [n2] });
          }
        }
        class Occur extends o.XFAObject {
          constructor(e3) {
            super(f, "occur", true);
            this.id = e3.id || "";
            this.initial = "" !== e3.initial ? (0, c.getInteger)({ data: e3.initial, defaultValue: "", validate: (e4) => true }) : "";
            this.max = "" !== e3.max ? (0, c.getInteger)({ data: e3.max, defaultValue: 1, validate: (e4) => true }) : "";
            this.min = "" !== e3.min ? (0, c.getInteger)({ data: e3.min, defaultValue: 1, validate: (e4) => true }) : "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
          [r.$clean]() {
            const e3 = this[r.$getParent](), t3 = this.min;
            "" === this.min && (this.min = e3 instanceof PageArea || e3 instanceof PageSet ? 0 : 1);
            "" === this.max && (this.max = "" === t3 ? e3 instanceof PageArea || e3 instanceof PageSet ? -1 : 1 : this.min);
            -1 !== this.max && this.max < this.min && (this.max = this.min);
            "" === this.initial && (this.initial = e3 instanceof Template ? 1 : this.min);
          }
        }
        class Oid extends o.StringObject {
          constructor(e3) {
            super(f, "oid");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Oids extends o.XFAObject {
          constructor(e3) {
            super(f, "oids", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.oid = new o.XFAObjectArray();
          }
        }
        class Overflow extends o.XFAObject {
          constructor(e3) {
            super(f, "overflow");
            this.id = e3.id || "";
            this.leader = e3.leader || "";
            this.target = e3.target || "";
            this.trailer = e3.trailer || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$getExtra]() {
            if (!this[r.$extra]) {
              const e3 = this[r.$getParent](), t3 = this[r.$getTemplateRoot](), a3 = t3[r.$searchNode](this.target, e3), n2 = t3[r.$searchNode](this.leader, e3), i2 = t3[r.$searchNode](this.trailer, e3);
              this[r.$extra] = { target: (a3 == null ? void 0 : a3[0]) || null, leader: (n2 == null ? void 0 : n2[0]) || null, trailer: (i2 == null ? void 0 : i2[0]) || null, addLeader: false, addTrailer: false };
            }
            return this[r.$extra];
          }
        }
        class PageArea extends o.XFAObject {
          constructor(e3) {
            super(f, "pageArea", true);
            this.blankOrNotBlank = (0, c.getStringOption)(e3.blankOrNotBlank, ["any", "blank", "notBlank"]);
            this.id = e3.id || "";
            this.initialNumber = (0, c.getInteger)({ data: e3.initialNumber, defaultValue: 1, validate: (e4) => true });
            this.name = e3.name || "";
            this.numbered = (0, c.getInteger)({ data: e3.numbered, defaultValue: 1, validate: (e4) => true });
            this.oddOrEven = (0, c.getStringOption)(e3.oddOrEven, ["any", "even", "odd"]);
            this.pagePosition = (0, c.getStringOption)(e3.pagePosition, ["any", "first", "last", "only", "rest"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.desc = null;
            this.extras = null;
            this.medium = null;
            this.occur = null;
            this.area = new o.XFAObjectArray();
            this.contentArea = new o.XFAObjectArray();
            this.draw = new o.XFAObjectArray();
            this.exclGroup = new o.XFAObjectArray();
            this.field = new o.XFAObjectArray();
            this.subform = new o.XFAObjectArray();
          }
          [r.$isUsable]() {
            if (!this[r.$extra]) {
              this[r.$extra] = { numberOfUse: 0 };
              return true;
            }
            return !this.occur || -1 === this.occur.max || this[r.$extra].numberOfUse < this.occur.max;
          }
          [r.$cleanPage]() {
            delete this[r.$extra];
          }
          [r.$getNextPage]() {
            this[r.$extra] || (this[r.$extra] = { numberOfUse: 0 });
            const e3 = this[r.$getParent]();
            if ("orderedOccurrence" === e3.relation && this[r.$isUsable]()) {
              this[r.$extra].numberOfUse += 1;
              return this;
            }
            return e3[r.$getNextPage]();
          }
          [r.$getAvailableSpace]() {
            return this[r.$extra].space || { width: 0, height: 0 };
          }
          [r.$toHTML]() {
            this[r.$extra] || (this[r.$extra] = { numberOfUse: 1 });
            const e3 = [];
            this[r.$extra].children = e3;
            const t3 = /* @__PURE__ */ Object.create(null);
            if (this.medium && this.medium.short && this.medium.long) {
              t3.width = (0, s.measureToString)(this.medium.short);
              t3.height = (0, s.measureToString)(this.medium.long);
              this[r.$extra].space = { width: this.medium.short, height: this.medium.long };
              if ("landscape" === this.medium.orientation) {
                const e4 = t3.width;
                t3.width = t3.height;
                t3.height = e4;
                this[r.$extra].space = { width: this.medium.long, height: this.medium.short };
              }
            } else (0, l.warn)("XFA - No medium specified in pageArea: please file a bug.");
            this[r.$childrenToHTML]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true });
            this[r.$childrenToHTML]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true });
            return c.HTMLResult.success({ name: "div", children: e3, attributes: { class: ["xfaPage"], id: this[r.$uid], style: t3, xfaName: this.name } });
          }
        }
        class PageSet extends o.XFAObject {
          constructor(e3) {
            super(f, "pageSet", true);
            this.duplexImposition = (0, c.getStringOption)(e3.duplexImposition, ["longEdge", "shortEdge"]);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.relation = (0, c.getStringOption)(e3.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.occur = null;
            this.pageArea = new o.XFAObjectArray();
            this.pageSet = new o.XFAObjectArray();
          }
          [r.$cleanPage]() {
            for (const e3 of this.pageArea.children) e3[r.$cleanPage]();
            for (const e3 of this.pageSet.children) e3[r.$cleanPage]();
          }
          [r.$isUsable]() {
            return !this.occur || -1 === this.occur.max || this[r.$extra].numberOfUse < this.occur.max;
          }
          [r.$getNextPage]() {
            this[r.$extra] || (this[r.$extra] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 });
            if ("orderedOccurrence" === this.relation) {
              if (this[r.$extra].pageIndex + 1 < this.pageArea.children.length) {
                this[r.$extra].pageIndex += 1;
                return this.pageArea.children[this[r.$extra].pageIndex][r.$getNextPage]();
              }
              if (this[r.$extra].pageSetIndex + 1 < this.pageSet.children.length) {
                this[r.$extra].pageSetIndex += 1;
                return this.pageSet.children[this[r.$extra].pageSetIndex][r.$getNextPage]();
              }
              if (this[r.$isUsable]()) {
                this[r.$extra].numberOfUse += 1;
                this[r.$extra].pageIndex = -1;
                this[r.$extra].pageSetIndex = -1;
                return this[r.$getNextPage]();
              }
              const e4 = this[r.$getParent]();
              if (e4 instanceof PageSet) return e4[r.$getNextPage]();
              this[r.$cleanPage]();
              return this[r.$getNextPage]();
            }
            const e3 = this[r.$getTemplateRoot]()[r.$extra].pageNumber, t3 = e3 % 2 == 0 ? "even" : "odd", a3 = 0 === e3 ? "first" : "rest";
            let n2 = this.pageArea.children.find((e4) => e4.oddOrEven === t3 && e4.pagePosition === a3);
            if (n2) return n2;
            n2 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && e4.pagePosition === a3);
            if (n2) return n2;
            n2 = this.pageArea.children.find((e4) => "any" === e4.oddOrEven && "any" === e4.pagePosition);
            return n2 || this.pageArea.children[0];
          }
        }
        class Para extends o.XFAObject {
          constructor(e3) {
            super(f, "para", true);
            this.hAlign = (0, c.getStringOption)(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
            this.id = e3.id || "";
            this.lineHeight = e3.lineHeight ? (0, c.getMeasurement)(e3.lineHeight, "0pt") : "";
            this.marginLeft = e3.marginLeft ? (0, c.getMeasurement)(e3.marginLeft, "0pt") : "";
            this.marginRight = e3.marginRight ? (0, c.getMeasurement)(e3.marginRight, "0pt") : "";
            this.orphans = (0, c.getInteger)({ data: e3.orphans, defaultValue: 0, validate: (e4) => e4 >= 0 });
            this.preserve = e3.preserve || "";
            this.radixOffset = e3.radixOffset ? (0, c.getMeasurement)(e3.radixOffset, "0pt") : "";
            this.spaceAbove = e3.spaceAbove ? (0, c.getMeasurement)(e3.spaceAbove, "0pt") : "";
            this.spaceBelow = e3.spaceBelow ? (0, c.getMeasurement)(e3.spaceBelow, "0pt") : "";
            this.tabDefault = e3.tabDefault ? (0, c.getMeasurement)(this.tabDefault) : "";
            this.tabStops = (e3.tabStops || "").trim().split(/\s+/).map((e4, t3) => t3 % 2 == 1 ? (0, c.getMeasurement)(e4) : e4);
            this.textIndent = e3.textIndent ? (0, c.getMeasurement)(e3.textIndent, "0pt") : "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.vAlign = (0, c.getStringOption)(e3.vAlign, ["top", "bottom", "middle"]);
            this.widows = (0, c.getInteger)({ data: e3.widows, defaultValue: 0, validate: (e4) => e4 >= 0 });
            this.hyphenation = null;
          }
          [r.$toStyle]() {
            const e3 = (0, s.toStyle)(this, "hAlign");
            "" !== this.marginLeft && (e3.paddingLeft = (0, s.measureToString)(this.marginLeft));
            "" !== this.marginRight && (e3.paddingight = (0, s.measureToString)(this.marginRight));
            "" !== this.spaceAbove && (e3.paddingTop = (0, s.measureToString)(this.spaceAbove));
            "" !== this.spaceBelow && (e3.paddingBottom = (0, s.measureToString)(this.spaceBelow));
            if ("" !== this.textIndent) {
              e3.textIndent = (0, s.measureToString)(this.textIndent);
              (0, s.fixTextIndent)(e3);
            }
            this.lineHeight > 0 && (e3.lineHeight = (0, s.measureToString)(this.lineHeight));
            "" !== this.tabDefault && (e3.tabSize = (0, s.measureToString)(this.tabDefault));
            this.tabStops.length;
            this.hyphenatation && Object.assign(e3, this.hyphenatation[r.$toStyle]());
            return e3;
          }
        }
        class PasswordEdit extends o.XFAObject {
          constructor(e3) {
            super(f, "passwordEdit", true);
            this.hScrollPolicy = (0, c.getStringOption)(e3.hScrollPolicy, ["auto", "off", "on"]);
            this.id = e3.id || "";
            this.passwordChar = e3.passwordChar || "*";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.extras = null;
            this.margin = null;
          }
        }
        class Pattern extends o.XFAObject {
          constructor(e3) {
            super(f, "pattern", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle](e3) {
            e3 = e3 ? e3[r.$toStyle]() : "#FFFFFF";
            const t3 = this.color ? this.color[r.$toStyle]() : "#000000", a3 = "repeating-linear-gradient", n2 = `${e3},${e3} 5px,${t3} 5px,${t3} 10px`;
            switch (this.type) {
              case "crossHatch":
                return `${a3}(to top,${n2}) ${a3}(to right,${n2})`;
              case "crossDiagonal":
                return `${a3}(45deg,${n2}) ${a3}(-45deg,${n2})`;
              case "diagonalLeft":
                return `${a3}(45deg,${n2})`;
              case "diagonalRight":
                return `${a3}(-45deg,${n2})`;
              case "horizontal":
                return `${a3}(to top,${n2})`;
              case "vertical":
                return `${a3}(to right,${n2})`;
            }
            return "";
          }
        }
        class Picture extends o.StringObject {
          constructor(e3) {
            super(f, "picture");
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Proto extends o.XFAObject {
          constructor(e3) {
            super(f, "proto", true);
            this.appearanceFilter = new o.XFAObjectArray();
            this.arc = new o.XFAObjectArray();
            this.area = new o.XFAObjectArray();
            this.assist = new o.XFAObjectArray();
            this.barcode = new o.XFAObjectArray();
            this.bindItems = new o.XFAObjectArray();
            this.bookend = new o.XFAObjectArray();
            this.boolean = new o.XFAObjectArray();
            this.border = new o.XFAObjectArray();
            this.break = new o.XFAObjectArray();
            this.breakAfter = new o.XFAObjectArray();
            this.breakBefore = new o.XFAObjectArray();
            this.button = new o.XFAObjectArray();
            this.calculate = new o.XFAObjectArray();
            this.caption = new o.XFAObjectArray();
            this.certificate = new o.XFAObjectArray();
            this.certificates = new o.XFAObjectArray();
            this.checkButton = new o.XFAObjectArray();
            this.choiceList = new o.XFAObjectArray();
            this.color = new o.XFAObjectArray();
            this.comb = new o.XFAObjectArray();
            this.connect = new o.XFAObjectArray();
            this.contentArea = new o.XFAObjectArray();
            this.corner = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.dateTimeEdit = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.defaultUi = new o.XFAObjectArray();
            this.desc = new o.XFAObjectArray();
            this.digestMethod = new o.XFAObjectArray();
            this.digestMethods = new o.XFAObjectArray();
            this.draw = new o.XFAObjectArray();
            this.edge = new o.XFAObjectArray();
            this.encoding = new o.XFAObjectArray();
            this.encodings = new o.XFAObjectArray();
            this.encrypt = new o.XFAObjectArray();
            this.encryptData = new o.XFAObjectArray();
            this.encryption = new o.XFAObjectArray();
            this.encryptionMethod = new o.XFAObjectArray();
            this.encryptionMethods = new o.XFAObjectArray();
            this.event = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.exObject = new o.XFAObjectArray();
            this.exclGroup = new o.XFAObjectArray();
            this.execute = new o.XFAObjectArray();
            this.extras = new o.XFAObjectArray();
            this.field = new o.XFAObjectArray();
            this.fill = new o.XFAObjectArray();
            this.filter = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.font = new o.XFAObjectArray();
            this.format = new o.XFAObjectArray();
            this.handler = new o.XFAObjectArray();
            this.hyphenation = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.imageEdit = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.issuers = new o.XFAObjectArray();
            this.items = new o.XFAObjectArray();
            this.keep = new o.XFAObjectArray();
            this.keyUsage = new o.XFAObjectArray();
            this.line = new o.XFAObjectArray();
            this.linear = new o.XFAObjectArray();
            this.lockDocument = new o.XFAObjectArray();
            this.manifest = new o.XFAObjectArray();
            this.margin = new o.XFAObjectArray();
            this.mdp = new o.XFAObjectArray();
            this.medium = new o.XFAObjectArray();
            this.message = new o.XFAObjectArray();
            this.numericEdit = new o.XFAObjectArray();
            this.occur = new o.XFAObjectArray();
            this.oid = new o.XFAObjectArray();
            this.oids = new o.XFAObjectArray();
            this.overflow = new o.XFAObjectArray();
            this.pageArea = new o.XFAObjectArray();
            this.pageSet = new o.XFAObjectArray();
            this.para = new o.XFAObjectArray();
            this.passwordEdit = new o.XFAObjectArray();
            this.pattern = new o.XFAObjectArray();
            this.picture = new o.XFAObjectArray();
            this.radial = new o.XFAObjectArray();
            this.reason = new o.XFAObjectArray();
            this.reasons = new o.XFAObjectArray();
            this.rectangle = new o.XFAObjectArray();
            this.ref = new o.XFAObjectArray();
            this.script = new o.XFAObjectArray();
            this.setProperty = new o.XFAObjectArray();
            this.signData = new o.XFAObjectArray();
            this.signature = new o.XFAObjectArray();
            this.signing = new o.XFAObjectArray();
            this.solid = new o.XFAObjectArray();
            this.speak = new o.XFAObjectArray();
            this.stipple = new o.XFAObjectArray();
            this.subform = new o.XFAObjectArray();
            this.subformSet = new o.XFAObjectArray();
            this.subjectDN = new o.XFAObjectArray();
            this.subjectDNs = new o.XFAObjectArray();
            this.submit = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.textEdit = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
            this.timeStamp = new o.XFAObjectArray();
            this.toolTip = new o.XFAObjectArray();
            this.traversal = new o.XFAObjectArray();
            this.traverse = new o.XFAObjectArray();
            this.ui = new o.XFAObjectArray();
            this.validate = new o.XFAObjectArray();
            this.value = new o.XFAObjectArray();
            this.variables = new o.XFAObjectArray();
          }
        }
        class Radial extends o.XFAObject {
          constructor(e3) {
            super(f, "radial", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["toEdge", "toCenter"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle](e3) {
            e3 = e3 ? e3[r.$toStyle]() : "#FFFFFF";
            const t3 = this.color ? this.color[r.$toStyle]() : "#000000";
            return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e3},${t3}` : `${t3},${e3}`})`;
          }
        }
        class Reason extends o.StringObject {
          constructor(e3) {
            super(f, "reason");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Reasons extends o.XFAObject {
          constructor(e3) {
            super(f, "reasons", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.reason = new o.XFAObjectArray();
          }
        }
        class Rectangle extends o.XFAObject {
          constructor(e3) {
            super(f, "rectangle", true);
            this.hand = (0, c.getStringOption)(e3.hand, ["even", "left", "right"]);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.corner = new o.XFAObjectArray(4);
            this.edge = new o.XFAObjectArray(4);
            this.fill = null;
          }
          [r.$toHTML]() {
            var _a;
            const e3 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t3 = e3[r.$toStyle](), a3 = /* @__PURE__ */ Object.create(null);
            "visible" === ((_a = this.fill) == null ? void 0 : _a.presence) ? Object.assign(a3, this.fill[r.$toStyle]()) : a3.fill = "transparent";
            a3.strokeWidth = (0, s.measureToString)("visible" === e3.presence ? e3.thickness : 0);
            a3.stroke = t3.color;
            const n2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[r.$toStyle](), i2 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: g, width: "100%", height: "100%", x: 0, y: 0, rx: n2.radius, ry: n2.radius, style: a3 } }], attributes: { xmlns: g, style: { overflow: "visible" }, width: "100%", height: "100%" } };
            if (hasMargin(this[r.$getParent]()[r.$getParent]())) return c.HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [i2] });
            i2.attributes.style.position = "absolute";
            return c.HTMLResult.success(i2);
          }
        }
        class RefElement extends o.StringObject {
          constructor(e3) {
            super(f, "ref");
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Script extends o.StringObject {
          constructor(e3) {
            super(f, "script");
            this.binding = e3.binding || "";
            this.contentType = e3.contentType || "";
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.runAt = (0, c.getStringOption)(e3.runAt, ["client", "both", "server"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class SetProperty extends o.XFAObject {
          constructor(e3) {
            super(f, "setProperty");
            this.connection = e3.connection || "";
            this.ref = e3.ref || "";
            this.target = e3.target || "";
          }
        }
        t2.SetProperty = SetProperty;
        class SignData extends o.XFAObject {
          constructor(e3) {
            super(f, "signData", true);
            this.id = e3.id || "";
            this.operation = (0, c.getStringOption)(e3.operation, ["sign", "clear", "verify"]);
            this.ref = e3.ref || "";
            this.target = e3.target || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.filter = null;
            this.manifest = null;
          }
        }
        class Signature extends o.XFAObject {
          constructor(e3) {
            super(f, "signature", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["PDF1.3", "PDF1.6"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.border = null;
            this.extras = null;
            this.filter = null;
            this.manifest = null;
            this.margin = null;
          }
        }
        class Signing extends o.XFAObject {
          constructor(e3) {
            super(f, "signing", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.certificate = new o.XFAObjectArray();
          }
        }
        class Solid extends o.XFAObject {
          constructor(e3) {
            super(f, "solid", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
          }
          [r.$toStyle](e3) {
            return e3 ? e3[r.$toStyle]() : "#FFFFFF";
          }
        }
        class Speak extends o.StringObject {
          constructor(e3) {
            super(f, "speak");
            this.disable = (0, c.getInteger)({ data: e3.disable, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.id = e3.id || "";
            this.priority = (0, c.getStringOption)(e3.priority, ["custom", "caption", "name", "toolTip"]);
            this.rid = e3.rid || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Stipple extends o.XFAObject {
          constructor(e3) {
            super(f, "stipple", true);
            this.id = e3.id || "";
            this.rate = (0, c.getInteger)({ data: e3.rate, defaultValue: 50, validate: (e4) => e4 >= 0 && e4 <= 100 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.color = null;
            this.extras = null;
          }
          [r.$toStyle](e3) {
            const t3 = this.rate / 100;
            return l.Util.makeHexColor(Math.round(e3.value.r * (1 - t3) + this.value.r * t3), Math.round(e3.value.g * (1 - t3) + this.value.g * t3), Math.round(e3.value.b * (1 - t3) + this.value.b * t3));
          }
        }
        class Subform extends o.XFAObject {
          constructor(e3) {
            super(f, "subform", true);
            this.access = (0, c.getStringOption)(e3.access, ["open", "nonInteractive", "protected", "readOnly"]);
            this.allowMacro = (0, c.getInteger)({ data: e3.allowMacro, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.anchorType = (0, c.getStringOption)(e3.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
            this.colSpan = (0, c.getInteger)({ data: e3.colSpan, defaultValue: 1, validate: (e4) => e4 >= 1 || -1 === e4 });
            this.columnWidths = (e3.columnWidths || "").trim().split(/\s+/).map((e4) => "-1" === e4 ? -1 : (0, c.getMeasurement)(e4));
            this.h = e3.h ? (0, c.getMeasurement)(e3.h) : "";
            this.hAlign = (0, c.getStringOption)(e3.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
            this.id = e3.id || "";
            this.layout = (0, c.getStringOption)(e3.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
            this.locale = e3.locale || "";
            this.maxH = (0, c.getMeasurement)(e3.maxH, "0pt");
            this.maxW = (0, c.getMeasurement)(e3.maxW, "0pt");
            this.mergeMode = (0, c.getStringOption)(e3.mergeMode, ["consumeData", "matchTemplate"]);
            this.minH = (0, c.getMeasurement)(e3.minH, "0pt");
            this.minW = (0, c.getMeasurement)(e3.minW, "0pt");
            this.name = e3.name || "";
            this.presence = (0, c.getStringOption)(e3.presence, ["visible", "hidden", "inactive", "invisible"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.restoreState = (0, c.getStringOption)(e3.restoreState, ["manual", "auto"]);
            this.scope = (0, c.getStringOption)(e3.scope, ["name", "none"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.w = e3.w ? (0, c.getMeasurement)(e3.w) : "";
            this.x = (0, c.getMeasurement)(e3.x, "0pt");
            this.y = (0, c.getMeasurement)(e3.y, "0pt");
            this.assist = null;
            this.bind = null;
            this.bookend = null;
            this.border = null;
            this.break = null;
            this.calculate = null;
            this.desc = null;
            this.extras = null;
            this.keep = null;
            this.margin = null;
            this.occur = null;
            this.overflow = null;
            this.pageSet = null;
            this.para = null;
            this.traversal = null;
            this.validate = null;
            this.variables = null;
            this.area = new o.XFAObjectArray();
            this.breakAfter = new o.XFAObjectArray();
            this.breakBefore = new o.XFAObjectArray();
            this.connect = new o.XFAObjectArray();
            this.draw = new o.XFAObjectArray();
            this.event = new o.XFAObjectArray();
            this.exObject = new o.XFAObjectArray();
            this.exclGroup = new o.XFAObjectArray();
            this.field = new o.XFAObjectArray();
            this.proto = new o.XFAObjectArray();
            this.setProperty = new o.XFAObjectArray();
            this.subform = new o.XFAObjectArray();
            this.subformSet = new o.XFAObjectArray();
          }
          [r.$getSubformParent]() {
            const e3 = this[r.$getParent]();
            return e3 instanceof SubformSet ? e3[r.$getSubformParent]() : e3;
          }
          [r.$isBindable]() {
            return true;
          }
          [r.$isThereMoreWidth]() {
            return this.layout.endsWith("-tb") && 0 === this[r.$extra].attempt && this[r.$extra].numberInLine > 0 || this[r.$getParent]()[r.$isThereMoreWidth]();
          }
          *[r.$getContainedChildren]() {
            yield* getContainedChildren(this);
          }
          [r.$flushHTML]() {
            return (0, i.flushHTML)(this);
          }
          [r.$addHTML](e3, t3) {
            (0, i.addHTML)(this, e3, t3);
          }
          [r.$getAvailableSpace]() {
            return (0, i.getAvailableSpace)(this);
          }
          [r.$isSplittable]() {
            var _a;
            const e3 = this[r.$getSubformParent]();
            if (!e3[r.$isSplittable]()) return false;
            if (void 0 !== this[r.$extra]._isSplittable) return this[r.$extra]._isSplittable;
            if ("position" === this.layout || this.layout.includes("row")) {
              this[r.$extra]._isSplittable = false;
              return false;
            }
            if (this.keep && "none" !== this.keep.intact) {
              this[r.$extra]._isSplittable = false;
              return false;
            }
            if (((_a = e3.layout) == null ? void 0 : _a.endsWith("-tb")) && 0 !== e3[r.$extra].numberInLine) return false;
            this[r.$extra]._isSplittable = true;
            return true;
          }
          [r.$toHTML](e3) {
            var _a;
            setTabIndex(this);
            if (this.break) {
              if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
                const e4 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
                e4[r.$globalData] = this[r.$globalData];
                this[r.$appendChild](e4);
                this.breakAfter.push(e4);
              }
              if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
                const e4 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
                e4[r.$globalData] = this[r.$globalData];
                this[r.$appendChild](e4);
                this.breakBefore.push(e4);
              }
              if ("" !== this.break.overflowTarget) {
                const e4 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
                e4[r.$globalData] = this[r.$globalData];
                this[r.$appendChild](e4);
                this.overflow.push(e4);
              }
              this[r.$removeChild](this.break);
              this.break = null;
            }
            if ("hidden" === this.presence || "inactive" === this.presence) return c.HTMLResult.EMPTY;
            (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, l.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
            if (this.breakBefore.children.length >= 1) {
              const e4 = this.breakBefore.children[0];
              if (handleBreak(e4)) return c.HTMLResult.breakNode(e4);
            }
            if ((_a = this[r.$extra]) == null ? void 0 : _a.afterBreakAfter) return c.HTMLResult.EMPTY;
            (0, s.fixDimensions)(this);
            const t3 = [], a3 = { id: this[r.$uid], class: [] };
            (0, s.setAccess)(this, a3.class);
            this[r.$extra] || (this[r.$extra] = /* @__PURE__ */ Object.create(null));
            Object.assign(this[r.$extra], { children: t3, line: null, attributes: a3, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e3.width), height: Math.min(this.h || 1 / 0, e3.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
            const n2 = this[r.$getTemplateRoot](), o2 = n2[r.$extra].noLayoutFailure, h2 = this[r.$isSplittable]();
            h2 || setFirstUnsplittable(this);
            if (!(0, i.checkDimensions)(this, e3)) return c.HTMLResult.FAILURE;
            const u2 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
            if (this.layout.includes("row")) {
              const e4 = this[r.$getSubformParent]().columnWidths;
              if (Array.isArray(e4) && e4.length > 0) {
                this[r.$extra].columnWidths = e4;
                this[r.$extra].currentColumn = 0;
              }
            }
            const d2 = (0, s.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), f2 = ["xfaSubform"], g2 = (0, s.layoutClass)(this);
            g2 && f2.push(g2);
            a3.style = d2;
            a3.class = f2;
            this.name && (a3.xfaName = this.name);
            if (this.overflow) {
              const t4 = this.overflow[r.$getExtra]();
              if (t4.addLeader) {
                t4.addLeader = false;
                handleOverflow(this, t4.leader, e3);
              }
            }
            this[r.$pushPara]();
            const p2 = "lr-tb" === this.layout || "rl-tb" === this.layout, m2 = p2 ? 2 : 1;
            for (; this[r.$extra].attempt < m2; this[r.$extra].attempt++) {
              p2 && 1 === this[r.$extra].attempt && (this[r.$extra].numberInLine = 0);
              const e4 = this[r.$childrenToHTML]({ filter: u2, include: true });
              if (e4.success) break;
              if (e4.isBreak()) {
                this[r.$popPara]();
                return e4;
              }
              if (p2 && 0 === this[r.$extra].attempt && 0 === this[r.$extra].numberInLine && !n2[r.$extra].noLayoutFailure) {
                this[r.$extra].attempt = m2;
                break;
              }
            }
            this[r.$popPara]();
            h2 || unsetFirstUnsplittable(this);
            n2[r.$extra].noLayoutFailure = o2;
            if (this[r.$extra].attempt === m2) {
              this.overflow && (this[r.$getTemplateRoot]()[r.$extra].overflowNode = this.overflow);
              h2 || delete this[r.$extra];
              return c.HTMLResult.FAILURE;
            }
            if (this.overflow) {
              const t4 = this.overflow[r.$getExtra]();
              if (t4.addTrailer) {
                t4.addTrailer = false;
                handleOverflow(this, t4.trailer, e3);
              }
            }
            let b2 = 0, y = 0;
            if (this.margin) {
              b2 = this.margin.leftInset + this.margin.rightInset;
              y = this.margin.topInset + this.margin.bottomInset;
            }
            const w = Math.max(this[r.$extra].width + b2, this.w || 0), S = Math.max(this[r.$extra].height + y, this.h || 0), x = [this.x, this.y, w, S];
            "" === this.w && (d2.width = (0, s.measureToString)(w));
            "" === this.h && (d2.height = (0, s.measureToString)(S));
            if (("0px" === d2.width || "0px" === d2.height) && 0 === t3.length) return c.HTMLResult.EMPTY;
            const C = { name: "div", attributes: a3, children: t3 };
            applyAssist(this, a3);
            const k = c.HTMLResult.success((0, s.createWrapper)(this, C), x);
            if (this.breakAfter.children.length >= 1) {
              const e4 = this.breakAfter.children[0];
              if (handleBreak(e4)) {
                this[r.$extra].afterBreakAfter = k;
                return c.HTMLResult.breakNode(e4);
              }
            }
            delete this[r.$extra];
            return k;
          }
        }
        class SubformSet extends o.XFAObject {
          constructor(e3) {
            super(f, "subformSet", true);
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.relation = (0, c.getStringOption)(e3.relation, ["ordered", "choice", "unordered"]);
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.bookend = null;
            this.break = null;
            this.desc = null;
            this.extras = null;
            this.occur = null;
            this.overflow = null;
            this.breakAfter = new o.XFAObjectArray();
            this.breakBefore = new o.XFAObjectArray();
            this.subform = new o.XFAObjectArray();
            this.subformSet = new o.XFAObjectArray();
          }
          *[r.$getContainedChildren]() {
            yield* getContainedChildren(this);
          }
          [r.$getSubformParent]() {
            let e3 = this[r.$getParent]();
            for (; !(e3 instanceof Subform); ) e3 = e3[r.$getParent]();
            return e3;
          }
          [r.$isBindable]() {
            return true;
          }
        }
        class SubjectDN extends o.ContentObject {
          constructor(e3) {
            super(f, "subjectDN");
            this.delimiter = e3.delimiter || ",";
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            this[r.$content] = new Map(this[r.$content].split(this.delimiter).map((e3) => {
              (e3 = e3.split("=", 2))[0] = e3[0].trim();
              return e3;
            }));
          }
        }
        class SubjectDNs extends o.XFAObject {
          constructor(e3) {
            super(f, "subjectDNs", true);
            this.id = e3.id || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.subjectDN = new o.XFAObjectArray();
          }
        }
        class Submit extends o.XFAObject {
          constructor(e3) {
            super(f, "submit", true);
            this.embedPDF = (0, c.getInteger)({ data: e3.embedPDF, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.format = (0, c.getStringOption)(e3.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
            this.id = e3.id || "";
            this.target = e3.target || "";
            this.textEncoding = (0, c.getKeyword)({ data: e3.textEncoding ? e3.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e4) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e4) || e4.match(/iso-8859-\d{2}/) });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.xdpContent = e3.xdpContent || "";
            this.encrypt = null;
            this.encryptData = new o.XFAObjectArray();
            this.signData = new o.XFAObjectArray();
          }
        }
        class Template extends o.XFAObject {
          constructor(e3) {
            super(f, "template", true);
            this.baseProfile = (0, c.getStringOption)(e3.baseProfile, ["full", "interactiveForms"]);
            this.extras = null;
            this.subform = new o.XFAObjectArray();
          }
          [r.$finalize]() {
            0 === this.subform.children.length && (0, l.warn)("XFA - No subforms in template node.");
            this.subform.children.length >= 2 && (0, l.warn)("XFA - Several subforms in template node: please file a bug.");
            this[r.$tabIndex] = 5e3;
          }
          [r.$isSplittable]() {
            return true;
          }
          [r.$searchNode](e3, t3) {
            return e3.startsWith("#") ? [this[r.$ids].get(e3.slice(1))] : (0, d.searchNode)(this, t3, e3, true, true);
          }
          *[r.$toPages]() {
            var _a, _b, _c;
            if (!this.subform.children.length) return c.HTMLResult.success({ name: "div", children: [] });
            this[r.$extra] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
            const e3 = this.subform.children[0];
            e3.pageSet[r.$cleanPage]();
            const t3 = e3.pageSet.pageArea.children, a3 = { name: "div", children: [] };
            let n2 = null, i2 = null, s2 = null;
            if (e3.breakBefore.children.length >= 1) {
              i2 = e3.breakBefore.children[0];
              s2 = i2.target;
            } else if (e3.subform.children.length >= 1 && e3.subform.children[0].breakBefore.children.length >= 1) {
              i2 = e3.subform.children[0].breakBefore.children[0];
              s2 = i2.target;
            } else if ((_a = e3.break) == null ? void 0 : _a.beforeTarget) {
              i2 = e3.break;
              s2 = i2.beforeTarget;
            } else if (e3.subform.children.length >= 1 && ((_b = e3.subform.children[0].break) == null ? void 0 : _b.beforeTarget)) {
              i2 = e3.subform.children[0].break;
              s2 = i2.beforeTarget;
            }
            if (i2) {
              const e4 = this[r.$searchNode](s2, i2[r.$getParent]());
              if (e4 instanceof PageArea) {
                n2 = e4;
                i2[r.$extra] = {};
              }
            }
            n2 || (n2 = t3[0]);
            n2[r.$extra] = { numberOfUse: 1 };
            const o2 = n2[r.$getParent]();
            o2[r.$extra] = { numberOfUse: 1, pageIndex: o2.pageArea.children.indexOf(n2), pageSetIndex: 0 };
            let h2, u2 = null, d2 = null, f2 = true, g2 = 0, p2 = 0;
            for (; ; ) {
              if (f2) g2 = 0;
              else {
                a3.children.pop();
                if (3 == ++g2) {
                  (0, l.warn)("XFA - Something goes wrong: please file a bug.");
                  return a3;
                }
              }
              h2 = null;
              this[r.$extra].currentPageArea = n2;
              const t4 = n2[r.$toHTML]().html;
              a3.children.push(t4);
              if (u2) {
                this[r.$extra].noLayoutFailure = true;
                t4.children.push(u2[r.$toHTML](n2[r.$extra].space).html);
                u2 = null;
              }
              if (d2) {
                this[r.$extra].noLayoutFailure = true;
                t4.children.push(d2[r.$toHTML](n2[r.$extra].space).html);
                d2 = null;
              }
              const i3 = n2.contentArea.children, s3 = t4.children.filter((e4) => e4.attributes.class.includes("xfaContentarea"));
              f2 = false;
              this[r.$extra].firstUnsplittable = null;
              this[r.$extra].noLayoutFailure = false;
              const flush = (t5) => {
                var _a2;
                const a4 = e3[r.$flushHTML]();
                if (a4) {
                  f2 || (f2 = ((_a2 = a4.children) == null ? void 0 : _a2.length) > 0);
                  s3[t5].children.push(a4);
                }
              };
              for (let t5 = p2, n3 = i3.length; t5 < n3; t5++) {
                const n4 = this[r.$extra].currentContentArea = i3[t5], o3 = { width: n4.w, height: n4.h };
                p2 = 0;
                if (u2) {
                  s3[t5].children.push(u2[r.$toHTML](o3).html);
                  u2 = null;
                }
                if (d2) {
                  s3[t5].children.push(d2[r.$toHTML](o3).html);
                  d2 = null;
                }
                const c2 = e3[r.$toHTML](o3);
                if (c2.success) {
                  if (c2.html) {
                    f2 || (f2 = ((_c = c2.html.children) == null ? void 0 : _c.length) > 0);
                    s3[t5].children.push(c2.html);
                  } else !f2 && a3.children.length > 1 && a3.children.pop();
                  return a3;
                }
                if (c2.isBreak()) {
                  const e4 = c2.breakNode;
                  flush(t5);
                  if ("auto" === e4.targetType) continue;
                  if (e4.leader) {
                    u2 = this[r.$searchNode](e4.leader, e4[r.$getParent]());
                    u2 = u2 ? u2[0] : null;
                  }
                  if (e4.trailer) {
                    d2 = this[r.$searchNode](e4.trailer, e4[r.$getParent]());
                    d2 = d2 ? d2[0] : null;
                  }
                  if ("pageArea" === e4.targetType) {
                    h2 = e4[r.$extra].target;
                    t5 = 1 / 0;
                  } else if (e4[r.$extra].target) {
                    h2 = e4[r.$extra].target;
                    p2 = e4[r.$extra].index + 1;
                    t5 = 1 / 0;
                  } else t5 = e4[r.$extra].index;
                } else if (this[r.$extra].overflowNode) {
                  const e4 = this[r.$extra].overflowNode;
                  this[r.$extra].overflowNode = null;
                  const a4 = e4[r.$getExtra](), n5 = a4.target;
                  a4.addLeader = null !== a4.leader;
                  a4.addTrailer = null !== a4.trailer;
                  flush(t5);
                  const s4 = t5;
                  t5 = 1 / 0;
                  if (n5 instanceof PageArea) h2 = n5;
                  else if (n5 instanceof ContentArea) {
                    const e5 = i3.indexOf(n5);
                    if (-1 !== e5) e5 > s4 ? t5 = e5 - 1 : p2 = e5;
                    else {
                      h2 = n5[r.$getParent]();
                      p2 = h2.contentArea.children.indexOf(n5);
                    }
                  }
                } else flush(t5);
              }
              this[r.$extra].pageNumber += 1;
              h2 && (h2[r.$isUsable]() ? h2[r.$extra].numberOfUse += 1 : h2 = null);
              n2 = h2 || n2[r.$getNextPage]();
              yield null;
            }
          }
        }
        t2.Template = Template;
        class Text extends o.ContentObject {
          constructor(e3) {
            super(f, "text");
            this.id = e3.id || "";
            this.maxChars = (0, c.getInteger)({ data: e3.maxChars, defaultValue: 0, validate: (e4) => e4 >= 0 });
            this.name = e3.name || "";
            this.rid = e3.rid || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$acceptWhitespace]() {
            return true;
          }
          [r.$onChild](e3) {
            if (e3[r.$namespaceId] === n.NamespaceIds.xhtml.id) {
              this[r.$content] = e3;
              return true;
            }
            (0, l.warn)(`XFA - Invalid content in Text: ${e3[r.$nodeName]}.`);
            return false;
          }
          [r.$onText](e3) {
            this[r.$content] instanceof o.XFAObject || super[r.$onText](e3);
          }
          [r.$finalize]() {
            "string" == typeof this[r.$content] && (this[r.$content] = this[r.$content].replaceAll("\r\n", "\n"));
          }
          [r.$getExtra]() {
            return "string" == typeof this[r.$content] ? this[r.$content].split(/[\u2029\u2028\n]/).reduce((e3, t3) => {
              t3 && e3.push(t3);
              return e3;
            }, []).join("\n") : this[r.$content][r.$text]();
          }
          [r.$toHTML](e3) {
            if ("string" == typeof this[r.$content]) {
              const e4 = valueToHtml(this[r.$content]).html;
              if (this[r.$content].includes("\u2029")) {
                e4.name = "div";
                e4.children = [];
                this[r.$content].split("\u2029").map((e5) => e5.split(/[\u2028\n]/).reduce((e6, t3) => {
                  e6.push({ name: "span", value: t3 }, { name: "br" });
                  return e6;
                }, [])).forEach((t3) => {
                  e4.children.push({ name: "p", children: t3 });
                });
              } else if (/[\u2028\n]/.test(this[r.$content])) {
                e4.name = "div";
                e4.children = [];
                this[r.$content].split(/[\u2028\n]/).forEach((t3) => {
                  e4.children.push({ name: "span", value: t3 }, { name: "br" });
                });
              }
              return c.HTMLResult.success(e4);
            }
            return this[r.$content][r.$toHTML](e3);
          }
        }
        t2.Text = Text;
        class TextEdit extends o.XFAObject {
          constructor(e3) {
            super(f, "textEdit", true);
            this.allowRichText = (0, c.getInteger)({ data: e3.allowRichText, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.hScrollPolicy = (0, c.getStringOption)(e3.hScrollPolicy, ["auto", "off", "on"]);
            this.id = e3.id || "";
            this.multiLine = (0, c.getInteger)({ data: e3.multiLine, defaultValue: "", validate: (e4) => 0 === e4 || 1 === e4 });
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.vScrollPolicy = (0, c.getStringOption)(e3.vScrollPolicy, ["auto", "off", "on"]);
            this.border = null;
            this.comb = null;
            this.extras = null;
            this.margin = null;
          }
          [r.$toHTML](e3) {
            var _a, _b;
            const t3 = (0, s.toStyle)(this, "border", "font", "margin");
            let a3;
            const n2 = this[r.$getParent]()[r.$getParent]();
            "" === this.multiLine && (this.multiLine = n2 instanceof Draw ? 1 : 0);
            a3 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: ((_a = n2[r.$data]) == null ? void 0 : _a[r.$uid]) || n2[r.$uid], fieldId: n2[r.$uid], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(n2), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: ((_b = n2[r.$data]) == null ? void 0 : _b[r.$uid]) || n2[r.$uid], fieldId: n2[r.$uid], class: ["xfaTextfield"], style: t3, "aria-label": ariaLabel(n2), "aria-required": false } };
            if (isRequired(n2)) {
              a3.attributes["aria-required"] = true;
              a3.attributes.required = true;
            }
            return c.HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a3] });
          }
        }
        class Time extends o.StringObject {
          constructor(e3) {
            super(f, "time");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
          [r.$finalize]() {
            const e3 = this[r.$content].trim();
            this[r.$content] = e3 ? new Date(e3) : null;
          }
          [r.$toHTML](e3) {
            return valueToHtml(this[r.$content] ? this[r.$content].toString() : "");
          }
        }
        class TimeStamp extends o.XFAObject {
          constructor(e3) {
            super(f, "timeStamp");
            this.id = e3.id || "";
            this.server = e3.server || "";
            this.type = (0, c.getStringOption)(e3.type, ["optional", "required"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class ToolTip extends o.StringObject {
          constructor(e3) {
            super(f, "toolTip");
            this.id = e3.id || "";
            this.rid = e3.rid || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Traversal extends o.XFAObject {
          constructor(e3) {
            super(f, "traversal", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.traverse = new o.XFAObjectArray();
          }
        }
        class Traverse extends o.XFAObject {
          constructor(e3) {
            super(f, "traverse", true);
            this.id = e3.id || "";
            this.operation = (0, c.getStringOption)(e3.operation, ["next", "back", "down", "first", "left", "right", "up"]);
            this.ref = e3.ref || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.script = null;
          }
          get name() {
            return this.operation;
          }
          [r.$isTransparent]() {
            return false;
          }
        }
        class Ui extends o.XFAObject {
          constructor(e3) {
            super(f, "ui", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.picture = null;
            this.barcode = null;
            this.button = null;
            this.checkButton = null;
            this.choiceList = null;
            this.dateTimeEdit = null;
            this.defaultUi = null;
            this.imageEdit = null;
            this.numericEdit = null;
            this.passwordEdit = null;
            this.signature = null;
            this.textEdit = null;
          }
          [r.$getExtra]() {
            if (void 0 === this[r.$extra]) {
              for (const e3 of Object.getOwnPropertyNames(this)) {
                if ("extras" === e3 || "picture" === e3) continue;
                const t3 = this[e3];
                if (t3 instanceof o.XFAObject) {
                  this[r.$extra] = t3;
                  return t3;
                }
              }
              this[r.$extra] = null;
            }
            return this[r.$extra];
          }
          [r.$toHTML](e3) {
            const t3 = this[r.$getExtra]();
            return t3 ? t3[r.$toHTML](e3) : c.HTMLResult.EMPTY;
          }
        }
        class Validate extends o.XFAObject {
          constructor(e3) {
            super(f, "validate", true);
            this.formatTest = (0, c.getStringOption)(e3.formatTest, ["warning", "disabled", "error"]);
            this.id = e3.id || "";
            this.nullTest = (0, c.getStringOption)(e3.nullTest, ["disabled", "error", "warning"]);
            this.scriptTest = (0, c.getStringOption)(e3.scriptTest, ["error", "disabled", "warning"]);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.extras = null;
            this.message = null;
            this.picture = null;
            this.script = null;
          }
        }
        class Value extends o.XFAObject {
          constructor(e3) {
            super(f, "value", true);
            this.id = e3.id || "";
            this.override = (0, c.getInteger)({ data: e3.override, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.relevant = (0, c.getRelevant)(e3.relevant);
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.arc = null;
            this.boolean = null;
            this.date = null;
            this.dateTime = null;
            this.decimal = null;
            this.exData = null;
            this.float = null;
            this.image = null;
            this.integer = null;
            this.line = null;
            this.rectangle = null;
            this.text = null;
            this.time = null;
          }
          [r.$setValue](e3) {
            var _a;
            const t3 = this[r.$getParent]();
            if (t3 instanceof Field && ((_a = t3.ui) == null ? void 0 : _a.imageEdit)) {
              if (!this.image) {
                this.image = new Image({});
                this[r.$appendChild](this.image);
              }
              this.image[r.$content] = e3[r.$content];
              return;
            }
            const a3 = e3[r.$nodeName];
            if (null === this[a3]) {
              for (const e4 of Object.getOwnPropertyNames(this)) {
                const t4 = this[e4];
                if (t4 instanceof o.XFAObject) {
                  this[e4] = null;
                  this[r.$removeChild](t4);
                }
              }
              this[e3[r.$nodeName]] = e3;
              this[r.$appendChild](e3);
            } else this[a3][r.$content] = e3[r.$content];
          }
          [r.$text]() {
            if (this.exData) return "string" == typeof this.exData[r.$content] ? this.exData[r.$content].trim() : this.exData[r.$content][r.$text]().trim();
            for (const e3 of Object.getOwnPropertyNames(this)) {
              if ("image" === e3) continue;
              const t3 = this[e3];
              if (t3 instanceof o.XFAObject) return (t3[r.$content] || "").toString().trim();
            }
            return null;
          }
          [r.$toHTML](e3) {
            for (const t3 of Object.getOwnPropertyNames(this)) {
              const a3 = this[t3];
              if (a3 instanceof o.XFAObject) return a3[r.$toHTML](e3);
            }
            return c.HTMLResult.EMPTY;
          }
        }
        t2.Value = Value;
        class Variables extends o.XFAObject {
          constructor(e3) {
            super(f, "variables", true);
            this.id = e3.id || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
            this.boolean = new o.XFAObjectArray();
            this.date = new o.XFAObjectArray();
            this.dateTime = new o.XFAObjectArray();
            this.decimal = new o.XFAObjectArray();
            this.exData = new o.XFAObjectArray();
            this.float = new o.XFAObjectArray();
            this.image = new o.XFAObjectArray();
            this.integer = new o.XFAObjectArray();
            this.manifest = new o.XFAObjectArray();
            this.script = new o.XFAObjectArray();
            this.text = new o.XFAObjectArray();
            this.time = new o.XFAObjectArray();
          }
          [r.$isTransparent]() {
            return true;
          }
        }
        class TemplateNamespace {
          static [n.$buildXFAObject](e3, t3) {
            if (TemplateNamespace.hasOwnProperty(e3)) {
              const a3 = TemplateNamespace[e3](t3);
              a3[r.$setSetAttributes](t3);
              return a3;
            }
          }
          static appearanceFilter(e3) {
            return new AppearanceFilter(e3);
          }
          static arc(e3) {
            return new Arc(e3);
          }
          static area(e3) {
            return new Area(e3);
          }
          static assist(e3) {
            return new Assist(e3);
          }
          static barcode(e3) {
            return new Barcode(e3);
          }
          static bind(e3) {
            return new Bind(e3);
          }
          static bindItems(e3) {
            return new BindItems(e3);
          }
          static bookend(e3) {
            return new Bookend(e3);
          }
          static boolean(e3) {
            return new BooleanElement(e3);
          }
          static border(e3) {
            return new Border(e3);
          }
          static break(e3) {
            return new Break(e3);
          }
          static breakAfter(e3) {
            return new BreakAfter(e3);
          }
          static breakBefore(e3) {
            return new BreakBefore(e3);
          }
          static button(e3) {
            return new Button(e3);
          }
          static calculate(e3) {
            return new Calculate(e3);
          }
          static caption(e3) {
            return new Caption(e3);
          }
          static certificate(e3) {
            return new Certificate(e3);
          }
          static certificates(e3) {
            return new Certificates(e3);
          }
          static checkButton(e3) {
            return new CheckButton(e3);
          }
          static choiceList(e3) {
            return new ChoiceList(e3);
          }
          static color(e3) {
            return new Color(e3);
          }
          static comb(e3) {
            return new Comb(e3);
          }
          static connect(e3) {
            return new Connect(e3);
          }
          static contentArea(e3) {
            return new ContentArea(e3);
          }
          static corner(e3) {
            return new Corner(e3);
          }
          static date(e3) {
            return new DateElement(e3);
          }
          static dateTime(e3) {
            return new DateTime(e3);
          }
          static dateTimeEdit(e3) {
            return new DateTimeEdit(e3);
          }
          static decimal(e3) {
            return new Decimal(e3);
          }
          static defaultUi(e3) {
            return new DefaultUi(e3);
          }
          static desc(e3) {
            return new Desc(e3);
          }
          static digestMethod(e3) {
            return new DigestMethod(e3);
          }
          static digestMethods(e3) {
            return new DigestMethods(e3);
          }
          static draw(e3) {
            return new Draw(e3);
          }
          static edge(e3) {
            return new Edge(e3);
          }
          static encoding(e3) {
            return new Encoding(e3);
          }
          static encodings(e3) {
            return new Encodings(e3);
          }
          static encrypt(e3) {
            return new Encrypt(e3);
          }
          static encryptData(e3) {
            return new EncryptData(e3);
          }
          static encryption(e3) {
            return new Encryption(e3);
          }
          static encryptionMethod(e3) {
            return new EncryptionMethod(e3);
          }
          static encryptionMethods(e3) {
            return new EncryptionMethods(e3);
          }
          static event(e3) {
            return new Event(e3);
          }
          static exData(e3) {
            return new ExData(e3);
          }
          static exObject(e3) {
            return new ExObject(e3);
          }
          static exclGroup(e3) {
            return new ExclGroup(e3);
          }
          static execute(e3) {
            return new Execute(e3);
          }
          static extras(e3) {
            return new Extras(e3);
          }
          static field(e3) {
            return new Field(e3);
          }
          static fill(e3) {
            return new Fill(e3);
          }
          static filter(e3) {
            return new Filter(e3);
          }
          static float(e3) {
            return new Float(e3);
          }
          static font(e3) {
            return new Font(e3);
          }
          static format(e3) {
            return new Format(e3);
          }
          static handler(e3) {
            return new Handler(e3);
          }
          static hyphenation(e3) {
            return new Hyphenation(e3);
          }
          static image(e3) {
            return new Image(e3);
          }
          static imageEdit(e3) {
            return new ImageEdit(e3);
          }
          static integer(e3) {
            return new Integer(e3);
          }
          static issuers(e3) {
            return new Issuers(e3);
          }
          static items(e3) {
            return new Items(e3);
          }
          static keep(e3) {
            return new Keep(e3);
          }
          static keyUsage(e3) {
            return new KeyUsage(e3);
          }
          static line(e3) {
            return new Line(e3);
          }
          static linear(e3) {
            return new Linear(e3);
          }
          static lockDocument(e3) {
            return new LockDocument(e3);
          }
          static manifest(e3) {
            return new Manifest(e3);
          }
          static margin(e3) {
            return new Margin(e3);
          }
          static mdp(e3) {
            return new Mdp(e3);
          }
          static medium(e3) {
            return new Medium(e3);
          }
          static message(e3) {
            return new Message(e3);
          }
          static numericEdit(e3) {
            return new NumericEdit(e3);
          }
          static occur(e3) {
            return new Occur(e3);
          }
          static oid(e3) {
            return new Oid(e3);
          }
          static oids(e3) {
            return new Oids(e3);
          }
          static overflow(e3) {
            return new Overflow(e3);
          }
          static pageArea(e3) {
            return new PageArea(e3);
          }
          static pageSet(e3) {
            return new PageSet(e3);
          }
          static para(e3) {
            return new Para(e3);
          }
          static passwordEdit(e3) {
            return new PasswordEdit(e3);
          }
          static pattern(e3) {
            return new Pattern(e3);
          }
          static picture(e3) {
            return new Picture(e3);
          }
          static proto(e3) {
            return new Proto(e3);
          }
          static radial(e3) {
            return new Radial(e3);
          }
          static reason(e3) {
            return new Reason(e3);
          }
          static reasons(e3) {
            return new Reasons(e3);
          }
          static rectangle(e3) {
            return new Rectangle(e3);
          }
          static ref(e3) {
            return new RefElement(e3);
          }
          static script(e3) {
            return new Script(e3);
          }
          static setProperty(e3) {
            return new SetProperty(e3);
          }
          static signData(e3) {
            return new SignData(e3);
          }
          static signature(e3) {
            return new Signature(e3);
          }
          static signing(e3) {
            return new Signing(e3);
          }
          static solid(e3) {
            return new Solid(e3);
          }
          static speak(e3) {
            return new Speak(e3);
          }
          static stipple(e3) {
            return new Stipple(e3);
          }
          static subform(e3) {
            return new Subform(e3);
          }
          static subformSet(e3) {
            return new SubformSet(e3);
          }
          static subjectDN(e3) {
            return new SubjectDN(e3);
          }
          static subjectDNs(e3) {
            return new SubjectDNs(e3);
          }
          static submit(e3) {
            return new Submit(e3);
          }
          static template(e3) {
            return new Template(e3);
          }
          static text(e3) {
            return new Text(e3);
          }
          static textEdit(e3) {
            return new TextEdit(e3);
          }
          static time(e3) {
            return new Time(e3);
          }
          static timeStamp(e3) {
            return new TimeStamp(e3);
          }
          static toolTip(e3) {
            return new ToolTip(e3);
          }
          static traversal(e3) {
            return new Traversal(e3);
          }
          static traverse(e3) {
            return new Traverse(e3);
          }
          static ui(e3) {
            return new Ui(e3);
          }
          static validate(e3) {
            return new Validate(e3);
          }
          static value(e3) {
            return new Value(e3);
          }
          static variables(e3) {
            return new Variables(e3);
          }
        }
        t2.TemplateNamespace = TemplateNamespace;
      }, (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NamespaceIds = t2.$buildXFAObject = void 0;
        const a2 = Symbol();
        t2.$buildXFAObject = a2;
        t2.NamespaceIds = { config: { id: 0, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e3) => "http://ns.adobe.com/xdp/pdf/" === e3 }, signature: { id: 6, check: (e3) => "http://www.w3.org/2000/09/xmldsig#" === e3 }, sourceSet: { id: 7, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e3) => "http://www.w3.org/1999/XSL/Transform" === e3 }, template: { id: 9, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e3) => e3.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e3) => "http://ns.adobe.com/xdp/" === e3 }, xfdf: { id: 12, check: (e3) => "http://ns.adobe.com/xfdf/" === e3 }, xhtml: { id: 13, check: (e3) => "http://www.w3.org/1999/xhtml" === e3 }, xmpmeta: { id: 14, check: (e3) => "http://ns.adobe.com/xmpmeta/" === e3 } };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.addHTML = function addHTML(e3, t3, a3) {
          const i = e3[r.$extra], s = i.availableSpace, [o, c, l, h] = a3;
          switch (e3.layout) {
            case "position":
              i.width = Math.max(i.width, o + l);
              i.height = Math.max(i.height, c + h);
              i.children.push(t3);
              break;
            case "lr-tb":
            case "rl-tb":
              if (!i.line || 1 === i.attempt) {
                i.line = createLine(e3, []);
                i.children.push(i.line);
                i.numberInLine = 0;
              }
              i.numberInLine += 1;
              i.line.children.push(t3);
              if (0 === i.attempt) {
                i.currentWidth += l;
                i.height = Math.max(i.height, i.prevHeight + h);
              } else {
                i.currentWidth = l;
                i.prevHeight = i.height;
                i.height += h;
                i.attempt = 0;
              }
              i.width = Math.max(i.width, i.currentWidth);
              break;
            case "rl-row":
            case "row": {
              i.children.push(t3);
              i.width += l;
              i.height = Math.max(i.height, h);
              const e4 = (0, n.measureToString)(i.height);
              for (const t4 of i.children) t4.attributes.style.height = e4;
              break;
            }
            case "table":
            case "tb":
              i.width = Math.min(s.width, Math.max(i.width, l));
              i.height += h;
              i.children.push(t3);
          }
        };
        t2.checkDimensions = function checkDimensions(e3, t3) {
          var _a;
          if (null === e3[r.$getTemplateRoot]()[r.$extra].firstUnsplittable) return true;
          if (0 === e3.w || 0 === e3.h) return true;
          const a3 = e3[r.$getSubformParent](), n2 = ((_a = a3[r.$extra]) == null ? void 0 : _a.attempt) || 0, [, i, s, o] = function getTransformedBBox(e4) {
            let t4, a4, r2 = "" === e4.w ? NaN : e4.w, n3 = "" === e4.h ? NaN : e4.h, [i2, s2] = [0, 0];
            switch (e4.anchorType || "") {
              case "bottomCenter":
                [i2, s2] = [r2 / 2, n3];
                break;
              case "bottomLeft":
                [i2, s2] = [0, n3];
                break;
              case "bottomRight":
                [i2, s2] = [r2, n3];
                break;
              case "middleCenter":
                [i2, s2] = [r2 / 2, n3 / 2];
                break;
              case "middleLeft":
                [i2, s2] = [0, n3 / 2];
                break;
              case "middleRight":
                [i2, s2] = [r2, n3 / 2];
                break;
              case "topCenter":
                [i2, s2] = [r2 / 2, 0];
                break;
              case "topRight":
                [i2, s2] = [r2, 0];
            }
            switch (e4.rotate || 0) {
              case 0:
                [t4, a4] = [-i2, -s2];
                break;
              case 90:
                [t4, a4] = [-s2, i2];
                [r2, n3] = [n3, -r2];
                break;
              case 180:
                [t4, a4] = [i2, s2];
                [r2, n3] = [-r2, -n3];
                break;
              case 270:
                [t4, a4] = [s2, -i2];
                [r2, n3] = [-n3, r2];
            }
            return [e4.x + t4 + Math.min(0, r2), e4.y + a4 + Math.min(0, n3), Math.abs(r2), Math.abs(n3)];
          }(e3);
          switch (a3.layout) {
            case "lr-tb":
            case "rl-tb":
              return 0 === n2 ? e3[r.$getTemplateRoot]()[r.$extra].noLayoutFailure ? "" !== e3.w ? Math.round(s - t3.width) <= 2 : t3.width > 2 : !("" !== e3.h && Math.round(o - t3.height) > 2) && ("" !== e3.w ? Math.round(s - t3.width) <= 2 || 0 === a3[r.$extra].numberInLine && t3.height > 2 : t3.width > 2) : !!e3[r.$getTemplateRoot]()[r.$extra].noLayoutFailure || !("" !== e3.h && Math.round(o - t3.height) > 2) && (("" === e3.w || Math.round(s - t3.width) <= 2 || !a3[r.$isThereMoreWidth]()) && t3.height > 2);
            case "table":
            case "tb":
              return !!e3[r.$getTemplateRoot]()[r.$extra].noLayoutFailure || ("" === e3.h || e3[r.$isSplittable]() ? ("" === e3.w || Math.round(s - t3.width) <= 2 || !a3[r.$isThereMoreWidth]()) && t3.height > 2 : Math.round(o - t3.height) <= 2);
            case "position":
              if (e3[r.$getTemplateRoot]()[r.$extra].noLayoutFailure) return true;
              if ("" === e3.h || Math.round(o + i - t3.height) <= 2) return true;
              return o + i > e3[r.$getTemplateRoot]()[r.$extra].currentContentArea.h;
            case "rl-row":
            case "row":
              return !!e3[r.$getTemplateRoot]()[r.$extra].noLayoutFailure || ("" === e3.h || Math.round(o - t3.height) <= 2);
            default:
              return true;
          }
        };
        t2.flushHTML = function flushHTML(e3) {
          if (!e3[r.$extra]) return null;
          const t3 = { name: "div", attributes: e3[r.$extra].attributes, children: e3[r.$extra].children };
          if (e3[r.$extra].failingNode) {
            const a3 = e3[r.$extra].failingNode[r.$flushHTML]();
            a3 && (e3.layout.endsWith("-tb") ? t3.children.push(createLine(e3, [a3])) : t3.children.push(a3));
          }
          if (0 === t3.children.length) return null;
          return t3;
        };
        t2.getAvailableSpace = function getAvailableSpace(e3) {
          const t3 = e3[r.$extra].availableSpace, a3 = e3.margin ? e3.margin.topInset + e3.margin.bottomInset : 0, n2 = e3.margin ? e3.margin.leftInset + e3.margin.rightInset : 0;
          switch (e3.layout) {
            case "lr-tb":
            case "rl-tb":
              return 0 === e3[r.$extra].attempt ? { width: t3.width - n2 - e3[r.$extra].currentWidth, height: t3.height - a3 - e3[r.$extra].prevHeight } : { width: t3.width - n2, height: t3.height - a3 - e3[r.$extra].height };
            case "rl-row":
            case "row":
              return { width: e3[r.$extra].columnWidths.slice(e3[r.$extra].currentColumn).reduce((e4, t4) => e4 + t4), height: t3.height - n2 };
            case "table":
            case "tb":
              return { width: t3.width - n2, height: t3.height - a3 - e3[r.$extra].height };
            default:
              return t3;
          }
        };
        var r = a2(78), n = a2(83);
        function createLine(e3, t3) {
          return { name: "div", attributes: { class: ["lr-tb" === e3.layout ? "xfaLr" : "xfaRl"] }, children: t3 };
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.computeBbox = function computeBbox(e3, t3, a3) {
          let n2;
          if ("" !== e3.w && "" !== e3.h) n2 = [e3.x, e3.y, e3.w, e3.h];
          else {
            if (!a3) return null;
            let i2 = e3.w;
            if ("" === i2) {
              if (0 === e3.maxW) {
                const t4 = e3[r.$getSubformParent]();
                i2 = "position" === t4.layout && "" !== t4.w ? 0 : e3.minW;
              } else i2 = Math.min(e3.maxW, a3.width);
              t3.attributes.style.width = measureToString(i2);
            }
            let s2 = e3.h;
            if ("" === s2) {
              if (0 === e3.maxH) {
                const t4 = e3[r.$getSubformParent]();
                s2 = "position" === t4.layout && "" !== t4.h ? 0 : e3.minH;
              } else s2 = Math.min(e3.maxH, a3.height);
              t3.attributes.style.height = measureToString(s2);
            }
            n2 = [e3.x, e3.y, i2, s2];
          }
          return n2;
        };
        t2.createWrapper = function createWrapper(e3, t3) {
          const { attributes: a3 } = t3, { style: n2 } = a3, i2 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
          a3.class.push("xfaWrapped");
          if (e3.border) {
            const { widths: a4, insets: s2 } = e3.border[r.$extra];
            let o2, c2, l2 = s2[0], h = s2[3];
            const u = s2[0] + s2[2], d = s2[1] + s2[3];
            switch (e3.border.hand) {
              case "even":
                l2 -= a4[0] / 2;
                h -= a4[3] / 2;
                o2 = `calc(100% + ${(a4[1] + a4[3]) / 2 - d}px)`;
                c2 = `calc(100% + ${(a4[0] + a4[2]) / 2 - u}px)`;
                break;
              case "left":
                l2 -= a4[0];
                h -= a4[3];
                o2 = `calc(100% + ${a4[1] + a4[3] - d}px)`;
                c2 = `calc(100% + ${a4[0] + a4[2] - u}px)`;
                break;
              case "right":
                o2 = d ? `calc(100% - ${d}px)` : "100%";
                c2 = u ? `calc(100% - ${u}px)` : "100%";
            }
            const f = ["xfaBorder"];
            isPrintOnly(e3.border) && f.push("xfaPrintOnly");
            const g = { name: "div", attributes: { class: f, style: { top: `${l2}px`, left: `${h}px`, width: o2, height: c2 } }, children: [] };
            for (const e4 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) if (void 0 !== n2[e4]) {
              g.attributes.style[e4] = n2[e4];
              delete n2[e4];
            }
            i2.children.push(g, t3);
          } else i2.children.push(t3);
          for (const e4 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) if (void 0 !== n2[e4]) {
            i2.attributes.style[e4] = n2[e4];
            delete n2[e4];
          }
          i2.attributes.style.position = "absolute" === n2.position ? "absolute" : "relative";
          delete n2.position;
          if (n2.alignSelf) {
            i2.attributes.style.alignSelf = n2.alignSelf;
            delete n2.alignSelf;
          }
          return i2;
        };
        t2.fixDimensions = function fixDimensions(e3) {
          var _a;
          const t3 = e3[r.$getSubformParent]();
          if ((_a = t3.layout) == null ? void 0 : _a.includes("row")) {
            const a3 = t3[r.$extra], n2 = e3.colSpan;
            let i2;
            i2 = -1 === n2 ? a3.columnWidths.slice(a3.currentColumn).reduce((e4, t4) => e4 + t4, 0) : a3.columnWidths.slice(a3.currentColumn, a3.currentColumn + n2).reduce((e4, t4) => e4 + t4, 0);
            isNaN(i2) || (e3.w = i2);
          }
          t3.layout && "position" !== t3.layout && (e3.x = e3.y = 0);
          "table" === e3.layout && "" === e3.w && Array.isArray(e3.columnWidths) && (e3.w = e3.columnWidths.reduce((e4, t4) => e4 + t4, 0));
        };
        t2.fixTextIndent = function fixTextIndent(e3) {
          const t3 = (0, i.getMeasurement)(e3.textIndent, "0px");
          if (t3 >= 0) return;
          const a3 = "padding" + ("left" == ("right" === e3.textAlign ? "right" : "left") ? "Left" : "Right"), r2 = (0, i.getMeasurement)(e3[a3], "0px");
          e3[a3] = r2 - t3 + "px";
        };
        t2.fixURL = function fixURL(e3) {
          const t3 = (0, n.createValidAbsoluteUrl)(e3, null, { addDefaultProtocol: true, tryConvertEncoding: true });
          return t3 ? t3.href : null;
        };
        t2.isPrintOnly = isPrintOnly;
        t2.layoutClass = function layoutClass(e3) {
          switch (e3.layout) {
            case "position":
            default:
              return "xfaPosition";
            case "lr-tb":
              return "xfaLrTb";
            case "rl-row":
              return "xfaRlRow";
            case "rl-tb":
              return "xfaRlTb";
            case "row":
              return "xfaRow";
            case "table":
              return "xfaTable";
            case "tb":
              return "xfaTb";
          }
        };
        t2.layoutNode = function layoutNode(e3, t3) {
          let a3 = null, n2 = null, i2 = false;
          if ((!e3.w || !e3.h) && e3.value) {
            let s2 = 0, o2 = 0;
            if (e3.margin) {
              s2 = e3.margin.leftInset + e3.margin.rightInset;
              o2 = e3.margin.topInset + e3.margin.bottomInset;
            }
            let c2 = null, l2 = null;
            if (e3.para) {
              l2 = /* @__PURE__ */ Object.create(null);
              c2 = "" === e3.para.lineHeight ? null : e3.para.lineHeight;
              l2.top = "" === e3.para.spaceAbove ? 0 : e3.para.spaceAbove;
              l2.bottom = "" === e3.para.spaceBelow ? 0 : e3.para.spaceBelow;
              l2.left = "" === e3.para.marginLeft ? 0 : e3.para.marginLeft;
              l2.right = "" === e3.para.marginRight ? 0 : e3.para.marginRight;
            }
            let h = e3.font;
            if (!h) {
              const t4 = e3[r.$getTemplateRoot]();
              let a4 = e3[r.$getParent]();
              for (; a4 && a4 !== t4; ) {
                if (a4.font) {
                  h = a4.font;
                  break;
                }
                a4 = a4[r.$getParent]();
              }
            }
            const u = (e3.w || t3.width) - s2, d = e3[r.$globalData].fontFinder;
            if (e3.value.exData && e3.value.exData[r.$content] && "text/html" === e3.value.exData.contentType) {
              const t4 = layoutText(e3.value.exData[r.$content], h, l2, c2, d, u);
              n2 = t4.width;
              a3 = t4.height;
              i2 = t4.isBroken;
            } else {
              const t4 = e3.value[r.$text]();
              if (t4) {
                const e4 = layoutText(t4, h, l2, c2, d, u);
                n2 = e4.width;
                a3 = e4.height;
                i2 = e4.isBroken;
              }
            }
            null === n2 || e3.w || (n2 += s2);
            null === a3 || e3.h || (a3 += o2);
          }
          return { w: n2, h: a3, isBroken: i2 };
        };
        t2.measureToString = measureToString;
        t2.setAccess = function setAccess(e3, t3) {
          switch (e3.access) {
            case "nonInteractive":
              t3.push("xfaNonInteractive");
              break;
            case "readOnly":
              t3.push("xfaReadOnly");
              break;
            case "protected":
              t3.push("xfaDisabled");
          }
        };
        t2.setFontFamily = function setFontFamily(e3, t3, a3, r2) {
          if (!a3) {
            delete r2.fontFamily;
            return;
          }
          const n2 = (0, i.stripQuotes)(e3.typeface);
          r2.fontFamily = `"${n2}"`;
          const o2 = a3.find(n2);
          if (o2) {
            const { fontFamily: a4 } = o2.regular.cssFontInfo;
            a4 !== n2 && (r2.fontFamily = `"${a4}"`);
            const i2 = getCurrentPara(t3);
            if (i2 && "" !== i2.lineHeight) return;
            if (r2.lineHeight) return;
            const c2 = (0, s.selectFont)(e3, o2);
            c2 && (r2.lineHeight = Math.max(1.2, c2.lineHeight));
          }
        };
        t2.setMinMaxDimensions = function setMinMaxDimensions(e3, t3) {
          if ("position" === e3[r.$getSubformParent]().layout) {
            e3.minW > 0 && (t3.minWidth = measureToString(e3.minW));
            e3.maxW > 0 && (t3.maxWidth = measureToString(e3.maxW));
            e3.minH > 0 && (t3.minHeight = measureToString(e3.minH));
            e3.maxH > 0 && (t3.maxHeight = measureToString(e3.maxH));
          }
        };
        t2.setPara = function setPara(e3, t3, a3) {
          var _a;
          if ((_a = a3.attributes.class) == null ? void 0 : _a.includes("xfaRich")) {
            if (t3) {
              "" === e3.h && (t3.height = "auto");
              "" === e3.w && (t3.width = "auto");
            }
            const n2 = getCurrentPara(e3);
            if (n2) {
              const e4 = a3.attributes.style;
              e4.display = "flex";
              e4.flexDirection = "column";
              switch (n2.vAlign) {
                case "top":
                  e4.justifyContent = "start";
                  break;
                case "bottom":
                  e4.justifyContent = "end";
                  break;
                case "middle":
                  e4.justifyContent = "center";
              }
              const t4 = n2[r.$toStyle]();
              for (const [a4, r2] of Object.entries(t4)) a4 in e4 || (e4[a4] = r2);
            }
          }
        };
        t2.toStyle = function toStyle(e3, ...t3) {
          const a3 = /* @__PURE__ */ Object.create(null);
          for (const i2 of t3) {
            const t4 = e3[i2];
            if (null !== t4) {
              if (l.hasOwnProperty(i2)) l[i2](e3, a3);
              else if (t4 instanceof c.XFAObject) {
                const e4 = t4[r.$toStyle]();
                e4 ? Object.assign(a3, e4) : (0, n.warn)(`(DEBUG) - XFA - style for ${i2} not implemented yet`);
              }
            }
          }
          return a3;
        };
        var r = a2(78), n = a2(2), i = a2(84), s = a2(85), o = a2(86), c = a2(87);
        function measureToString(e3) {
          return "string" == typeof e3 ? "0px" : Number.isInteger(e3) ? `${e3}px` : `${e3.toFixed(2)}px`;
        }
        const l = { anchorType(e3, t3) {
          const a3 = e3[r.$getSubformParent]();
          if (a3 && (!a3.layout || "position" === a3.layout)) {
            "transform" in t3 || (t3.transform = "");
            switch (e3.anchorType) {
              case "bottomCenter":
                t3.transform += "translate(-50%, -100%)";
                break;
              case "bottomLeft":
                t3.transform += "translate(0,-100%)";
                break;
              case "bottomRight":
                t3.transform += "translate(-100%,-100%)";
                break;
              case "middleCenter":
                t3.transform += "translate(-50%,-50%)";
                break;
              case "middleLeft":
                t3.transform += "translate(0,-50%)";
                break;
              case "middleRight":
                t3.transform += "translate(-100%,-50%)";
                break;
              case "topCenter":
                t3.transform += "translate(-50%,0)";
                break;
              case "topRight":
                t3.transform += "translate(-100%,0)";
            }
          }
        }, dimensions(e3, t3) {
          var _a;
          const a3 = e3[r.$getSubformParent]();
          let n2 = e3.w;
          const i2 = e3.h;
          if ((_a = a3.layout) == null ? void 0 : _a.includes("row")) {
            const t4 = a3[r.$extra], i3 = e3.colSpan;
            let s2;
            if (-1 === i3) {
              s2 = t4.columnWidths.slice(t4.currentColumn).reduce((e4, t5) => e4 + t5, 0);
              t4.currentColumn = 0;
            } else {
              s2 = t4.columnWidths.slice(t4.currentColumn, t4.currentColumn + i3).reduce((e4, t5) => e4 + t5, 0);
              t4.currentColumn = (t4.currentColumn + e3.colSpan) % t4.columnWidths.length;
            }
            isNaN(s2) || (n2 = e3.w = s2);
          }
          t3.width = "" !== n2 ? measureToString(n2) : "auto";
          t3.height = "" !== i2 ? measureToString(i2) : "auto";
        }, position(e3, t3) {
          const a3 = e3[r.$getSubformParent]();
          if (!(a3 == null ? void 0 : a3.layout) || "position" === a3.layout) {
            t3.position = "absolute";
            t3.left = measureToString(e3.x);
            t3.top = measureToString(e3.y);
          }
        }, rotate(e3, t3) {
          if (e3.rotate) {
            "transform" in t3 || (t3.transform = "");
            t3.transform += `rotate(-${e3.rotate}deg)`;
            t3.transformOrigin = "top left";
          }
        }, presence(e3, t3) {
          switch (e3.presence) {
            case "invisible":
              t3.visibility = "hidden";
              break;
            case "hidden":
            case "inactive":
              t3.display = "none";
          }
        }, hAlign(e3, t3) {
          if ("para" === e3[r.$nodeName]) switch (e3.hAlign) {
            case "justifyAll":
              t3.textAlign = "justify-all";
              break;
            case "radix":
              t3.textAlign = "left";
              break;
            default:
              t3.textAlign = e3.hAlign;
          }
          else switch (e3.hAlign) {
            case "left":
              t3.alignSelf = "start";
              break;
            case "center":
              t3.alignSelf = "center";
              break;
            case "right":
              t3.alignSelf = "end";
          }
        }, margin(e3, t3) {
          e3.margin && (t3.margin = e3.margin[r.$toStyle]().margin);
        } };
        function layoutText(e3, t3, a3, n2, i2, s2) {
          const c2 = new o.TextMeasure(t3, a3, n2, i2);
          "string" == typeof e3 ? c2.addString(e3) : e3[r.$pushGlyphs](c2);
          return c2.compute(s2);
        }
        function isPrintOnly(e3) {
          return e3.relevant.length > 0 && !e3.relevant[0].excluded && "print" === e3.relevant[0].viewname;
        }
        function getCurrentPara(e3) {
          const t3 = e3[r.$getTemplateRoot]()[r.$extra].paraStack;
          return t3.length ? t3.at(-1) : null;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.HTMLResult = void 0;
        t2.getBBox = function getBBox(e3) {
          const t3 = -1;
          if (!e3) return { x: t3, y: t3, width: t3, height: t3 };
          const a3 = e3.trim().split(/\s*,\s*/).map((e4) => getMeasurement(e4, "-1"));
          if (a3.length < 4 || a3[2] < 0 || a3[3] < 0) return { x: t3, y: t3, width: t3, height: t3 };
          const [r2, n2, i2, s] = a3;
          return { x: r2, y: n2, width: i2, height: s };
        };
        t2.getColor = function getColor(e3, t3 = [0, 0, 0]) {
          let [a3, r2, n2] = t3;
          if (!e3) return { r: a3, g: r2, b: n2 };
          const i2 = e3.trim().split(/\s*,\s*/).map((e4) => Math.min(Math.max(0, parseInt(e4.trim(), 10)), 255)).map((e4) => isNaN(e4) ? 0 : e4);
          if (i2.length < 3) return { r: a3, g: r2, b: n2 };
          [a3, r2, n2] = i2;
          return { r: a3, g: r2, b: n2 };
        };
        t2.getFloat = function getFloat({ data: e3, defaultValue: t3, validate: a3 }) {
          if (!e3) return t3;
          e3 = e3.trim();
          const r2 = parseFloat(e3);
          if (!isNaN(r2) && a3(r2)) return r2;
          return t3;
        };
        t2.getInteger = function getInteger({ data: e3, defaultValue: t3, validate: a3 }) {
          if (!e3) return t3;
          e3 = e3.trim();
          const r2 = parseInt(e3, 10);
          if (!isNaN(r2) && a3(r2)) return r2;
          return t3;
        };
        t2.getKeyword = getKeyword;
        t2.getMeasurement = getMeasurement;
        t2.getRatio = function getRatio(e3) {
          if (!e3) return { num: 1, den: 1 };
          const t3 = e3.trim().split(/\s*:\s*/).map((e4) => parseFloat(e4)).filter((e4) => !isNaN(e4));
          1 === t3.length && t3.push(1);
          if (0 === t3.length) return { num: 1, den: 1 };
          const [a3, r2] = t3;
          return { num: a3, den: r2 };
        };
        t2.getRelevant = function getRelevant(e3) {
          if (!e3) return [];
          return e3.trim().split(/\s+/).map((e4) => ({ excluded: "-" === e4[0], viewname: e4.substring(1) }));
        };
        t2.getStringOption = function getStringOption(e3, t3) {
          return getKeyword({ data: e3, defaultValue: t3[0], validate: (e4) => t3.includes(e4) });
        };
        t2.stripQuotes = function stripQuotes(e3) {
          if (e3.startsWith("'") || e3.startsWith('"')) return e3.slice(1, -1);
          return e3;
        };
        var r = a2(2);
        const n = { pt: (e3) => e3, cm: (e3) => e3 / 2.54 * 72, mm: (e3) => e3 / 25.4 * 72, in: (e3) => 72 * e3, px: (e3) => e3 }, i = /([+-]?\d+\.?\d*)(.*)/;
        function getKeyword({ data: e3, defaultValue: t3, validate: a3 }) {
          return e3 && a3(e3 = e3.trim()) ? e3 : t3;
        }
        function getMeasurement(e3, t3 = "0") {
          t3 || (t3 = "0");
          if (!e3) return getMeasurement(t3);
          const a3 = e3.trim().match(i);
          if (!a3) return getMeasurement(t3);
          const [, r2, s] = a3, o = parseFloat(r2);
          if (isNaN(o)) return getMeasurement(t3);
          if (0 === o) return 0;
          const c = n[s];
          return c ? c(o) : o;
        }
        class HTMLResult {
          static get FAILURE() {
            return (0, r.shadow)(this, "FAILURE", new HTMLResult(false, null, null, null));
          }
          static get EMPTY() {
            return (0, r.shadow)(this, "EMPTY", new HTMLResult(true, null, null, null));
          }
          constructor(e3, t3, a3, r2) {
            this.success = e3;
            this.html = t3;
            this.bbox = a3;
            this.breakNode = r2;
          }
          isBreak() {
            return !!this.breakNode;
          }
          static breakNode(e3) {
            return new HTMLResult(false, null, null, e3);
          }
          static success(e3, t3 = null) {
            return new HTMLResult(true, e3, t3, null);
          }
        }
        t2.HTMLResult = HTMLResult;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.FontFinder = void 0;
        t2.getMetrics = function getMetrics(e3, t3 = false) {
          let a3 = null;
          if (e3) {
            const t4 = (0, n.stripQuotes)(e3.typeface), i3 = e3[r.$globalData].fontFinder.find(t4);
            a3 = selectFont(e3, i3);
          }
          if (!a3) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
          const i2 = e3.size || 10, s = a3.lineHeight ? Math.max(t3 ? 0 : 1.2, a3.lineHeight) : 1.2, o = void 0 === a3.lineGap ? 0.2 : a3.lineGap;
          return { lineHeight: s * i2, lineGap: o * i2, lineNoGap: Math.max(1, s - o) * i2 };
        };
        t2.selectFont = selectFont;
        var r = a2(78), n = a2(84), i = a2(2);
        t2.FontFinder = class FontFinder {
          constructor(e3) {
            this.fonts = /* @__PURE__ */ new Map();
            this.cache = /* @__PURE__ */ new Map();
            this.warned = /* @__PURE__ */ new Set();
            this.defaultFont = null;
            this.add(e3);
          }
          add(e3, t3 = null) {
            for (const t4 of e3) this.addPdfFont(t4);
            for (const e4 of this.fonts.values()) e4.regular || (e4.regular = e4.italic || e4.bold || e4.bolditalic);
            if (!t3 || 0 === t3.size) return;
            const a3 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
            for (const e4 of t3) this.fonts.set(e4, a3);
          }
          addPdfFont(e3) {
            var _a, _b, _c;
            const t3 = e3.cssFontInfo, a3 = t3.fontFamily;
            let r2 = this.fonts.get(a3);
            if (!r2) {
              r2 = /* @__PURE__ */ Object.create(null);
              this.fonts.set(a3, r2);
              this.defaultFont || (this.defaultFont = r2);
            }
            let n2 = "";
            const i2 = parseFloat(t3.fontWeight);
            0 !== parseFloat(t3.italicAngle) ? n2 = i2 >= 700 ? "bolditalic" : "italic" : i2 >= 700 && (n2 = "bold");
            if (!n2) {
              (e3.name.includes("Bold") || ((_a = e3.psName) == null ? void 0 : _a.includes("Bold"))) && (n2 = "bold");
              (e3.name.includes("Italic") || e3.name.endsWith("It") || ((_b = e3.psName) == null ? void 0 : _b.includes("Italic")) || ((_c = e3.psName) == null ? void 0 : _c.endsWith("It"))) && (n2 += "italic");
            }
            n2 || (n2 = "regular");
            r2[n2] = e3;
          }
          getDefault() {
            return this.defaultFont;
          }
          find(e3, t3 = true) {
            var _a, _b;
            let a3 = this.fonts.get(e3) || this.cache.get(e3);
            if (a3) return a3;
            const r2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
            let n2 = e3.replaceAll(r2, "");
            a3 = this.fonts.get(n2);
            if (a3) {
              this.cache.set(e3, a3);
              return a3;
            }
            n2 = n2.toLowerCase();
            const s = [];
            for (const [e4, t4] of this.fonts.entries()) e4.replaceAll(r2, "").toLowerCase().startsWith(n2) && s.push(t4);
            if (0 === s.length) for (const [, e4] of this.fonts.entries()) ((_a = e4.regular.name) == null ? void 0 : _a.replaceAll(r2, "").toLowerCase().startsWith(n2)) && s.push(e4);
            if (0 === s.length) {
              n2 = n2.replaceAll(/psmt|mt/gi, "");
              for (const [e4, t4] of this.fonts.entries()) e4.replaceAll(r2, "").toLowerCase().startsWith(n2) && s.push(t4);
            }
            if (0 === s.length) for (const e4 of this.fonts.values()) ((_b = e4.regular.name) == null ? void 0 : _b.replaceAll(r2, "").toLowerCase().startsWith(n2)) && s.push(e4);
            if (s.length >= 1) {
              1 !== s.length && t3 && (0, i.warn)(`XFA - Too many choices to guess the correct font: ${e3}`);
              this.cache.set(e3, s[0]);
              return s[0];
            }
            if (t3 && !this.warned.has(e3)) {
              this.warned.add(e3);
              (0, i.warn)(`XFA - Cannot find the font: ${e3}`);
            }
            return null;
          }
        };
        function selectFont(e3, t3) {
          return "italic" === e3.posture ? "bold" === e3.weight ? t3.bolditalic : t3.italic : "bold" === e3.weight ? t3.bold : t3.regular;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.TextMeasure = void 0;
        var r = a2(85);
        class FontInfo {
          constructor(e3, t3, a3, n) {
            this.lineHeight = a3;
            this.paraMargin = t3 || { top: 0, bottom: 0, left: 0, right: 0 };
            if (!e3) {
              [this.pdfFont, this.xfaFont] = this.defaultFont(n);
              return;
            }
            this.xfaFont = { typeface: e3.typeface, posture: e3.posture, weight: e3.weight, size: e3.size, letterSpacing: e3.letterSpacing };
            const i = n.find(e3.typeface);
            if (i) {
              this.pdfFont = (0, r.selectFont)(e3, i);
              this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(n));
            } else [this.pdfFont, this.xfaFont] = this.defaultFont(n);
          }
          defaultFont(e3) {
            const t3 = e3.find("Helvetica", false) || e3.find("Myriad Pro", false) || e3.find("Arial", false) || e3.getDefault();
            if (t3 == null ? void 0 : t3.regular) {
              const e4 = t3.regular;
              return [e4, { typeface: e4.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
            }
            return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
          }
        }
        class FontSelector {
          constructor(e3, t3, a3, r2) {
            this.fontFinder = r2;
            this.stack = [new FontInfo(e3, t3, a3, r2)];
          }
          pushData(e3, t3, a3) {
            const r2 = this.stack.at(-1);
            for (const t4 of ["typeface", "posture", "weight", "size", "letterSpacing"]) e3[t4] || (e3[t4] = r2.xfaFont[t4]);
            for (const e4 of ["top", "bottom", "left", "right"]) isNaN(t3[e4]) && (t3[e4] = r2.paraMargin[e4]);
            const n = new FontInfo(e3, t3, a3 || r2.lineHeight, this.fontFinder);
            n.pdfFont || (n.pdfFont = r2.pdfFont);
            this.stack.push(n);
          }
          popFont() {
            this.stack.pop();
          }
          topFont() {
            return this.stack.at(-1);
          }
        }
        t2.TextMeasure = class TextMeasure {
          constructor(e3, t3, a3, r2) {
            this.glyphs = [];
            this.fontSelector = new FontSelector(e3, t3, a3, r2);
            this.extraHeight = 0;
          }
          pushData(e3, t3, a3) {
            this.fontSelector.pushData(e3, t3, a3);
          }
          popFont(e3) {
            return this.fontSelector.popFont();
          }
          addPara() {
            const e3 = this.fontSelector.topFont();
            this.extraHeight += e3.paraMargin.top + e3.paraMargin.bottom;
          }
          addString(e3) {
            if (!e3) return;
            const t3 = this.fontSelector.topFont(), a3 = t3.xfaFont.size;
            if (t3.pdfFont) {
              const r2 = t3.xfaFont.letterSpacing, n = t3.pdfFont, i = n.lineHeight || 1.2, s = t3.lineHeight || Math.max(1.2, i) * a3, o = i - (void 0 === n.lineGap ? 0.2 : n.lineGap), c = Math.max(1, o) * a3, l = a3 / 1e3, h = n.defaultWidth || n.charsToGlyphs(" ")[0].width;
              for (const t4 of e3.split(/[\u2029\n]/)) {
                const e4 = n.encodeString(t4).join(""), a4 = n.charsToGlyphs(e4);
                for (const e5 of a4) {
                  const t5 = e5.width || h;
                  this.glyphs.push([t5 * l + r2, s, c, e5.unicode, false]);
                }
                this.glyphs.push([0, 0, 0, "\n", true]);
              }
              this.glyphs.pop();
            } else {
              for (const t4 of e3.split(/[\u2029\n]/)) {
                for (const e4 of t4.split("")) this.glyphs.push([a3, 1.2 * a3, a3, e4, false]);
                this.glyphs.push([0, 0, 0, "\n", true]);
              }
              this.glyphs.pop();
            }
          }
          compute(e3) {
            let t3 = -1, a3 = 0, r2 = 0, n = 0, i = 0, s = 0, o = false, c = true;
            for (let l = 0, h = this.glyphs.length; l < h; l++) {
              const [h2, u, d, f, g] = this.glyphs[l], p = " " === f, m = c ? d : u;
              if (g) {
                r2 = Math.max(r2, i);
                i = 0;
                n += s;
                s = m;
                t3 = -1;
                a3 = 0;
                c = false;
              } else if (p) if (i + h2 > e3) {
                r2 = Math.max(r2, i);
                i = 0;
                n += s;
                s = m;
                t3 = -1;
                a3 = 0;
                o = true;
                c = false;
              } else {
                s = Math.max(m, s);
                a3 = i;
                i += h2;
                t3 = l;
              }
              else if (i + h2 > e3) {
                n += s;
                s = m;
                if (-1 !== t3) {
                  l = t3;
                  r2 = Math.max(r2, a3);
                  i = 0;
                  t3 = -1;
                  a3 = 0;
                } else {
                  r2 = Math.max(r2, i);
                  i = h2;
                }
                o = true;
                c = false;
              } else {
                i += h2;
                s = Math.max(m, s);
              }
            }
            r2 = Math.max(r2, i);
            n += s + this.extraHeight;
            return { width: 1.02 * r2, height: n, isBroken: o };
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XmlObject = t2.XFAObjectArray = t2.XFAObject = t2.XFAAttribute = t2.StringObject = t2.OptionObject = t2.Option10 = t2.Option01 = t2.IntegerObject = t2.ContentObject = void 0;
        var r = a2(78), n = a2(84), i = a2(2), s = a2(3), o = a2(81), c = a2(88);
        const l = Symbol(), h = Symbol(), u = Symbol(), d = Symbol("_children"), f = Symbol(), g = Symbol(), p = Symbol(), m = Symbol(), b = Symbol(), y = Symbol(), w = Symbol(), S = Symbol(), x = Symbol(), C = Symbol("parent"), k = Symbol(), v = Symbol(), F = Symbol();
        let O = 0;
        const T = o.NamespaceIds.datasets.id;
        class XFAObject {
          constructor(e3, t3, a3 = false) {
            this[r.$namespaceId] = e3;
            this[r.$nodeName] = t3;
            this[w] = a3;
            this[C] = null;
            this[d] = [];
            this[r.$uid] = `${t3}${O++}`;
            this[r.$globalData] = null;
          }
          get isXFAObject() {
            return true;
          }
          get isXFAObjectArray() {
            return false;
          }
          createNodes(e3) {
            let t3 = this, a3 = null;
            for (const { name: n2, index: i2 } of e3) {
              for (let e4 = 0, s2 = isFinite(i2) ? i2 : 0; e4 <= s2; e4++) {
                const e5 = t3[r.$namespaceId] === T ? -1 : t3[r.$namespaceId];
                a3 = new XmlObject(e5, n2);
                t3[r.$appendChild](a3);
              }
              t3 = a3;
            }
            return a3;
          }
          [r.$onChild](e3) {
            if (!this[w] || !this[r.$onChildCheck](e3)) return false;
            const t3 = e3[r.$nodeName], a3 = this[t3];
            if (!(a3 instanceof XFAObjectArray)) {
              null !== a3 && this[r.$removeChild](a3);
              this[t3] = e3;
              this[r.$appendChild](e3);
              return true;
            }
            if (a3.push(e3)) {
              this[r.$appendChild](e3);
              return true;
            }
            let n2 = "";
            this.id ? n2 = ` (id: ${this.id})` : this.name && (n2 = ` (name: ${this.name} ${this.h.value})`);
            (0, i.warn)(`XFA - node "${this[r.$nodeName]}"${n2} has already enough "${t3}"!`);
            return false;
          }
          [r.$onChildCheck](e3) {
            return this.hasOwnProperty(e3[r.$nodeName]) && e3[r.$namespaceId] === this[r.$namespaceId];
          }
          [r.$isNsAgnostic]() {
            return false;
          }
          [r.$acceptWhitespace]() {
            return false;
          }
          [r.$isCDATAXml]() {
            return false;
          }
          [r.$isBindable]() {
            return false;
          }
          [r.$popPara]() {
            this.para && this[r.$getTemplateRoot]()[r.$extra].paraStack.pop();
          }
          [r.$pushPara]() {
            this[r.$getTemplateRoot]()[r.$extra].paraStack.push(this.para);
          }
          [r.$setId](e3) {
            this.id && this[r.$namespaceId] === o.NamespaceIds.template.id && e3.set(this.id, this);
          }
          [r.$getTemplateRoot]() {
            return this[r.$globalData].template;
          }
          [r.$isSplittable]() {
            return false;
          }
          [r.$isThereMoreWidth]() {
            return false;
          }
          [r.$appendChild](e3) {
            e3[C] = this;
            this[d].push(e3);
            !e3[r.$globalData] && this[r.$globalData] && (e3[r.$globalData] = this[r.$globalData]);
          }
          [r.$removeChild](e3) {
            const t3 = this[d].indexOf(e3);
            this[d].splice(t3, 1);
          }
          [r.$hasSettableValue]() {
            return this.hasOwnProperty("value");
          }
          [r.$setValue](e3) {
          }
          [r.$onText](e3) {
          }
          [r.$finalize]() {
          }
          [r.$clean](e3) {
            delete this[w];
            if (this[r.$cleanup]) {
              e3.clean(this[r.$cleanup]);
              delete this[r.$cleanup];
            }
          }
          [r.$indexOf](e3) {
            return this[d].indexOf(e3);
          }
          [r.$insertAt](e3, t3) {
            t3[C] = this;
            this[d].splice(e3, 0, t3);
            !t3[r.$globalData] && this[r.$globalData] && (t3[r.$globalData] = this[r.$globalData]);
          }
          [r.$isTransparent]() {
            return !this.name;
          }
          [r.$lastAttribute]() {
            return "";
          }
          [r.$text]() {
            return 0 === this[d].length ? this[r.$content] : this[d].map((e3) => e3[r.$text]()).join("");
          }
          get [u]() {
            const e3 = Object.getPrototypeOf(this);
            if (!e3._attributes) {
              const t3 = e3._attributes = /* @__PURE__ */ new Set();
              for (const e4 of Object.getOwnPropertyNames(this)) {
                if (null === this[e4] || this[e4] instanceof XFAObject || this[e4] instanceof XFAObjectArray) break;
                t3.add(e4);
              }
            }
            return (0, i.shadow)(this, u, e3._attributes);
          }
          [r.$isDescendent](e3) {
            let t3 = this;
            for (; t3; ) {
              if (t3 === e3) return true;
              t3 = t3[r.$getParent]();
            }
            return false;
          }
          [r.$getParent]() {
            return this[C];
          }
          [r.$getSubformParent]() {
            return this[r.$getParent]();
          }
          [r.$getChildren](e3 = null) {
            return e3 ? this[e3] : this[d];
          }
          [r.$dump]() {
            const e3 = /* @__PURE__ */ Object.create(null);
            this[r.$content] && (e3.$content = this[r.$content]);
            for (const t3 of Object.getOwnPropertyNames(this)) {
              const a3 = this[t3];
              null !== a3 && (a3 instanceof XFAObject ? e3[t3] = a3[r.$dump]() : a3 instanceof XFAObjectArray ? a3.isEmpty() || (e3[t3] = a3.dump()) : e3[t3] = a3);
            }
            return e3;
          }
          [r.$toStyle]() {
            return null;
          }
          [r.$toHTML]() {
            return n.HTMLResult.EMPTY;
          }
          *[r.$getContainedChildren]() {
            for (const e3 of this[r.$getChildren]()) yield e3;
          }
          *[m](e3, t3) {
            for (const a3 of this[r.$getContainedChildren]()) if (!e3 || t3 === e3.has(a3[r.$nodeName])) {
              const e4 = this[r.$getAvailableSpace](), t4 = a3[r.$toHTML](e4);
              t4.success || (this[r.$extra].failingNode = a3);
              yield t4;
            }
          }
          [r.$flushHTML]() {
            return null;
          }
          [r.$addHTML](e3, t3) {
            this[r.$extra].children.push(e3);
          }
          [r.$getAvailableSpace]() {
          }
          [r.$childrenToHTML]({ filter: e3 = null, include: t3 = true }) {
            if (this[r.$extra].generator) {
              const e4 = this[r.$getAvailableSpace](), t4 = this[r.$extra].failingNode[r.$toHTML](e4);
              if (!t4.success) return t4;
              t4.html && this[r.$addHTML](t4.html, t4.bbox);
              delete this[r.$extra].failingNode;
            } else this[r.$extra].generator = this[m](e3, t3);
            for (; ; ) {
              const e4 = this[r.$extra].generator.next();
              if (e4.done) break;
              const t4 = e4.value;
              if (!t4.success) return t4;
              t4.html && this[r.$addHTML](t4.html, t4.bbox);
            }
            this[r.$extra].generator = null;
            return n.HTMLResult.EMPTY;
          }
          [r.$setSetAttributes](e3) {
            this[v] = new Set(Object.keys(e3));
          }
          [y](e3) {
            const t3 = this[u], a3 = this[v];
            return [...e3].filter((e4) => t3.has(e4) && !a3.has(e4));
          }
          [r.$resolvePrototypes](e3, t3 = /* @__PURE__ */ new Set()) {
            for (const a3 of this[d]) a3[k](e3, t3);
          }
          [k](e3, t3) {
            const a3 = this[b](e3, t3);
            a3 ? this[l](a3, e3, t3) : this[r.$resolvePrototypes](e3, t3);
          }
          [b](e3, t3) {
            const { use: a3, usehref: n2 } = this;
            if (!a3 && !n2) return null;
            let s2 = null, o2 = null, h2 = null, u2 = a3;
            if (n2) {
              u2 = n2;
              n2.startsWith("#som(") && n2.endsWith(")") ? o2 = n2.slice(5, -1) : n2.startsWith(".#som(") && n2.endsWith(")") ? o2 = n2.slice(6, -1) : n2.startsWith("#") ? h2 = n2.slice(1) : n2.startsWith(".#") && (h2 = n2.slice(2));
            } else a3.startsWith("#") ? h2 = a3.slice(1) : o2 = a3;
            this.use = this.usehref = "";
            if (h2) s2 = e3.get(h2);
            else {
              s2 = (0, c.searchNode)(e3.get(r.$root), this, o2, true, false);
              s2 && (s2 = s2[0]);
            }
            if (!s2) {
              (0, i.warn)(`XFA - Invalid prototype reference: ${u2}.`);
              return null;
            }
            if (s2[r.$nodeName] !== this[r.$nodeName]) {
              (0, i.warn)(`XFA - Incompatible prototype: ${s2[r.$nodeName]} !== ${this[r.$nodeName]}.`);
              return null;
            }
            if (t3.has(s2)) {
              (0, i.warn)("XFA - Cycle detected in prototypes use.");
              return null;
            }
            t3.add(s2);
            const d2 = s2[b](e3, t3);
            d2 && s2[l](d2, e3, t3);
            s2[r.$resolvePrototypes](e3, t3);
            t3.delete(s2);
            return s2;
          }
          [l](e3, t3, a3) {
            if (a3.has(e3)) {
              (0, i.warn)("XFA - Cycle detected in prototypes use.");
              return;
            }
            !this[r.$content] && e3[r.$content] && (this[r.$content] = e3[r.$content]);
            new Set(a3).add(e3);
            for (const t4 of this[y](e3[v])) {
              this[t4] = e3[t4];
              this[v] && this[v].add(t4);
            }
            for (const n2 of Object.getOwnPropertyNames(this)) {
              if (this[u].has(n2)) continue;
              const i2 = this[n2], s2 = e3[n2];
              if (i2 instanceof XFAObjectArray) {
                for (const e4 of i2[d]) e4[k](t3, a3);
                for (let n3 = i2[d].length, o2 = s2[d].length; n3 < o2; n3++) {
                  const s3 = e3[d][n3][r.$clone]();
                  if (!i2.push(s3)) break;
                  s3[C] = this;
                  this[d].push(s3);
                  s3[k](t3, a3);
                }
              } else if (null === i2) {
                if (null !== s2) {
                  const e4 = s2[r.$clone]();
                  e4[C] = this;
                  this[n2] = e4;
                  this[d].push(e4);
                  e4[k](t3, a3);
                }
              } else {
                i2[r.$resolvePrototypes](t3, a3);
                s2 && i2[l](s2, t3, a3);
              }
            }
          }
          static [f](e3) {
            return Array.isArray(e3) ? e3.map((e4) => XFAObject[f](e4)) : "object" == typeof e3 && null !== e3 ? Object.assign({}, e3) : e3;
          }
          [r.$clone]() {
            const e3 = Object.create(Object.getPrototypeOf(this));
            for (const t3 of Object.getOwnPropertySymbols(this)) try {
              e3[t3] = this[t3];
            } catch {
              (0, i.shadow)(e3, t3, this[t3]);
            }
            e3[r.$uid] = `${e3[r.$nodeName]}${O++}`;
            e3[d] = [];
            for (const t3 of Object.getOwnPropertyNames(this)) {
              if (this[u].has(t3)) {
                e3[t3] = XFAObject[f](this[t3]);
                continue;
              }
              const a3 = this[t3];
              e3[t3] = a3 instanceof XFAObjectArray ? new XFAObjectArray(a3[S]) : null;
            }
            for (const t3 of this[d]) {
              const a3 = t3[r.$nodeName], n2 = t3[r.$clone]();
              e3[d].push(n2);
              n2[C] = e3;
              null === e3[a3] ? e3[a3] = n2 : e3[a3][d].push(n2);
            }
            return e3;
          }
          [r.$getChildren](e3 = null) {
            return e3 ? this[d].filter((t3) => t3[r.$nodeName] === e3) : this[d];
          }
          [r.$getChildrenByClass](e3) {
            return this[e3];
          }
          [r.$getChildrenByName](e3, t3, a3 = true) {
            return Array.from(this[r.$getChildrenByNameIt](e3, t3, a3));
          }
          *[r.$getChildrenByNameIt](e3, t3, a3 = true) {
            if ("parent" !== e3) {
              for (const a4 of this[d]) {
                a4[r.$nodeName] === e3 && (yield a4);
                a4.name === e3 && (yield a4);
                (t3 || a4[r.$isTransparent]()) && (yield* a4[r.$getChildrenByNameIt](e3, t3, false));
              }
              a3 && this[u].has(e3) && (yield new XFAAttribute(this, e3, this[e3]));
            } else yield this[C];
          }
        }
        t2.XFAObject = XFAObject;
        class XFAObjectArray {
          constructor(e3 = 1 / 0) {
            this[S] = e3;
            this[d] = [];
          }
          get isXFAObject() {
            return false;
          }
          get isXFAObjectArray() {
            return true;
          }
          push(e3) {
            if (this[d].length <= this[S]) {
              this[d].push(e3);
              return true;
            }
            (0, i.warn)(`XFA - node "${e3[r.$nodeName]}" accepts no more than ${this[S]} children`);
            return false;
          }
          isEmpty() {
            return 0 === this[d].length;
          }
          dump() {
            return 1 === this[d].length ? this[d][0][r.$dump]() : this[d].map((e3) => e3[r.$dump]());
          }
          [r.$clone]() {
            const e3 = new XFAObjectArray(this[S]);
            e3[d] = this[d].map((e4) => e4[r.$clone]());
            return e3;
          }
          get children() {
            return this[d];
          }
          clear() {
            this[d].length = 0;
          }
        }
        t2.XFAObjectArray = XFAObjectArray;
        class XFAAttribute {
          constructor(e3, t3, a3) {
            this[C] = e3;
            this[r.$nodeName] = t3;
            this[r.$content] = a3;
            this[r.$consumed] = false;
            this[r.$uid] = "attribute" + O++;
          }
          [r.$getParent]() {
            return this[C];
          }
          [r.$isDataValue]() {
            return true;
          }
          [r.$getDataValue]() {
            return this[r.$content].trim();
          }
          [r.$setValue](e3) {
            e3 = e3.value || "";
            this[r.$content] = e3.toString();
          }
          [r.$text]() {
            return this[r.$content];
          }
          [r.$isDescendent](e3) {
            return this[C] === e3 || this[C][r.$isDescendent](e3);
          }
        }
        t2.XFAAttribute = XFAAttribute;
        class XmlObject extends XFAObject {
          constructor(e3, t3, a3 = {}) {
            super(e3, t3);
            this[r.$content] = "";
            this[g] = null;
            if ("#text" !== t3) {
              const e4 = /* @__PURE__ */ new Map();
              this[h] = e4;
              for (const [t4, r2] of Object.entries(a3)) e4.set(t4, new XFAAttribute(this, t4, r2));
              if (a3.hasOwnProperty(r.$nsAttributes)) {
                const e5 = a3[r.$nsAttributes].xfa.dataNode;
                void 0 !== e5 && ("dataGroup" === e5 ? this[g] = false : "dataValue" === e5 && (this[g] = true));
              }
            }
            this[r.$consumed] = false;
          }
          [r.$toString](e3) {
            const t3 = this[r.$nodeName];
            if ("#text" === t3) {
              e3.push((0, s.encodeToXmlString)(this[r.$content]));
              return;
            }
            const a3 = (0, i.utf8StringToString)(t3), n2 = this[r.$namespaceId] === T ? "xfa:" : "";
            e3.push(`<${n2}${a3}`);
            for (const [t4, a4] of this[h].entries()) {
              const n3 = (0, i.utf8StringToString)(t4);
              e3.push(` ${n3}="${(0, s.encodeToXmlString)(a4[r.$content])}"`);
            }
            null !== this[g] && (this[g] ? e3.push(' xfa:dataNode="dataValue"') : e3.push(' xfa:dataNode="dataGroup"'));
            if (this[r.$content] || 0 !== this[d].length) {
              e3.push(">");
              if (this[r.$content]) "string" == typeof this[r.$content] ? e3.push((0, s.encodeToXmlString)(this[r.$content])) : this[r.$content][r.$toString](e3);
              else for (const t4 of this[d]) t4[r.$toString](e3);
              e3.push(`</${n2}${a3}>`);
            } else e3.push("/>");
          }
          [r.$onChild](e3) {
            if (this[r.$content]) {
              const e4 = new XmlObject(this[r.$namespaceId], "#text");
              this[r.$appendChild](e4);
              e4[r.$content] = this[r.$content];
              this[r.$content] = "";
            }
            this[r.$appendChild](e3);
            return true;
          }
          [r.$onText](e3) {
            this[r.$content] += e3;
          }
          [r.$finalize]() {
            if (this[r.$content] && this[d].length > 0) {
              const e3 = new XmlObject(this[r.$namespaceId], "#text");
              this[r.$appendChild](e3);
              e3[r.$content] = this[r.$content];
              delete this[r.$content];
            }
          }
          [r.$toHTML]() {
            return "#text" === this[r.$nodeName] ? n.HTMLResult.success({ name: "#text", value: this[r.$content] }) : n.HTMLResult.EMPTY;
          }
          [r.$getChildren](e3 = null) {
            return e3 ? this[d].filter((t3) => t3[r.$nodeName] === e3) : this[d];
          }
          [r.$getAttributes]() {
            return this[h];
          }
          [r.$getChildrenByClass](e3) {
            const t3 = this[h].get(e3);
            return void 0 !== t3 ? t3 : this[r.$getChildren](e3);
          }
          *[r.$getChildrenByNameIt](e3, t3) {
            const a3 = this[h].get(e3);
            a3 && (yield a3);
            for (const a4 of this[d]) {
              a4[r.$nodeName] === e3 && (yield a4);
              t3 && (yield* a4[r.$getChildrenByNameIt](e3, t3));
            }
          }
          *[r.$getAttributeIt](e3, t3) {
            const a3 = this[h].get(e3);
            !a3 || t3 && a3[r.$consumed] || (yield a3);
            for (const a4 of this[d]) yield* a4[r.$getAttributeIt](e3, t3);
          }
          *[r.$getRealChildrenByNameIt](e3, t3, a3) {
            for (const n2 of this[d]) {
              n2[r.$nodeName] !== e3 || a3 && n2[r.$consumed] || (yield n2);
              t3 && (yield* n2[r.$getRealChildrenByNameIt](e3, t3, a3));
            }
          }
          [r.$isDataValue]() {
            return null === this[g] ? 0 === this[d].length || this[d][0][r.$namespaceId] === o.NamespaceIds.xhtml.id : this[g];
          }
          [r.$getDataValue]() {
            return null === this[g] ? 0 === this[d].length ? this[r.$content].trim() : this[d][0][r.$namespaceId] === o.NamespaceIds.xhtml.id ? this[d][0][r.$text]().trim() : null : this[r.$content].trim();
          }
          [r.$setValue](e3) {
            e3 = e3.value || "";
            this[r.$content] = e3.toString();
          }
          [r.$dump](e3 = false) {
            const t3 = /* @__PURE__ */ Object.create(null);
            e3 && (t3.$ns = this[r.$namespaceId]);
            this[r.$content] && (t3.$content = this[r.$content]);
            t3.$name = this[r.$nodeName];
            t3.children = [];
            for (const a3 of this[d]) t3.children.push(a3[r.$dump](e3));
            t3.attributes = /* @__PURE__ */ Object.create(null);
            for (const [e4, a3] of this[h]) t3.attributes[e4] = a3[r.$content];
            return t3;
          }
        }
        t2.XmlObject = XmlObject;
        class ContentObject extends XFAObject {
          constructor(e3, t3) {
            super(e3, t3);
            this[r.$content] = "";
          }
          [r.$onText](e3) {
            this[r.$content] += e3;
          }
          [r.$finalize]() {
          }
        }
        t2.ContentObject = ContentObject;
        class OptionObject extends ContentObject {
          constructor(e3, t3, a3) {
            super(e3, t3);
            this[x] = a3;
          }
          [r.$finalize]() {
            this[r.$content] = (0, n.getKeyword)({ data: this[r.$content], defaultValue: this[x][0], validate: (e3) => this[x].includes(e3) });
          }
          [r.$clean](e3) {
            super[r.$clean](e3);
            delete this[x];
          }
        }
        t2.OptionObject = OptionObject;
        class StringObject extends ContentObject {
          [r.$finalize]() {
            this[r.$content] = this[r.$content].trim();
          }
        }
        t2.StringObject = StringObject;
        class IntegerObject extends ContentObject {
          constructor(e3, t3, a3, r2) {
            super(e3, t3);
            this[p] = a3;
            this[F] = r2;
          }
          [r.$finalize]() {
            this[r.$content] = (0, n.getInteger)({ data: this[r.$content], defaultValue: this[p], validate: this[F] });
          }
          [r.$clean](e3) {
            super[r.$clean](e3);
            delete this[p];
            delete this[F];
          }
        }
        t2.IntegerObject = IntegerObject;
        t2.Option01 = class Option01 extends IntegerObject {
          constructor(e3, t3) {
            super(e3, t3, 0, (e4) => 1 === e4);
          }
        };
        t2.Option10 = class Option10 extends IntegerObject {
          constructor(e3, t3) {
            super(e3, t3, 1, (e4) => 0 === e4);
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.createDataNode = function createDataNode(e3, t3, a3) {
          const i2 = parseExpression(a3);
          if (!i2) return null;
          if (i2.some((e4) => e4.operator === o.dotDot)) return null;
          const s2 = c.get(i2[0].name);
          let l2 = 0;
          if (s2) {
            e3 = s2(e3, t3);
            l2 = 1;
          } else e3 = t3 || e3;
          for (let t4 = i2.length; l2 < t4; l2++) {
            const { name: t5, operator: a4, index: s3 } = i2[l2];
            if (!isFinite(s3)) {
              i2[l2].index = 0;
              return e3.createNodes(i2.slice(l2));
            }
            let c2;
            switch (a4) {
              case o.dot:
                c2 = e3[r.$getChildrenByName](t5, false);
                break;
              case o.dotDot:
                c2 = e3[r.$getChildrenByName](t5, true);
                break;
              case o.dotHash:
                c2 = e3[r.$getChildrenByClass](t5);
                c2 = c2.isXFAObjectArray ? c2.children : [c2];
            }
            if (0 === c2.length) return e3.createNodes(i2.slice(l2));
            if (!(s3 < c2.length)) {
              i2[l2].index = s3 - c2.length;
              return e3.createNodes(i2.slice(l2));
            }
            {
              const t6 = c2[s3];
              if (!t6.isXFAObject) {
                (0, n.warn)("XFA - Cannot create a node.");
                return null;
              }
              e3 = t6;
            }
          }
          return null;
        };
        t2.searchNode = function searchNode(e3, t3, a3, n2 = true, i2 = true) {
          const s2 = parseExpression(a3, n2);
          if (!s2) return null;
          const h = c.get(s2[0].name);
          let u, d = 0;
          if (h) {
            u = true;
            e3 = [h(e3, t3)];
            d = 1;
          } else {
            u = null === t3;
            e3 = [t3 || e3];
          }
          for (let a4 = s2.length; d < a4; d++) {
            const { name: a5, cacheName: n3, operator: c2, index: h2 } = s2[d], f = [];
            for (const t4 of e3) {
              if (!t4.isXFAObject) continue;
              let e4, s3;
              if (i2) {
                s3 = l.get(t4);
                if (!s3) {
                  s3 = /* @__PURE__ */ new Map();
                  l.set(t4, s3);
                }
                e4 = s3.get(n3);
              }
              if (!e4) {
                switch (c2) {
                  case o.dot:
                    e4 = t4[r.$getChildrenByName](a5, false);
                    break;
                  case o.dotDot:
                    e4 = t4[r.$getChildrenByName](a5, true);
                    break;
                  case o.dotHash:
                    e4 = t4[r.$getChildrenByClass](a5);
                    e4 = e4.isXFAObjectArray ? e4.children : [e4];
                }
                i2 && s3.set(n3, e4);
              }
              e4.length > 0 && f.push(e4);
            }
            if (0 !== f.length || u || 0 !== d) e3 = isFinite(h2) ? f.filter((e4) => h2 < e4.length).map((e4) => e4[h2]) : f.flat();
            else {
              const a6 = t3[r.$getParent]();
              if (!(t3 = a6)) return null;
              d = -1;
              e3 = [t3];
            }
          }
          if (0 === e3.length) return null;
          return e3;
        };
        var r = a2(78), n = a2(2);
        const i = /^[^.[]+/, s = /^[^\]]+/, o = { dot: 0, dotDot: 1, dotHash: 2, dotBracket: 3, dotParen: 4 }, c = /* @__PURE__ */ new Map([["$data", (e3, t3) => e3.datasets ? e3.datasets.data : e3], ["$record", (e3, t3) => (e3.datasets ? e3.datasets.data : e3)[r.$getChildren]()[0]], ["$template", (e3, t3) => e3.template], ["$connectionSet", (e3, t3) => e3.connectionSet], ["$form", (e3, t3) => e3.form], ["$layout", (e3, t3) => e3.layout], ["$host", (e3, t3) => e3.host], ["$dataWindow", (e3, t3) => e3.dataWindow], ["$event", (e3, t3) => e3.event], ["!", (e3, t3) => e3.datasets], ["$xfa", (e3, t3) => e3], ["xfa", (e3, t3) => e3], ["$", (e3, t3) => t3]]), l = /* @__PURE__ */ new WeakMap();
        function parseExpression(e3, t3, a3 = true) {
          let r2 = e3.match(i);
          if (!r2) return null;
          let [c2] = r2;
          const l2 = [{ name: c2, cacheName: "." + c2, index: 0, js: null, formCalc: null, operator: o.dot }];
          let h = c2.length;
          for (; h < e3.length; ) {
            const d = h;
            if ("[" === e3.charAt(h++)) {
              r2 = e3.slice(h).match(s);
              if (!r2) {
                (0, n.warn)("XFA - Invalid index in SOM expression");
                return null;
              }
              l2.at(-1).index = "*" === (u = (u = r2[0]).trim()) ? 1 / 0 : parseInt(u, 10) || 0;
              h += r2[0].length + 1;
              continue;
            }
            let f;
            switch (e3.charAt(h)) {
              case ".":
                if (!t3) return null;
                h++;
                f = o.dotDot;
                break;
              case "#":
                h++;
                f = o.dotHash;
                break;
              case "[":
                if (a3) {
                  (0, n.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
                  return null;
                }
                f = o.dotBracket;
                break;
              case "(":
                if (a3) {
                  (0, n.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
                  return null;
                }
                f = o.dotParen;
                break;
              default:
                f = o.dot;
            }
            r2 = e3.slice(h).match(i);
            if (!r2) break;
            [c2] = r2;
            h += c2.length;
            l2.push({ name: c2, cacheName: e3.slice(d, h), operator: f, index: 0, js: null, formCalc: null });
          }
          var u;
          return l2;
        }
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DataHandler = void 0;
        var r = a2(78);
        t2.DataHandler = class DataHandler {
          constructor(e3, t3) {
            this.data = t3;
            this.dataset = e3.datasets || null;
          }
          serialize(e3) {
            const t3 = [[-1, this.data[r.$getChildren]()]];
            for (; t3.length > 0; ) {
              const a4 = t3.at(-1), [n, i] = a4;
              if (n + 1 === i.length) {
                t3.pop();
                continue;
              }
              const s = i[++a4[0]], o = e3.get(s[r.$uid]);
              if (o) s[r.$setValue](o);
              else {
                const t4 = s[r.$getAttributes]();
                for (const a5 of t4.values()) {
                  const t5 = e3.get(a5[r.$uid]);
                  if (t5) {
                    a5[r.$setValue](t5);
                    break;
                  }
                }
              }
              const c = s[r.$getChildren]();
              c.length > 0 && t3.push([-1, c]);
            }
            const a3 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
            if (this.dataset) for (const e4 of this.dataset[r.$getChildren]()) "data" !== e4[r.$nodeName] && e4[r.$toString](a3);
            this.data[r.$toString](a3);
            a3.push("</xfa:datasets>");
            return a3.join("");
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XFAParser = void 0;
        var r = a2(78), n = a2(71), i = a2(91), s = a2(2);
        class XFAParser extends n.XMLParserBase {
          constructor(e3 = null, t3 = false) {
            super();
            this._builder = new i.Builder(e3);
            this._stack = [];
            this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() };
            this._ids = /* @__PURE__ */ new Map();
            this._current = this._builder.buildRoot(this._ids);
            this._errorCode = n.XMLParserErrorCode.NoError;
            this._whiteRegex = /^\s+$/;
            this._nbsps = /\xa0+/g;
            this._richText = t3;
          }
          parse(e3) {
            this.parseXml(e3);
            if (this._errorCode === n.XMLParserErrorCode.NoError) {
              this._current[r.$finalize]();
              return this._current.element;
            }
          }
          onText(e3) {
            e3 = e3.replace(this._nbsps, (e4) => e4.slice(1) + " ");
            this._richText || this._current[r.$acceptWhitespace]() ? this._current[r.$onText](e3, this._richText) : this._whiteRegex.test(e3) || this._current[r.$onText](e3.trim());
          }
          onCdata(e3) {
            this._current[r.$onText](e3);
          }
          _mkAttributes(e3, t3) {
            let a3 = null, n2 = null;
            const i2 = /* @__PURE__ */ Object.create({});
            for (const { name: o, value: c } of e3) if ("xmlns" === o) a3 ? (0, s.warn)(`XFA - multiple namespace definition in <${t3}>`) : a3 = c;
            else if (o.startsWith("xmlns:")) {
              const e4 = o.substring(6);
              n2 || (n2 = []);
              n2.push({ prefix: e4, value: c });
            } else {
              const e4 = o.indexOf(":");
              if (-1 === e4) i2[o] = c;
              else {
                let t4 = i2[r.$nsAttributes];
                t4 || (t4 = i2[r.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                const [a4, n3] = [o.slice(0, e4), o.slice(e4 + 1)];
                (t4[a4] || (t4[a4] = /* @__PURE__ */ Object.create(null)))[n3] = c;
              }
            }
            return [a3, n2, i2];
          }
          _getNameAndPrefix(e3, t3) {
            const a3 = e3.indexOf(":");
            return -1 === a3 ? [e3, null] : [e3.substring(a3 + 1), t3 ? "" : e3.substring(0, a3)];
          }
          onBeginElement(e3, t3, a3) {
            const [n2, i2, s2] = this._mkAttributes(t3, e3), [o, c] = this._getNameAndPrefix(e3, this._builder.isNsAgnostic()), l = this._builder.build({ nsPrefix: c, name: o, attributes: s2, namespace: n2, prefixes: i2 });
            l[r.$globalData] = this._globalData;
            if (a3) {
              l[r.$finalize]();
              this._current[r.$onChild](l) && l[r.$setId](this._ids);
              l[r.$clean](this._builder);
            } else {
              this._stack.push(this._current);
              this._current = l;
            }
          }
          onEndElement(e3) {
            const t3 = this._current;
            if (t3[r.$isCDATAXml]() && "string" == typeof t3[r.$content]) {
              const e4 = new XFAParser();
              e4._globalData = this._globalData;
              const a3 = e4.parse(t3[r.$content]);
              t3[r.$content] = null;
              t3[r.$onChild](a3);
            }
            t3[r.$finalize]();
            this._current = this._stack.pop();
            this._current[r.$onChild](t3) && t3[r.$setId](this._ids);
            t3[r.$clean](this._builder);
          }
          onError(e3) {
            this._errorCode = e3;
          }
        }
        t2.XFAParser = XFAParser;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.Builder = void 0;
        var r = a2(81), n = a2(78), i = a2(92), s = a2(80), o = a2(101), c = a2(2), l = a2(87);
        class Root extends l.XFAObject {
          constructor(e3) {
            super(-1, "root", /* @__PURE__ */ Object.create(null));
            this.element = null;
            this[n.$ids] = e3;
          }
          [n.$onChild](e3) {
            this.element = e3;
            return true;
          }
          [n.$finalize]() {
            super[n.$finalize]();
            if (this.element.template instanceof s.Template) {
              this[n.$ids].set(n.$root, this.element);
              this.element.template[n.$resolvePrototypes](this[n.$ids]);
              this.element.template[n.$ids] = this[n.$ids];
            }
          }
        }
        class Empty extends l.XFAObject {
          constructor() {
            super(-1, "", /* @__PURE__ */ Object.create(null));
          }
          [n.$onChild](e3) {
            return false;
          }
        }
        t2.Builder = class Builder {
          constructor(e3 = null) {
            this._namespaceStack = [];
            this._nsAgnosticLevel = 0;
            this._namespacePrefixes = /* @__PURE__ */ new Map();
            this._namespaces = /* @__PURE__ */ new Map();
            this._nextNsId = Math.max(...Object.values(r.NamespaceIds).map(({ id: e4 }) => e4));
            this._currentNamespace = e3 || new o.UnknownNamespace(++this._nextNsId);
          }
          buildRoot(e3) {
            return new Root(e3);
          }
          build({ nsPrefix: e3, name: t3, attributes: a3, namespace: s2, prefixes: o2 }) {
            const c2 = null !== s2;
            if (c2) {
              this._namespaceStack.push(this._currentNamespace);
              this._currentNamespace = this._searchNamespace(s2);
            }
            o2 && this._addNamespacePrefix(o2);
            if (a3.hasOwnProperty(n.$nsAttributes)) {
              const e4 = i.NamespaceSetUp.datasets, t4 = a3[n.$nsAttributes];
              let r2 = null;
              for (const [a4, n2] of Object.entries(t4)) {
                if (this._getNamespaceToUse(a4) === e4) {
                  r2 = { xfa: n2 };
                  break;
                }
              }
              r2 ? a3[n.$nsAttributes] = r2 : delete a3[n.$nsAttributes];
            }
            const l2 = this._getNamespaceToUse(e3), h = (l2 == null ? void 0 : l2[r.$buildXFAObject](t3, a3)) || new Empty();
            h[n.$isNsAgnostic]() && this._nsAgnosticLevel++;
            (c2 || o2 || h[n.$isNsAgnostic]()) && (h[n.$cleanup] = { hasNamespace: c2, prefixes: o2, nsAgnostic: h[n.$isNsAgnostic]() });
            return h;
          }
          isNsAgnostic() {
            return this._nsAgnosticLevel > 0;
          }
          _searchNamespace(e3) {
            let t3 = this._namespaces.get(e3);
            if (t3) return t3;
            for (const [a3, { check: n2 }] of Object.entries(r.NamespaceIds)) if (n2(e3)) {
              t3 = i.NamespaceSetUp[a3];
              if (t3) {
                this._namespaces.set(e3, t3);
                return t3;
              }
              break;
            }
            t3 = new o.UnknownNamespace(++this._nextNsId);
            this._namespaces.set(e3, t3);
            return t3;
          }
          _addNamespacePrefix(e3) {
            for (const { prefix: t3, value: a3 } of e3) {
              const e4 = this._searchNamespace(a3);
              let r2 = this._namespacePrefixes.get(t3);
              if (!r2) {
                r2 = [];
                this._namespacePrefixes.set(t3, r2);
              }
              r2.push(e4);
            }
          }
          _getNamespaceToUse(e3) {
            if (!e3) return this._currentNamespace;
            const t3 = this._namespacePrefixes.get(e3);
            if ((t3 == null ? void 0 : t3.length) > 0) return t3.at(-1);
            (0, c.warn)(`Unknown namespace prefix: ${e3}.`);
            return null;
          }
          clean(e3) {
            const { hasNamespace: t3, prefixes: a3, nsAgnostic: r2 } = e3;
            t3 && (this._currentNamespace = this._namespaceStack.pop());
            a3 && a3.forEach(({ prefix: e4 }) => {
              this._namespacePrefixes.get(e4).pop();
            });
            r2 && this._nsAgnosticLevel--;
          }
        };
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NamespaceSetUp = void 0;
        var r = a2(93), n = a2(94), i = a2(95), s = a2(96), o = a2(97), c = a2(98), l = a2(80), h = a2(99), u = a2(100);
        const d = { config: r.ConfigNamespace, connection: n.ConnectionSetNamespace, datasets: i.DatasetsNamespace, localeSet: s.LocaleSetNamespace, signature: o.SignatureNamespace, stylesheet: c.StylesheetNamespace, template: l.TemplateNamespace, xdp: h.XdpNamespace, xhtml: u.XhtmlNamespace };
        t2.NamespaceSetUp = d;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ConfigNamespace = void 0;
        var r = a2(81), n = a2(78), i = a2(87), s = a2(84), o = a2(2);
        const c = r.NamespaceIds.config.id;
        class Acrobat extends i.XFAObject {
          constructor(e3) {
            super(c, "acrobat", true);
            this.acrobat7 = null;
            this.autoSave = null;
            this.common = null;
            this.validate = null;
            this.validateApprovalSignatures = null;
            this.submitUrl = new i.XFAObjectArray();
          }
        }
        class Acrobat7 extends i.XFAObject {
          constructor(e3) {
            super(c, "acrobat7", true);
            this.dynamicRender = null;
          }
        }
        class ADBE_JSConsole extends i.OptionObject {
          constructor(e3) {
            super(c, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
          }
        }
        class ADBE_JSDebugger extends i.OptionObject {
          constructor(e3) {
            super(c, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
          }
        }
        class AddSilentPrint extends i.Option01 {
          constructor(e3) {
            super(c, "addSilentPrint");
          }
        }
        class AddViewerPreferences extends i.Option01 {
          constructor(e3) {
            super(c, "addViewerPreferences");
          }
        }
        class AdjustData extends i.Option10 {
          constructor(e3) {
            super(c, "adjustData");
          }
        }
        class AdobeExtensionLevel extends i.IntegerObject {
          constructor(e3) {
            super(c, "adobeExtensionLevel", 0, (e4) => e4 >= 1 && e4 <= 8);
          }
        }
        class Agent extends i.XFAObject {
          constructor(e3) {
            super(c, "agent", true);
            this.name = e3.name ? e3.name.trim() : "";
            this.common = new i.XFAObjectArray();
          }
        }
        class AlwaysEmbed extends i.ContentObject {
          constructor(e3) {
            super(c, "alwaysEmbed");
          }
        }
        class Amd extends i.StringObject {
          constructor(e3) {
            super(c, "amd");
          }
        }
        class Area extends i.XFAObject {
          constructor(e3) {
            super(c, "area");
            this.level = (0, s.getInteger)({ data: e3.level, defaultValue: 0, validate: (e4) => e4 >= 1 && e4 <= 3 });
            this.name = (0, s.getStringOption)(e3.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
          }
        }
        class Attributes extends i.OptionObject {
          constructor(e3) {
            super(c, "attributes", ["preserve", "delegate", "ignore"]);
          }
        }
        class AutoSave extends i.OptionObject {
          constructor(e3) {
            super(c, "autoSave", ["disabled", "enabled"]);
          }
        }
        class Base extends i.StringObject {
          constructor(e3) {
            super(c, "base");
          }
        }
        class BatchOutput extends i.XFAObject {
          constructor(e3) {
            super(c, "batchOutput");
            this.format = (0, s.getStringOption)(e3.format, ["none", "concat", "zip", "zipCompress"]);
          }
        }
        class BehaviorOverride extends i.ContentObject {
          constructor(e3) {
            super(c, "behaviorOverride");
          }
          [n.$finalize]() {
            this[n.$content] = new Map(this[n.$content].trim().split(/\s+/).filter((e3) => e3.includes(":")).map((e3) => e3.split(":", 2)));
          }
        }
        class Cache extends i.XFAObject {
          constructor(e3) {
            super(c, "cache", true);
            this.templateCache = null;
          }
        }
        class Change extends i.Option01 {
          constructor(e3) {
            super(c, "change");
          }
        }
        class Common extends i.XFAObject {
          constructor(e3) {
            super(c, "common", true);
            this.data = null;
            this.locale = null;
            this.localeSet = null;
            this.messaging = null;
            this.suppressBanner = null;
            this.template = null;
            this.validationMessaging = null;
            this.versionControl = null;
            this.log = new i.XFAObjectArray();
          }
        }
        class Compress extends i.XFAObject {
          constructor(e3) {
            super(c, "compress");
            this.scope = (0, s.getStringOption)(e3.scope, ["imageOnly", "document"]);
          }
        }
        class CompressLogicalStructure extends i.Option01 {
          constructor(e3) {
            super(c, "compressLogicalStructure");
          }
        }
        class CompressObjectStream extends i.Option10 {
          constructor(e3) {
            super(c, "compressObjectStream");
          }
        }
        class Compression extends i.XFAObject {
          constructor(e3) {
            super(c, "compression", true);
            this.compressLogicalStructure = null;
            this.compressObjectStream = null;
            this.level = null;
            this.type = null;
          }
        }
        class Config extends i.XFAObject {
          constructor(e3) {
            super(c, "config", true);
            this.acrobat = null;
            this.present = null;
            this.trace = null;
            this.agent = new i.XFAObjectArray();
          }
        }
        class Conformance extends i.OptionObject {
          constructor(e3) {
            super(c, "conformance", ["A", "B"]);
          }
        }
        class ContentCopy extends i.Option01 {
          constructor(e3) {
            super(c, "contentCopy");
          }
        }
        class Copies extends i.IntegerObject {
          constructor(e3) {
            super(c, "copies", 1, (e4) => e4 >= 1);
          }
        }
        class Creator extends i.StringObject {
          constructor(e3) {
            super(c, "creator");
          }
        }
        class CurrentPage extends i.IntegerObject {
          constructor(e3) {
            super(c, "currentPage", 0, (e4) => e4 >= 0);
          }
        }
        class Data extends i.XFAObject {
          constructor(e3) {
            super(c, "data", true);
            this.adjustData = null;
            this.attributes = null;
            this.incrementalLoad = null;
            this.outputXSL = null;
            this.range = null;
            this.record = null;
            this.startNode = null;
            this.uri = null;
            this.window = null;
            this.xsl = null;
            this.excludeNS = new i.XFAObjectArray();
            this.transform = new i.XFAObjectArray();
          }
        }
        class Debug extends i.XFAObject {
          constructor(e3) {
            super(c, "debug", true);
            this.uri = null;
          }
        }
        class DefaultTypeface extends i.ContentObject {
          constructor(e3) {
            super(c, "defaultTypeface");
            this.writingScript = (0, s.getStringOption)(e3.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
          }
        }
        class Destination extends i.OptionObject {
          constructor(e3) {
            super(c, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
          }
        }
        class DocumentAssembly extends i.Option01 {
          constructor(e3) {
            super(c, "documentAssembly");
          }
        }
        class Driver extends i.XFAObject {
          constructor(e3) {
            super(c, "driver", true);
            this.name = e3.name ? e3.name.trim() : "";
            this.fontInfo = null;
            this.xdc = null;
          }
        }
        class DuplexOption extends i.OptionObject {
          constructor(e3) {
            super(c, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
          }
        }
        class DynamicRender extends i.OptionObject {
          constructor(e3) {
            super(c, "dynamicRender", ["forbidden", "required"]);
          }
        }
        class Embed extends i.Option01 {
          constructor(e3) {
            super(c, "embed");
          }
        }
        class Encrypt extends i.Option01 {
          constructor(e3) {
            super(c, "encrypt");
          }
        }
        class Encryption extends i.XFAObject {
          constructor(e3) {
            super(c, "encryption", true);
            this.encrypt = null;
            this.encryptionLevel = null;
            this.permissions = null;
          }
        }
        class EncryptionLevel extends i.OptionObject {
          constructor(e3) {
            super(c, "encryptionLevel", ["40bit", "128bit"]);
          }
        }
        class Enforce extends i.StringObject {
          constructor(e3) {
            super(c, "enforce");
          }
        }
        class Equate extends i.XFAObject {
          constructor(e3) {
            super(c, "equate");
            this.force = (0, s.getInteger)({ data: e3.force, defaultValue: 1, validate: (e4) => 0 === e4 });
            this.from = e3.from || "";
            this.to = e3.to || "";
          }
        }
        class EquateRange extends i.XFAObject {
          constructor(e3) {
            super(c, "equateRange");
            this.from = e3.from || "";
            this.to = e3.to || "";
            this._unicodeRange = e3.unicodeRange || "";
          }
          get unicodeRange() {
            const e3 = [], t3 = /U\+([0-9a-fA-F]+)/, a3 = this._unicodeRange;
            for (let r2 of a3.split(",").map((e4) => e4.trim()).filter((e4) => !!e4)) {
              r2 = r2.split("-", 2).map((e4) => {
                const a4 = e4.match(t3);
                return a4 ? parseInt(a4[1], 16) : 0;
              });
              1 === r2.length && r2.push(r2[0]);
              e3.push(r2);
            }
            return (0, o.shadow)(this, "unicodeRange", e3);
          }
        }
        class Exclude extends i.ContentObject {
          constructor(e3) {
            super(c, "exclude");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim().split(/\s+/).filter((e3) => e3 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e3));
          }
        }
        class ExcludeNS extends i.StringObject {
          constructor(e3) {
            super(c, "excludeNS");
          }
        }
        class FlipLabel extends i.OptionObject {
          constructor(e3) {
            super(c, "flipLabel", ["usePrinterSetting", "on", "off"]);
          }
        }
        class FontInfo extends i.XFAObject {
          constructor(e3) {
            super(c, "fontInfo", true);
            this.embed = null;
            this.map = null;
            this.subsetBelow = null;
            this.alwaysEmbed = new i.XFAObjectArray();
            this.defaultTypeface = new i.XFAObjectArray();
            this.neverEmbed = new i.XFAObjectArray();
          }
        }
        class FormFieldFilling extends i.Option01 {
          constructor(e3) {
            super(c, "formFieldFilling");
          }
        }
        class GroupParent extends i.StringObject {
          constructor(e3) {
            super(c, "groupParent");
          }
        }
        class IfEmpty extends i.OptionObject {
          constructor(e3) {
            super(c, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
          }
        }
        class IncludeXDPContent extends i.StringObject {
          constructor(e3) {
            super(c, "includeXDPContent");
          }
        }
        class IncrementalLoad extends i.OptionObject {
          constructor(e3) {
            super(c, "incrementalLoad", ["none", "forwardOnly"]);
          }
        }
        class IncrementalMerge extends i.Option01 {
          constructor(e3) {
            super(c, "incrementalMerge");
          }
        }
        class Interactive extends i.Option01 {
          constructor(e3) {
            super(c, "interactive");
          }
        }
        class Jog extends i.OptionObject {
          constructor(e3) {
            super(c, "jog", ["usePrinterSetting", "none", "pageSet"]);
          }
        }
        class LabelPrinter extends i.XFAObject {
          constructor(e3) {
            super(c, "labelPrinter", true);
            this.name = (0, s.getStringOption)(e3.name, ["zpl", "dpl", "ipl", "tcpl"]);
            this.batchOutput = null;
            this.flipLabel = null;
            this.fontInfo = null;
            this.xdc = null;
          }
        }
        class Layout extends i.OptionObject {
          constructor(e3) {
            super(c, "layout", ["paginate", "panel"]);
          }
        }
        class Level extends i.IntegerObject {
          constructor(e3) {
            super(c, "level", 0, (e4) => e4 > 0);
          }
        }
        class Linearized extends i.Option01 {
          constructor(e3) {
            super(c, "linearized");
          }
        }
        class Locale extends i.StringObject {
          constructor(e3) {
            super(c, "locale");
          }
        }
        class LocaleSet extends i.StringObject {
          constructor(e3) {
            super(c, "localeSet");
          }
        }
        class Log extends i.XFAObject {
          constructor(e3) {
            super(c, "log", true);
            this.mode = null;
            this.threshold = null;
            this.to = null;
            this.uri = null;
          }
        }
        class MapElement extends i.XFAObject {
          constructor(e3) {
            super(c, "map", true);
            this.equate = new i.XFAObjectArray();
            this.equateRange = new i.XFAObjectArray();
          }
        }
        class MediumInfo extends i.XFAObject {
          constructor(e3) {
            super(c, "mediumInfo", true);
            this.map = null;
          }
        }
        class Message extends i.XFAObject {
          constructor(e3) {
            super(c, "message", true);
            this.msgId = null;
            this.severity = null;
          }
        }
        class Messaging extends i.XFAObject {
          constructor(e3) {
            super(c, "messaging", true);
            this.message = new i.XFAObjectArray();
          }
        }
        class Mode extends i.OptionObject {
          constructor(e3) {
            super(c, "mode", ["append", "overwrite"]);
          }
        }
        class ModifyAnnots extends i.Option01 {
          constructor(e3) {
            super(c, "modifyAnnots");
          }
        }
        class MsgId extends i.IntegerObject {
          constructor(e3) {
            super(c, "msgId", 1, (e4) => e4 >= 1);
          }
        }
        class NameAttr extends i.StringObject {
          constructor(e3) {
            super(c, "nameAttr");
          }
        }
        class NeverEmbed extends i.ContentObject {
          constructor(e3) {
            super(c, "neverEmbed");
          }
        }
        class NumberOfCopies extends i.IntegerObject {
          constructor(e3) {
            super(c, "numberOfCopies", null, (e4) => e4 >= 2 && e4 <= 5);
          }
        }
        class OpenAction extends i.XFAObject {
          constructor(e3) {
            super(c, "openAction", true);
            this.destination = null;
          }
        }
        class Output extends i.XFAObject {
          constructor(e3) {
            super(c, "output", true);
            this.to = null;
            this.type = null;
            this.uri = null;
          }
        }
        class OutputBin extends i.StringObject {
          constructor(e3) {
            super(c, "outputBin");
          }
        }
        class OutputXSL extends i.XFAObject {
          constructor(e3) {
            super(c, "outputXSL", true);
            this.uri = null;
          }
        }
        class Overprint extends i.OptionObject {
          constructor(e3) {
            super(c, "overprint", ["none", "both", "draw", "field"]);
          }
        }
        class Packets extends i.StringObject {
          constructor(e3) {
            super(c, "packets");
          }
          [n.$finalize]() {
            "*" !== this[n.$content] && (this[n.$content] = this[n.$content].trim().split(/\s+/).filter((e3) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e3)));
          }
        }
        class PageOffset extends i.XFAObject {
          constructor(e3) {
            super(c, "pageOffset");
            this.x = (0, s.getInteger)({ data: e3.x, defaultValue: "useXDCSetting", validate: (e4) => true });
            this.y = (0, s.getInteger)({ data: e3.y, defaultValue: "useXDCSetting", validate: (e4) => true });
          }
        }
        class PageRange extends i.StringObject {
          constructor(e3) {
            super(c, "pageRange");
          }
          [n.$finalize]() {
            const e3 = this[n.$content].trim().split(/\s+/).map((e4) => parseInt(e4, 10)), t3 = [];
            for (let a3 = 0, r2 = e3.length; a3 < r2; a3 += 2) t3.push(e3.slice(a3, a3 + 2));
            this[n.$content] = t3;
          }
        }
        class Pagination extends i.OptionObject {
          constructor(e3) {
            super(c, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
          }
        }
        class PaginationOverride extends i.OptionObject {
          constructor(e3) {
            super(c, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
          }
        }
        class Part extends i.IntegerObject {
          constructor(e3) {
            super(c, "part", 1, (e4) => false);
          }
        }
        class Pcl extends i.XFAObject {
          constructor(e3) {
            super(c, "pcl", true);
            this.name = e3.name || "";
            this.batchOutput = null;
            this.fontInfo = null;
            this.jog = null;
            this.mediumInfo = null;
            this.outputBin = null;
            this.pageOffset = null;
            this.staple = null;
            this.xdc = null;
          }
        }
        class Pdf extends i.XFAObject {
          constructor(e3) {
            super(c, "pdf", true);
            this.name = e3.name || "";
            this.adobeExtensionLevel = null;
            this.batchOutput = null;
            this.compression = null;
            this.creator = null;
            this.encryption = null;
            this.fontInfo = null;
            this.interactive = null;
            this.linearized = null;
            this.openAction = null;
            this.pdfa = null;
            this.producer = null;
            this.renderPolicy = null;
            this.scriptModel = null;
            this.silentPrint = null;
            this.submitFormat = null;
            this.tagged = null;
            this.version = null;
            this.viewerPreferences = null;
            this.xdc = null;
          }
        }
        class Pdfa extends i.XFAObject {
          constructor(e3) {
            super(c, "pdfa", true);
            this.amd = null;
            this.conformance = null;
            this.includeXDPContent = null;
            this.part = null;
          }
        }
        class Permissions extends i.XFAObject {
          constructor(e3) {
            super(c, "permissions", true);
            this.accessibleContent = null;
            this.change = null;
            this.contentCopy = null;
            this.documentAssembly = null;
            this.formFieldFilling = null;
            this.modifyAnnots = null;
            this.plaintextMetadata = null;
            this.print = null;
            this.printHighQuality = null;
          }
        }
        class PickTrayByPDFSize extends i.Option01 {
          constructor(e3) {
            super(c, "pickTrayByPDFSize");
          }
        }
        class Picture extends i.StringObject {
          constructor(e3) {
            super(c, "picture");
          }
        }
        class PlaintextMetadata extends i.Option01 {
          constructor(e3) {
            super(c, "plaintextMetadata");
          }
        }
        class Presence extends i.OptionObject {
          constructor(e3) {
            super(c, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
          }
        }
        class Present extends i.XFAObject {
          constructor(e3) {
            super(c, "present", true);
            this.behaviorOverride = null;
            this.cache = null;
            this.common = null;
            this.copies = null;
            this.destination = null;
            this.incrementalMerge = null;
            this.layout = null;
            this.output = null;
            this.overprint = null;
            this.pagination = null;
            this.paginationOverride = null;
            this.script = null;
            this.validate = null;
            this.xdp = null;
            this.driver = new i.XFAObjectArray();
            this.labelPrinter = new i.XFAObjectArray();
            this.pcl = new i.XFAObjectArray();
            this.pdf = new i.XFAObjectArray();
            this.ps = new i.XFAObjectArray();
            this.submitUrl = new i.XFAObjectArray();
            this.webClient = new i.XFAObjectArray();
            this.zpl = new i.XFAObjectArray();
          }
        }
        class Print extends i.Option01 {
          constructor(e3) {
            super(c, "print");
          }
        }
        class PrintHighQuality extends i.Option01 {
          constructor(e3) {
            super(c, "printHighQuality");
          }
        }
        class PrintScaling extends i.OptionObject {
          constructor(e3) {
            super(c, "printScaling", ["appdefault", "noScaling"]);
          }
        }
        class PrinterName extends i.StringObject {
          constructor(e3) {
            super(c, "printerName");
          }
        }
        class Producer extends i.StringObject {
          constructor(e3) {
            super(c, "producer");
          }
        }
        class Ps extends i.XFAObject {
          constructor(e3) {
            super(c, "ps", true);
            this.name = e3.name || "";
            this.batchOutput = null;
            this.fontInfo = null;
            this.jog = null;
            this.mediumInfo = null;
            this.outputBin = null;
            this.staple = null;
            this.xdc = null;
          }
        }
        class Range extends i.ContentObject {
          constructor(e3) {
            super(c, "range");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim().split(/\s*,\s*/, 2).map((e3) => e3.split("-").map((e4) => parseInt(e4.trim(), 10))).filter((e3) => e3.every((e4) => !isNaN(e4))).map((e3) => {
              1 === e3.length && e3.push(e3[0]);
              return e3;
            });
          }
        }
        class Record extends i.ContentObject {
          constructor(e3) {
            super(c, "record");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim();
            const e3 = parseInt(this[n.$content], 10);
            !isNaN(e3) && e3 >= 0 && (this[n.$content] = e3);
          }
        }
        class Relevant extends i.ContentObject {
          constructor(e3) {
            super(c, "relevant");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim().split(/\s+/);
          }
        }
        class Rename extends i.ContentObject {
          constructor(e3) {
            super(c, "rename");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim();
            (this[n.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[n.$content])) && (0, o.warn)("XFA - Rename: invalid XFA name");
          }
        }
        class RenderPolicy extends i.OptionObject {
          constructor(e3) {
            super(c, "renderPolicy", ["server", "client"]);
          }
        }
        class RunScripts extends i.OptionObject {
          constructor(e3) {
            super(c, "runScripts", ["both", "client", "none", "server"]);
          }
        }
        class Script extends i.XFAObject {
          constructor(e3) {
            super(c, "script", true);
            this.currentPage = null;
            this.exclude = null;
            this.runScripts = null;
          }
        }
        class ScriptModel extends i.OptionObject {
          constructor(e3) {
            super(c, "scriptModel", ["XFA", "none"]);
          }
        }
        class Severity extends i.OptionObject {
          constructor(e3) {
            super(c, "severity", ["ignore", "error", "information", "trace", "warning"]);
          }
        }
        class SilentPrint extends i.XFAObject {
          constructor(e3) {
            super(c, "silentPrint", true);
            this.addSilentPrint = null;
            this.printerName = null;
          }
        }
        class Staple extends i.XFAObject {
          constructor(e3) {
            super(c, "staple");
            this.mode = (0, s.getStringOption)(e3.mode, ["usePrinterSetting", "on", "off"]);
          }
        }
        class StartNode extends i.StringObject {
          constructor(e3) {
            super(c, "startNode");
          }
        }
        class StartPage extends i.IntegerObject {
          constructor(e3) {
            super(c, "startPage", 0, (e4) => true);
          }
        }
        class SubmitFormat extends i.OptionObject {
          constructor(e3) {
            super(c, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
          }
        }
        class SubmitUrl extends i.StringObject {
          constructor(e3) {
            super(c, "submitUrl");
          }
        }
        class SubsetBelow extends i.IntegerObject {
          constructor(e3) {
            super(c, "subsetBelow", 100, (e4) => e4 >= 0 && e4 <= 100);
          }
        }
        class SuppressBanner extends i.Option01 {
          constructor(e3) {
            super(c, "suppressBanner");
          }
        }
        class Tagged extends i.Option01 {
          constructor(e3) {
            super(c, "tagged");
          }
        }
        class Template extends i.XFAObject {
          constructor(e3) {
            super(c, "template", true);
            this.base = null;
            this.relevant = null;
            this.startPage = null;
            this.uri = null;
            this.xsl = null;
          }
        }
        class Threshold extends i.OptionObject {
          constructor(e3) {
            super(c, "threshold", ["trace", "error", "information", "warning"]);
          }
        }
        class To extends i.OptionObject {
          constructor(e3) {
            super(c, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
          }
        }
        class TemplateCache extends i.XFAObject {
          constructor(e3) {
            super(c, "templateCache");
            this.maxEntries = (0, s.getInteger)({ data: e3.maxEntries, defaultValue: 5, validate: (e4) => e4 >= 0 });
          }
        }
        class Trace extends i.XFAObject {
          constructor(e3) {
            super(c, "trace", true);
            this.area = new i.XFAObjectArray();
          }
        }
        class Transform extends i.XFAObject {
          constructor(e3) {
            super(c, "transform", true);
            this.groupParent = null;
            this.ifEmpty = null;
            this.nameAttr = null;
            this.picture = null;
            this.presence = null;
            this.rename = null;
            this.whitespace = null;
          }
        }
        class Type extends i.OptionObject {
          constructor(e3) {
            super(c, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
          }
        }
        class Uri extends i.StringObject {
          constructor(e3) {
            super(c, "uri");
          }
        }
        class Validate extends i.OptionObject {
          constructor(e3) {
            super(c, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
          }
        }
        class ValidateApprovalSignatures extends i.ContentObject {
          constructor(e3) {
            super(c, "validateApprovalSignatures");
          }
          [n.$finalize]() {
            this[n.$content] = this[n.$content].trim().split(/\s+/).filter((e3) => ["docReady", "postSign"].includes(e3));
          }
        }
        class ValidationMessaging extends i.OptionObject {
          constructor(e3) {
            super(c, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
          }
        }
        class Version extends i.OptionObject {
          constructor(e3) {
            super(c, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
          }
        }
        class VersionControl extends i.XFAObject {
          constructor(e3) {
            super(c, "VersionControl");
            this.outputBelow = (0, s.getStringOption)(e3.outputBelow, ["warn", "error", "update"]);
            this.sourceAbove = (0, s.getStringOption)(e3.sourceAbove, ["warn", "error"]);
            this.sourceBelow = (0, s.getStringOption)(e3.sourceBelow, ["update", "maintain"]);
          }
        }
        class ViewerPreferences extends i.XFAObject {
          constructor(e3) {
            super(c, "viewerPreferences", true);
            this.ADBE_JSConsole = null;
            this.ADBE_JSDebugger = null;
            this.addViewerPreferences = null;
            this.duplexOption = null;
            this.enforce = null;
            this.numberOfCopies = null;
            this.pageRange = null;
            this.pickTrayByPDFSize = null;
            this.printScaling = null;
          }
        }
        class WebClient extends i.XFAObject {
          constructor(e3) {
            super(c, "webClient", true);
            this.name = e3.name ? e3.name.trim() : "";
            this.fontInfo = null;
            this.xdc = null;
          }
        }
        class Whitespace extends i.OptionObject {
          constructor(e3) {
            super(c, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
          }
        }
        class Window extends i.ContentObject {
          constructor(e3) {
            super(c, "window");
          }
          [n.$finalize]() {
            const e3 = this[n.$content].trim().split(/\s*,\s*/, 2).map((e4) => parseInt(e4, 10));
            if (e3.some((e4) => isNaN(e4))) this[n.$content] = [0, 0];
            else {
              1 === e3.length && e3.push(e3[0]);
              this[n.$content] = e3;
            }
          }
        }
        class Xdc extends i.XFAObject {
          constructor(e3) {
            super(c, "xdc", true);
            this.uri = new i.XFAObjectArray();
            this.xsl = new i.XFAObjectArray();
          }
        }
        class Xdp extends i.XFAObject {
          constructor(e3) {
            super(c, "xdp", true);
            this.packets = null;
          }
        }
        class Xsl extends i.XFAObject {
          constructor(e3) {
            super(c, "xsl", true);
            this.debug = null;
            this.uri = null;
          }
        }
        class Zpl extends i.XFAObject {
          constructor(e3) {
            super(c, "zpl", true);
            this.name = e3.name ? e3.name.trim() : "";
            this.batchOutput = null;
            this.flipLabel = null;
            this.fontInfo = null;
            this.xdc = null;
          }
        }
        class ConfigNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (ConfigNamespace.hasOwnProperty(e3)) return ConfigNamespace[e3](t3);
          }
          static acrobat(e3) {
            return new Acrobat(e3);
          }
          static acrobat7(e3) {
            return new Acrobat7(e3);
          }
          static ADBE_JSConsole(e3) {
            return new ADBE_JSConsole(e3);
          }
          static ADBE_JSDebugger(e3) {
            return new ADBE_JSDebugger(e3);
          }
          static addSilentPrint(e3) {
            return new AddSilentPrint(e3);
          }
          static addViewerPreferences(e3) {
            return new AddViewerPreferences(e3);
          }
          static adjustData(e3) {
            return new AdjustData(e3);
          }
          static adobeExtensionLevel(e3) {
            return new AdobeExtensionLevel(e3);
          }
          static agent(e3) {
            return new Agent(e3);
          }
          static alwaysEmbed(e3) {
            return new AlwaysEmbed(e3);
          }
          static amd(e3) {
            return new Amd(e3);
          }
          static area(e3) {
            return new Area(e3);
          }
          static attributes(e3) {
            return new Attributes(e3);
          }
          static autoSave(e3) {
            return new AutoSave(e3);
          }
          static base(e3) {
            return new Base(e3);
          }
          static batchOutput(e3) {
            return new BatchOutput(e3);
          }
          static behaviorOverride(e3) {
            return new BehaviorOverride(e3);
          }
          static cache(e3) {
            return new Cache(e3);
          }
          static change(e3) {
            return new Change(e3);
          }
          static common(e3) {
            return new Common(e3);
          }
          static compress(e3) {
            return new Compress(e3);
          }
          static compressLogicalStructure(e3) {
            return new CompressLogicalStructure(e3);
          }
          static compressObjectStream(e3) {
            return new CompressObjectStream(e3);
          }
          static compression(e3) {
            return new Compression(e3);
          }
          static config(e3) {
            return new Config(e3);
          }
          static conformance(e3) {
            return new Conformance(e3);
          }
          static contentCopy(e3) {
            return new ContentCopy(e3);
          }
          static copies(e3) {
            return new Copies(e3);
          }
          static creator(e3) {
            return new Creator(e3);
          }
          static currentPage(e3) {
            return new CurrentPage(e3);
          }
          static data(e3) {
            return new Data(e3);
          }
          static debug(e3) {
            return new Debug(e3);
          }
          static defaultTypeface(e3) {
            return new DefaultTypeface(e3);
          }
          static destination(e3) {
            return new Destination(e3);
          }
          static documentAssembly(e3) {
            return new DocumentAssembly(e3);
          }
          static driver(e3) {
            return new Driver(e3);
          }
          static duplexOption(e3) {
            return new DuplexOption(e3);
          }
          static dynamicRender(e3) {
            return new DynamicRender(e3);
          }
          static embed(e3) {
            return new Embed(e3);
          }
          static encrypt(e3) {
            return new Encrypt(e3);
          }
          static encryption(e3) {
            return new Encryption(e3);
          }
          static encryptionLevel(e3) {
            return new EncryptionLevel(e3);
          }
          static enforce(e3) {
            return new Enforce(e3);
          }
          static equate(e3) {
            return new Equate(e3);
          }
          static equateRange(e3) {
            return new EquateRange(e3);
          }
          static exclude(e3) {
            return new Exclude(e3);
          }
          static excludeNS(e3) {
            return new ExcludeNS(e3);
          }
          static flipLabel(e3) {
            return new FlipLabel(e3);
          }
          static fontInfo(e3) {
            return new FontInfo(e3);
          }
          static formFieldFilling(e3) {
            return new FormFieldFilling(e3);
          }
          static groupParent(e3) {
            return new GroupParent(e3);
          }
          static ifEmpty(e3) {
            return new IfEmpty(e3);
          }
          static includeXDPContent(e3) {
            return new IncludeXDPContent(e3);
          }
          static incrementalLoad(e3) {
            return new IncrementalLoad(e3);
          }
          static incrementalMerge(e3) {
            return new IncrementalMerge(e3);
          }
          static interactive(e3) {
            return new Interactive(e3);
          }
          static jog(e3) {
            return new Jog(e3);
          }
          static labelPrinter(e3) {
            return new LabelPrinter(e3);
          }
          static layout(e3) {
            return new Layout(e3);
          }
          static level(e3) {
            return new Level(e3);
          }
          static linearized(e3) {
            return new Linearized(e3);
          }
          static locale(e3) {
            return new Locale(e3);
          }
          static localeSet(e3) {
            return new LocaleSet(e3);
          }
          static log(e3) {
            return new Log(e3);
          }
          static map(e3) {
            return new MapElement(e3);
          }
          static mediumInfo(e3) {
            return new MediumInfo(e3);
          }
          static message(e3) {
            return new Message(e3);
          }
          static messaging(e3) {
            return new Messaging(e3);
          }
          static mode(e3) {
            return new Mode(e3);
          }
          static modifyAnnots(e3) {
            return new ModifyAnnots(e3);
          }
          static msgId(e3) {
            return new MsgId(e3);
          }
          static nameAttr(e3) {
            return new NameAttr(e3);
          }
          static neverEmbed(e3) {
            return new NeverEmbed(e3);
          }
          static numberOfCopies(e3) {
            return new NumberOfCopies(e3);
          }
          static openAction(e3) {
            return new OpenAction(e3);
          }
          static output(e3) {
            return new Output(e3);
          }
          static outputBin(e3) {
            return new OutputBin(e3);
          }
          static outputXSL(e3) {
            return new OutputXSL(e3);
          }
          static overprint(e3) {
            return new Overprint(e3);
          }
          static packets(e3) {
            return new Packets(e3);
          }
          static pageOffset(e3) {
            return new PageOffset(e3);
          }
          static pageRange(e3) {
            return new PageRange(e3);
          }
          static pagination(e3) {
            return new Pagination(e3);
          }
          static paginationOverride(e3) {
            return new PaginationOverride(e3);
          }
          static part(e3) {
            return new Part(e3);
          }
          static pcl(e3) {
            return new Pcl(e3);
          }
          static pdf(e3) {
            return new Pdf(e3);
          }
          static pdfa(e3) {
            return new Pdfa(e3);
          }
          static permissions(e3) {
            return new Permissions(e3);
          }
          static pickTrayByPDFSize(e3) {
            return new PickTrayByPDFSize(e3);
          }
          static picture(e3) {
            return new Picture(e3);
          }
          static plaintextMetadata(e3) {
            return new PlaintextMetadata(e3);
          }
          static presence(e3) {
            return new Presence(e3);
          }
          static present(e3) {
            return new Present(e3);
          }
          static print(e3) {
            return new Print(e3);
          }
          static printHighQuality(e3) {
            return new PrintHighQuality(e3);
          }
          static printScaling(e3) {
            return new PrintScaling(e3);
          }
          static printerName(e3) {
            return new PrinterName(e3);
          }
          static producer(e3) {
            return new Producer(e3);
          }
          static ps(e3) {
            return new Ps(e3);
          }
          static range(e3) {
            return new Range(e3);
          }
          static record(e3) {
            return new Record(e3);
          }
          static relevant(e3) {
            return new Relevant(e3);
          }
          static rename(e3) {
            return new Rename(e3);
          }
          static renderPolicy(e3) {
            return new RenderPolicy(e3);
          }
          static runScripts(e3) {
            return new RunScripts(e3);
          }
          static script(e3) {
            return new Script(e3);
          }
          static scriptModel(e3) {
            return new ScriptModel(e3);
          }
          static severity(e3) {
            return new Severity(e3);
          }
          static silentPrint(e3) {
            return new SilentPrint(e3);
          }
          static staple(e3) {
            return new Staple(e3);
          }
          static startNode(e3) {
            return new StartNode(e3);
          }
          static startPage(e3) {
            return new StartPage(e3);
          }
          static submitFormat(e3) {
            return new SubmitFormat(e3);
          }
          static submitUrl(e3) {
            return new SubmitUrl(e3);
          }
          static subsetBelow(e3) {
            return new SubsetBelow(e3);
          }
          static suppressBanner(e3) {
            return new SuppressBanner(e3);
          }
          static tagged(e3) {
            return new Tagged(e3);
          }
          static template(e3) {
            return new Template(e3);
          }
          static templateCache(e3) {
            return new TemplateCache(e3);
          }
          static threshold(e3) {
            return new Threshold(e3);
          }
          static to(e3) {
            return new To(e3);
          }
          static trace(e3) {
            return new Trace(e3);
          }
          static transform(e3) {
            return new Transform(e3);
          }
          static type(e3) {
            return new Type(e3);
          }
          static uri(e3) {
            return new Uri(e3);
          }
          static validate(e3) {
            return new Validate(e3);
          }
          static validateApprovalSignatures(e3) {
            return new ValidateApprovalSignatures(e3);
          }
          static validationMessaging(e3) {
            return new ValidationMessaging(e3);
          }
          static version(e3) {
            return new Version(e3);
          }
          static versionControl(e3) {
            return new VersionControl(e3);
          }
          static viewerPreferences(e3) {
            return new ViewerPreferences(e3);
          }
          static webClient(e3) {
            return new WebClient(e3);
          }
          static whitespace(e3) {
            return new Whitespace(e3);
          }
          static window(e3) {
            return new Window(e3);
          }
          static xdc(e3) {
            return new Xdc(e3);
          }
          static xdp(e3) {
            return new Xdp(e3);
          }
          static xsl(e3) {
            return new Xsl(e3);
          }
          static zpl(e3) {
            return new Zpl(e3);
          }
        }
        t2.ConfigNamespace = ConfigNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ConnectionSetNamespace = void 0;
        var r = a2(81), n = a2(87);
        const i = r.NamespaceIds.connectionSet.id;
        class ConnectionSet extends n.XFAObject {
          constructor(e3) {
            super(i, "connectionSet", true);
            this.wsdlConnection = new n.XFAObjectArray();
            this.xmlConnection = new n.XFAObjectArray();
            this.xsdConnection = new n.XFAObjectArray();
          }
        }
        class EffectiveInputPolicy extends n.XFAObject {
          constructor(e3) {
            super(i, "effectiveInputPolicy");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class EffectiveOutputPolicy extends n.XFAObject {
          constructor(e3) {
            super(i, "effectiveOutputPolicy");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Operation extends n.StringObject {
          constructor(e3) {
            super(i, "operation");
            this.id = e3.id || "";
            this.input = e3.input || "";
            this.name = e3.name || "";
            this.output = e3.output || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class RootElement extends n.StringObject {
          constructor(e3) {
            super(i, "rootElement");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class SoapAction extends n.StringObject {
          constructor(e3) {
            super(i, "soapAction");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class SoapAddress extends n.StringObject {
          constructor(e3) {
            super(i, "soapAddress");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class Uri extends n.StringObject {
          constructor(e3) {
            super(i, "uri");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class WsdlAddress extends n.StringObject {
          constructor(e3) {
            super(i, "wsdlAddress");
            this.id = e3.id || "";
            this.name = e3.name || "";
            this.use = e3.use || "";
            this.usehref = e3.usehref || "";
          }
        }
        class WsdlConnection extends n.XFAObject {
          constructor(e3) {
            super(i, "wsdlConnection", true);
            this.dataDescription = e3.dataDescription || "";
            this.name = e3.name || "";
            this.effectiveInputPolicy = null;
            this.effectiveOutputPolicy = null;
            this.operation = null;
            this.soapAction = null;
            this.soapAddress = null;
            this.wsdlAddress = null;
          }
        }
        class XmlConnection extends n.XFAObject {
          constructor(e3) {
            super(i, "xmlConnection", true);
            this.dataDescription = e3.dataDescription || "";
            this.name = e3.name || "";
            this.uri = null;
          }
        }
        class XsdConnection extends n.XFAObject {
          constructor(e3) {
            super(i, "xsdConnection", true);
            this.dataDescription = e3.dataDescription || "";
            this.name = e3.name || "";
            this.rootElement = null;
            this.uri = null;
          }
        }
        class ConnectionSetNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (ConnectionSetNamespace.hasOwnProperty(e3)) return ConnectionSetNamespace[e3](t3);
          }
          static connectionSet(e3) {
            return new ConnectionSet(e3);
          }
          static effectiveInputPolicy(e3) {
            return new EffectiveInputPolicy(e3);
          }
          static effectiveOutputPolicy(e3) {
            return new EffectiveOutputPolicy(e3);
          }
          static operation(e3) {
            return new Operation(e3);
          }
          static rootElement(e3) {
            return new RootElement(e3);
          }
          static soapAction(e3) {
            return new SoapAction(e3);
          }
          static soapAddress(e3) {
            return new SoapAddress(e3);
          }
          static uri(e3) {
            return new Uri(e3);
          }
          static wsdlAddress(e3) {
            return new WsdlAddress(e3);
          }
          static wsdlConnection(e3) {
            return new WsdlConnection(e3);
          }
          static xmlConnection(e3) {
            return new XmlConnection(e3);
          }
          static xsdConnection(e3) {
            return new XsdConnection(e3);
          }
        }
        t2.ConnectionSetNamespace = ConnectionSetNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DatasetsNamespace = void 0;
        var r = a2(78), n = a2(81), i = a2(87);
        const s = n.NamespaceIds.datasets.id;
        class Data extends i.XmlObject {
          constructor(e3) {
            super(s, "data", e3);
          }
          [r.$isNsAgnostic]() {
            return true;
          }
        }
        class Datasets extends i.XFAObject {
          constructor(e3) {
            super(s, "datasets", true);
            this.data = null;
            this.Signature = null;
          }
          [r.$onChild](e3) {
            const t3 = e3[r.$nodeName];
            ("data" === t3 && e3[r.$namespaceId] === s || "Signature" === t3 && e3[r.$namespaceId] === n.NamespaceIds.signature.id) && (this[t3] = e3);
            this[r.$appendChild](e3);
          }
        }
        class DatasetsNamespace {
          static [n.$buildXFAObject](e3, t3) {
            if (DatasetsNamespace.hasOwnProperty(e3)) return DatasetsNamespace[e3](t3);
          }
          static datasets(e3) {
            return new Datasets(e3);
          }
          static data(e3) {
            return new Data(e3);
          }
        }
        t2.DatasetsNamespace = DatasetsNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.LocaleSetNamespace = void 0;
        var r = a2(81), n = a2(87), i = a2(84);
        const s = r.NamespaceIds.localeSet.id;
        class CalendarSymbols extends n.XFAObject {
          constructor(e3) {
            super(s, "calendarSymbols", true);
            this.name = "gregorian";
            this.dayNames = new n.XFAObjectArray(2);
            this.eraNames = null;
            this.meridiemNames = null;
            this.monthNames = new n.XFAObjectArray(2);
          }
        }
        class CurrencySymbol extends n.StringObject {
          constructor(e3) {
            super(s, "currencySymbol");
            this.name = (0, i.getStringOption)(e3.name, ["symbol", "isoname", "decimal"]);
          }
        }
        class CurrencySymbols extends n.XFAObject {
          constructor(e3) {
            super(s, "currencySymbols", true);
            this.currencySymbol = new n.XFAObjectArray(3);
          }
        }
        class DatePattern extends n.StringObject {
          constructor(e3) {
            super(s, "datePattern");
            this.name = (0, i.getStringOption)(e3.name, ["full", "long", "med", "short"]);
          }
        }
        class DatePatterns extends n.XFAObject {
          constructor(e3) {
            super(s, "datePatterns", true);
            this.datePattern = new n.XFAObjectArray(4);
          }
        }
        class DateTimeSymbols extends n.ContentObject {
          constructor(e3) {
            super(s, "dateTimeSymbols");
          }
        }
        class Day extends n.StringObject {
          constructor(e3) {
            super(s, "day");
          }
        }
        class DayNames extends n.XFAObject {
          constructor(e3) {
            super(s, "dayNames", true);
            this.abbr = (0, i.getInteger)({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.day = new n.XFAObjectArray(7);
          }
        }
        class Era extends n.StringObject {
          constructor(e3) {
            super(s, "era");
          }
        }
        class EraNames extends n.XFAObject {
          constructor(e3) {
            super(s, "eraNames", true);
            this.era = new n.XFAObjectArray(2);
          }
        }
        class Locale extends n.XFAObject {
          constructor(e3) {
            super(s, "locale", true);
            this.desc = e3.desc || "";
            this.name = "isoname";
            this.calendarSymbols = null;
            this.currencySymbols = null;
            this.datePatterns = null;
            this.dateTimeSymbols = null;
            this.numberPatterns = null;
            this.numberSymbols = null;
            this.timePatterns = null;
            this.typeFaces = null;
          }
        }
        class LocaleSet extends n.XFAObject {
          constructor(e3) {
            super(s, "localeSet", true);
            this.locale = new n.XFAObjectArray();
          }
        }
        class Meridiem extends n.StringObject {
          constructor(e3) {
            super(s, "meridiem");
          }
        }
        class MeridiemNames extends n.XFAObject {
          constructor(e3) {
            super(s, "meridiemNames", true);
            this.meridiem = new n.XFAObjectArray(2);
          }
        }
        class Month extends n.StringObject {
          constructor(e3) {
            super(s, "month");
          }
        }
        class MonthNames extends n.XFAObject {
          constructor(e3) {
            super(s, "monthNames", true);
            this.abbr = (0, i.getInteger)({ data: e3.abbr, defaultValue: 0, validate: (e4) => 1 === e4 });
            this.month = new n.XFAObjectArray(12);
          }
        }
        class NumberPattern extends n.StringObject {
          constructor(e3) {
            super(s, "numberPattern");
            this.name = (0, i.getStringOption)(e3.name, ["full", "long", "med", "short"]);
          }
        }
        class NumberPatterns extends n.XFAObject {
          constructor(e3) {
            super(s, "numberPatterns", true);
            this.numberPattern = new n.XFAObjectArray(4);
          }
        }
        class NumberSymbol extends n.StringObject {
          constructor(e3) {
            super(s, "numberSymbol");
            this.name = (0, i.getStringOption)(e3.name, ["decimal", "grouping", "percent", "minus", "zero"]);
          }
        }
        class NumberSymbols extends n.XFAObject {
          constructor(e3) {
            super(s, "numberSymbols", true);
            this.numberSymbol = new n.XFAObjectArray(5);
          }
        }
        class TimePattern extends n.StringObject {
          constructor(e3) {
            super(s, "timePattern");
            this.name = (0, i.getStringOption)(e3.name, ["full", "long", "med", "short"]);
          }
        }
        class TimePatterns extends n.XFAObject {
          constructor(e3) {
            super(s, "timePatterns", true);
            this.timePattern = new n.XFAObjectArray(4);
          }
        }
        class TypeFace extends n.XFAObject {
          constructor(e3) {
            super(s, "typeFace", true);
            this.name = "" | e3.name;
          }
        }
        class TypeFaces extends n.XFAObject {
          constructor(e3) {
            super(s, "typeFaces", true);
            this.typeFace = new n.XFAObjectArray();
          }
        }
        class LocaleSetNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (LocaleSetNamespace.hasOwnProperty(e3)) return LocaleSetNamespace[e3](t3);
          }
          static calendarSymbols(e3) {
            return new CalendarSymbols(e3);
          }
          static currencySymbol(e3) {
            return new CurrencySymbol(e3);
          }
          static currencySymbols(e3) {
            return new CurrencySymbols(e3);
          }
          static datePattern(e3) {
            return new DatePattern(e3);
          }
          static datePatterns(e3) {
            return new DatePatterns(e3);
          }
          static dateTimeSymbols(e3) {
            return new DateTimeSymbols(e3);
          }
          static day(e3) {
            return new Day(e3);
          }
          static dayNames(e3) {
            return new DayNames(e3);
          }
          static era(e3) {
            return new Era(e3);
          }
          static eraNames(e3) {
            return new EraNames(e3);
          }
          static locale(e3) {
            return new Locale(e3);
          }
          static localeSet(e3) {
            return new LocaleSet(e3);
          }
          static meridiem(e3) {
            return new Meridiem(e3);
          }
          static meridiemNames(e3) {
            return new MeridiemNames(e3);
          }
          static month(e3) {
            return new Month(e3);
          }
          static monthNames(e3) {
            return new MonthNames(e3);
          }
          static numberPattern(e3) {
            return new NumberPattern(e3);
          }
          static numberPatterns(e3) {
            return new NumberPatterns(e3);
          }
          static numberSymbol(e3) {
            return new NumberSymbol(e3);
          }
          static numberSymbols(e3) {
            return new NumberSymbols(e3);
          }
          static timePattern(e3) {
            return new TimePattern(e3);
          }
          static timePatterns(e3) {
            return new TimePatterns(e3);
          }
          static typeFace(e3) {
            return new TypeFace(e3);
          }
          static typeFaces(e3) {
            return new TypeFaces(e3);
          }
        }
        t2.LocaleSetNamespace = LocaleSetNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SignatureNamespace = void 0;
        var r = a2(81), n = a2(87);
        const i = r.NamespaceIds.signature.id;
        class Signature extends n.XFAObject {
          constructor(e3) {
            super(i, "signature", true);
          }
        }
        class SignatureNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (SignatureNamespace.hasOwnProperty(e3)) return SignatureNamespace[e3](t3);
          }
          static signature(e3) {
            return new Signature(e3);
          }
        }
        t2.SignatureNamespace = SignatureNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.StylesheetNamespace = void 0;
        var r = a2(81), n = a2(87);
        const i = r.NamespaceIds.stylesheet.id;
        class Stylesheet extends n.XFAObject {
          constructor(e3) {
            super(i, "stylesheet", true);
          }
        }
        class StylesheetNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (StylesheetNamespace.hasOwnProperty(e3)) return StylesheetNamespace[e3](t3);
          }
          static stylesheet(e3) {
            return new Stylesheet(e3);
          }
        }
        t2.StylesheetNamespace = StylesheetNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XdpNamespace = void 0;
        var r = a2(81), n = a2(78), i = a2(87);
        const s = r.NamespaceIds.xdp.id;
        class Xdp extends i.XFAObject {
          constructor(e3) {
            super(s, "xdp", true);
            this.uuid = e3.uuid || "";
            this.timeStamp = e3.timeStamp || "";
            this.config = null;
            this.connectionSet = null;
            this.datasets = null;
            this.localeSet = null;
            this.stylesheet = new i.XFAObjectArray();
            this.template = null;
          }
          [n.$onChildCheck](e3) {
            const t3 = r.NamespaceIds[e3[n.$nodeName]];
            return t3 && e3[n.$namespaceId] === t3.id;
          }
        }
        class XdpNamespace {
          static [r.$buildXFAObject](e3, t3) {
            if (XdpNamespace.hasOwnProperty(e3)) return XdpNamespace[e3](t3);
          }
          static xdp(e3) {
            return new Xdp(e3);
          }
        }
        t2.XdpNamespace = XdpNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XhtmlNamespace = void 0;
        var r = a2(78), n = a2(81), i = a2(83), s = a2(84), o = a2(87);
        const c = n.NamespaceIds.xhtml.id, l = Symbol(), h = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), u = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e3) => "none" === e3 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e3) => `scaleX(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (e3) => `scaleY(${Math.max(0, Math.min(parseInt(e3) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e3, t3) => {
          e3 = t3.fontSize = (0, s.getMeasurement)(e3);
          return (0, i.measureToString)(0.99 * e3);
        }], ["letter-spacing", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["line-height", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["margin", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["margin-bottom", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["margin-left", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["margin-right", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["margin-top", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["text-indent", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))], ["font-family", (e3) => e3], ["vertical-align", (e3) => (0, i.measureToString)((0, s.getMeasurement)(e3))]]), d = /\s+/g, f = /[\r\n]+/g, g = /\r\n?/g;
        function mapStyle(e3, t3, a3) {
          const n2 = /* @__PURE__ */ Object.create(null);
          if (!e3) return n2;
          const o2 = /* @__PURE__ */ Object.create(null);
          for (const [t4, a4] of e3.split(";").map((e4) => e4.split(":", 2))) {
            const e4 = u.get(t4);
            if ("" === e4) continue;
            let r2 = a4;
            e4 && (r2 = "string" == typeof e4 ? e4 : e4(a4, o2));
            t4.endsWith("scale") ? n2.transform = n2.transform ? `${n2[t4]} ${r2}` : r2 : n2[t4.replaceAll(/-([a-zA-Z])/g, (e5, t5) => t5.toUpperCase())] = r2;
          }
          n2.fontFamily && (0, i.setFontFamily)({ typeface: n2.fontFamily, weight: n2.fontWeight || "normal", posture: n2.fontStyle || "normal", size: o2.fontSize || 0 }, t3, t3[r.$globalData].fontFinder, n2);
          if (a3 && n2.verticalAlign && "0px" !== n2.verticalAlign && n2.fontSize) {
            const e4 = 0.583, t4 = 0.333, a4 = (0, s.getMeasurement)(n2.fontSize);
            n2.fontSize = (0, i.measureToString)(a4 * e4);
            n2.verticalAlign = (0, i.measureToString)(Math.sign((0, s.getMeasurement)(n2.verticalAlign)) * a4 * t4);
          }
          a3 && n2.fontSize && (n2.fontSize = `calc(${n2.fontSize} * var(--scale-factor))`);
          (0, i.fixTextIndent)(n2);
          return n2;
        }
        const p = /* @__PURE__ */ new Set(["body", "html"]);
        class XhtmlObject extends o.XmlObject {
          constructor(e3, t3) {
            super(c, t3);
            this[l] = false;
            this.style = e3.style || "";
          }
          [r.$clean](e3) {
            super[r.$clean](e3);
            this.style = function checkStyle(e4) {
              return e4.style ? e4.style.trim().split(/\s*;\s*/).filter((e5) => !!e5).map((e5) => e5.split(/\s*:\s*/, 2)).filter(([t3, a3]) => {
                "font-family" === t3 && e4[r.$globalData].usedTypefaces.add(a3);
                return h.has(t3);
              }).map((e5) => e5.join(":")).join(";") : "";
            }(this);
          }
          [r.$acceptWhitespace]() {
            return !p.has(this[r.$nodeName]);
          }
          [r.$onText](e3, t3 = false) {
            if (t3) this[l] = true;
            else {
              e3 = e3.replaceAll(f, "");
              this.style.includes("xfa-spacerun:yes") || (e3 = e3.replaceAll(d, " "));
            }
            e3 && (this[r.$content] += e3);
          }
          [r.$pushGlyphs](e3, t3 = true) {
            const a3 = /* @__PURE__ */ Object.create(null), n2 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
            let i2 = null;
            for (const [e4, t4] of this.style.split(";").map((e5) => e5.split(":", 2))) switch (e4) {
              case "font-family":
                a3.typeface = (0, s.stripQuotes)(t4);
                break;
              case "font-size":
                a3.size = (0, s.getMeasurement)(t4);
                break;
              case "font-weight":
                a3.weight = t4;
                break;
              case "font-style":
                a3.posture = t4;
                break;
              case "letter-spacing":
                a3.letterSpacing = (0, s.getMeasurement)(t4);
                break;
              case "margin":
                const e5 = t4.split(/ \t/).map((e6) => (0, s.getMeasurement)(e6));
                switch (e5.length) {
                  case 1:
                    n2.top = n2.bottom = n2.left = n2.right = e5[0];
                    break;
                  case 2:
                    n2.top = n2.bottom = e5[0];
                    n2.left = n2.right = e5[1];
                    break;
                  case 3:
                    n2.top = e5[0];
                    n2.bottom = e5[2];
                    n2.left = n2.right = e5[1];
                    break;
                  case 4:
                    n2.top = e5[0];
                    n2.left = e5[1];
                    n2.bottom = e5[2];
                    n2.right = e5[3];
                }
                break;
              case "margin-top":
                n2.top = (0, s.getMeasurement)(t4);
                break;
              case "margin-bottom":
                n2.bottom = (0, s.getMeasurement)(t4);
                break;
              case "margin-left":
                n2.left = (0, s.getMeasurement)(t4);
                break;
              case "margin-right":
                n2.right = (0, s.getMeasurement)(t4);
                break;
              case "line-height":
                i2 = (0, s.getMeasurement)(t4);
            }
            e3.pushData(a3, n2, i2);
            if (this[r.$content]) e3.addString(this[r.$content]);
            else for (const t4 of this[r.$getChildren]()) "#text" !== t4[r.$nodeName] ? t4[r.$pushGlyphs](e3) : e3.addString(t4[r.$content]);
            t3 && e3.popFont();
          }
          [r.$toHTML](e3) {
            const t3 = [];
            this[r.$extra] = { children: t3 };
            this[r.$childrenToHTML]({});
            if (0 === t3.length && !this[r.$content]) return s.HTMLResult.EMPTY;
            let a3;
            a3 = this[l] ? this[r.$content] ? this[r.$content].replaceAll(g, "\n") : void 0 : this[r.$content] || void 0;
            return s.HTMLResult.success({ name: this[r.$nodeName], attributes: { href: this.href, style: mapStyle(this.style, this, this[l]) }, children: t3, value: a3 });
          }
        }
        class A extends XhtmlObject {
          constructor(e3) {
            super(e3, "a");
            this.href = (0, i.fixURL)(e3.href) || "";
          }
        }
        class B extends XhtmlObject {
          constructor(e3) {
            super(e3, "b");
          }
          [r.$pushGlyphs](e3) {
            e3.pushFont({ weight: "bold" });
            super[r.$pushGlyphs](e3);
            e3.popFont();
          }
        }
        class Body extends XhtmlObject {
          constructor(e3) {
            super(e3, "body");
          }
          [r.$toHTML](e3) {
            const t3 = super[r.$toHTML](e3), { html: a3 } = t3;
            if (!a3) return s.HTMLResult.EMPTY;
            a3.name = "div";
            a3.attributes.class = ["xfaRich"];
            return t3;
          }
        }
        class Br extends XhtmlObject {
          constructor(e3) {
            super(e3, "br");
          }
          [r.$text]() {
            return "\n";
          }
          [r.$pushGlyphs](e3) {
            e3.addString("\n");
          }
          [r.$toHTML](e3) {
            return s.HTMLResult.success({ name: "br" });
          }
        }
        class Html extends XhtmlObject {
          constructor(e3) {
            super(e3, "html");
          }
          [r.$toHTML](e3) {
            var _a;
            const t3 = [];
            this[r.$extra] = { children: t3 };
            this[r.$childrenToHTML]({});
            if (0 === t3.length) return s.HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[r.$content] || "" });
            if (1 === t3.length) {
              const e4 = t3[0];
              if ((_a = e4.attributes) == null ? void 0 : _a.class.includes("xfaRich")) return s.HTMLResult.success(e4);
            }
            return s.HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t3 });
          }
        }
        class I extends XhtmlObject {
          constructor(e3) {
            super(e3, "i");
          }
          [r.$pushGlyphs](e3) {
            e3.pushFont({ posture: "italic" });
            super[r.$pushGlyphs](e3);
            e3.popFont();
          }
        }
        class Li extends XhtmlObject {
          constructor(e3) {
            super(e3, "li");
          }
        }
        class Ol extends XhtmlObject {
          constructor(e3) {
            super(e3, "ol");
          }
        }
        class P extends XhtmlObject {
          constructor(e3) {
            super(e3, "p");
          }
          [r.$pushGlyphs](e3) {
            super[r.$pushGlyphs](e3, false);
            e3.addString("\n");
            e3.addPara();
            e3.popFont();
          }
          [r.$text]() {
            return this[r.$getParent]()[r.$getChildren]().at(-1) === this ? super[r.$text]() : super[r.$text]() + "\n";
          }
        }
        class Span extends XhtmlObject {
          constructor(e3) {
            super(e3, "span");
          }
        }
        class Sub extends XhtmlObject {
          constructor(e3) {
            super(e3, "sub");
          }
        }
        class Sup extends XhtmlObject {
          constructor(e3) {
            super(e3, "sup");
          }
        }
        class Ul extends XhtmlObject {
          constructor(e3) {
            super(e3, "ul");
          }
        }
        class XhtmlNamespace {
          static [n.$buildXFAObject](e3, t3) {
            if (XhtmlNamespace.hasOwnProperty(e3)) return XhtmlNamespace[e3](t3);
          }
          static a(e3) {
            return new A(e3);
          }
          static b(e3) {
            return new B(e3);
          }
          static body(e3) {
            return new Body(e3);
          }
          static br(e3) {
            return new Br(e3);
          }
          static html(e3) {
            return new Html(e3);
          }
          static i(e3) {
            return new I(e3);
          }
          static li(e3) {
            return new Li(e3);
          }
          static ol(e3) {
            return new Ol(e3);
          }
          static p(e3) {
            return new P(e3);
          }
          static span(e3) {
            return new Span(e3);
          }
          static sub(e3) {
            return new Sub(e3);
          }
          static sup(e3) {
            return new Sup(e3);
          }
          static ul(e3) {
            return new Ul(e3);
          }
        }
        t2.XhtmlNamespace = XhtmlNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.UnknownNamespace = void 0;
        var r = a2(81), n = a2(87);
        class UnknownNamespace {
          constructor(e3) {
            this.namespaceId = e3;
          }
          [r.$buildXFAObject](e3, t3) {
            return new n.XmlObject(this.namespaceId, e3, t3);
          }
        }
        t2.UnknownNamespace = UnknownNamespace;
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DatasetReader = void 0;
        var r = a2(2), n = a2(3), i = a2(71);
        function decodeString(e3) {
          try {
            return (0, r.stringToUTF8String)(e3);
          } catch (t3) {
            (0, r.warn)(`UTF-8 decoding failed: "${t3}".`);
            return e3;
          }
        }
        class DatasetXMLParser extends i.SimpleXMLParser {
          constructor(e3) {
            super(e3);
            this.node = null;
          }
          onEndElement(e3) {
            const t3 = super.onEndElement(e3);
            if (t3 && "xfa:datasets" === e3) {
              this.node = t3;
              throw new Error("Aborting DatasetXMLParser.");
            }
          }
        }
        t2.DatasetReader = class DatasetReader {
          constructor(e3) {
            if (e3.datasets) this.node = new i.SimpleXMLParser({ hasAttributes: true }).parseFromString(e3.datasets).documentElement;
            else {
              const t3 = new DatasetXMLParser({ hasAttributes: true });
              try {
                t3.parseFromString(e3["xdp:xdp"]);
              } catch {
              }
              this.node = t3.node;
            }
          }
          getValue(e3) {
            if (!this.node || !e3) return "";
            const t3 = this.node.searchNode((0, n.parseXFAPath)(e3), 0);
            if (!t3) return "";
            const a3 = t3.firstChild;
            return "value" === (a3 == null ? void 0 : a3.nodeName) ? t3.children.map((e4) => decodeString(e4.textContent)) : decodeString(t3.textContent);
          }
        };
      }, (e2, t2, a2) => {
        var _B, _a;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.XRef = void 0;
        var r = a2(2), n = a2(4), i = a2(16), s = a2(3), o = a2(5), c = a2(74);
        t2.XRef = (_a = class {
          constructor(e3, t3) {
            __privateAdd(this, _B, null);
            this.stream = e3;
            this.pdfManager = t3;
            this.entries = [];
            this._xrefStms = /* @__PURE__ */ new Set();
            this._cacheMap = /* @__PURE__ */ new Map();
            this._pendingRefs = new n.RefSet();
            this._newPersistentRefNum = null;
            this._newTemporaryRefNum = null;
          }
          getNewPersistentRef(e3) {
            null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
            const t3 = this._newPersistentRefNum++;
            this._cacheMap.set(t3, e3);
            return n.Ref.get(t3, 0);
          }
          getNewTemporaryRef() {
            null === this._newTemporaryRefNum && (this._newTemporaryRefNum = this.entries.length || 1);
            return n.Ref.get(this._newTemporaryRefNum++, 0);
          }
          resetNewTemporaryRef() {
            this._newTemporaryRefNum = null;
          }
          setStartXRef(e3) {
            this.startXRefQueue = [e3];
          }
          parse(e3 = false) {
            let t3, a3, i2;
            if (e3) {
              (0, r.warn)("Indexing all PDF objects");
              t3 = this.indexObjects();
            } else t3 = this.readXRef();
            t3.assignXref(this);
            this.trailer = t3;
            try {
              a3 = t3.get("Encrypt");
            } catch (e4) {
              if (e4 instanceof s.MissingDataException) throw e4;
              (0, r.warn)(`XRef.parse - Invalid "Encrypt" reference: "${e4}".`);
            }
            if (a3 instanceof n.Dict) {
              const e4 = t3.get("ID"), r2 = (e4 == null ? void 0 : e4.length) ? e4[0] : "";
              a3.suppressEncryption = true;
              this.encrypt = new c.CipherTransformFactory(a3, r2, this.pdfManager.password);
            }
            try {
              i2 = t3.get("Root");
            } catch (e4) {
              if (e4 instanceof s.MissingDataException) throw e4;
              (0, r.warn)(`XRef.parse - Invalid "Root" reference: "${e4}".`);
            }
            if (i2 instanceof n.Dict) try {
              if (i2.get("Pages") instanceof n.Dict) {
                this.root = i2;
                return;
              }
            } catch (e4) {
              if (e4 instanceof s.MissingDataException) throw e4;
              (0, r.warn)(`XRef.parse - Invalid "Pages" reference: "${e4}".`);
            }
            if (!e3) throw new s.XRefParseException();
            throw new r.InvalidPDFException("Invalid Root reference.");
          }
          processXRefTable(e3) {
            "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e3.lexer.stream.pos, parserBuf1: e3.buf1, parserBuf2: e3.buf2 });
            const t3 = this.readXRefTable(e3);
            if (!(0, n.isCmd)(t3, "trailer")) throw new r.FormatError("Invalid XRef table: could not find trailer dictionary");
            let a3 = e3.getObj();
            a3 instanceof n.Dict || !a3.dict || (a3 = a3.dict);
            if (!(a3 instanceof n.Dict)) throw new r.FormatError("Invalid XRef table: could not parse trailer dictionary");
            delete this.tableState;
            return a3;
          }
          readXRefTable(e3) {
            const t3 = e3.lexer.stream, a3 = this.tableState;
            t3.pos = a3.streamPos;
            e3.buf1 = a3.parserBuf1;
            e3.buf2 = a3.parserBuf2;
            let i2;
            for (; ; ) {
              if (!("firstEntryNum" in a3) || !("entryCount" in a3)) {
                if ((0, n.isCmd)(i2 = e3.getObj(), "trailer")) break;
                a3.firstEntryNum = i2;
                a3.entryCount = e3.getObj();
              }
              let s2 = a3.firstEntryNum;
              const o2 = a3.entryCount;
              if (!Number.isInteger(s2) || !Number.isInteger(o2)) throw new r.FormatError("Invalid XRef table: wrong types in subsection header");
              for (let i3 = a3.entryNum; i3 < o2; i3++) {
                a3.streamPos = t3.pos;
                a3.entryNum = i3;
                a3.parserBuf1 = e3.buf1;
                a3.parserBuf2 = e3.buf2;
                const c2 = {};
                c2.offset = e3.getObj();
                c2.gen = e3.getObj();
                const l = e3.getObj();
                if (l instanceof n.Cmd) switch (l.cmd) {
                  case "f":
                    c2.free = true;
                    break;
                  case "n":
                    c2.uncompressed = true;
                }
                if (!Number.isInteger(c2.offset) || !Number.isInteger(c2.gen) || !c2.free && !c2.uncompressed) throw new r.FormatError(`Invalid entry in XRef subsection: ${s2}, ${o2}`);
                0 === i3 && c2.free && 1 === s2 && (s2 = 0);
                this.entries[i3 + s2] || (this.entries[i3 + s2] = c2);
              }
              a3.entryNum = 0;
              a3.streamPos = t3.pos;
              a3.parserBuf1 = e3.buf1;
              a3.parserBuf2 = e3.buf2;
              delete a3.firstEntryNum;
              delete a3.entryCount;
            }
            if (this.entries[0] && !this.entries[0].free) throw new r.FormatError("Invalid XRef table: unexpected first object");
            return i2;
          }
          processXRefStream(e3) {
            if (!("streamState" in this)) {
              const t3 = e3.dict, a3 = t3.get("W");
              let r2 = t3.get("Index");
              r2 || (r2 = [0, t3.get("Size")]);
              this.streamState = { entryRanges: r2, byteWidths: a3, entryNum: 0, streamPos: e3.pos };
            }
            this.readXRefStream(e3);
            delete this.streamState;
            return e3.dict;
          }
          readXRefStream(e3) {
            const t3 = this.streamState;
            e3.pos = t3.streamPos;
            const [a3, n2, i2] = t3.byteWidths, s2 = t3.entryRanges;
            for (; s2.length > 0; ) {
              const [o2, c2] = s2;
              if (!Number.isInteger(o2) || !Number.isInteger(c2)) throw new r.FormatError(`Invalid XRef range fields: ${o2}, ${c2}`);
              if (!Number.isInteger(a3) || !Number.isInteger(n2) || !Number.isInteger(i2)) throw new r.FormatError(`Invalid XRef entry fields length: ${o2}, ${c2}`);
              for (let s3 = t3.entryNum; s3 < c2; ++s3) {
                t3.entryNum = s3;
                t3.streamPos = e3.pos;
                let c3 = 0, l = 0, h = 0;
                for (let t4 = 0; t4 < a3; ++t4) {
                  const t5 = e3.getByte();
                  if (-1 === t5) throw new r.FormatError("Invalid XRef byteWidths 'type'.");
                  c3 = c3 << 8 | t5;
                }
                0 === a3 && (c3 = 1);
                for (let t4 = 0; t4 < n2; ++t4) {
                  const t5 = e3.getByte();
                  if (-1 === t5) throw new r.FormatError("Invalid XRef byteWidths 'offset'.");
                  l = l << 8 | t5;
                }
                for (let t4 = 0; t4 < i2; ++t4) {
                  const t5 = e3.getByte();
                  if (-1 === t5) throw new r.FormatError("Invalid XRef byteWidths 'generation'.");
                  h = h << 8 | t5;
                }
                const u = {};
                u.offset = l;
                u.gen = h;
                switch (c3) {
                  case 0:
                    u.free = true;
                    break;
                  case 1:
                    u.uncompressed = true;
                    break;
                  case 2:
                    break;
                  default:
                    throw new r.FormatError(`Invalid XRef entry type: ${c3}`);
                }
                this.entries[o2 + s3] || (this.entries[o2 + s3] = u);
              }
              t3.entryNum = 0;
              t3.streamPos = e3.pos;
              s2.splice(0, 2);
            }
          }
          indexObjects() {
            function readToken(e4, t4) {
              let a4 = "", r2 = e4[t4];
              for (; 10 !== r2 && 13 !== r2 && 60 !== r2 && !(++t4 >= e4.length); ) {
                a4 += String.fromCharCode(r2);
                r2 = e4[t4];
              }
              return a4;
            }
            function skipUntil(e4, t4, a4) {
              const r2 = a4.length, n2 = e4.length;
              let i2 = 0;
              for (; t4 < n2; ) {
                let n3 = 0;
                for (; n3 < r2 && e4[t4 + n3] === a4[n3]; ) ++n3;
                if (n3 >= r2) break;
                t4++;
                i2++;
              }
              return i2;
            }
            const e3 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t3 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, a3 = /^(\d+)\s+(\d+)\s+obj\b/, o2 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), c2 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), l = new Uint8Array([47, 88, 82, 101, 102]);
            this.entries.length = 0;
            this._cacheMap.clear();
            const h = this.stream;
            h.pos = 0;
            const u = h.getBytes(), d = (0, r.bytesToString)(u), f = u.length;
            let g = h.start;
            const p = [], m = [];
            for (; g < f; ) {
              let n2 = u[g];
              if (9 === n2 || 10 === n2 || 13 === n2 || 32 === n2) {
                ++g;
                continue;
              }
              if (37 === n2) {
                do {
                  ++g;
                  if (g >= f) break;
                  n2 = u[g];
                } while (10 !== n2 && 13 !== n2);
                continue;
              }
              const b2 = readToken(u, g);
              let y2;
              if (b2.startsWith("xref") && (4 === b2.length || /\s/.test(b2[4]))) {
                g += skipUntil(u, g, o2);
                p.push(g);
                g += skipUntil(u, g, c2);
              } else if (y2 = a3.exec(b2)) {
                const t4 = 0 | y2[1], a4 = 0 | y2[2], n3 = g + b2.length;
                let o3, c3 = false;
                if (this.entries[t4]) {
                  if (this.entries[t4].gen === a4) try {
                    new i.Parser({ lexer: new i.Lexer(h.makeSubStream(n3)) }).getObj();
                    c3 = true;
                  } catch (e4) {
                    e4 instanceof s.ParserEOFException ? (0, r.warn)(`indexObjects -- checking object (${b2}): "${e4}".`) : c3 = true;
                  }
                } else c3 = true;
                c3 && (this.entries[t4] = { offset: g - h.start, gen: a4, uncompressed: true });
                e3.lastIndex = n3;
                const p2 = e3.exec(d);
                if (p2) {
                  o3 = e3.lastIndex + 1 - g;
                  if ("endobj" !== p2[1]) {
                    (0, r.warn)(`indexObjects: Found "${p2[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
                    o3 -= p2[1].length + 1;
                  }
                } else o3 = f - g;
                const w2 = u.subarray(g, g + o3), S2 = skipUntil(w2, 0, l);
                if (S2 < o3 && w2[S2 + 5] < 64) {
                  m.push(g - h.start);
                  this._xrefStms.add(g - h.start);
                }
                g += o3;
              } else if (b2.startsWith("trailer") && (7 === b2.length || /\s/.test(b2[7]))) {
                p.push(g);
                const e4 = g + b2.length;
                let a4;
                t3.lastIndex = e4;
                const n3 = t3.exec(d);
                if (n3) {
                  a4 = t3.lastIndex + 1 - g;
                  if ("startxref" !== n3[1]) {
                    (0, r.warn)(`indexObjects: Found "${n3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
                    a4 -= n3[1].length + 1;
                  }
                } else a4 = f - g;
                g += a4;
              } else g += b2.length + 1;
            }
            for (const e4 of m) {
              this.startXRefQueue.push(e4);
              this.readXRef(true);
            }
            const b = [];
            let y, w, S = false;
            for (const e4 of p) {
              h.pos = e4;
              const t4 = new i.Parser({ lexer: new i.Lexer(h), xref: this, allowStreams: true, recoveryMode: true }), a4 = t4.getObj();
              if (!(0, n.isCmd)(a4, "trailer")) continue;
              const r2 = t4.getObj();
              if (r2 instanceof n.Dict) {
                b.push(r2);
                r2.has("Encrypt") && (S = true);
              }
            }
            for (const e4 of [...b, "genFallback", ...b]) {
              if ("genFallback" === e4) {
                if (!w) break;
                this._generationFallback = true;
                continue;
              }
              let t4 = false;
              try {
                const a4 = e4.get("Root");
                if (!(a4 instanceof n.Dict)) continue;
                const r2 = a4.get("Pages");
                if (!(r2 instanceof n.Dict)) continue;
                const i2 = r2.get("Count");
                Number.isInteger(i2) && (t4 = true);
              } catch (e5) {
                w = e5;
                continue;
              }
              if (t4 && (!S || e4.has("Encrypt")) && e4.has("ID")) return e4;
              y = e4;
            }
            if (y) return y;
            if (this.topDict) return this.topDict;
            throw new r.InvalidPDFException("Invalid PDF structure.");
          }
          readXRef(e3 = false) {
            const t3 = this.stream, a3 = /* @__PURE__ */ new Set();
            for (; this.startXRefQueue.length; ) {
              try {
                const e4 = this.startXRefQueue[0];
                if (a3.has(e4)) {
                  (0, r.warn)("readXRef - skipping XRef table since it was already parsed.");
                  this.startXRefQueue.shift();
                  continue;
                }
                a3.add(e4);
                t3.pos = e4 + t3.start;
                const s2 = new i.Parser({ lexer: new i.Lexer(t3), xref: this, allowStreams: true });
                let c2, l = s2.getObj();
                if ((0, n.isCmd)(l, "xref")) {
                  c2 = this.processXRefTable(s2);
                  this.topDict || (this.topDict = c2);
                  l = c2.get("XRefStm");
                  if (Number.isInteger(l) && !this._xrefStms.has(l)) {
                    this._xrefStms.add(l);
                    this.startXRefQueue.push(l);
                    __privateGet(this, _B) ?? __privateSet(this, _B, l);
                  }
                } else {
                  if (!Number.isInteger(l)) throw new r.FormatError("Invalid XRef stream header");
                  if (!(Number.isInteger(s2.getObj()) && (0, n.isCmd)(s2.getObj(), "obj") && (l = s2.getObj()) instanceof o.BaseStream)) throw new r.FormatError("Invalid XRef stream");
                  c2 = this.processXRefStream(l);
                  this.topDict || (this.topDict = c2);
                  if (!c2) throw new r.FormatError("Failed to read XRef stream");
                }
                l = c2.get("Prev");
                Number.isInteger(l) ? this.startXRefQueue.push(l) : l instanceof n.Ref && this.startXRefQueue.push(l.num);
              } catch (e4) {
                if (e4 instanceof s.MissingDataException) throw e4;
                (0, r.info)("(while reading XRef): " + e4);
              }
              this.startXRefQueue.shift();
            }
            if (this.topDict) return this.topDict;
            if (!e3) throw new s.XRefParseException();
          }
          get lastXRefStreamPos() {
            return __privateGet(this, _B) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
          }
          getEntry(e3) {
            const t3 = this.entries[e3];
            return t3 && !t3.free && t3.offset ? t3 : null;
          }
          fetchIfRef(e3, t3 = false) {
            return e3 instanceof n.Ref ? this.fetch(e3, t3) : e3;
          }
          fetch(e3, t3 = false) {
            if (!(e3 instanceof n.Ref)) throw new Error("ref object is not a reference");
            const a3 = e3.num, i2 = this._cacheMap.get(a3);
            if (void 0 !== i2) {
              i2 instanceof n.Dict && !i2.objId && (i2.objId = e3.toString());
              return i2;
            }
            let s2 = this.getEntry(a3);
            if (null === s2) {
              this._cacheMap.set(a3, s2);
              return s2;
            }
            if (this._pendingRefs.has(e3)) {
              this._pendingRefs.remove(e3);
              (0, r.warn)(`Ignoring circular reference: ${e3}.`);
              return n.CIRCULAR_REF;
            }
            this._pendingRefs.put(e3);
            try {
              s2 = s2.uncompressed ? this.fetchUncompressed(e3, s2, t3) : this.fetchCompressed(e3, s2, t3);
              this._pendingRefs.remove(e3);
            } catch (t4) {
              this._pendingRefs.remove(e3);
              throw t4;
            }
            s2 instanceof n.Dict ? s2.objId = e3.toString() : s2 instanceof o.BaseStream && (s2.dict.objId = e3.toString());
            return s2;
          }
          fetchUncompressed(e3, t3, a3 = false) {
            const c2 = e3.gen;
            let l = e3.num;
            if (t3.gen !== c2) {
              const i2 = `Inconsistent generation in XRef: ${e3}`;
              if (this._generationFallback && t3.gen < c2) {
                (0, r.warn)(i2);
                return this.fetchUncompressed(n.Ref.get(l, t3.gen), t3, a3);
              }
              throw new s.XRefEntryException(i2);
            }
            const h = this.stream.makeSubStream(t3.offset + this.stream.start), u = new i.Parser({ lexer: new i.Lexer(h), xref: this, allowStreams: true }), d = u.getObj(), f = u.getObj(), g = u.getObj();
            if (d !== l || f !== c2 || !(g instanceof n.Cmd)) throw new s.XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
            if ("obj" !== g.cmd) {
              if (g.cmd.startsWith("obj")) {
                l = parseInt(g.cmd.substring(3), 10);
                if (!Number.isNaN(l)) return l;
              }
              throw new s.XRefEntryException(`Bad (uncompressed) XRef entry: ${e3}`);
            }
            (t3 = this.encrypt && !a3 ? u.getObj(this.encrypt.createCipherTransform(l, c2)) : u.getObj()) instanceof o.BaseStream || this._cacheMap.set(l, t3);
            return t3;
          }
          fetchCompressed(e3, t3, a3 = false) {
            const c2 = t3.offset, l = this.fetch(n.Ref.get(c2, 0));
            if (!(l instanceof o.BaseStream)) throw new r.FormatError("bad ObjStm stream");
            const h = l.dict.get("First"), u = l.dict.get("N");
            if (!Number.isInteger(h) || !Number.isInteger(u)) throw new r.FormatError("invalid first and n parameters for ObjStm stream");
            let d = new i.Parser({ lexer: new i.Lexer(l), xref: this, allowStreams: true });
            const f = new Array(u), g = new Array(u);
            for (let e4 = 0; e4 < u; ++e4) {
              const t4 = d.getObj();
              if (!Number.isInteger(t4)) throw new r.FormatError(`invalid object number in the ObjStm stream: ${t4}`);
              const a4 = d.getObj();
              if (!Number.isInteger(a4)) throw new r.FormatError(`invalid object offset in the ObjStm stream: ${a4}`);
              f[e4] = t4;
              g[e4] = a4;
            }
            const p = (l.start || 0) + h, m = new Array(u);
            for (let e4 = 0; e4 < u; ++e4) {
              const t4 = e4 < u - 1 ? g[e4 + 1] - g[e4] : void 0;
              if (t4 < 0) throw new r.FormatError("Invalid offset in the ObjStm stream.");
              d = new i.Parser({ lexer: new i.Lexer(l.makeSubStream(p + g[e4], t4, l.dict)), xref: this, allowStreams: true });
              const a4 = d.getObj();
              m[e4] = a4;
              if (a4 instanceof o.BaseStream) continue;
              const n2 = f[e4], s2 = this.entries[n2];
              s2 && s2.offset === c2 && s2.gen === e4 && this._cacheMap.set(n2, a4);
            }
            if (void 0 === (t3 = m[t3.gen])) throw new s.XRefEntryException(`Bad (compressed) XRef entry: ${e3}`);
            return t3;
          }
          async fetchIfRefAsync(e3, t3) {
            return e3 instanceof n.Ref ? this.fetchAsync(e3, t3) : e3;
          }
          async fetchAsync(e3, t3) {
            try {
              return this.fetch(e3, t3);
            } catch (a3) {
              if (!(a3 instanceof s.MissingDataException)) throw a3;
              await this.pdfManager.requestRange(a3.begin, a3.end);
              return this.fetchAsync(e3, t3);
            }
          }
          getCatalogObj() {
            return this.root;
          }
        }, _B = new WeakMap(), _a);
      }, (e2, t2, a2) => {
        var _MessageHandler_instances, N_fn, E_fn, R_fn, _a;
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.MessageHandler = void 0;
        var r = a2(2);
        const n = 1, i = 2, s = 1, o = 2, c = 3, l = 4, h = 5, u = 6, d = 7, f = 8;
        function wrapReason(e3) {
          e3 instanceof Error || "object" == typeof e3 && null !== e3 || (0, r.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
          switch (e3.name) {
            case "AbortException":
              return new r.AbortException(e3.message);
            case "MissingPDFException":
              return new r.MissingPDFException(e3.message);
            case "PasswordException":
              return new r.PasswordException(e3.message, e3.code);
            case "UnexpectedResponseException":
              return new r.UnexpectedResponseException(e3.message, e3.status);
            case "UnknownErrorException":
              return new r.UnknownErrorException(e3.message, e3.details);
            default:
              return new r.UnknownErrorException(e3.message, e3.toString());
          }
        }
        t2.MessageHandler = (_a = class {
          constructor(e3, t3, a3) {
            __privateAdd(this, _MessageHandler_instances);
            this.sourceName = e3;
            this.targetName = t3;
            this.comObj = a3;
            this.callbackId = 1;
            this.streamId = 1;
            this.streamSinks = /* @__PURE__ */ Object.create(null);
            this.streamControllers = /* @__PURE__ */ Object.create(null);
            this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
            this.actionHandler = /* @__PURE__ */ Object.create(null);
            this._onComObjOnMessage = (e4) => {
              const t4 = e4.data;
              if (t4.targetName !== this.sourceName) return;
              if (t4.stream) {
                __privateMethod(this, _MessageHandler_instances, E_fn).call(this, t4);
                return;
              }
              if (t4.callback) {
                const e5 = t4.callbackId, a4 = this.callbackCapabilities[e5];
                if (!a4) throw new Error(`Cannot resolve callback ${e5}`);
                delete this.callbackCapabilities[e5];
                if (t4.callback === n) a4.resolve(t4.data);
                else {
                  if (t4.callback !== i) throw new Error("Unexpected callback case");
                  a4.reject(wrapReason(t4.reason));
                }
                return;
              }
              const r2 = this.actionHandler[t4.action];
              if (!r2) throw new Error(`Unknown action from worker: ${t4.action}`);
              if (t4.callbackId) {
                const e5 = this.sourceName, s2 = t4.sourceName;
                new Promise(function(e6) {
                  e6(r2(t4.data));
                }).then(function(r3) {
                  a3.postMessage({ sourceName: e5, targetName: s2, callback: n, callbackId: t4.callbackId, data: r3 });
                }, function(r3) {
                  a3.postMessage({ sourceName: e5, targetName: s2, callback: i, callbackId: t4.callbackId, reason: wrapReason(r3) });
                });
              } else t4.streamId ? __privateMethod(this, _MessageHandler_instances, N_fn).call(this, t4) : r2(t4.data);
            };
            a3.addEventListener("message", this._onComObjOnMessage);
          }
          on(e3, t3) {
            const a3 = this.actionHandler;
            if (a3[e3]) throw new Error(`There is already an actionName called "${e3}"`);
            a3[e3] = t3;
          }
          send(e3, t3, a3) {
            this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, data: t3 }, a3);
          }
          sendWithPromise(e3, t3, a3) {
            const n2 = this.callbackId++, i2 = new r.PromiseCapability();
            this.callbackCapabilities[n2] = i2;
            try {
              this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e3, callbackId: n2, data: t3 }, a3);
            } catch (e4) {
              i2.reject(e4);
            }
            return i2.promise;
          }
          sendWithStream(e3, t3, a3, n2) {
            const i2 = this.streamId++, o2 = this.sourceName, c2 = this.targetName, l2 = this.comObj;
            return new ReadableStream({ start: (a4) => {
              const s2 = new r.PromiseCapability();
              this.streamControllers[i2] = { controller: a4, startCall: s2, pullCall: null, cancelCall: null, isClosed: false };
              l2.postMessage({ sourceName: o2, targetName: c2, action: e3, streamId: i2, data: t3, desiredSize: a4.desiredSize }, n2);
              return s2.promise;
            }, pull: (e4) => {
              const t4 = new r.PromiseCapability();
              this.streamControllers[i2].pullCall = t4;
              l2.postMessage({ sourceName: o2, targetName: c2, stream: u, streamId: i2, desiredSize: e4.desiredSize });
              return t4.promise;
            }, cancel: (e4) => {
              (0, r.assert)(e4 instanceof Error, "cancel must have a valid reason");
              const t4 = new r.PromiseCapability();
              this.streamControllers[i2].cancelCall = t4;
              this.streamControllers[i2].isClosed = true;
              l2.postMessage({ sourceName: o2, targetName: c2, stream: s, streamId: i2, reason: wrapReason(e4) });
              return t4.promise;
            } }, a3);
          }
          destroy() {
            this.comObj.removeEventListener("message", this._onComObjOnMessage);
          }
        }, _MessageHandler_instances = new WeakSet(), N_fn = function(e3) {
          const t3 = e3.streamId, a3 = this.sourceName, n2 = e3.sourceName, i2 = this.comObj, s2 = this, o2 = this.actionHandler[e3.action], u2 = { enqueue(e4, s3 = 1, o3) {
            if (this.isCancelled) return;
            const c2 = this.desiredSize;
            this.desiredSize -= s3;
            if (c2 > 0 && this.desiredSize <= 0) {
              this.sinkCapability = new r.PromiseCapability();
              this.ready = this.sinkCapability.promise;
            }
            i2.postMessage({ sourceName: a3, targetName: n2, stream: l, streamId: t3, chunk: e4 }, o3);
          }, close() {
            if (!this.isCancelled) {
              this.isCancelled = true;
              i2.postMessage({ sourceName: a3, targetName: n2, stream: c, streamId: t3 });
              delete s2.streamSinks[t3];
            }
          }, error(e4) {
            (0, r.assert)(e4 instanceof Error, "error must have a valid reason");
            if (!this.isCancelled) {
              this.isCancelled = true;
              i2.postMessage({ sourceName: a3, targetName: n2, stream: h, streamId: t3, reason: wrapReason(e4) });
            }
          }, sinkCapability: new r.PromiseCapability(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e3.desiredSize, ready: null };
          u2.sinkCapability.resolve();
          u2.ready = u2.sinkCapability.promise;
          this.streamSinks[t3] = u2;
          new Promise(function(t4) {
            t4(o2(e3.data, u2));
          }).then(function() {
            i2.postMessage({ sourceName: a3, targetName: n2, stream: f, streamId: t3, success: true });
          }, function(e4) {
            i2.postMessage({ sourceName: a3, targetName: n2, stream: f, streamId: t3, reason: wrapReason(e4) });
          });
        }, E_fn = function(e3) {
          const t3 = e3.streamId, a3 = this.sourceName, n2 = e3.sourceName, i2 = this.comObj, g = this.streamControllers[t3], p = this.streamSinks[t3];
          switch (e3.stream) {
            case f:
              e3.success ? g.startCall.resolve() : g.startCall.reject(wrapReason(e3.reason));
              break;
            case d:
              e3.success ? g.pullCall.resolve() : g.pullCall.reject(wrapReason(e3.reason));
              break;
            case u:
              if (!p) {
                i2.postMessage({ sourceName: a3, targetName: n2, stream: d, streamId: t3, success: true });
                break;
              }
              p.desiredSize <= 0 && e3.desiredSize > 0 && p.sinkCapability.resolve();
              p.desiredSize = e3.desiredSize;
              new Promise(function(e4) {
                var _a2;
                e4((_a2 = p.onPull) == null ? void 0 : _a2.call(p));
              }).then(function() {
                i2.postMessage({ sourceName: a3, targetName: n2, stream: d, streamId: t3, success: true });
              }, function(e4) {
                i2.postMessage({ sourceName: a3, targetName: n2, stream: d, streamId: t3, reason: wrapReason(e4) });
              });
              break;
            case l:
              (0, r.assert)(g, "enqueue should have stream controller");
              if (g.isClosed) break;
              g.controller.enqueue(e3.chunk);
              break;
            case c:
              (0, r.assert)(g, "close should have stream controller");
              if (g.isClosed) break;
              g.isClosed = true;
              g.controller.close();
              __privateMethod(this, _MessageHandler_instances, R_fn).call(this, g, t3);
              break;
            case h:
              (0, r.assert)(g, "error should have stream controller");
              g.controller.error(wrapReason(e3.reason));
              __privateMethod(this, _MessageHandler_instances, R_fn).call(this, g, t3);
              break;
            case o:
              e3.success ? g.cancelCall.resolve() : g.cancelCall.reject(wrapReason(e3.reason));
              __privateMethod(this, _MessageHandler_instances, R_fn).call(this, g, t3);
              break;
            case s:
              if (!p) break;
              new Promise(function(t4) {
                var _a2;
                t4((_a2 = p.onCancel) == null ? void 0 : _a2.call(p, wrapReason(e3.reason)));
              }).then(function() {
                i2.postMessage({ sourceName: a3, targetName: n2, stream: o, streamId: t3, success: true });
              }, function(e4) {
                i2.postMessage({ sourceName: a3, targetName: n2, stream: o, streamId: t3, reason: wrapReason(e4) });
              });
              p.sinkCapability.reject(wrapReason(e3.reason));
              p.isCancelled = true;
              delete this.streamSinks[t3];
              break;
            default:
              throw new Error("Unexpected stream case");
          }
        }, R_fn = async function(e3, t3) {
          var _a2, _b, _c;
          await Promise.allSettled([(_a2 = e3.startCall) == null ? void 0 : _a2.promise, (_b = e3.pullCall) == null ? void 0 : _b.promise, (_c = e3.cancelCall) == null ? void 0 : _c.promise]);
          delete this.streamControllers[t3];
        }, _a);
      }, (e2, t2, a2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PDFWorkerStream = void 0;
        var r = a2(2);
        t2.PDFWorkerStream = class PDFWorkerStream {
          constructor(e3) {
            this._msgHandler = e3;
            this._contentLength = null;
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }
          getFullReader() {
            (0, r.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
            return this._fullRequestReader;
          }
          getRangeReader(e3, t3) {
            const a3 = new PDFWorkerStreamRangeReader(e3, t3, this._msgHandler);
            this._rangeRequestReaders.push(a3);
            return a3;
          }
          cancelAllRequests(e3) {
            var _a;
            (_a = this._fullRequestReader) == null ? void 0 : _a.cancel(e3);
            for (const t3 of this._rangeRequestReaders.slice(0)) t3.cancel(e3);
          }
        };
        class PDFWorkerStreamReader {
          constructor(e3) {
            this._msgHandler = e3;
            this.onProgress = null;
            this._contentLength = null;
            this._isRangeSupported = false;
            this._isStreamingSupported = false;
            const t3 = this._msgHandler.sendWithStream("GetReader");
            this._reader = t3.getReader();
            this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e4) => {
              this._isStreamingSupported = e4.isStreamingSupported;
              this._isRangeSupported = e4.isRangeSupported;
              this._contentLength = e4.contentLength;
            });
          }
          get headersReady() {
            return this._headersReady;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          async read() {
            const { value: e3, done: t3 } = await this._reader.read();
            return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
          }
          cancel(e3) {
            this._reader.cancel(e3);
          }
        }
        class PDFWorkerStreamRangeReader {
          constructor(e3, t3, a3) {
            this._msgHandler = a3;
            this.onProgress = null;
            const r2 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e3, end: t3 });
            this._reader = r2.getReader();
          }
          get isStreamingSupported() {
            return false;
          }
          async read() {
            const { value: e3, done: t3 } = await this._reader.read();
            return t3 ? { value: void 0, done: true } : { value: e3.buffer, done: false };
          }
          cancel(e3) {
            this._reader.cancel(e3);
          }
        }
      }], t = {};
      function __w_pdfjs_require__(a2) {
        var r = t[a2];
        if (void 0 !== r) return r.exports;
        var n = t[a2] = { exports: {} };
        e[a2](n, n.exports, __w_pdfjs_require__);
        return n.exports;
      }
      var a = {};
      (() => {
        var e2 = a;
        Object.defineProperty(e2, "__esModule", { value: true });
        Object.defineProperty(e2, "WorkerMessageHandler", { enumerable: true, get: function() {
          return t2.WorkerMessageHandler;
        } });
        var t2 = __w_pdfjs_require__(1);
      })();
      return a;
    })());
  }
});
export default require_pdf_worker_min();
//# sourceMappingURL=pdfjs-dist_build_pdf__worker__min__js.js.map
